Qualcomm® HexagonTM V67
Programmer’s Reference Manual
80-N2040-45 Rev. B
February 25, 2020
All Qualcomm products mentioned herein are products of Qualcomm Technologies, Inc. and/or its subsidiaries
Qualcomm and Hexagon are trademarks of Qualcomm Incorporated, registered in the United States and other countries. Other
product and brand names may be trademarks or registered trademarks of their respective owners.
This technical data may be subject to U.S. and international export, re-export, or transfer (“export”) laws. Diversion contrary to U.S.
and international law is strictly prohibited.
                                                   Qualcomm Technologies, Inc.
                                                      5775 Morehouse Drive
                                                       San Diego, CA 92121
                                                               U.S.A.
                        © 2018, 2020 Qualcomm Technologies, Inc. and/or its subsidiaries. All rights reserved.
Contents
                  Figures .............................................................................................................................. 14
                  Tables ................................................................................................................................ 15
                  1 Introduction......................................................................................... 17
                  1.1 Features....................................................................................................................... 17
                  1.2 Functional units .......................................................................................................... 19
                      1.2.1 Memory............................................................................................................. 20
                      1.2.2 Registers............................................................................................................ 20
                      1.2.3 Sequencer.......................................................................................................... 20
                      1.2.4 Execution units.................................................................................................. 20
                      1.2.5 Load/store units................................................................................................. 20
                  1.3 Instruction set ............................................................................................................. 21
                      1.3.1 Addressing modes............................................................................................. 21
                      1.3.2 Scalar operations............................................................................................... 22
                      1.3.3 Vector operations .............................................................................................. 22
                      1.3.4 Floating-point operations .................................................................................. 23
                      1.3.5 Program flow .................................................................................................... 24
                      1.3.6 Instruction packets ............................................................................................ 24
                      1.3.7 Dot-new instructions......................................................................................... 25
                      1.3.8 Compound instructions ..................................................................................... 25
                      1.3.9 Duplex instructions ........................................................................................... 25
                      1.3.10 Instruction classes ........................................................................................... 25
                      1.3.11 Instruction intrinsics........................................................................................ 26
                  1.4 Notation ...................................................................................................................... 27
                      1.4.1 Instruction syntax.............................................................................................. 27
                      1.4.2 Register operands.............................................................................................. 28
                      1.4.3 Numeric operands ............................................................................................. 30
                  1.5 Terminology ............................................................................................................... 31
                  1.6 Technical assistance.................................................................................................... 31
                  2 Registers ............................................................................................. 32
                  2.1 General registers......................................................................................................... 32
                  2.2 Control registers ......................................................................................................... 35
                      2.2.1 Program counter................................................................................................ 37
                      2.2.2 Loop registers.................................................................................................... 38
80-N2040-45 Rev. B                                                                                                                                         2
Hexagon V67 Programmer’s Reference Manual                                                                                                   Contents
                      2.2.3 User status register............................................................................................ 38
                      2.2.4 Modifier registers.............................................................................................. 41
                      2.2.5 Predicate registers ............................................................................................. 42
                      2.2.6 Circular start registers ....................................................................................... 43
                      2.2.7 User general pointer register............................................................................. 43
                      2.2.8 Global pointer ................................................................................................... 43
                      2.2.9 Cycle count registers......................................................................................... 44
                      2.2.10 Frame limit register......................................................................................... 44
                      2.2.11 Frame key register........................................................................................... 45
                      2.2.12 Packet count registers ..................................................................................... 45
                      2.2.13 Qtimer registers............................................................................................... 46
                  3 Instructions ......................................................................................... 47
                  3.1 Instruction syntax ....................................................................................................... 47
                  3.2 Instruction classes....................................................................................................... 48
                  3.3 Instruction packets...................................................................................................... 49
                      3.3.1 Packet execution semantics............................................................................... 50
                      3.3.2 Sequencing semantics ....................................................................................... 50
                      3.3.3 Resource constraints ......................................................................................... 51
                      3.3.4 Grouping constraints......................................................................................... 52
                      3.3.5 Dependency constraints .................................................................................... 53
                      3.3.6 Ordering constraints.......................................................................................... 53
                      3.3.7 Alignment constraints ....................................................................................... 54
                  3.4 Instruction intrinsics ................................................................................................... 54
                  3.5 Compound instructions............................................................................................... 55
                  3.6 Duplex instructions..................................................................................................... 55
                  4 Data Processing ................................................................................. 56
                  4.1 Data types ................................................................................................................... 57
                      4.1.1 Fixed-point data ................................................................................................ 57
                      4.1.2 Floating-point data ............................................................................................ 57
                      4.1.3 Complex data .................................................................................................... 57
                      4.1.4 Vector data ........................................................................................................ 57
                  4.2 Instruction options ...................................................................................................... 59
                      4.2.1 Fractional scaling .............................................................................................. 59
                      4.2.2 Saturation .......................................................................................................... 59
                      4.2.3 Arithmetic rounding.......................................................................................... 59
                      4.2.4 Convergent rounding ........................................................................................ 60
                      4.2.5 Scaling for divide and square-root.................................................................... 60
                  4.3 XTYPE operations...................................................................................................... 61
                      4.3.1 ALU .................................................................................................................. 61
                      4.3.2 Bit manipulation................................................................................................ 62
80-N2040-45 Rev. B                                                                                                                                    3
Hexagon V67 Programmer’s Reference Manual                                                                                                   Contents
                      4.3.3 Complex............................................................................................................ 62
                      4.3.4 Floating point .................................................................................................... 63
                      4.3.5 Multiply............................................................................................................. 64
                      4.3.6 Permute ............................................................................................................. 66
                      4.3.7 Predicate............................................................................................................ 66
                      4.3.8 Shift................................................................................................................... 67
                  4.4 ALU32 operations ...................................................................................................... 68
                  4.5 Vector operations ........................................................................................................ 69
                  4.6 CR operations ............................................................................................................. 71
                  4.7 Compound operations................................................................................................. 71
                  4.8 Special operations....................................................................................................... 71
                      4.8.1 H.264 CABAC processing................................................................................ 72
                          4.8.1.1 CABAC implementation ......................................................................... 73
                          4.8.1.2 Code example .......................................................................................... 74
                      4.8.2 IP internet checksum......................................................................................... 75
                          4.8.2.1 Code example .......................................................................................... 76
                      4.8.3 Software-defined radio...................................................................................... 77
                          4.8.3.1 Rake despreading .................................................................................... 77
                          4.8.3.2 Polynomial operations............................................................................. 78
                  5 Memory................................................................................................ 79
                  5.1 Memory model ........................................................................................................... 80
                      5.1.1 Address space.................................................................................................... 80
                      5.1.2 Byte order.......................................................................................................... 80
                      5.1.3 Alignment ......................................................................................................... 80
                  5.2 Memory loads............................................................................................................. 81
                  5.3 Memory stores ............................................................................................................ 82
                  5.4 Dual stores .................................................................................................................. 82
                  5.5 Slot 1 store with slot 0 load ........................................................................................ 83
                  5.6 New-value stores ........................................................................................................ 83
                  5.7 Mem-ops..................................................................................................................... 84
                  5.8 Addressing modes ...................................................................................................... 84
                      5.8.1 Absolute ............................................................................................................ 85
                      5.8.2 Absolute-set ...................................................................................................... 85
                      5.8.3 Absolute with register offset ............................................................................. 85
                      5.8.4 Global pointer relative ...................................................................................... 86
                      5.8.5 Indirect .............................................................................................................. 87
                      5.8.6 Indirect with offset ............................................................................................ 87
                      5.8.7 Indirect with register offset ............................................................................... 87
                      5.8.8 Indirect with auto-increment immediate........................................................... 88
                      5.8.9 Indirect with auto-increment register................................................................ 88
                      5.8.10 Circular with auto-increment immediate ........................................................ 89
                      5.8.11 Circular with auto-increment register ............................................................. 91
80-N2040-45 Rev. B                                                                                                                                    4
Hexagon V67 Programmer’s Reference Manual                                                                                                 Contents
                      5.8.12 Bit-reversed with auto-increment register ...................................................... 92
                  5.9 Conditional load/stores............................................................................................... 93
                  5.10 Cache memory.......................................................................................................... 94
                      5.10.1 Uncached memory .......................................................................................... 95
                      5.10.2 Tightly coupled memory................................................................................. 95
                      5.10.3 Cache maintenance operations........................................................................ 95
                      5.10.4 L2 cache operations ........................................................................................ 96
                      5.10.5 Cache line zero................................................................................................ 97
                      5.10.6 Cache prefetch ................................................................................................ 97
                  5.11 Memory ordering.................................................................................................... 100
                  5.12 Atomic operations .................................................................................................. 101
                  6 Conditional Execution..................................................................... 103
                  6.1 Scalar predicates....................................................................................................... 103
                      6.1.1 Generating scalar predicates ........................................................................... 104
                      6.1.2 Consuming scalar predicates........................................................................... 106
                      6.1.3 Auto-AND predicates ..................................................................................... 107
                      6.1.4 Dot-new predicates ......................................................................................... 108
                      6.1.5 Dependency constraints .................................................................................. 109
                  6.2 Vector predicates ...................................................................................................... 109
                      6.2.1 Vector compare ............................................................................................... 109
                      6.2.2 Vector mux instruction.................................................................................... 111
                      6.2.3 Using vector conditionals ............................................................................... 112
                  6.3 Predicate operations.................................................................................................. 113
                  7 Software Stack ...................................................................................114
                  7.1 Stack structure .......................................................................................................... 114
                  7.2 Stack frames ............................................................................................................. 115
                  7.3 Stack protection ........................................................................................................ 116
                      7.3.1 Stack bounds checking.................................................................................... 116
                      7.3.2 Stack smashing protection .............................................................................. 116
                  7.4 Stack registers........................................................................................................... 117
                  7.5 Stack instructions...................................................................................................... 118
                  8 Program Flow.....................................................................................119
                  8.1 Conditional instructions............................................................................................ 119
                  8.2 Hardware loops......................................................................................................... 120
                      8.2.1 Loop setup....................................................................................................... 121
                      8.2.2 Loop end ......................................................................................................... 122
                      8.2.3 Loop execution................................................................................................ 123
                      8.2.4 Pipelined hardware loops................................................................................ 124
                      8.2.5 Loop restrictions ............................................................................................. 126
80-N2040-45 Rev. B                                                                                                                                 5
Hexagon V67 Programmer’s Reference Manual                                                                                                     Contents
                  8.3 Software branches .................................................................................................... 127
                      8.3.1 Jumps .............................................................................................................. 128
                      8.3.2 Calls ................................................................................................................ 128
                      8.3.3 Returns ............................................................................................................ 129
                      8.3.4 Extended branches .......................................................................................... 130
                      8.3.5 Branches to and from packets ......................................................................... 130
                  8.4 Speculative jumps..................................................................................................... 131
                  8.5 Compare jumps......................................................................................................... 132
                      8.5.1 New-value compare jumps ............................................................................. 133
                  8.6 Register transfer jumps............................................................................................. 134
                  8.7 Dual jumps................................................................................................................ 135
                  8.8 Hint indirect jump target .......................................................................................... 136
                  8.9 Pauses ....................................................................................................................... 137
                  8.10 Exceptions .............................................................................................................. 137
                  9 PMU Events....................................................................................... 140
                  9.1 V67 processor event symbols................................................................................... 141
                  10 Instruction Encoding...................................................................... 151
                  10.1 Instructions ............................................................................................................. 151
                  10.2 Sub-instructions...................................................................................................... 152
                  10.3 Duplexes ................................................................................................................. 155
                  10.4 Instruction classes................................................................................................... 157
                  10.5 Instruction packets.................................................................................................. 158
                  10.6 Loop packets........................................................................................................... 159
                  10.7 Immediate values.................................................................................................... 160
                  10.8 Scaled immediates .................................................................................................. 160
                  10.9 Constant extenders.................................................................................................. 161
                  10.10 New-value operands ............................................................................................. 164
                  10.11 Instruction mapping .............................................................................................. 165
                  11 Instruction Set................................................................................. 166
                  11.1 ALU32 .................................................................................................................... 169
                      11.1.1 ALU32/ALU ................................................................................................. 169
                            Logical operations .......................................................................................... 171
                            Negate............................................................................................................. 173
                            Nop ................................................................................................................. 174
                            Subtract........................................................................................................... 175
                            Sign extend ..................................................................................................... 177
                            Transfer immediate......................................................................................... 178
                            Transfer register ............................................................................................. 180
                            Vector add halfwords ..................................................................................... 181
80-N2040-45 Rev. B                                                                                                                                     6
Hexagon V67 Programmer’s Reference Manual                                                                                                        Contents
                              Vector average halfwords............................................................................... 182
                              Vector subtract halfwords .............................................................................. 183
                              Zero extend..................................................................................................... 185
                      11.1.2 ALU32/PERM .............................................................................................. 186
                              Mux ................................................................................................................ 188
                              Shift word by 16 ............................................................................................. 190
                              Pack high and low halfwords ......................................................................... 192
                      11.1.3 ALU32/PRED ............................................................................................... 193
                              Conditional shift halfword.............................................................................. 195
                              Conditional combine ...................................................................................... 197
                              Conditional logical operations........................................................................ 198
                              Conditional subtract ....................................................................................... 200
                              Conditional sign extend.................................................................................. 201
                              Conditional transfer ........................................................................................ 203
                              Conditional zero extend.................................................................................. 204
                              Compare ......................................................................................................... 206
                              Compare to general register ........................................................................... 208
                  11.2 CR........................................................................................................................... 209
                              Corner detection acceleration ......................................................................... 211
                              Logical reductions on predicates .................................................................... 212
                              Looping instructions....................................................................................... 213
                              Add to PC ....................................................................................................... 215
                              Pipelined loop instructions ............................................................................. 216
                              Logical operations on predicates .................................................................... 218
                              User control register transfer .......................................................................... 220
                  11.3 JR ............................................................................................................................ 221
                              Hint an indirect jump address......................................................................... 223
                              Jump to address from register ........................................................................ 224
                  11.4 J............................................................................................................................... 225
                              Compare and jump ......................................................................................... 227
                              Jump to address .............................................................................................. 231
                              Jump to address conditioned on new predicate .............................................. 233
                              Jump to address condition on register value .................................................. 234
                              Transfer and jump .......................................................................................... 236
                  11.5 LD........................................................................................................................... 237
                              Load doubleword conditionally...................................................................... 240
                              Load byte ........................................................................................................ 242
                              Load byte conditionally.................................................................................. 244
                              Load byte into shifted vector.......................................................................... 246
                              Load half into shifted vector .......................................................................... 249
                              Load halfword ................................................................................................ 252
                              Load halfword conditionally .......................................................................... 254
                              Memory Copy................................................................................................. 256
80-N2040-45 Rev. B                                                                                                                                        7
Hexagon V67 Programmer’s Reference Manual                                                                                                     Contents
                            Load unsigned byte ........................................................................................ 257
                            Load unsigned byte conditionally .................................................................. 259
                            Load unsigned halfword ................................................................................. 261
                            Load unsigned halfword conditionally........................................................... 263
                            Load word....................................................................................................... 265
                            Load word conditionally ................................................................................ 267
                            Deallocate stack frame ................................................................................... 269
                            Deallocate frame and return ........................................................................... 271
                            Load and unpack bytes to halfwords .............................................................. 273
                  11.6 MEMOP.................................................................................................................. 281
                            Operation on memory halfword ..................................................................... 283
                            Operation on memory word ........................................................................... 284
                  11.7 NV .......................................................................................................................... 285
                      11.7.1 NV/J .............................................................................................................. 285
                      11.7.2 NV/ST ........................................................................................................... 289
                            Store new-value byte conditionally ................................................................ 291
                            Store new-value halfword .............................................................................. 294
                            Store new-value halfword conditionally ........................................................ 296
                            Store new-value word..................................................................................... 299
                            Store new-value word conditionally............................................................... 301
                  11.8 ST............................................................................................................................ 304
                            Store doubleword conditionally ..................................................................... 307
                            Store byte........................................................................................................ 309
                            Store byte conditionally.................................................................................. 311
                            Store halfword ................................................................................................ 314
                            Store halfword conditionally .......................................................................... 317
                            Store word ...................................................................................................... 320
                            Store word conditionally ................................................................................ 322
                            Allocate stack frame ....................................................................................... 325
                  11.9 SYSTEM ................................................................................................................ 327
                      11.9.1 SYSTEM/GUEST ......................................................................................... 327
                      11.9.2 SYSTEM/MONITOR ................................................................................... 329
                            Swap SGP control register ............................................................................. 330
                            Cancel pending interrupts............................................................................... 331
                            Data cache kill ................................................................................................ 332
                            Data cache maintenance monitor instructions................................................ 333
                            Read the interrupt mask for a thread .............................................................. 335
                            Acquire hardware lock ................................................................................... 336
                            Release hardware lock.................................................................................... 337
                            Interrupt to thread assignment read ................................................................ 338
                            Interrupt to thread assignment write............................................................... 340
                            Instruction cache maintenance supervisor operations .................................... 342
                            Instruction cache maintenance operations (single-thread) ............................. 343
80-N2040-45 Rev. B                                                                                                                                      8
Hexagon V67 Programmer’s Reference Manual                                                                                                  Contents
                            L2 cache operations by index ......................................................................... 344
                            L2 cache global operations............................................................................. 345
                            L2 cache operations by address...................................................................... 347
                            L2 tag read/write ............................................................................................ 349
                            Load from physical address............................................................................ 351
                            Raise NMI on threads..................................................................................... 352
                            Resume from Wait mode................................................................................ 353
                            Return from exception.................................................................................... 354
                            Set the interrupt mask for a thread ................................................................. 355
                            Set the priority for a thread............................................................................. 356
                            Set interrupt auto disable ................................................................................ 357
                            Start threads .................................................................................................... 358
                            Stop threads .................................................................................................... 359
                            Software interrupt........................................................................................... 360
                            TLB read/write/probe operations ................................................................... 361
                            System control register transfer...................................................................... 363
                            Transition threads to Wait mode .................................................................... 365
                      11.9.3 SYSTEM/USER............................................................................................ 366
                            Store conditional............................................................................................. 367
                            Zero a cache line............................................................................................. 369
                            Memory barrier............................................................................................... 370
                            Breakpoint ...................................................................................................... 371
                            Data cache prefetch ........................................................................................ 372
                            Data cache maintenance user operations........................................................ 373
                            Send value to DIAG trace .............................................................................. 375
                            Instruction cache maintenance user operations .............................................. 376
                            Instruction synchronization ............................................................................ 377
                            L2 cache prefetch ........................................................................................... 378
                            Pause............................................................................................................... 381
                            Memory thread synchronization..................................................................... 382
                            Send value to ETM trace ................................................................................ 383
                            Trap ................................................................................................................ 384
                  11.10 XTYPE ................................................................................................................. 386
                      11.10.1 XTYPE/ALU .............................................................................................. 386
                            Absolute value word....................................................................................... 387
                            Add and accumulate ....................................................................................... 388
                            Add doublewords ........................................................................................... 390
                            Add halfword.................................................................................................. 392
                            Add or subtract doublewords with carry ........................................................ 394
                            Clip to unsigned.............................................................................................. 395
                            Logical doublewords ...................................................................................... 396
                            Logical-logical doublewords .......................................................................... 398
                            Logical-logical words..................................................................................... 399
80-N2040-45 Rev. B                                                                                                                                  9
Hexagon V67 Programmer’s Reference Manual                                                                                             Contents
                         Maximum words............................................................................................. 401
                         Maximum doublewords.................................................................................. 402
                         Minimum words ............................................................................................. 403
                         Minimum doublewords .................................................................................. 404
                         Modulo wrap .................................................................................................. 405
                         Negate............................................................................................................. 406
                         Round ............................................................................................................. 407
                         Subtract doublewords ..................................................................................... 410
                         Subtract and accumulate words ...................................................................... 411
                         Subtract halfword ........................................................................................... 412
                         Sign extend word to doubleword.................................................................... 414
                         Vector absolute value halfwords .................................................................... 415
                         Vector absolute value words .......................................................................... 416
                         Vector absolute difference bytes .................................................................... 417
                         Vector absolute difference halfwords............................................................. 418
                         Vector absolute difference words................................................................... 419
                         Vector add compare and select maximum bytes ............................................ 420
                         Vector add compare and select maximum halfwords .................................... 421
                         Vector add halfwords ..................................................................................... 423
                         Vector add halfwords with saturate and pack to unsigned bytes ................... 425
                         Vector reduce add unsigned bytes.................................................................. 426
                         Vector reduce add halfwords.......................................................................... 428
                         Vector add bytes ............................................................................................. 430
                         Vector add words............................................................................................ 431
                         Vector average halfwords............................................................................... 432
                         Vector average unsigned bytes....................................................................... 434
                         Vector average words ..................................................................................... 435
                         Vector clip to unsigned................................................................................... 437
                         Vector compare and compute minimum bytes............................................... 438
                         Vector conditional negate............................................................................... 439
                         Vector maximum bytes .................................................................................. 440
                         Vector maximum halfwords ........................................................................... 441
                         Vector reduce maximum halfwords ............................................................... 442
                         Vector reduce maximum words ..................................................................... 444
                         Vector maximum words ................................................................................. 446
                         Vector minimum bytes ................................................................................... 447
                         Vector minimum halfwords............................................................................ 448
                         Vector reduce minimum halfwords ................................................................ 449
                         Vector reduce minimum words ...................................................................... 451
                         Vector minimum words.................................................................................. 453
                         Vector reduce conditional negate ................................................................... 454
                         Vector sum of absolute differences unsigned bytes ....................................... 455
                         Vector subtract halfwords .............................................................................. 457
80-N2040-45 Rev. B                                                                                                                            10
Hexagon V67 Programmer’s Reference Manual                                                                                             Contents
                         Vector subtract bytes ...................................................................................... 459
                         Vector subtract words..................................................................................... 460
                   11.10.2 XTYPE/BIT ................................................................................................ 461
                         Count population ............................................................................................ 464
                         Count trailing.................................................................................................. 465
                         Extract bitfield ................................................................................................ 466
                         Insert bitfield .................................................................................................. 469
                         Interleave/deinterleave ................................................................................... 471
                         Linear feedback-shift iteration ....................................................................... 472
                         Masked parity ................................................................................................. 473
                         Bit reverse....................................................................................................... 474
                         Set/clear/toggle bit.......................................................................................... 475
                         Split bitfield .................................................................................................... 477
                         Table index ..................................................................................................... 479
                   11.10.3 XTYPE/COMPLEX.................................................................................... 482
                         Complex add/sub words ................................................................................. 485
                         Complex multiply........................................................................................... 487
                         Complex multiply real or imaginary .............................................................. 490
                         Complex multiply with round and pack ......................................................... 492
                         Complex multiply 32x16................................................................................ 494
                         Complex multiply real or imaginary 32-bit.................................................... 496
                         Vector complex multiply real or imaginary ................................................... 500
                         Vector complex conjugate.............................................................................. 503
                         Vector complex rotate .................................................................................... 504
                         Vector reduce complex multiply real or imaginary........................................ 506
                         Vector reduce complex multiply by scalar..................................................... 509
                         Vector reduce complex multiply by scalar with round and pack ................... 512
                         Vector reduce complex rotate......................................................................... 514
                   11.10.4 XTYPE/FP .................................................................................................. 517
                         Classify floating-point value .......................................................................... 518
                         Compare floating-point value......................................................................... 519
                         Convert floating-point value to other format ................................................. 521
                         Convert integer to floating-point value .......................................................... 522
                         Convert floating-point value to integer .......................................................... 524
                         Floating point extreme value assistance ......................................................... 526
                         Floating point fused multiply-add .................................................................. 527
                         Floating point fused multiply-add with scaling.............................................. 528
                         Floating point reciprocal square root approximation ..................................... 529
                         Floating point fused multiply-add for library routines ................................... 530
                         Create floating-point constant ........................................................................ 532
                         Floating point maximum ................................................................................ 533
                         Floating point minimum ................................................................................. 534
                         Floating point multiply ................................................................................... 535
80-N2040-45 Rev. B                                                                                                                            11
Hexagon V67 Programmer’s Reference Manual                                                                                              Contents
                         Floating point reciprocal approximation ........................................................ 536
                         Floating point subtraction............................................................................... 537
                   11.10.5 XTYPE/MPY .............................................................................................. 538
                         Vector multiply word by signed half (32x16) ................................................ 541
                         Vector multiply word by unsigned half (32x16) ............................................ 545
                         Multiply signed halfwords.............................................................................. 549
                         Multiply unsigned halfwords.......................................................................... 556
                         Polynomial multiply words ............................................................................ 561
                         Vector reduce multiply word by signed half (32x16) .................................... 563
                         Multiply and use upper result ......................................................................... 565
                         Multiply and use full result ............................................................................ 568
                         Vector dual multiply....................................................................................... 570
                         Vector dual multiply with round and pack ..................................................... 573
                         Vector reduce multiply bytes ......................................................................... 575
                         Vector dual multiply signed by unsigned bytes ............................................. 577
                         Vector multiply even halfwords ..................................................................... 579
                         Vector multiply halfwords.............................................................................. 581
                         Vector multiply halfwords with round and pack............................................ 583
                         Vector multiply halfwords, signed by unsigned............................................. 585
                         Vector reduce multiply halfwords .................................................................. 587
                         Vector multiply bytes ..................................................................................... 589
                         Vector polynomial multiply halfwords .......................................................... 591
                   11.10.6 XTYPE/PERM............................................................................................ 593
                         Saturate ........................................................................................................... 595
                         Swizzle bytes .................................................................................................. 597
                         Vector align .................................................................................................... 598
                         Vector round and pack ................................................................................... 600
                         Vector saturate and pack ................................................................................ 602
                         Vector saturate without pack .......................................................................... 605
                         Vector shuffle ................................................................................................. 607
                         Vector splat bytes ........................................................................................... 609
                         Vector splat halfwords.................................................................................... 610
                         Vector splice................................................................................................... 611
                         Vector sign extend.......................................................................................... 612
                         Vector truncate ............................................................................................... 614
                         Vector zero extend.......................................................................................... 616
                   11.10.7 XTYPE/PRED ............................................................................................ 618
                         Compare byte ................................................................................................. 620
                         Compare half .................................................................................................. 622
                         Compare doublewords.................................................................................... 624
                         Compare bit mask........................................................................................... 625
                         Mask generate from predicate ........................................................................ 626
                         Check for TLB match..................................................................................... 627
80-N2040-45 Rev. B                                                                                                                             12
Hexagon V67 Programmer’s Reference Manual                                                                                                    Contents
                              Predicate transfer ............................................................................................ 628
                              Test bit ............................................................................................................ 629
                              Vector compare halfwords ............................................................................. 630
                              Vector compare bytes for any match.............................................................. 632
                              Vector compare bytes ..................................................................................... 633
                              Vector compare words.................................................................................... 635
                              Viterbi pack even and odd predicate bits ....................................................... 637
                              Vector mux ..................................................................................................... 638
                       11.10.8 XTYPE/SHIFT............................................................................................ 639
                              Shift by immediate ......................................................................................... 640
                              Shift by immediate and accumulate ............................................................... 642
                              Shift by immediate and add............................................................................ 645
                              Shift by immediate and logical....................................................................... 646
                              Shift right by immediate with rounding ......................................................... 650
                              Shift left by immediate with saturation .......................................................... 652
                              Shift by register .............................................................................................. 653
                              Shift by register and accumulate .................................................................... 656
                              Shift by register and logical............................................................................ 659
                              Shift by register with saturation ..................................................................... 663
                              Vector shift halfwords by immediate ............................................................. 665
                              Vector arithmetic shift halfwords with round ................................................ 667
                              Vector arithmetic shift halfwords with saturate and pack .............................. 669
                              Vector shift halfwords by register .................................................................. 671
                              Vector shift words by immediate ................................................................... 673
                              Vector shift words by register ........................................................................ 675
                              Vector shift words with truncate and pack ..................................................... 677
                  Instruction Index ............................................................................................................. 679
                  Intrinsics Index ............................................................................................................... 694
80-N2040-45 Rev. B                                                                                                                                   13
Hexagon V67 Programmer’s Reference Manual                                                                                       Figures
                  Figures
                    Figure 1-1   Hexagon V67 processor architecture ................................................... 19
                    Figure 1-2   Vector instruction example .................................................................. 23
                    Figure 1-3   Instruction classes and combinations................................................... 26
                    Figure 1-4   Register field symbols.......................................................................... 29
                    Figure 2-1   General registers .................................................................................. 32
                    Figure 2-2   Control registers................................................................................... 35
                    Figure 3-1   Packet grouping combinations ............................................................. 51
                    Figure 4-1   Vector byte operation........................................................................... 58
                    Figure 4-2   Vector halfword operation ................................................................... 58
                    Figure 4-3   Vector word operation ......................................................................... 58
                    Figure 4-4   64-bit shift and add/sub/logical............................................................ 67
                    Figure 4-5   Vector halfword shift right................................................................... 70
                    Figure 5-1   Hexagon processor byte order ............................................................. 80
                    Figure 5-2   L2FETCH instruction .......................................................................... 99
                    Figure 6-1   Vector byte compare .......................................................................... 110
                    Figure 6-2   Vector halfword compare .................................................................. 110
                    Figure 6-3   Vector mux instruction ...................................................................... 111
                    Figure 7-1   Stack structure.................................................................................... 115
                    Figure 10-1  Instruction packet encoding ............................................................... 158
80-N2040-45 Rev. B                                                                                                                    14
Hexagon V67 Programmer’s Reference Manual                                                                                         Tables
                  Tables
                    Table 1-1    Register symbols .................................................................................. 28
                    Table 1-2    Register bit field symbols .................................................................... 29
                    Table 1-3    Instruction operands............................................................................. 30
                    Table 1-4    Data symbols........................................................................................ 31
                    Table 2-1    General register aliases ........................................................................ 34
                    Table 2-2    General register pairs ........................................................................... 34
                    Table 2-3    Aliased control registers ...................................................................... 36
                    Table 2-4    Control register pairs............................................................................ 37
                    Table 2-5    Loop registers....................................................................................... 38
                    Table 2-6    User status register ............................................................................... 39
                    Table 2-7    Modifier registers (indirect auto-increment addressing)...................... 41
                    Table 2-8    Modifier registers (circular addressing)............................................... 41
                    Table 2-9    Modifier registers (bit-reversed addressing) ........................................ 42
                    Table 2-10   Predicate registers ................................................................................ 42
                    Table 2-11   Circular start registers .......................................................................... 43
                    Table 2-12   User general pointer register ................................................................ 43
                    Table 2-13   Global pointer register ......................................................................... 43
                    Table 2-14   Cycle count registers............................................................................ 44
                    Table 2-15   Frame limit register.............................................................................. 44
                    Table 2-16   Frame key register................................................................................ 45
                    Table 2-17   Packet count registers .......................................................................... 45
                    Table 2-18   Qtimer registers.................................................................................... 46
                    Table 3-1    Instruction symbols .............................................................................. 47
                    Table 3-2    Instruction classes ................................................................................ 48
                    Table 4-1    Single-precision multiply options ........................................................ 65
                    Table 4-2    Double precision multiply options....................................................... 65
                    Table 4-3    Control register transfer instructions ................................................... 71
                    Table 5-1    Memory alignment restrictions ............................................................ 81
                    Table 5-2    Load instructions.................................................................................. 81
                    Table 5-3    Store instructions.................................................................................. 82
                    Table 5-4    Mem-ops .............................................................................................. 84
                    Table 5-5    Addressing modes ................................................................................ 84
                    Table 5-6    Offset ranges (global pointer relative) ................................................. 86
                    Table 5-7    Offset ranges (indirect with offset) ...................................................... 87
                    Table 5-8    Increment ranges (indirect with auto-inc immediate) .......................... 88
                    Table 5-9    Increment ranges (circular with auto-inc immediate) .......................... 89
                    Table 5-10   Increment ranges (circular with auto-inc register)............................... 91
                    Table 5-11   Addressing modes (conditional load/store) ......................................... 93
                    Table 5-12   Conditional offset ranges (indirect with offset) ................................... 94
                    Table 5-13   Cache instructions (user-level)............................................................. 96
                    Table 5-14   Memory ordering instructions............................................................ 100
80-N2040-45 Rev. B                                                                                                                      15
Hexagon V67 Programmer’s Reference Manual                                                                                         Tables
                   Table 5-15    Atomic instructions ............................................................................ 101
                   Table 6-1     Scalar predicate-generating instructions ............................................ 104
                   Table 6-2     Vector mux instruction ....................................................................... 111
                   Table 6-3     Predicate register instructions ............................................................ 113
                   Table 7-1     Stack registers .................................................................................... 117
                   Table 7-2     Stack instructions ............................................................................... 118
                   Table 8-1     Loop instructions ............................................................................... 121
                   Table 8-2     Software pipelined loop ..................................................................... 124
                   Table 8-3     Software pipelined loop (using spNloop0) ........................................ 126
                   Table 8-4     Software branch instructions.............................................................. 127
                   Table 8-5     Jump instructions ............................................................................... 128
                   Table 8-6     Call instructions ................................................................................. 128
                   Table 8-7     Return instructions ............................................................................. 129
                   Table 8-8     Speculative jump instructions ............................................................ 131
                   Table 8-9     Compare jump instructions ................................................................ 133
                   Table 8-10    New-value compare jump instructions .............................................. 134
                   Table 8-11    Register transfer jump instructions .................................................... 135
                   Table 8-12    Dual jump instructions ....................................................................... 135
                   Table 8-13    Jump hint instruction.......................................................................... 136
                   Table 8-14    Pause instruction ................................................................................ 137
                   Table 8-15    V67 exceptions................................................................................... 138
                   Table 9-1     V67 processor events symbols........................................................... 141
                   Table 10-1    Instruction fields ................................................................................ 151
                   Table 10-2    Sub-instructions ................................................................................. 153
                   Table 10-3    Sub-instruction registers .................................................................... 154
                   Table 10-4    Duplex instruction.............................................................................. 155
                   Table 10-5    Duplex ICLASS field......................................................................... 155
                   Table 10-6    Instruction class encoding.................................................................. 157
                   Table 10-7    Loop packet encoding ........................................................................ 159
                   Table 10-8    Scaled immediate encoding (indirect offsets) .................................... 160
                   Table 10-9    Constant extender encoding ............................................................... 161
                   Table 10-10   Constant extender instructions ........................................................... 162
                   Table 10-11   Instruction mapping ........................................................................... 165
                   Table 11-1    Instruction syntax symbols ................................................................ 167
                   Table 11-2    Instruction operand symbols .............................................................. 168
                   Table 11-3    Instruction behavior symbols ............................................................. 168
80-N2040-45 Rev. B                                                                                                                     16
          1 Introduction
                  The Qualcomm HexagonTM processor is a general-purpose digital signal processor
                  designed for high performance and low power across a wide variety of multimedia and
                  modem applications. V67 is a member of the sixth generation of the Hexagon processor
                  architecture.
       1.1        Features
                       ■  Memory
                          Program code and data are stored in a unified 32-bit address space. The load/store
                          architecture supports a complete set of addressing modes for both compiler code
                          generation and DSP application programming.
                       ■  Registers
                          Thirty two 32-bit general purpose registers can be accessed as single registers or
                          as 64-bit register pairs. The general registers hold all data including scalar,
                          pointer, and packed vector data.
                       ■  Data types
                          Instructions can perform a wide variety of operations on fixed-point or floating-
                          point data. The fixed-point operations support scalar and vector data in a variety
                          of sizes. The floating-point operations support single-precision data.
                       ■  Parallel execution
                          Instructions can be grouped into very long instruction word (VLIW) packets for
                          parallel execution, with each packet containing from one to four instructions.
                          Vector instructions operate on single instruction multiple data (SIMD) vectors.
                       ■  Program flow
                          Nestable zero-overhead hardware loops are supported. Conditional/unconditional
                          jumps and subroutine calls support both PC-relative and register indirect
                          addressing. Two program flow instructions can be grouped into one packet.
                       ■  Instruction pipeline
                          Pipeline hazards are resolved by the hardware: instruction scheduling is not
                          constrained by pipeline restrictions.
                       ■  Code compression
80-N2040-45 Rev. B                                                                                          17
Hexagon V67 Programmer’s Reference Manual                                                       Introduction
                       Compound instructions merge certain common operation sequences (add-
                       accumulate, shift-add, etc.) into a single instruction. Duplex encodings express
                       two parallel instructions in a single 32-bit word.
                   ■   Cache memory
                       Memory accesses can be cached or uncached80-N2040-45 Rev. B. Separate L1
                       instruction and data caches exist for program code and data. A unified L2 cache
                       can be partly or wholly configured as tightly-coupled memory (TCM).
                   ■   Virtual memory
                       Memory is addressed virtually, with virtual-to-physical memory mapping handled
                       by a resident OS. Virtual memory supports the implementation of memory
                       management and memory protection in a hardware-independent manner.
80-N2040-45 Rev. B                                                                                        18
Hexagon V67 Programmer’s Reference Manual                                                      Introduction
       1.2        Functional units
                  Figure 1-1 shows the major functional units of the Hexagon V67 processor architecture:
                       ■    Memory and registers
                       ■    Instruction sequencer
                       ■    Execution units
                       ■    Load/store units
                                                          Memory
                                                  (unified address space)
                                                                               Load/            Load/
                                                                                          64
                        128
                                       4x32 bit                                Store  64        Store
                                     Instructions              S3: X Unit
                                                           XTYPE Instructions
                                                           ALU32 Instructions
                                                           J Instructions
                       Sequencer                           CR Instructions
                          Packets of
                      1-4 instructions
                                                               S2: X Unit
                                                           XTYPE Instructions
                                                           ALU32 Instructions
                                                           J Instructions
                                                           JR Instructions
                                                                                     General
                    Control Registers
                    Hardware Loop Regs
                                                                                     Registers
                    Modifier Registers                     S1: Load/Store
                    Status Register                                 Unit              R0-R31
                    Program Counter                        LD Instructions
                    Predicate Registers                    ST Instructions
                    User General Pointer                   ALU32 Instructions
                    Global Pointer
                    Circular Start Registers
                                                           S0: Load/Store
                                                                    Unit
                                                           LD Instructions
                                                           ST Instructions
                                                           ALU32 Instructions
                                                           MEMOP Instructions
                                                           NV Instructions
                                                           SYSTEM Instructions
                  Figure 1-1       Hexagon V67 processor architecture
80-N2040-45 Rev. B                                                                                       19
Hexagon V67 Programmer’s Reference Manual                                                            Introduction
     1.2.1        Memory
                  The Hexagon processor features a unified byte-addressable memory. This memory has a
                  single 32-bit virtual address space which holds both instructions and data. It operates in
                  little-endian mode.
     1.2.2        Registers
                  The Hexagon processor has two sets of registers: general registers and control registers.
                  The general registers include thirty-two 32-bit registers (named R0 through R31) which
                  can be accessed either as single registers or as aligned 64-bit register pairs. The general
                  registers are used to contain all pointer, scalar, vector, and accumulator data.
                  The control registers include special-purpose registers such as program counter, status
                  register, loop registers, etc.
     1.2.3        Sequencer
                  The instruction sequencer processes packets of one to four instructions in each cycle. If a
                  packet contains more than one instruction, the instructions are executed in parallel.
                  The instruction combinations allowed in a packet are limited to the instruction types that
                  can be executed in parallel in the four execution units (as shown in Figure 1-1).
     1.2.4        Execution units
                  The dual execution units are identical: each includes a 64-bit shifter and a vector
                  multiply/accumulate unit with four 16x16 multipliers to support both scalar and vector
                  instructions.
                  These units also perform 32- and 64-bit ALU instructions, and jump and loop instructions.
                       NOTE     Each execution unit supports floating-point instructions.
     1.2.5        Load/store units
                  The two load/store units can operate on signed or unsigned bytes, halfwords (16-bit),
                  words (32-bit), or double words (64-bit).
                  To increase the number of instruction combinations allowed in packets, the load units also
                  support 32-bit ALU instructions.
80-N2040-45 Rev. B                                                                                             20
Hexagon V67 Programmer’s Reference Manual                                                          Introduction
       1.3        Instruction set
                  In order for the Hexagon processor to achieve large amounts of work per cycle, the
                  instruction set was designed with the following properties:
                        ■  Static grouping (VLIW) architecture
                        ■  Static fusing of simple dependent instructions
                        ■  Extensive compound instructions
                        ■  A large set of SIMD and application-specific instructions
                  To support efficient compilation, the instruction set is designed to be orthogonal with
                  respect to registers, addressing modes, and load/store access size.
     1.3.1        Addressing modes
                  The Hexagon processor supports the following memory addressing modes:
                        ■ 32-bit absolute
                        ■  32-bit absolute-set
                        ■  Absolute with register offset
                        ■  Global pointer relative
                        ■  Indirect
                        ■  Indirect with offset
                        ■  Indirect with register offset
                        ■  Indirect with auto-increment (immediate or register)
                        ■  Circular with auto-increment (immediate or register)
                        ■  Bit-reversed with auto-increment register
                  For example:
                       R2  = memw(##myvariable)
                       R2  = memw(R3=##myvariable)
                       R2  = memw(R4<<#3+##myvariable)
                       R2  = memw(GP+#200)
                       R2  = memw(R1)
                       R2  = memw(R3+#100)
                       R2  = memw(R3+R4<<#2)
                       R2  = memw(R3++#4)
                       R2  = memw(R0++M1)
                       R0  = memw(R2++#8:circ(M0))
                       R0  = memw(R2++I:circ(M0))
                       R2  = memw(R0++M1:brev)
                  Auto-increment with register addressing uses one of the two dedicated address-modify
                  registers M0 and M1 (which are part of the control registers).
80-N2040-45 Rev. B                                                                                           21
Hexagon V67 Programmer’s Reference Manual                                                           Introduction
                      NOTE      Atomic memory operations (load locked/store conditional) are supported to
                                implement multi-thread synchronization.
     1.3.2        Scalar operations
                  The Hexagon processor includes the following scalar operations on fixed-point data:
                        ■ Multiplication of 16-bit, 32-bit, and complex data
                        ■   Addition and subtraction of 16-, 32-, and 64-bit data (with and without saturation)
                        ■   Logical operations on 32- and 64-bit data (AND, OR, XOR, NOT)
                        ■   Shifts on 32- and 64-bit data (arithmetic and logical)
                        ■   Min/max, negation, absolute value, parity, norm, swizzle
                        ■   Compares of 8-, 16-, 32-, and 64-bit data
                        ■   Sign and zero extension (8- and 16- to 32-bit, 32- to 64-bit)
                        ■   Bit manipulation
                        ■   Predicate operations
     1.3.3        Vector operations
                  The Hexagon processor includes the following vector operations on fixed-point data:
                        ■ Multiplication (halfwords, word by half, vector reduce, dual multiply)
                        ■   Addition and subtraction of word and halfword data
                        ■   Shifts on word and halfword data (arithmetic and logical)
                        ■   Min/max, average, negative average, absolute difference, absolute value
                        ■   Compares of word, halfword, and byte data
                        ■   Reduce, sum of absolute differences on unsigned bytes
                        ■   Special-purpose data arrangement (such as pack, splat, shuffle, align, saturate,
                            splice, truncate, complex conjugate, complex rotate, zero extend)
                      NOTE      Certain vector operations support automatic scaling, saturation, and rounding.
                  For example, the following instruction performs a vector operation:
                       R1:0 += vrmpyh(R3:2,R5:4)
                  It is defined to perform the following operations in one cycle:
                       R1:0 += ((R2.L * R4.L) +
                            (R2.H * R4.H) +
                            (R3.L * R5.L) +
                            (R3.H * R5.H)
                                   )
80-N2040-45 Rev. B                                                                                            22
Hexagon V67 Programmer’s Reference Manual                                                      Introduction
                  Figure 1-2 shows a schematic of this instruction type.
                                                                                       Rss
                                                                                       Rtt
                             *               *                *            *
                                 32                                       32
                                                 32            32
                                                     Add
                                                                                               64
                                                                                       Rdd
                                             64-bit Register Pair
                  Figure 1-2 Vector instruction example
     1.3.4        Floating-point operations
                  The Hexagon processor includes the following operations on floating-point data:
                      ■ Addition and subtraction
                      ■   Multiplication (with optional scaling)
                      ■   Min/max/compare
                      ■   Reciprocal/square root approximation
                      ■   Format conversion
80-N2040-45 Rev. B                                                                                       23
Hexagon V67 Programmer’s Reference Manual                                                             Introduction
     1.3.5        Program flow
                  The Hexagon processor supports zero-overhead hardware loops. For example:
                          loop0(start,#3)             // loop 3 times
                       start:
                            { R0 = mpyi(R0,R0) } :endloop0
                  The loop instructions support nestable loops, with few restrictions on their use.
                  Software branches use a predicated branch mechanism. Explicit compare instructions
                  generate a predicate bit, which is then tested by conditional branch instructions. For
                  example:
                       P1 = cmp.eq(R2, R3)
                       if (P1) jump end
                  Jumps and subroutine calls can be conditional or unconditional, and support both PC-
                  relative and register indirect addressing modes. For example:
                       jump end
                       jumpr R1
                       call function
                       callr R2
                  The subroutine call instructions store the return address in register R31. Subroutine
                  returns are performed using a jump indirect instruction through this register. For example:
                       jumpr R31          // subroutine return
     1.3.6        Instruction packets
                  Sequences of instructions can be explicitly grouped into packets for parallel execution.
                  For example:
                       {
                            R8 = memh(R3++#2)
                            R12 = memw(R1++#4)
                            R = mpy(R10,R6):<<1:sat
                            R7 = add(R9,#2)
                       }
                  Brace characters are used to delimit the start and end of an instruction packet.
                  Packets can be from one to four instructions long. Packets of varying length can be freely
                  mixed in a program.
                  Packets have various restrictions on the allowable instruction combinations. The primary
                  restriction is determined by the instruction class of the instructions in a packet.
80-N2040-45 Rev. B                                                                                              24
Hexagon V67 Programmer’s Reference Manual                                                           Introduction
     1.3.7        Dot-new instructions
                  In many cases, a predicate or general register can be both generated and used in the same
                  instruction packet. This feature is expressed in assembly language by appending the suffix
                  “.new” to the specified register. For example:
                       {
                       P0 = cmp.eq(R2,#4)
                       if (P0.new) R3 = memw(R4)
                       if (!P0.new) R5 = #5
                       }
                       {
                       R2 = memh(R4+#8)
                       memw(R5) = R2.new
                       }
     1.3.8        Compound instructions
                  Certain common operation pairs (add-accumulate, shift-add, deallocframe-return, etc.) can
                  be performed by compound instructions. Using compound instructions reduces code size
                  and improves code performance.
     1.3.9        Duplex instructions
                  A subset of the most common instructions (load, store, branch, ALU) can be packed
                  together in pairs into single 32-bit instructions known as duplex instructions. Duplex
                  instructions reduce code size.
    1.3.10        Instruction classes
                  The instructions are assigned to specific instruction classes. Classes are important for two
                  reasons:
                        ■ Only certain combinations of instructions can be written in parallel (as shown in
                           Figure 1-1), and the allowable combinations are specified by instruction class.
                        ■  Instruction classes logically correspond with instruction types, so they serve as
                           mnemonics for looking up specific instructions.
80-N2040-45 Rev. B                                                                                            25
Hexagon V67 Programmer’s Reference Manual                                                                         Introduction
                  Figure 1-3 presents an overview of the instruction classes and how they can be grouped
                  together.
                           Slot 0                         Slot 1              Slot 2                       Slot 3
                    LD Instructions               LD Instructions
                                                                      XTYPE Instructions           XTYPE Instructions
                    ST Instructions               ST Instructions
                                                                      ALU32 Instructions           ALU32 Instructions
                    ALU32 Instructions            ALU32 Instructions
                                                                      J Instructions               J Instructions
                    MEMOP Instructions            Some J Instructions
                                                                      JR Instructions              CR Instructions
                    NV Instructions
                    SYSTEM Instructions
                    Some J Instructions
                          XTYPE Instructions (32/64 bit)                          J Instructions
                          Arithmetic, Logical, Bit Manipulation                   Jump/Call PC-relative
                          Multiply (Integer, Fractional, Complex)
                          Floating-point Operations
                                                                                  JR Instructions
                          Permute / Vector Permute Operations
                          Predicate Operations                                    Jump/Call Register
                          Shift / Shift with Add/Sub/Logical
                          Vector Byte ALU                                         LD Instructions
                          Vector Halfword (ALU, Shift, Multiply)                  Loads (8/16/32/64 bit)
                          Vector Word (ALU, Shift)                                Deallocframe
                          ALU32 Instructions                                      ST Instructions
                          Arithmetic / Logical (32 bit)                           Stores (8/16/32/64 bit)
                          Vector Halfword                                         Allocframe
                          CR Instructions                                         MEMOP Instructions
                          Control-Register Transfers                              Operation on memory (8/16/32 bit)
                          Hardware Loop Setup
                          Predicate Logicals & Reductions                         SYSTEM Instructions
                                                                                  Prefetch
                          NV Instructions                                         Cache Maintenance
                          New-value Jumps                                         Bus Operations
                          New-value Stores
                  Figure 1-3 Instruction classes and combinations
    1.3.11        Instruction intrinsics
                  To support efficient coding of the time-critical sections of a program (without resorting to
                  assembly language), the C compilers support intrinsics which are used to directly express
                  Hexagon processor instructions from within C code. For example:
                       int main()
                       {
                              long long v1 = 0xFFFF0000FFFF0000;
                              long long v2 = 0x0000FFFF0000FFFF;
                              long long result;
                              // find the minimum for each half-word in 64-bit vector
                              result = Q6_P_vminh_PP(v1,v2);
                       }
                  Intrinsics are defined for most of the Hexagon processor instructions.
80-N2040-45 Rev. B                                                                                                          26
Hexagon V67 Programmer’s Reference Manual                                                          Introduction
       1.4        Notation
                  This section presents the notational conventions used in this document to describe
                  Hexagon processor instructions:
                       ■ Instruction syntax
                       ■  Register operands
                       ■  Numeric operands
                     NOTE     The notation described here does not appear in actual assembly language
                              instructions. It only specifies the instruction syntax and behavior.
     1.4.1        Instruction syntax
                  The following notation describes the syntax of instructions:
                       ■  Monospaced font is used for instructions
                       ■  Square brackets enclose optional items (e.g., [:sat], means that saturation is
                          optional)
                       ■  Braces indicate a choice of items (e.g., {Rs,#s16}, means that either Rs or a
                          signed 16-bit immediate can be used)
80-N2040-45 Rev. B                                                                                           27
Hexagon V67 Programmer’s Reference Manual                                                           Introduction
     1.4.2        Register operands
                  The following notation describes register operands in the syntax and behavior of
                  instructions:
                       Rds[.elst]
                  The ds field indicates the register operand type and bit size (as defined in Table 1-1).
                  Table 1-1     Register symbols
                       Symbol              Operand Type          Size (in Bits)
                   d                Destination                       32
                   dd                                                 64
                   s                First source                      32
                   ss                                                 64
                   t                Second source                     32
                   tt                                                 64
                   u                Third source                      32
                   uu                                                 64
                   x                Source and destination            32
                   xx                                                 64
                  Examples of ds field (describing instruction syntax):
                       Rd = neg(Rs)                   // Rd -> 32-bit dest, Rs 32-bit source
                       Rd = xor(Rs,Rt)                // Rt -> 32-bit second source
                       Rx = insert(Rs,Rtt)            // Rx -> both source and dest
                  Examples of ds field (describing instruction behavior):
                       Rdd = Rss + Rtt                // Rdd, Rss, Rtt -> 64-bit registers
80-N2040-45 Rev. B                                                                                            28
Hexagon V67 Programmer’s Reference Manual                                                                         Introduction
                  The optional elst field (short for “element size and type”) specifies parts of a register when
                  the register is used as a vector. It can specify the following values:
                        ■ A signed or unsigned byte, halfword, or word within the register (as defined in
                            Figure 1-4)
                        ■   A bit-field within the register (as defined in Table 1-2)
                                  Rds.elst
                                         s, t, u = 32-bit source register
                                         d          = 32-bit register destination
                                         x          = 32-bit register source/destination
                                         ss, tt, uu = 64-bit source register pair
                                         dd         = 64-bit register destination
                                         xx         = 64-bit register source/destination
         Rds.elst
                         .b[7]      .b[6]       .b[5]     .b[4]    .b[3]      .b[2]     .b[1]     .b[0]  Signed Bytes
                        .ub[7]     .ub[6]      .ub[5]    .ub[4]   .ub[3]     .ub[2]    .ub[1]    .ub[0] Unsigned Bytes
                             .h[3]                  .h[2]               .h[1]               .h[0]       Signed Halfwords
                            .uh[3]                 .uh[2]              .uh[1]              .uh[0]       Unsigned Halfwords
                                        .w[1]                                     .w[0]                 Signed Words
                                       .uw[1]                                    .uw[0]                 Unsigned Words
                  Figure 1-4 Register field symbols
                  Table 1-2       Register bit field symbols
                       Symbol                                             Meaning
                   .sN                   Bits [N-1:0] are treated as a N-bit signed number.
                                         For example, R0.s16 means that the least significant 16-bits of R0
                                         are treated as a 16-bit signed number.
                   .uN                   Bits [N-1:0] are treated as a N-bit unsigned number.
                   .H                    The most-significant 16 bits of a 32-bit register.
                   .L                    The least-significant 16 bits of a 32-bit register.
                  Examples of elst field:
                       EA = Rt.h[1]                                 // .h[1] -> bit field 31:16 in Rt
                       Pd = (Rss.u64 > Rtt.u64)                     // .u64 -> unsigned 64-bit value
                       Rd = mpyu(Rs.L,Rt.H)                         // .L/.H -> low/high 16-bit fields
                      NOTE       The control and predicate registers use the same notation as the general
                                 registers, but are written as Cx and Px (respectively) instead of Rx.
80-N2040-45 Rev. B                                                                                                          29
Hexagon V67 Programmer’s Reference Manual                                                             Introduction
     1.4.3        Numeric operands
                  Table 1-3 lists the notation used to describe numeric operands in the syntax and behavior
                  of instructions:
                  Table 1-3     Instruction operands
                       Symbol                          Meaning                           Min         Max
                   #uN              Unsigned N-bit immediate value                 0            2N-1
                   #sN              Signed N-bit immediate value                   -2N-1        2N-1-1
                   #mN              Signed N-bit immediate value                   -(2N-1-1)    2N-1-1
                   #uN:S            Unsigned N-bit immediate value representing    0            (2N-1)  2S
                                    integral multiples of 2S in specified range
                   #sN:S            Signed N-bit immediate value representing      (-2N-1)  2S (2N-1-1)  2S
                                    integral multiples of 2S in specified range
                   #rN:S            Same as #sN:S, but value is offset from PC     (-2N-1)  2S (2N-1-1)  2S
                                    of current packet
                   ##               Same as #, but associated value (u,s,m,r)      –            –
                                    is 32 bits
                   usatN            Saturate value to unsigned N-bit number        0            2N-1
                   satN             Saturate value to signed N-bit number          -2N-1        2N-1-1
                  #uN, #sN, and #mN specify immediate operands in instructions. The # symbol appears in
                  the actual instruction to indicate the immediate operand.
                  #rN specifies loop and branch destinations in instructions. In this case the # symbol does
                  not appear in the actual instruction; instead, the entire #rN symbol (including its :S suffix)
                  is expressed as a loop or branch symbol whose numeric value is determined by the
                  assembler and linker. For example:
                       call my_proc                      // instruction example
                  The :S suffix indicates that the S least-significant bits in a value are implied zero bits and
                  therefore not encoded in the instruction. The implied zero bits are called scale bits.
                  For example, #s4:2 denotes a signed immediate operand represented by four bits encoded
                  in the instruction, and two scale bits. The possible values for this operand are -32, -28, -24,
                  -20, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, and 28.
                  ## specifies a 32-bit immediate operand in an instruction (including a loop or branch
                  destination). The ## symbol appears in the actual instruction to indicate the operand.
                  Examples of operand symbols:
                       Rd =   add(Rs,#s16)             //   #s16       ->   signed 16-bit imm value
                       Rd =   memw(Rs++#s4:2)          //   #s4:2      ->   scaled signed 4-bit imm value
                       call   #r22:2                   //   #r22:2     ->   scaled 22-bit PC-rel addr value
                       Rd =   ##u32                    //   ##u32      ->   unsigned 32-bit imm value
80-N2040-45 Rev. B                                                                                              30
Hexagon V67 Programmer’s Reference Manual                                                          Introduction
                      NOTE     When an instruction contains more than one immediate operand, the operand
                               symbols are specified in upper and lower case (e.g., #uN and #UN) to indicate
                               where they appear in the instruction encodings
       1.5        Terminology
                  Table 1-4 lists the symbols used in Hexagon processor instruction names to specify the
                  supported data types.
                  Table 1-4     Data symbols
                        Size        Symbol               Type
                   8-bit         B             Byte
                   8-bit         UB            Unsigned Byte
                   16-bit        H             Half word
                   16-bit        UH            Unsigned Half word
                   32-bit        W             Word
                   32-bit        UW            Unsigned Word
                   64-bit        D             Double word
       1.6        Technical assistance
                  For assistance or clarification on information in this document, submit a case to
                  Qualcomm Technologies, Inc. (QTI) at https://createpoint.qti.qualcomm.com/.
                  If you do not have access to the CDMATech Support website, register for access or send
                  email to support.cdmatech@qti.qualcomm.com.
80-N2040-45 Rev. B                                                                                           31
          2 Registers
                  General registers are used for all general-purpose computation including address
                  generation and scalar and vector arithmetic.
                  Control registers support special-purpose processor features such as hardware loops and
                  predicates.
       2.1        General registers
                  The Hexagon processor has thirty-two 32-bit general-purpose registers (named R0 through
                  R31). These registers are used to store operands in virtually all the instructions:
                         Memory addresses for load/store instructions
                         Data operands for arithmetic/logic instructions
                         Vector operands for vector instructions
                  For example:
                      R1 = memh(R0)                       // Load from address R0
                      R4 = add(R2,R3)                     // Add
                      R28 = vaddh(R11,R10)                // Vector add halfword
                  Figure 2-1 shows the general registers.
                      R3        R2      R1       R0
                                     ..
                          R3:2              R1:0
                                      .
                     R31       R30      R29      R28
                         R31:30           R29:28
                  Figure 2-1 General registers
80-N2040-45 Rev. B                                                                                        32
Hexagon V67 Programmer’s Reference Manual                                                            Registers
                  Aliased registers
                  Three of the general registers – R29 through R31 – are used to support subroutines
                  (Section 8.3.2) and the software stack (Chapter 7). These registers are modified implicitly
                  by the subroutine and stack instructions. They have symbol aliases which are used to
                  indicate when these registers are being accessed as subroutine and stack registers.
                  For example:
                      SP = add(SP, #-8)          // SP is alias of R29
                      allocframe                 // Modifies SP (R29) and FP (R30)
                      call init                  // Modifies LR (R31)
80-N2040-45 Rev. B                                                                                          33
Hexagon V67 Programmer’s Reference Manual                                                                   Registers
                  Table 2-1 defines the aliased general registers.
                  Table 2-1     General register aliases
                    Register        Alias           Name                            Description
                       R29           SP       Stack pointer     Points to topmost element of stack in memory.
                       R30           FP       Frame pointer     Points to current procedure frame on stack.
                                                                Used by external debuggers to examine the stack
                                                                and determine call sequence, parameters, local
                                                                variables, etc.
                       R31           LR       Link register     Stores return address of a subroutine call.
                  Register pairs
                  The general registers can be specified as register pairs which represent a single 64-bit
                  register. For example:
                       R1:0 = memd(R3)                                // Load doubleword
                       R7:6 = valignb(R9:8,R7:6, #2)                  // Vector align
                      NOTE     The first register in a register pair must always be odd-numbered, and the
                               second must be the next lower register.
                  Table 2-2 lists the general register pairs.
                  Table 2-2     General register pairs
                         Register              Register Pair
                   R0                     R1:0
                   R1
                   R2                     R3:2
                   R3
                   R4                     R5:4
                   R5
                   R6                     R7:6
                   R7
                                          ...
                   R24                    R25:24
                   R25
                   R26                    R27:26
                   R27
                   R28                    R29:28
                   R29 (SP)
                   R30 (FP)               R31:30 (LR:FP)
                   R31 (LR)
80-N2040-45 Rev. B                                                                                                 34
Hexagon V67 Programmer’s Reference Manual                                                                 Registers
       2.2        Control registers
                  The Hexagon processor includes a set of 32-bit control registers which provide access to
                  processor features such as the program counter, hardware loops, and vector predicates.
                  Unlike general registers, control registers can be used as instruction operands only in the
                  following cases:
                          Instructions that require a specific control register as an operand
                          Register transfer instructions
                  For example:
                       R2 = memw(R0++M1)             // Auto-increment addressing mode (M1)
                       R9 = PC                       // Get program counter (PC)
                       LC1 = R3                      // Set hardware loop count (LC1)
                      NOTE     When a control register is used in a register transfer, the other operand must
                               be a general register.
                  Figure 2-2 shows the control registers.
                        LC0      SA0                               UPCYCLELO
                                                 Loop Registers                         Cycle Count Registers
                        LC1      SA1                               UPCYCLEHI
                         PC     Program Counter                    FRAMELIMIT     Stack Bounds Register
                        USR     User Status Register               FRAMEKEY       Stack Smash Register
                         M0                                       PKTCOUNTLO
                                       Modifier Registers                               Packet Count Registers
                         M1                                       PKTCOUNTHI
                        P3:0    Predicate Registers                 UTIMERLO
                                                                                        Qtimer Registers
                        UGP     User General Pointer                UTIMERHI
                         GP     Global Pointer
                        CS0                                                       = V61 or greater
                                      Circular Start Registers
                        CS1
                  Figure 2-2 Control registers
80-N2040-45 Rev. B                                                                                               35
Hexagon V67 Programmer’s Reference Manual                                                             Registers
                  Aliased registers
                  The control registers have numeric aliases (C0 through C31).
                  Table 2-3 lists the aliased control registers.
                  Table 2-3     Aliased control registers
                       Register           Alias                     Name
                         SA0               C0      Loop start address register 0
                         LC0               C1      Loop count register 0
                         SA1               C2      Loop start address register 1
                         LC1               C3      Loop count register 1
                         P3:0              C4      Predicate registers 3:0
                       reserved            C5      –
                          M0               C6      Modifier register 0
                          M1               C7      Modifier register 1
                         USR               C8      User status register
                          PC               C9      Program counter
                         UGP               C10     User general pointer
                          GP               C11     Global pointer
                         CS0               C12     Circular start register 0
                         CS1               C13     Circular start register 1
                     UPCYCLELO             C14     Cycle count register (low)
                     UPCYCLEHI             C15     Cycle count register (high)
                      UPCYCLE            C15:14    Cycle count register
                     FRAMELIMIT            C16     Frame limit register
                     FRAMEKEY              C17     Frame key register
                    PKTCOUNTLO             C18     Packet count register (low)
                    PKTCOUNTHI             C19     Packet count register (high)
                     PKTCOUNT            C19:18    Packet count register
                       reserved          C20-29    –
                      UTIMERLO             C30     Qtimer register (low)
                      UTIMERHI             C31     Qtimer register (high)
                       UTIMER            C31:30    Qtimer register
                     NOTE      The control register numbers (0-31) are used to specify the control registers in
                               instruction encodings (Chapter 10).
80-N2040-45 Rev. B                                                                                            36
Hexagon V67 Programmer’s Reference Manual                                                              Registers
                  Register pairs
                  The control registers can be specified as register pairs which represent a single 64-bit
                  register. Control registers specified as pairs must use their numeric aliases. For example:
                       C1:0 = R5:4          // C1:0 specifies the LC0/SA0 register pair
                      NOTE     The first register in a control register pair must always be odd-numbered, and
                               the second must be the next lower register.
                  Table 2-4 lists the control register pairs.
                  Table 2-4     Control register pairs
                         Register             Register Pair
                   C0                    C1:0
                   C1
                   C2                    C3:2
                   C3
                   C4                    C5:4
                   C5
                   C6                    C7:6
                   C7
                                        ...
                   C30                   C31:30
                   C31
     2.2.1        Program counter
                  The Program Counter (PC) register points to the next instruction packet to execute
                  (Section 3.3). It is modified implicitly by instruction execution, but can be read directly.
                  For example:
                       R7 = PC          // Get program counter
                      NOTE     The PC register is read-only: writing to it has no effect.
80-N2040-45 Rev. B                                                                                             37
Hexagon V67 Programmer’s Reference Manual                                                              Registers
     2.2.2        Loop registers
                  The Hexagon processor includes two sets of loop registers to support nested hardware
                  loops (Section 8.2). Each hardware loop is implemented with a pair of registers containing
                  the loop count and loop start address. The loop registers are modified implicitly by the
                  loop instruction, but can also be accessed directly. For example:
                       loop0(start, R4)        // Modifies LC0 and SA0 (LC0=R4, SA0=&start)
                       LC1 = R22               // Set loop1 count
                       R9 = SA1                // Get loop1 start address
                  Table 2-5 defines the loop registers.
                  Table 2-5     Loop registers
                        Register               Name                               Description
                       LC0, LC1        Loop count             Number of loop iterations to execute.
                       SA0, SA1        Loop start address     Address of first instruction in loop.
     2.2.3        User status register
                  The user status register (USR) stores processor status and control bits that are accessible
                  by user programs. The status bits contain the status results of certain instructions, while
                  the control bits contain user-settable processor modes for hardware prefetching. For
                  example:
                       R9:8 = vaddw(R9:8, R3:2):sat                 // Vector add words
                       R6 = USR                                     // Get saturation status
                  USR stores the following status and control values:
                      Cache prefetch enable (Section 5.10.6)
                      Cache prefetch status (Section 5.10.6)
                      Floating point modes (Section 4.3.4)
                      Floating point status (Section 4.3.4)
                      Hardware loop configuration (Section 8.2)
                      Sticky saturation overflow (Section 4.2.2)
                     NOTE      A user control register transfer to USR cannot be grouped in an instruction
                               packet with a floating point instruction (Section 4.3.4).
                               Whenever a transfer to USR changes the Enable trap bits [29:25], an isync
                               instruction (Section 5.11) must be executed before the new exception
                               programming can take effect.
80-N2040-45 Rev. B                                                                                            38
Hexagon V67 Programmer’s Reference Manual                                                                  Registers
                  Table 2-6 defines the user status register.
                  Table 2-6    User status register
                    Name     R/W      Bits      Field                             Description
                   USR                 32                User Status Register
                               R       31   PFA          L2 Prefetch Active.
                                                         1: l2fetch instruction in progress
                                                         0: l2fetch finished (or inactive)
                                                         Set when non-blocking l2fetch instruction is prefetching
                                                         requested data.
                                                         Remains set until l2fetch prefetch operation is completed
                                                         (or not active).
                               R       30   reserved     Return 0 if read.
                                                         Reserved for future expansion. To remain compatible
                                                         with future processor versions, software should always
                                                         write this field with the same value read from the field.
                             R/W       29   FPINEE       Enable trap on IEEE Inexact.
                             R/W       28   FPUNFE       Enable trap on IEEE Underflow.
                             R/W       27   FPOVFE       Enable trap on IEEE Overflow.
                             R/W       26   FPDBZE       Enable trap on IEEE Divide-By-Zero.
                             R/W       25   FPINVE       Enable trap on IEEE Invalid.
                               R       24   reserved     Reserved
                             R/W     23:22 FPRND         Rounding Mode for Floating-Point Instructions.
                                                         00: Round to nearest, ties to even (default)
                                                         01: Toward zero
                                                         10: Downward (toward negative infinity)
                                                         11: Upward (toward positive infinity)
                               R     21:20 reserved      Return 0 if read.
                                                         Reserved for future expansion. To remain compatible
                                                         with future processor versions, software should always
                                                         write this field with the same value read from the field.
                               R     19:18 reserved      Reserved
                               R       17   reserved     Return 0 if read.
                                                         Reserved for future expansion. To remain compatible
                                                         with future processor versions, software should always
                                                         write this field with the same value read from the field.
                             R/W     16:15 HFI           L1 Instruction Prefetch.
                                                         00: Disable
                                                         01: Enable (1 line)
                                                         10: Enable (2 lines)
80-N2040-45 Rev. B                                                                                                 39
Hexagon V67 Programmer’s Reference Manual                                                             Registers
                  Table 2-6  User status register (Continued)
                    Name    R/W    Bits     Field                            Description
                            R/W   14:13 HFD         L1 Data Cache Prefetch.
                                                    Four levels are defined from disabled to Aggressive. It is
                                                    implementation-defined how these levels should be
                                                    interpreted.
                                                    00: Disable
                                                    01: Conservative
                                                    10: Moderate
                                                    11: Aggressive
                            R/W     12   PCMME      Enable packet counting in Monitor mode.
                            R/W     11   PCGME      Enable packet counting in Guest mode.
                            R/W     10   PCUME      Enable packet counting in User mode.
                            R/W    9:8   LPCFGE     Hardware Loop Configuration.
                                                    Number of loop iterations (0-3) remaining before pipeline
                                                    predicate should be set.
                             R     7:6   reserved   Return 0 if read.
                                                    Reserved for future expansion. To remain compatible
                                                    with future processor versions, software should always
                                                    write this field with the same value read from the field.
                            R/W      5   FPINPF     Floating-point IEEE Inexact Sticky Flag.
                            R/W      4   FPUNFF     Floating-point IEEE Underflow Sticky Flag.
                            R/W      3   FPOVFF     Floating-point IEEE Overflow Sticky Flag.
                            R/W      2   FPDBZF     Floating-point IEEE Divide-By-Zero Sticky Flag.
                            R/W      1   FPINVF     Floating-point IEEE Invalid Sticky Flag.
                            R/W      0   OVF        Sticky Saturation Overflow.
                                                    1: Saturation occurred
                                                    0: No saturation
                                                    Set when saturation occurs while executing instruction
                                                    that specifies optional saturation.
                                                    Remains set until explicitly cleared by a USR = Rs
                                                    instruction.
80-N2040-45 Rev. B                                                                                            40
Hexagon V67 Programmer’s Reference Manual                                                              Registers
     2.2.4        Modifier registers
                  The modifier registers (M0-M1) are used in the following addressing modes:
                          Indirect auto-increment register addressing
                          Circular addressing
                          Bit-reversed addressing
                  Indirect auto-increment
                  In indirect auto-increment register addressing (Section 5.8.9) the modifier registers store a
                  signed 32-bit value which specifies the increment (or decrement) value. For example:
                       M1 = R0                      // Set modifier register
                       R3 = memw(R2++M1)            // Load word
                  Table 2-7 defines the modifier registers as used in auto-increment register addressing.
                  Table 2-7     Modifier registers (indirect auto-increment addressing)
                         Register             Name                            Description
                         M0, M1        Increment          Signed auto-increment value.
                  Circular
                  In circular addressing (Section 5.8.10) the modifier registers store the circular buffer
                  length and related “K” and “I” values. For example:
                       M0 = R7                              // Set modifier register
                       R0 = memb(R2++#4:circ(M0))           // Load from circ buffer pointed
                                                            // to by R2 with size/K vals in M0
                       R0 = memb(R7++I:circ(M1))            // Load from circ buffer pointed
                                                            // to by R7 with size/K/I vals in M1
                  Table 2-8 defines the modifier registers as used in circular addressing.
                  Table 2-8     Modifier registers (circular addressing)
                      Name        R/W     Bits     Field                         Description
                     M0, M1                32               Circular buffer specifier.
                                  R/W    31:28 I[10:7]      I value (MSB - see Section 5.8.11)
                                  R/W    27:24 K            K value (Section 5.8.10)
                                  R/W    23:17 I[6:0]       I value (LSB)
                                  R/W     16:0  Length      Circular buffer length
80-N2040-45 Rev. B                                                                                            41
Hexagon V67 Programmer’s Reference Manual                                                               Registers
                  Bit-reversed
                  In bit-reversed addressing (Section 5.8.12) the modifier registers store a signed 32-bit
                  value which specifies the increment (or decrement) value. For example:
                       M1 = R7                         // Set modifier register
                       R2 = memub(R0++M1:brev) // The address is (R0.H | bitrev(R0.L))
                                                       // The orginal R0 (not reversed) is added
                                                       // to M1 and written back to R0
                  Table 2-9 defines the modifier registers as used in bit-reversed addressing.
                  Table 2-9     Modifier registers (bit-reversed addressing)
                        Register               Name                       Description
                         M0, M1        Increment            Signed auto-increment value.
     2.2.5        Predicate registers
                  The predicate registers (P0-P3) store the status results of the scalar and vector compare
                  instructions (Chapter 6). For example:
                       P1 = cmp.eq(R2, R3)                 //  Scalar compare
                       if (P1) jump end                    //  Jump to address (conditional)
                       R8 = P1                             //  Get compare status (P1 only)
                       P3:0 = R4                           //  Set compare status (P0-P3)
                  The four predicate registers can be specified as a register quadruple (P3:0) which
                  represents a single 32-bit register.
                      NOTE     Unlike the other control registers, the predicate registers are only 8 bits wide
                               because vector compares return a maximum of 8 status results.
                  Table 2-10 defines the predicate registers.
                  Table 2-10 Predicate registers
                        Register          Bits                Description
                     P0, P1,P2, P3          8     Compare status results.
                          P3:0             32     Compare status results.
                                         31:24    P3 register
                                         23:16    P2 register
                                          15:8    P1 register
                                           7:0    P0 register
80-N2040-45 Rev. B                                                                                             42
Hexagon V67 Programmer’s Reference Manual                                                                  Registers
     2.2.6        Circular start registers
                  The circular start registers (CS0 - CS1) store the start address of a circular buffer in
                  circular addressing (Section 5.8.10). For example:
                       CS0 = R5                               // Set circ start register
                       M0 = R7                                // Set modifier register
                       R0 = memb(R2++#4:circ(M0))             // Load from circ buffer pointed
                                                              // to by CS0 with size/K vals in M0
                  Table 2-11 defines the circular start registers.
                  Table 2-11   Circular start registers
                        Register              Name                             Description
                       CS0, CS1        Circular Start      Circular buffer start address.
     2.2.7        User general pointer register
                  The user general pointer (UGP) register is a general-purpose control register. For example:
                       R9 = UGP           // Get UGP
                       UGP = R3           // Set UGP
                      NOTE     UGP is typically used to store the address of thread local storage.
                  Table 2-12 defines the user general pointer register.
                  Table 2-12 User general pointer register
                      Register                Name                           Description
                        UGP        User General Pointer        General-purpose control register.
     2.2.8        Global pointer
                  The Global Pointer (GP) is used in GP-relative addressing. For example:
                       GP = R7                         // Set GP
                       R2 = memw(GP+#200)              // GP-relative load
                  Table 2-13 defines the global pointer register.
                  Table 2-13 Global pointer register
                      Name       R/W      Bits      Field                          Description
                   GP                      32                Global Pointer Register
                                 R/W      31:7   GDP         Global Data Pointer (Section 5.8.4).
                                  R       6:0    reserved    Return 0 if read.
                                                             Reserved for future expansion. To remain forward-
                                                             compatible with future processor versions, software
                                                             should always write this field with the same value
                                                             read from the field.
80-N2040-45 Rev. B                                                                                                43
Hexagon V67 Programmer’s Reference Manual                                                           Registers
     2.2.9        Cycle count registers
                  The cycle count registers (UPCYCLELO - UPCYCLEHI) store a 64-bit value containing the
                  current number of processor cycles executed since the Hexagon processor was last reset.
                  For example:
                      R5 = UPCYCLEHI           // Get cycle count (high)
                      R4 = UPCYCLELO           // Get cycle count (low)
                      R5:4 = UPCYCLE           // Get cycle count
                     NOTE     The RTOS must grant permission to access these registers. Without this
                              permission, reading these registers from user code always returns zero.
                  Table 2-14 defines the cycle count registers.
                  Table 2-14 Cycle count registers
                        Register               Name                            Description
                      UPCYCLELO         Cycle count (low)      Processor cycle count (low 32 bits)
                      UPCYCLEHI         Cycle count (high)     Processor cycle count (high 32 bits)
                       UPCYCLE          Cycle count            Processor cycle count (64 bits)
    2.2.10        Frame limit register
                  The frame limit register (FRAMELIMIT) stores the low address of the memory area
                  reserved for the software stack (Section 7.3.1). For example:
                      R9 = FRAMELIMIT              // Get frame limit register
                      FRAMELIMIT = R3              // Set frame limit register
                  Table 2-15 defines the frame limit register.
                  Table 2-15 Frame limit register
                        Register             Name                       Description
                    FRAMELIMIT         Frame Limit         Low address of software stack area.
80-N2040-45 Rev. B                                                                                         44
Hexagon V67 Programmer’s Reference Manual                                                             Registers
    2.2.11        Frame key register
                  The frame key register (FRAMEKEY) stores the key value that is used to XOR-scramble
                  return addresses when they are stored on the software stack (Section 7.3.2). For example:
                       R2 = FRAMEKEY            // Get frame key register
                       FRAMEKEY = R1            // Set frame key register
                  Table 2-16 defines the frame key register.
                  Table 2-16 Frame key register
                         Register             Name                         Description
                      FRAMEKEY          Frame Key            Key used to scramble return addresses
                                                             stored on software stack.
    2.2.12        Packet count registers
                  The packet count registers (PKTCOUNTLO - PKTCOUNTHI) store a 64-bit value
                  containing the current number of instruction packets executed since a PKTCOUNT register
                  was last written to. For example:
                       R9 = PKTCOUNTHI            // Get packet count (high)
                       R8 = PKTCOUNTLO            // Get packet count (low)
                       R9:8 = PKTCOUNT            // Get packet count
                  Packet counting can be configured to operate only in specific sets of processor modes
                  (e.g., User mode only, or Guest and Monitor modes only). The configuration for each
                  mode is controlled by bits [12:10] in the user status register (Section 2.2.3).
                  Packets with exceptions are not counted as committed packets.
                      NOTE     Each hardware thread has its own set of packet count registers.
                               The RTOS must grant permission to access these registers. Without this
                               permission, reading these registers from user code always returns zero.
                               When a value is written to a PKTCOUNT register, the 64-bit packet count
                               value is incremented before the value is stored in the register.
                  Table 2-17 defines the packet count registers.
                  Table 2-17 Packet count registers
                         Register               Name                             Description
                     PKTCOUNTLO          Packet count (low)     Processor packet count (low 32 bits)
                     PKTCOUNTHI          Packet count (high)    Processor packet count (high 32 bits)
                       PKTCOUNT          Cycle count            Processor packet count (64 bits)
80-N2040-45 Rev. B                                                                                           45
Hexagon V67 Programmer’s Reference Manual                                                             Registers
    2.2.13        Qtimer registers
                  The Qtimer registers (UTIMERLO - UTIMERHI) provide access to the Qtimer global
                  reference count value. They enable Hexagon software to read the 64-bit time value
                  without having to perform an expensive AHB load. For example:
                      R5 = UTIMERHI           // Get Qtimer reference count (high)
                      R4 = UTIMERLO           // Get Qtimer reference count (low)
                      R5:4 = UTIMER           // Get Qtimer reference count
                  These registers are read-only – they are automatically updated by hardware to always
                  contain the current Qtimer value.
                     NOTE      The RTOS must grant permission to access these registers. Without this
                               permission, reading these registers from user code always returns zero.
                  Table 2-18 defines the packet count registers.
                  Table 2-18 Qtimer registers
                        Register             Name                          Description
                       UTIMERLO         Qtimer (low)     Qtimer global reference count (low 32 bits)
                       UTIMERHI         Qtimer (high)    Qtimer global reference count (high 32 bits)
                        UTIMER          Qtimer           Qtimer global reference count (64 bits)
80-N2040-45 Rev. B                                                                                           46
          3 Instructions
                  Instruction encoding is described in Chapter 10.
                  For detailed descriptions of the Hexagon processor instructions see Chapter 11.
        3.1       Instruction syntax
                  Most Hexagon processor instructions have the following syntax:
                      dest = instr_name(source1,source2,...)[:option1][:option2]...
                  The item specified on the left-hand side (LHS) of the equation is assigned the value
                  specified by the right-hand side (RHS). For example:
                      R2 = add(R3,R1)         // Add R3 and R1, assign result to R2
                  Table 3-1 lists symbols commonly used in Hexagon processor instructions.
Table 3-1     Instruction symbols
       Symbol                         Example                                         Meaning
 =                   R2 = R3                                    Assignment of RHS to LHS
 #                   R1 = #1                                    Immediate value
 0x                  0xBABE                                     Hexadecimal number prefix
 memXX               R2 = memub(R3)                             Memory access
                                                                XX specifies access size and type
 ;                   R2 = R3; R4 = R5;                          Instruction delimiter, or end of instruction
 {...}                 {R2 = R3; R5 = R6}                         Instruction packet delimiter
 (...)                 R2 = memw(R0 + #100)                       Source list delimiter
 :endloopX           :endloop0                                  Loop end
                                                                X specifies loop instruction (0 or 1)
 :t                  if (P0.new) jump:t target                  Direction hint (jump taken)
 :nt                 if (!P1.new) jump:nt target                Direction hint (jump not taken)
 :sat                R2 = add(R1,R2):sat                        Saturate result
 :rnd                R2 = mpy(R1.H,R2.H):rnd                    Round result
 :carry              R5:4=add(R1:0,R3:2,P1):carry               Predicate used as carry input and output
 :<<16               R2 = add(R1.L,R2.L):<<16                   Shift result left by halfword
 :mem_noshuf         {memw(R5) = R2;                            Inhibit load/store reordering (Section 5.5)
                     R3 = memh(R6)}:mem_noshuf
80-N2040-45 Rev. B                                                                                           47
Hexagon V67 Programmer’s Reference Manual                                                            Instructions
       3.2        Instruction classes
                  The Hexagon processor instructions are assigned to specific instruction classes. Classes
                  determine what combinations of instructions can be written in parallel (Section 3.3).
                  Instruction classes logically correspond with instruction types. For instance, the ALU32
                  class contains ALU instructions which operate on 32-bit operands.
                  Table 3-2 lists the instruction classes and subclasses.
Table 3-2     Instruction classes
    Class                Subclass                              Description                    Section
 XTYPE         –                             Various operations                            Section 11.10
               ALU                               64-bit ALU operations                     Section 11.10.1
               Bit                               Bit operations                            Section 11.10.2
               Complex                           Complex math (using real and              Section 11.10.3
                                                 imaginary numbers)
               Floating point                    Floating point operations                 Section 11.10.4
               Multiply                          Multiply operations                       Section 11.10.5
               Permute                           Vector permute and format conversion      Section 11.10.6
                                                 (pack, splat, swizzle)
               Predicate                         Predicate operations                      Section 11.10.7
               Shift                             Shift operations                          Section 11.10.8
                                                 (with optional ALU operations)
 ALU32         –                             32-bit ALU operations                         Section 11.1
               ALU                               Arithmetic and logical                    Section 11.1.1
               Permute                           Permute                                   Section 11.1.2
               Predicate                         Predicate operations                      Section 11.1.3
 CR            –                             Control register access, loops                Section 11.2
 JR            –                             Jumps (register indirect addressing mode)     Section 11.3
 J             –                             Jumps (PC-relative addressing mode)           Section 11.4
 LD            –                             Memory load operations                        Section 11.5
 MEMOP         –                             Memory operations                             Section 11.6
 NV            –                             New-value operations                          Section 11.7
               Jump                              New-value jumps                           Section 11.7.1
               Store                             New-value stores                          Section 11.7.2
 ST            –                             Memory store operations;                      Section 11.8
                                             alloc stack frame
 SYSTEM        –                             Operating system access                       Section 11.9
               USER                              Application-level access                  Section 11.9.3
80-N2040-45 Rev. B                                                                                             48
Hexagon V67 Programmer’s Reference Manual                                                             Instructions
       3.3        Instruction packets
                  Instructions can be grouped together to form packets of independent instructions which
                  are executed together in parallel. The packets can contain 1, 2, 3, or 4 instructions.
                  Instruction packets must be explicitly specified in software. They are expressed in
                  assembly language by enclosing groups of instructions in curly braces. For example:
                       { R0 = R1; R2 = R3 }
                  Various rules and restrictions exist on what types of instructions can be grouped together,
                  and in what order they can appear in the packet. In particular, packet formation is subject
                  to the following constraints:
                          Resource constraints determine how many instructions of a specific type can
                           appear in a packet. The Hexagon processor has a fixed number of execution units:
                           each instruction is executed on a particular type of unit, and each unit can process
                           at most one instruction at a time. Thus, for example, because the Hexagon
                           processor contains only two load units, an instruction packet with three load
                           instructions is invalid. The resource constraints are described in Section 3.3.3
                          Grouping constraints are a small set of rules that apply above and beyond the
                           resource constraints. These rules are described in Section 3.3.4.
                          Dependency constraints ensure that no write-after-write hazards exist in a packet.
                           These rules are described in Section 3.3.5.
                          Ordering constraints dictate the ordering of instructions within a packet. These
                           rules are described in Section 3.3.6.
                          Alignment constraints dictate the placement of packets in memory. These rules are
                           described in Section 3.3.7.
                      NOTE      Individual instructions (which are not explicitly grouped in packets) are
                                executed by the Hexagon processor as packets containing a single instruction.
80-N2040-45 Rev. B                                                                                              49
Hexagon V67 Programmer’s Reference Manual                                                                 Instructions
     3.3.1        Packet execution semantics
                  Packets are defined to have parallel execution semantics. Specifically, the execution
                  behavior of a packet is defined as follows:
                           First, all instructions in the packet read their source registers in parallel.
                           Next, all instructions in the packet execute.
                           Finally, all instructions in the packet write their destination registers in parallel.
                  For example, consider the following packet:
                       { R2 = R3; R3 = R2; }
                  In the first phase, registers R3 and R2 are read from the register file. Then, after execution,
                  R2 is written with the old value of R3 and R3 is written with the old value of R2. In effect,
                  the result of this packet is that the values of R2 and R3 are swapped.
                      NOTE      Dual stores (Section 5.4), dual jumps (Section 8.7), new-value stores
                                (Section 5.6), new-value compare jumps (Section 8.5.1), and dot-new
                                predicates (Section 6.1.4) have non-parallel execution semantics.
     3.3.2        Sequencing semantics
                  Packets of any length can be freely mixed in code. A packet is considered an atomic unit:
                  in essence, a single large “instruction”. From the program perspective a packet either
                  executes to completion or not at all; it never executes only partially. For example, if a
                  packet causes a memory exception, the exception point is established before the packet.
                  A packet containing multiple load/store instructions may require service from the external
                  system. For instance, consider the case of a packet that performs two load operations that
                  both miss in the cache. The packet requires the data to be supplied by the memory system:
                           From the memory system perspective the two resulting load requests are
                            processed serially.
                           From the program perspective, however, both load operations must complete
                            before the packet can complete.
                  Thus, the packet is atomic from the program perspective.
                  Packets have a single PC address which is the address of the start of the packet. Branches
                  cannot be performed into the middle of a packet.
                  Architecturally, packets execute to completion – including updating all registers and
                  memory – before the next packet begins. As a result, application programs are not exposed
                  to any pipeline artifacts.
80-N2040-45 Rev. B                                                                                                  50
Hexagon V67 Programmer’s Reference Manual                                                                      Instructions
     3.3.3        Resource constraints
                  A packet cannot use more hardware resources than are physically available on the
                  processor. For instance, because the Hexagon processor has only two load units, a packet
                  with three load instructions is invalid. The behavior of such a packet is undefined. The
                  assembler automatically rejects packets that oversubscribe the hardware resources.
                  The processor supports up to four parallel instructions. The instructions are executed in
                  four parallel pipelines which are referred to as slots.The four slots are named Slot 0,
                  Slot 1, Slot 2, and Slot 3. (For more information see Section 1.2.)
                     NOTE         endloopN instructions (Section 8.2.2) do not use any slots.
                  Each instruction belongs to a specific instruction class (Section 3.2). For example, jumps
                  belong to instruction class J, while loads belong to instruction class LD. An instruction’s
                  class determines which slot it can execute in.
                  Figure 3-1 shows which instruction classes can be assigned to each of the four slots.
                          Slot 0                        Slot 1               Slot 2                       Slot 3
                   LD Instructions               LD Instructions
                                                                     XTYPE Instructions           XTYPE Instructions
                   ST Instructions               ST Instructions
                                                                     ALU32 Instructions           ALU32 Instructions
                   ALU32 Instructions            ALU32 Instructions
                                                                     J Instructions               J Instructions
                   MEMOP Instructions            Some J Instructions
                                                                     JR Instructions              CR Instructions
                   NV Instructions
                   SYSTEM Instructions
                   Some J Instructions
                         XTYPE Instructions (32/64 bit)                          J Instructions
                         Arithmetic, Logical, Bit Manipulation                   Jump/Call PC-relative
                         Multiply (Integer, Fractional, Complex)
                         Floating-point Operations
                                                                                 JR Instructions
                         Permute / Vector Permute Operations
                         Predicate Operations                                    Jump/Call Register
                         Shift / Shift with Add/Sub/Logical
                         Vector Byte ALU                                         LD Instructions
                         Vector Halfword (ALU, Shift, Multiply)                  Loads (8/16/32/64 bit)
                         Vector W ord (ALU, Shift)                               Deallocframe
                         ALU32 Instructions                                      ST Instructions
                         Arithmetic / Logical (32 bit)                           Stores (8/16/32/64 bit)
                         Vector Halfword                                         Allocfram e
                         CR Instructions                                         MEMOP Instructions
                         Control-Register Transfers                              Operation on memory (8/16/32 bit)
                         Hardware Loop Setup
                         Predicate Logicals & Reductions                         SYSTEM Instructions
                                                                                 Prefetch
                         NV Instructions                                         Cache Maintenance
                         New-value Jumps                                         Bus Operations
                         New-value Stores
                  Figure 3-1 Packet grouping combinations
80-N2040-45 Rev. B                                                                                                       51
Hexagon V67 Programmer’s Reference Manual                                                           Instructions
     3.3.4        Grouping constraints
                  A small number of restrictions determines what constitutes a valid packet. The assembler
                  ensures that all packets follow valid grouping rules. If a packet is executed which violates
                  a grouping rule, the behavior is undefined. The following rules must be followed:
                         Dot-new conditional instructions (Section 6.1.4) must be grouped in a packet with
                          an instruction that generates dot-new predicates.
                         ST-class instructions can be placed in Slot 1. In this case Slot 0 normally must
                          contain a second ST-class instruction (Section 5.4).
                         J-class instructions can be placed in Slots 2 or 3. However, only certain
                          combinations of program flow instructions (J or JR) can be grouped together in a
                          packet (Section 8.7). Otherwise, at most one program flow instruction is allowed
                          in a packet. Some Jump and Compare-Jump instructions can execute on slots 0 or
                          1, excluding calls, such as the following:
                              Instructions of the form “Pd=cmp.xx(); if(Pd.new)jump:hint <target>”
                              Instructions of the form “If(Pd[.new]) jump[:hint] <target>”
                              The “jump<target>” instruction
                         JR-class instructions can be placed in Slot 2. However, when encoded in a duplex
                          jumpr R31 can be placed in Slot 0 (Section 10.3).
                         Restrictions exist which limit the instructions that can appear in a packet at the
                          setup or end of a hardware loop (Section 8.2.4).
                         A user control register transfer to the control register USR cannot be grouped with
                          a floating point instruction (Section 2.2.3).
                         The SYSTEM-class instructions include prefetch, cache operations, bus
                          operations, load locked, and store conditional instructions (Section 5.10). These
                          instructions have the following grouping rules:
                              brkpt, trap, pause, icinva, isync, and syncht are solo instructions. They
                               must not be grouped with other instructions in a packet.
                              memw_locked, memd_locked, l2fetch, and trace must execute on Slot 0.
                               They must be grouped only with ALU32 or (non-FP) XTYPE instructions.
                              dccleana, dcinva, dccleaninva, and dczeroa must execute on Slot 0. Slot
                               1 must be empty or an ALU32 instruction.
80-N2040-45 Rev. B                                                                                            52
Hexagon V67 Programmer’s Reference Manual                                                               Instructions
     3.3.5        Dependency constraints
                  Instructions in a packet cannot write to the same destination register. The assembler
                  automatically flags such packets as invalid. If the processor executes a packet with two
                  writes to the same general register, an error exception is raised.
                  If the processor executes a packet that performs multiple writes to the same predicate or
                  control register, the behavior is undefined. Three special cases exist for this rule:
                          Conditional writes are allowed to target the same destination register only if at
                           most one of the writes is actually performed (Section 6.1.5).
                          The overflow flag in the status register has defined behavior when multiple
                           instructions write to it (Section 2.2.3). Instructions that write to the entire user
                           status register (for example, USR=R2) are not allowed to be grouped in a packet
                           with any instruction that writes to a bit in the user status register.
                          Multiple compare instructions are allowed to target the same predicate register in
                           order to perform a logical AND of the results (Section 6.1.3).
     3.3.6        Ordering constraints
                  In assembly code, instructions can appear in a packet in any order (with the exception of
                  dual jumps – Section 8.7). The assembler automatically encodes instructions in the packet
                  in the proper order.
                  In the binary encoding of a packet, the instructions must be ordered from Slot 3 down to
                  Slot 0. If the packet contains less than four instructions, any unused slot is skipped – a
                  NOP is unnecessary as the hardware handles the proper spacing of the instructions.
                  In memory, instructions in a packet must appear in strictly decreasing slot order.
                  Additionally, if an instruction can go in a higher-numbered slot, and that slot is empty,
                  then it must be moved into the higher-numbered slot.
                  For example, if a packet contains three instructions and Slot 1 is not used, encode the
                  instructions in the packet as follows:
                          Slot 3 instruction at lowest address
                          Slot 2 instruction follows Slot 3 instruction
                          Slot 0 instructions at the last (highest) address
                  If a packet contains a single load or store instruction, that instruction must go in Slot 0,
                  which is the highest address. As an example, a packet containing both LD and ALU32
                  instructions must be ordered so the LD is in Slot 0 and the ALU32 in another slot.
80-N2040-45 Rev. B                                                                                                53
Hexagon V67 Programmer’s Reference Manual                                                             Instructions
     3.3.7        Alignment constraints
                  Packets have the following constraints on their placement or alignment in memory:
                         Packets must be word-aligned (32-bit). If the processor executes an improperly
                           aligned packet, it raises an error exception (Section 8.10).
                          Packets should not wrap the 4 GB address space. If address wraparound occurs,
                           the processor behavior is undefined.
                  No other core-based restrictions exist for code placement or alignment.
                  If the processor branches to a packet which crosses a 16-byte address boundary, the
                  resulting instruction fetch stalls for one cycle. Packets that are jump targets or loop body
                  entries can be explicitly aligned to ensure this does not occur (Section 9.5.2).
       3.4        Instruction intrinsics
                  To support efficient coding of the time-critical sections of a program (without resorting to
                  assembly language), the C compilers support intrinsics which are used to directly express
                  Hexagon processor instructions from within C code.
                  The following example shows how an instruction intrinsic expresses the XTYPE
                  instruction “Rdd = vminh(Rtt,Rss)”:
                       #include <hexagon_protos.h>
                       int main()
                       {
                            long long v1 = 0xFFFF0000FFFF0000LL;
                            long long v2 = 0x0000FFFF0000FFFFLL;
                            long long result;
                            // find the minimum for each half-word in 64-bit vector
                            result = Q6_P_vminh_PP(v1,v2);
                       }
                  Intrinsics are provided for instructions in the following classes:
                          ALU32
                          XTYPE
                          CR (predicate operations only)
                          SYSTEM (dcfetch only)
                  For more information on intrinsics see Chapter 11.
80-N2040-45 Rev. B                                                                                              54
Hexagon V67 Programmer’s Reference Manual                                                              Instructions
       3.5        Compound instructions
                  The Hexagon processor supports compound instructions, which encode pairs of
                  commonly-used operations in a single instruction. For example, each of the following is a
                  single compound instruction:
                       dealloc_return                              //   deallocate frame and return
                       R2 &= and(R1, R0)                           //   and and and
                       R7 = add(R4, sub(#15, R3))                  //   subtract and add
                       R3 = sub(#20, asl(R3, #16))                 //   shift and subtract
                       R5 = add(R2, mpyi(#8, R4))                  //   multiply and add
                       {                                           //   compare and jump
                           P0 = cmp.eq (R2, R5)
                           if (P0.new) jump:nt target
                       }
                       {                                           // register transfer and jump
                               R2 = #15
                               jump target
                       }
                  Using compound instructions reduces code size and improves code performance.
                      NOTE      Compound instructions (with the exception of X-and-jump, as shown above)
                                have distinct assembly syntax from the instructions they are composed of.
       3.6        Duplex instructions
                  To reduce code size the Hexagon processor supports duplex instructions, which encode
                  pairs of commonly-used instructions in a 32-bit instruction container.
                  Unlike compound instructions (Section 3.5), duplex instructions do not have distinctive
                  syntax – in assembly code they appear identical to the instructions they are composed of.
                  The assembler is responsible for recognizing when a pair of instructions can be encoded as
                  a single duplex rather than a pair of regular instruction words.
                  In order to fit two instructions into a single 32-bit word, duplexes are limited to a subset of
                  the most common instructions (load, store, branch, ALU), and the most common register
                  operands.
                  For more information on duplexes, see Section 10.2 and Section 10.3.
80-N2040-45 Rev. B                                                                                               55
          4 Data Processing
                  The Hexagon processor provides a rich set of operations for processing scalar and vector
                  data.
                  This chapter presents an overview of the operations provided by the following Hexagon
                  processor instruction classes:
                         XTYPE – General-purpose data operations
                         ALU32 – Arithmetic/logical operations on 32-bit data
                     NOTE     For detailed descriptions of these instruction classes see Chapter 11.
80-N2040-45 Rev. B                                                                                       56
Hexagon V67 Programmer’s Reference Manual                                                      Data Processing
       4.1        Data types
                  The Hexagon processor provides operations for processing the following data types:
                          Fixed-point data
                          Floating-point data
                          Complex data
                          Vector data
     4.1.1        Fixed-point data
                  The Hexagon processor provides operations to process 8-, 16-, 32-, or 64-bit fixed-point
                  data. The data can be either integer or fractional, and in signed or unsigned format.
     4.1.2        Floating-point data
                  The Hexagon processor provides operations to process 32-bit floating-point numbers. The
                  numbers are stored in IEEE single-precision floating-point format.
                  Per the IEEE standard, certain floating-point values are defined to represent positive or
                  negative infinity, as well as Not-a-Number (NaN), which represents values that have no
                  mathematical meaning.
                  Floating-point numbers can be held in a general register.
     4.1.3        Complex data
                  The Hexagon processor provides operations to process 32- or 64-bit complex data.
                  Complex numbers include a signed real portion and a signed imaginary portion. Given
                  two complex numbers (a+bi) and (c+di), the complex multiply operations computes both
                  the real portion (ac-bd) and the imaginary portion (ad+bc) in a single instruction.
                  Complex numbers can be packed in a general register or register pair. When packed, the
                  imaginary portion occupies the most-significant portion of the register or register pair.
     4.1.4        Vector data
                  The Hexagon processor provides operations to process 64-bit vector data.
                  Vector data types pack multiple data items – bytes, halfwords, or words – into 64-bit
                  registers. Vector data operations are common in video and image processing.
                  Eight 8-bit bytes can be packed into a 64-bit register.
                  Figure 4-1 shows an example of a vector byte operation.
80-N2040-45 Rev. B                                                                                          57
Hexagon V67 Programmer’s Reference Manual                                                      Data Processing
                                                                                            Rss
                                                                                            Rtt
                     Op       Op      Op      Op      Op       Op       Op       Op
                                                                                           Rdd
                  Figure 4-1 Vector byte operation
                  Four 16-bit halfword values can be packed in a single 64-bit register pair.
                  Figure 4-2 shows an example of a vector halfword operation.
                                                                                            Rss
                                                                                            Rtt
                           Op              Op              Op                Op
                                                                                           Rdd
                  Figure 4-2 Vector halfword operation
                  Two 32-bit word values can be packed in a single 64-bit register pair.
                  Figure 4-3 shows an example of a vector word operation.
                                                                                           Rss
                                                                                            Rtt
                                  Op                               Op
                                                                                           Rdd
                  Figure 4-3 Vector word operation
80-N2040-45 Rev. B                                                                                          58
Hexagon V67 Programmer’s Reference Manual                                                         Data Processing
       4.2        Instruction options
                  Some instructions support optional scaling, saturation, and rounding. There are no mode
                  bits controlling these options – instead, they are explicitly specified as part of the
                  instruction name. The options are described in this section.
     4.2.1        Fractional scaling
                  In fractional data format, data is treated as fixed-point fractional values whose range is
                  determined by the word length and radix point position.
                  Fractional scaling is specified in an instruction by adding the :<<1 specifier. For
                  example:
                       R3:2 = cmpy(R0,R1):<<1:sat
                  When two fractional numbers are multiplied, the product must be scaled to restore the
                  original fractional data format. The Hexagon processor allows fractional scaling of the
                  product to be specified in the instruction for shifts of 0 and 1. Perform a shift of 1 for
                  Q1.15 numbers, and a shift of 0 for integer multiplication.
     4.2.2        Saturation
                  Certain instructions are available in saturating form. If a saturating arithmetic instruction
                  has a result which is smaller than the minimum value, then the result is set to the minimum
                  value. Similarly, if the operation has a result which is greater than the maximum value,
                  then the result is set to the maximum value.
                  Saturation is specified in an instruction by adding the :sat specifier. For example:
                       R2 = abs(R1):sat
                  The OVF bit in the user status register (Section 2.2.3) is set whenever a saturating
                  operation saturates to the maximum or minimum value. It remains set until explicitly
                  cleared by a control register transfer to USR. For vector-type saturating operations, if any
                  of the individual elements of the vector saturate, then OVF is set.
     4.2.3        Arithmetic rounding
                  Certain signed multiply instructions support optional arithmetic rounding (also known as
                  biased rounding). The arithmetic rounding operation takes a double precision fractional
                  value and adds 0x8000 to the low 16-bits (least significant 16-bit halfword).
                  Rounding is specified in an instruction by adding the :rnd specifier. For example:
                       R2 = mpy(R1.h,R2.h):rnd
                      NOTE     Arithmetic rounding can accumulate numerical errors, especially when the
                               number to be rounded is exactly 0.5. This happens most frequently when
                               dividing by 2 or averaging.
80-N2040-45 Rev. B                                                                                             59
Hexagon V67 Programmer’s Reference Manual                                                         Data Processing
     4.2.4        Convergent rounding
                  To address the problem of error accumulation in arithmetic rounding (Section 4.2.3), the
                  Hexagon processor includes four instructions that support positive and negative averaging
                  with a convergent rounding option.
                  These instructions work as follows:
                    1. Compute (A+B) or (A-B) for AVG and NAVG respectively.
                    2. Based on the two least-significant bits of the result, add a rounding constant as
                       follows:
                         If the two LSBs are 00, add 0
                           If the two LSBs are 01, add 0
                           If the two LSBs are 10, add 0
                           If the two LSBs are 11, add 1
                    3. Shift the result right by one bit.
     4.2.5        Scaling for divide and square-root
                  On the Hexagon processor, floating point divide and square-root operations are
                  implemented in software using library functions. To enable the efficient implementation of
                  these operations, the processor supports special variants of the multiply-accumulate
                  instruction. These are named scale FMA.
                  Scale FMA supports optional scaling of the product generated by the floating-point fused
                  multiply-add instruction.
                  Scaling is specified in the instruction by adding the :scale specifier and a predicate
                  register operand. For example:
                       R3 += sfmpy(R0,R1,P2):scale
                  For single precision, the scaling factor is two raised to the power specified by the contents
                  of the predicate register (which is treated as an 8-bit two's complement value). For double
                  precision, the predicate register value is doubled before being used as a power of two.
                      NOTE       Scale FMA instructions are not for use outside of divide and square-root
                                 library routines. No guarantee is provided that future versions of the Hexagon
                                 processor will implement these instructions using the same semantics. Future
                                 versions assume only that compatibility for scale FMA is limited to the needs
                                 of divide and square-root library routines.
80-N2040-45 Rev. B                                                                                             60
Hexagon V67 Programmer’s Reference Manual                                                   Data Processing
       4.3        XTYPE operations
                  The XTYPE instruction class includes most of the data-processing operations performed
                  by the Hexagon processor. These operations are categorized by their operation type:
                         ALU
                         Bit manipulation
                         Complex
                         Floating point
                         Multiply
                         Permute
                         Predicate
                         Shift
     4.3.1        ALU
                  ALU operations modify 8-, 16-, 32-, and 64-bit data. These operations include:
                         Add and subtract with and without saturation
                         Add and subtract with accumulate
                         Absolute value
                         Logical operations
                         Min, max, negate instructions
                         Register transfers of 64-bit data
                         Word to doubleword sign extension
                         Comparisons
                  For more information see Section 11.1.1.
80-N2040-45 Rev. B                                                                                       61
Hexagon V67 Programmer’s Reference Manual                                                        Data Processing
     4.3.2        Bit manipulation
                  Bit manipulation operations modify bit fields in a register or register pair. These
                  operations include:
                         Bit field insert
                         Bit field signed and unsigned extract
                         Count leading and trailing bits
                         Compare bit masks
                         Set / Clear / Toggle bit
                         Test bit operation
                         Interleave/deinterleave bits
                         Bit reverse
                         Split bit field
                         Masked parity and Linear Feedback shift
                         Table index formation
                  For more information see Section 11.10.2.
     4.3.3        Complex
                  Complex operations manipulate complex numbers. These operations include:
                         Complex add and subtract
                         Complex multiply with optional round and pack
                         Vector complex multiply
                         Vector complex conjugate
                         Vector complex rotate
                         Vector reduce complex multiply real or imaginary
                  For more information see Section 11.10.3.
80-N2040-45 Rev. B                                                                                            62
Hexagon V67 Programmer’s Reference Manual                                                        Data Processing
     4.3.4        Floating point
                  Floating-point operations manipulate single-precision floating point numbers. These
                  operations include:
                           Addition and subtraction
                           Multiplication (with optional scaling)
                           Min/max/compare
                           Format conversion
                  The Hexagon floating-point operations are defined to support the IEEE floating-point
                  standard. However, certain IEEE-required operations – such as divide and square root –
                  are not supported directly. Instead, special instructions are defined to support the
                  implementation of the required operations as library routines. These instructions include:
                           A special version of the fused multiply-add instruction (designed specifically for
                            use in library routines)
                           Reciprocal/square root approximations (which compute the approximate initial
                            values used in reciprocal and reciprocal-square-root routines)
                           Extreme value assistance (which adjusts input values if they cannot produce
                            correct results using convergence algorithms)
                  For more information see Section 11.10.4.
                      NOTE      The special floating-point instructions are not intended for use directly in user
                                code – use them only in the floating point library.
                  Format conversion
                  The floating-point conversion instructions sfmake and dfmake convert an unsigned 10-bit
                  immediate value into the corresponding floating-point value.
                  The immediate value must be encoded so bits [5:0] contain the significand, and bits [9:6]
                  the exponent. The exponent value is added to the initial exponent value (bias - 6).
                  For example, to generate the single-precision floating point value 2.0, bits [5:0] must be
                  set to 0, and bits [9:6] set to 7. Performing sfmake on this immediate value yields the
                  floating point value 0x40000000, which is 2.0.
                      NOTE      The conversion instructions are designed to handle common floating point
                                values, including most integers and many basic fractions (1/2, 3/4, etc.).
                  Rounding
                  The Hexagon user status register (Section 2.2.3) includes the FPRND field, which
                  specifies the IEEE-defined floating-point rounding mode.
80-N2040-45 Rev. B                                                                                             63
Hexagon V67 Programmer’s Reference Manual                                                        Data Processing
                  Exceptions
                  The Hexagon user status register (Section 2.2.3) includes five status fields, which work as
                  sticky flags for the five IEEE-defined exception conditions: inexact, overflow, underflow,
                  divide by zero, and invalid. A sticky flag is set when the corresponding exception occurs,
                  and remains set until explicitly cleared.
                  The user status register also includes five mode fields which specify whether to perform
                  an operating-system trap if one of the floating-point exceptions occurs. For every
                  instruction packet containing a floating-point operation, if a floating-point sticky flag and
                  the corresponding trap-enable bit are both set, a floating-point trap is generated. After the
                  packet commits, the Hexagon processor then automatically traps to the operating system.
                      NOTE      Non-floating-point instructions never generate a floating-point trap,
                                regardless of the state of the sticky flag and trap-enable bits.
     4.3.5        Multiply
                  Multiply operations support fixed-point multiplication, including both single- and double-
                  precision multiplication, and polynomial multiplication.
                  Single precision
                  In single-precision arithmetic a 16-bit value is multiplied by another 16-bit value. These
                  operands can come from the high portion or low portion of any register. Depending on the
                  instruction, the result of the 16  16 operation can optionally be accumulated, saturated,
                  rounded, or shifted left by 0-1 bits.
                  The instruction set supports operations on signed  signed, unsigned  unsigned, and
                  signed  unsigned data.
80-N2040-45 Rev. B                                                                                            64
Hexagon V67 Programmer’s Reference Manual                                                       Data Processing
                  Table 4-1 summarizes the options available for 16  16 single precision multiplications.
                  The symbols used in the table are as follows:
                         SS – Perform signed  signed multiply
                         UU – Perform unsigned  unsigned multiply
                         SU – Perform signed  unsigned multiply
                         A+ – Result added to accumulator
                         A- – Result subtracted from accumulator
                         0 – Result not added to accumulator
                  Table 4-1    Single-precision multiply options
                     Multiply       Result        Sign      Accumulate        Sat      Rnd      Scale
                      16  16         32           SS          A+, A-        Yes        No       0-1
                      16  16         32           SS             0          Yes       Yes       0-1
                      16  16         64           SS          A+, A-         No        No       0-1
                      16  16         64           SS             0           No       Yes       0-1
                      16  16         32           UU         A+, A-, 0       No        No       0-1
                      16  16         64           UU         A+, A-, 0       No        No       0-1
                      16  16         32           SU           A+, 0        Yes        No       0-1
                  Double precision
                  Double precision instructions are available for both 32  32 and 32  16 multiplication:
                         For 32  32 multiplication the result can be either 64 or 32 bits. The 32-bit result
                          can be either the high or low portion of the 64-bit product.
                         For 32  16 multiplication the result is always taken as the upper 32 bits.
                  The operands can be either signed or unsigned.
                  Table 4-2 summarizes the options available in double precision multiply.
                  Table 4-2    Double precision multiply options
                     Multiply       Result         Sign        Accumulate         Sat       Rnd     Scale
                     32 32          64          SS, UU         A+, A-, 0        No         No       0
                     32 32      32 (upper)      SS, UU             0            No        Yes       0
                     32 32       32 (low)       SS, UU           A+, 0          No         No       0
                     32 16      32 (upper)      SS, UU           A+, 0          Yes       Yes      0-1
                     32 32      32 (upper)        SU               0            No         No       0
                  Polynomial
                  Polynomial multiply instructions are available for both words and vector halfwords.
80-N2040-45 Rev. B                                                                                           65
Hexagon V67 Programmer’s Reference Manual                                                     Data Processing
                  These instructions are useful for many algorithms including scramble code generation,
                  cryptographic algorithms, convolutional, and Reed Solomon code.
                  For more information on multiply operations, see Section 11.10.5.
     4.3.6        Permute
                  Permute operations perform various operations on vector data, including arithmetic,
                  format conversion, and rearrangement of vector elements. Many types of conversions are
                  supported:
                          Swizzle bytes
                          Vector shuffle
                          Vector align
                          Vector saturate and pack
                          Vector splat bytes
                          Vector splice
                          Vector sign extend halfwords
                          Vector zero extend bytes
                          Vector zero extend halfwords
                          Scalar saturate to byte, halfword, word
                          Vector pack high and low halfwords
                          Vector round and pack
                          Vector splat halfwords
                  For more information, see Section 11.1.2 and Section 11.10.6.
     4.3.7        Predicate
                  Predicate operations modify predicate source data. The categories of instructions available
                  include:
                          Vector mask generation
                          Predicate transfers
                          Viterbi packing
                  For more information, see Section 11.1.3 and Section 11.10.7.
80-N2040-45 Rev. B                                                                                         66
Hexagon V67 Programmer’s Reference Manual                                                          Data Processing
     4.3.8        Shift
                  Scalar shift operations perform a variety of 32 and 64-bit shifts followed by an optional
                  add/sub or logical operation. Figure 4-4 shows the general operation.
                                                                                                   Rss
                                                                                                  # / Rt
                                                                                   Shift
                                                                                  amount
                                                     64-bit Shifter
                                                64-bit Add/Sub/Logical
                                                                                                Rxx
                  Figure 4-4 64-bit shift and add/sub/logical
                  Four shift types are supported:
                          ASR – Arithmetic shift right
                          ASL – Arithmetic shift left
                          LSR – Logical shift right
                          LSL – Logical shift left
                  In register-based shifts, the Rt register is a signed two’s-complement number. If this value
                  is positive, then the instruction opcode tells the direction of shift (right or left). If this
                  value is negative, then the shift direction indicated by the opcode is reversed.
                  When arithmetic right shifts are performed, the sign bit is shifted in, whereas logical right
                  shifts shift in zeros. Left shifts always shift in zeros.
                  Some shifts are available with saturation and rounding options.
                  For more information see Section 11.10.8.
80-N2040-45 Rev. B                                                                                               67
Hexagon V67 Programmer’s Reference Manual                                                   Data Processing
       4.4        ALU32 operations
                  The ALU32 instruction class includes general arithmetic/logical operations on 32-bit data:
                        Add, subtract, negate without saturation on 32-bit data
                        Logical operations such as AND, OR, XOR, AND with immediate, and OR with
                         immediate
                        Scalar 32-bit compares
                        Combine halfwords, combine words, combine with immediates, shift halfwords,
                         and Mux
                        Conditional add, combine, logical, subtract, and transfer.
                        NOP
                        Sign and zero-extend bytes and halfwords
                        Transfer immediates and registers
                        Vector add, subtract, and average halfwords
                  For more information see Section 11.1.
                     NOTE     ALU32 instructions can be executed on any slot (Section 3.3.3).
                              Chapter 6 describes the conditional execution and compare instructions.
80-N2040-45 Rev. B                                                                                        68
Hexagon V67 Programmer’s Reference Manual                                                     Data Processing
       4.5        Vector operations
                  Vector operations support arithmetic operations on vectors of bytes, halfwords, and words.
                  The vector operations belong to the XTYPE instruction class (except for vector add,
                  subtract, and average halfwords, which are ALU32).
                  Vector byte operations
                  The vector byte operations process packed vectors of signed or unsigned bytes. They
                  include the following operations:
                         Vector add and subtract signed or unsigned bytes
                         Vector min and max signed or unsigned bytes
                         Vector compare signed or unsigned bytes
                         Vector average unsigned bytes
                         Vector reduce add unsigned bytes
                         Vector sum of absolute differences unsigned bytes
                  Vector halfword operations
                  The vector halfword operations process packed 16-bit halfwords. They include the
                  following operations:
                         Vector add and subtract halfwords
                         Vector average halfwords
                         Vector compare halfwords
                         Vector min and max halfwords
                         Vector shift halfwords
                         Vector dual multiply
                         Vector dual multiply with round and pack
                         Vector multiply even halfwords with optional round and pack
                         Vector multiply halfwords
                         Vector reduce multiply halfwords
80-N2040-45 Rev. B                                                                                         69
Hexagon V67 Programmer’s Reference Manual                                                         Data Processing
                  For example, Figure 4-5 shows the operation of the vector arithmetic shift right halfword
                  (vasrh) instruction. In this instruction, each 16-bit half-word is shifted right by the same
                  amount which is specified in a register or with an immediate value. Because the shift is
                  arithmetic, the bits shifted in are copies of the sign bit.
                                                                                  Shift Amount   Rt / #u4
                                   lost              lost             lost                  lost Rss
                     s/z ext             s/z ext          s/z ext            s/z ext             Rdd
                  Figure 4-5 Vector halfword shift right
                  Vector word operations
                  The vector word operations process packed vectors of two words. They include the
                  following operations:
                            Vector add and subtract words
                            Vector average words
                            Vector compare words
                            Vector min and max words
                            Vector shift words with optional truncate and pack
                  For more information on vector operations see Section 11.1.1.
80-N2040-45 Rev. B                                                                                             70
Hexagon V67 Programmer’s Reference Manual                                                              Data Processing
       4.6        CR operations
                  The CR instruction class includes operations that access the control registers (Section 2.2).
                  Table 4-3 lists the instructions that access the control registers.
                  Table 4-3     Control register transfer instructions
                             Syntax                                           Operation
                   Rd = Cs                        Move control register to / from a general register.
                   Cd = Rs
                                                  NOTE - PC is not a valid destination register.
                   Rdd = Css                      Move control register pair to / from a general register pair.
                   Cdd = Rss
                                                  NOTE - PC is not a valid destination register.
                      NOTE     In register-pair transfers, control registers must be specified using their
                               numeric alias names – see Section 2.2 for details.
                   For more information see Section 11.2.
       4.7        Compound operations
                  The instruction set includes a number of instructions that perform multiple logical or
                  arithmetic operations in a single instruction. They include the following operations:
                         And/Or with inverted input
                         Compound logical register
                         Compound logical predicate
                         Compound add-subtract with immediates
                         Compound shift-operation with immediates (arithmetic or logical)
                         Multiply-add with immediates
       4.8        Special operations
                  The instruction set includes a number of special-purpose instructions to support specific
                  applications:
                         H.264 CABAC processing
                         IP Internet checksum
                         Software-defined radio
80-N2040-45 Rev. B                                                                                                  71
Hexagon V67 Programmer’s Reference Manual                                                     Data Processing
     4.8.1       H.264 CABAC processing
                 H.264/AVC is adopted in a diverse range of multimedia applications:
                             HD-DVDs
                             HDTV broadcasting
                             Internet video streaming
                 Context Adaptive Binary Arithmetic Coding (CABAC) is one of the two alternative
                 entropy coding methods specified in the H.264 main profile. CABAC offers superior
                 coding efficiency at the expense of greater computational complexity. The Hexagon
                 processor includes a dedicated instruction (decbin) to support CABAC decoding.
                 Binary arithmetic coding is based on the principle of recursive interval subdivision, and its
                 state is characterized by two quantities:
                             The current interval range
                             The current offset in the current code interval
                 The offset is read from the encoded bit stream. When decoding a bin, the interval range is
                 subdivided in two intervals based on the estimation of the probability pLPS of LPS: one
                 interval with width of rLPS = range x pLPS, and another with width of rMPS = range x
                 pMPS = range -rLPS, where LPS stands for Least Probable Symbol, and MPS for Most
                 Probable Symbol.
                 Depending on which subinterval the offset falls into, the decoder decides whether the bin
                 is decoded as MPS or LPS, after which the two quantities are iteratively updated, as shown
                 in Figure 4-1.
                              MPS occurs                    LPS occurs
                                             rLPS                        rLPS
                          range                         range
                                             rMPS                        rMPS
                                  offset                        offset
                          rangeNew = rMPS               rangeNew = rLPS
                          offsetNew = offset            offsetNew = offset-rMPS
                 Figure 4-1                Arithmetic decoding for one bin
80-N2040-45 Rev. B                                                                                          72
Hexagon V67 Programmer’s Reference Manual                                                          Data Processing
    4.8.1.1       CABAC implementation
                  In H.264 range is a 9-bit quantity, and offset is 9-bits in regular mode and 10-bits in bypass
                  mode during the whole decoding process. The calculation of rLPS is approximated by a
                  64×4 table of 256 bytes, where the range and the context state (selected for the bin to be
                  decoded) are used to address the lookup table. To maintain the precision of the whole
                  decoding process, the new range must be renormalized to ensure that the most significant
                  bit is always 1, and that the offset is synchronously refilled from the bit stream.
                  To simplify the renormalization/refilling process, the decoding scheme shown in
                  Figure 4-2 was created to significantly reduce the frequency of renormalization and
                  refilling bits from the bit-stream, while also being suitable for DSP implementation.
                            range: 32 bit register            18=29-bitpos
                                 0000 0000 0001 xxxx xxxx 0000 0000 0000
                                    bitpos=11            9        12=23-bitpos
                            offset: 32 bit register
                                 0000 0000 000x xxxx xxxx xxxx xxxx xxxx
                                                         Decode Decision
                                                      (ctxIdx, range, offset)
                                               bitpos=Count_leading_zeros(range)
                            rLPS=lutLPS[ctxIdx->state][(range>>(29-bitpos))&3]<<(23-bitpos)
                                                        rMPS=range-rLPS
                                        Yes               offset >= rMPS               No
                         bin = !ctxIdx->valMPS
                                                                                 bin = ctxIdx->valMPS
                              range = rLPS
                                                                                     range = rMPS
                          offset = offset - rMPS
                            ctxIdx->state == 0              Yes
                                             ctxIdx->valMPS=!ctxIdx->valMPS
                                    No
                              ctxIdx->state =                                        ctxIdx->state =
                    TransIndexLPS(ctxIdx->state)                             TransIndexMPS(ctxIdx->state)
                                                         Renormalization1
                                                           (range, offset)
                                                                Done
                  Figure 4-2         CABAC decoding engine for regular bin
80-N2040-45 Rev. B                                                                                              73
Hexagon V67 Programmer’s Reference Manual                                                   Data Processing
                  By using the decbin instruction, the Hexagon processor is able to decode one regular bin
                  in 2 cycles (not counting the bin refilling process).
                  For more information on the decbin instruction see CABAC decode bin.
                  For example:
                      Rdd = decbin(Rss,Rtt)
                      INPUT: Rss and Rtt register pairs as:
                      Rtt.w1[5:0] = state
                      Rtt.w1[8] = valMPS
                      Rtt.w0[4:0] = bitpos
                      Rss.w0 = range
                      Rss.w1 = offset
                      OUTPUT: Rdd register pair is packed as
                      Rdd.w0[5:0] = state
                      Rdd.w0[8] = valMPS
                      Rdd.w0[31:23] = range
                      Rdd.w0[22:16] = '0'
                      Rdd.w1 = offset (normalized)
                      OUTPUT: P0
                      P0 = (bin)
    4.8.1.2       Code example
                      H264CabacGetBinNC:
                      /****************************************************************
                      * Non-conventional call:
                      * Input: R1:0 = offset : range , R2 = dep,                  R3 = ctxIdx,
                      * R4 = (*ctxIdx), R5 = bitpos
                      *
                      * Return:
                      *          R1: 0 - offset : range
                      *          P0 - (bin)
                      *****************************************************************/
                      // Cycle #1
                      { R1:0= decbin(R1:0,R5:4)              // decoding one bin
                         R6 = asl(R22,R5)                    // where R22 = 0x100
                      }
                      // Cycle #2
                      { memb(R3) = R0                        // save context to *ctxIdx
                          R1:0 = vlsrw(R1:0,R5)              // re-align range and offset
                          P1 = cmp.gtu(R6,R1)               // need refill? i.e., P1= (range<0x100)
                          IF (!P1.new) jumpr:t LR // return
                      }
                      RENORM_REFILL:
                      ...
80-N2040-45 Rev. B                                                                                       74
Hexagon V67 Programmer’s Reference Manual                                                        Data Processing
     4.8.2        IP internet checksum
                  The key features of the internet checksum1 include:
                      The checksum can be summed in any order
                      Carries may be accumulated using an accumulator larger than size being added, and
                       added back in at any time
                  Using standard data-processing instructions, the internet checksum can be computed at 8
                  bytes per cycle in the main loop, by loading words and accumulating into doublewords.
                  After the loop, the upper word is added to the lower word; then the upper halfword is
                  added to the lower halfword, and any carries are added back in.
                  The Hexagon processor supports a dedicated instruction (vradduh) which enables the
                  internet checksum to be computed at a rate of 16 bytes per cycle.
                  The vradduh instruction accepts the halfwords of the two input vectors, adds them all
                  together, and places the result in a 32-bit destination register. This operation can be used
                  for both computing the sum of 16 bytes of input while preserving the carries, and also
                  accumulating carries at the end of computation.
                  For more information on the vradduh instruction see Vector reduce add halfwords.
                      NOTE     This operation utilizes the maximum load bandwidth available in the
                               Hexagon processor.
                  1 See RFC 1071 (http://www.faqs.org/rfcs/rfc1071.html)
80-N2040-45 Rev. B                                                                                            75
Hexagon V67 Programmer’s Reference Manual                                   Data Processing
    4.8.2.1       Code example
                    .text
                    .global fast_ip_check
                    // Assumes data is 8-byte aligned
                    // Assumes data is padded at least 16 bytes afterwords with 0's.
                    // input R0 points to data
                    // input R1 is length of data
                    // returns IP checksum in R0
                    fast_ip_check:
                    {
                       R1 = lsr(R1,#4)           // 16-byte chunks, rounded down, +1
                       R9:8 = combine(#0,#0)
                       R3:2 = combine(#0,#0)
                    }
                    {
                       loop0(1f,R1)
                       R7:6 = memd(R0+#8)
                       R5:4 = memd(R0++#16)
                    }
                    .falign
                    1:
                    {
                       R7:6 = memd(R0+#8)
                       R5:4 = memd(R0++#16)
                       R2 = vradduh(R5:4,R7:6)     // accumulate 8 halfwords
                       R8 = vradduh(R3:2,R9:8)     // accumulate carries
                    }:endloop0
                    // drain pipeline
                    {
                       R2 = vradduh(R5:4,R7:6)
                       R8 = vradduh(R3:2,R9:8)
                       R5:4 = combine(#0,#0)
                    }
                    {
                       R8 = vradduh(R3:2,R9:8)
                       R1 = #0
                    }
                    // may have some carries to add back in
                    {
                       R0 = vradduh(R5:4,R9:8)
                    }
                    // possible for one more to pop out
                    {
                       R0 = vradduh(R5:4,R1:0)
                    }
                    {
                       R0 = not(R0)
                       jumpr LR
                    }
80-N2040-45 Rev. B                                                                       76
Hexagon V67 Programmer’s Reference Manual                                                    Data Processing
     4.8.3        Software-defined radio
                  The Hexagon processor includes six special-purpose instructions which support the
                  implementation of software-defined radio. The instructions greatly accelerate the
                  following algorithms:
                          Rake despreading
                          Scramble code generation
                          Polynomial field processing
    4.8.3.1       Rake despreading
                  A fundamental operation in despreading is the PN multiply operation. In this operation the
                  received complex chips are compared against a pseudo-random sequence of QAM
                  constellation points and accumulated.
                  Figure 4-3 shows the vrcrotate instruction, which performs this operation. The products
                  are summed to form a soft 32-bit complex symbol. The instruction has both accumulating
                  and non-accumulating versions.
                Rxx += vrcrotate(Rss,Rt,#0)
                                                                          Rt
                          1 j -1 -j      1 j -1 -j     1 j -1 -j        1 j -1 -j
                             mux            mux          mux              mux
                          Im3     Re3     Im2      Re2  Im1      Re1   Im0      Re0     Rs
                              *              *            *                *
                                     +                               +
                                      I                            R                Rxx
                  Figure 4-3         Vector reduce complex rotate
                  For more information on the vrcrotate instruction, see Vector reduce complex rotate.
80-N2040-45 Rev. B                                                                                         77
Hexagon V67 Programmer’s Reference Manual                                                      Data Processing
                     NOTE      Using this instruction the Hexagon processor can process 5.3 chips per cycle,
                               and a 12-finger WCDMA user requires only 15 MHz.
    4.8.3.2       Polynomial operations
                  The polynomial multiply instructions support the following operations:
                          Scramble code generation (at a rate of 8 symbols per cycle for WCDMA)
                          Cryptographic algorithms (such as Elliptic Curve)
                          CRC checks (at a rate of 21bits per cycle)
                          Convolutional encoding
                          Reed Solomon codes
                  The four versions of this instruction support 32 x 32 and vector 16 x 16 multiplication both
                  with and without accumulation, as shown in Figure 4-4.
                                                                     Rxx += vpmpyh(Rs,Rt)
                    Rxx += pmpyw(Rs,Rt)
                                                                          Rs
                         Rs
                                                                          Rt
                         Rt
                                                                        16x16
                                                                       Carryless                       16x16
                                32x32
                               Carryless
                                                                      Polynomial
                                                                         Mpy        *           *    Carryless
                                                                                                    Polynomial
                                          *
                                                                                                        Mpy
                              Polynomial
                                 mpy
                                                                                   XOR       XOR
                                     XOR
                                   Rxx                                           Rxx
                  Figure 4-4        Polynomial multiply
                  For more information on the pmpy instructions, see Section 11.10.5.
80-N2040-45 Rev. B                                                                                            78
          5 Memory
                  The Hexagon processor features a load/store architecture, where numeric and logical
                  instructions operate on registers. Explicit load instructions move operands from memory
                  to registers, while store instructions move operands from registers to memory. A small
                  number of instructions (known as mem-ops) perform numeric and logical operations
                  directly on memory.
                  The address space is unified: all accesses target the same linear address space, which
                  contains both instructions and data.
80-N2040-45 Rev. B                                                                                       79
Hexagon V67 Programmer’s Reference Manual                                                              Memory
       5.1        Memory model
                  This section describes the memory model for the Hexagon processor.
     5.1.1        Address space
                  The Hexagon processor has a 32-bit byte-addressable memory address space. The entire
                  4G linear address space is addressable by the user application. A virtual-to-physical
                  address translation mechanism is provided.
     5.1.2        Byte order
                  The Hexagon processor is a little-endian machine: the lowest address byte in memory is
                  held in the least significant byte of a register, as shown in Figure 5-1.
                   Address   Contents
                       0        A                Register Contents
                       1        B
                                                            31               0
                       2        C
                                                                                 Load byte
                                                               -   -    -  A
                       3        D
                       4        E                              -   -    B  A    Load Halfword
                       5         F
                                                               D  C     B  A    Load word
                       6        G         63
                       7        H            H  G    F   E     D  C     B  A    Load doubleword
                  Figure 5-1 Hexagon processor byte order
     5.1.3        Alignment
                  Even though the Hexagon processor memory is byte-addressable, instructions and data
                  must be aligned in memory on specific address boundaries:
                        Instructions and instruction packets must be 32-bit aligned
                          Data must be aligned to its native access size.
                  Any unaligned memory access causes a memory-alignment exception.
                  The permute instructions (Section 4.3.6) can be used in applications that need to reference
                  unaligned vector data. The loads and stores still must be memory-aligned; however, the
                  permute instructions enable the data to be easily rearranged in registers.
80-N2040-45 Rev. B                                                                                          80
Hexagon V67 Programmer’s Reference Manual                                                                         Memory
                  Table 5-1 summarizes the alignment restrictions.
                  .
                  Table 5-1        Memory alignment restrictions
                          Data Type              Size (bits)        Exception When
                    Byte                               8         Never
                    Unsigned byte
                    Halfword                          16         LSB[0] != 0 1
                    Unsigned halfword
                    Word                              32         LSB[1:0] != 00
                    Unsigned word
                    Doubleword                        64         LSB[2:0] != 000
                    Instruction                       32         LSB[1:0] != 00
                    Instruction packet
                  1   LSB = Least significant bits of address
       5.2        Memory loads
                  Memory can be loaded in byte, halfword, word, or doubleword sizes. The data types
                  supported are signed or unsigned. The syntax used is memXX, where XX denotes the data
                  type.
                  Table 5-2 summarizes the supported load instructions.
Table 5-2     Load instructions
                                      Source           Destination
                                                           Size               Data
            Syntax                       Size                                                      Comment
                                                                          Placement
                                        (bits)            (bits)
 Rd = memub(Rs)                            8                32             Low 8 bits  Zero-extend 8 to 32 bits
 Rd = memb(Rs)                             8                32             Low 8 bits  Sign-extend 8 to 32 bits
 Rd = memuh(Rs)                           16                32            Low 16 bits  Zero-extend 16 to 32 bits
 Rd = memh(Rs)                            16                32            Low 16 bits  Sign-extend 16 to 32 bits
 Rd = memubh(Rs)                          16                32          Bytes 0 and 2  Bytes 1 and 3 zeroed 1
 Rd = membh(Rs)                           16                32          Bytes 0 and 2  Bytes 1 and 3 sign-extended
 Rd = memw(Rs)                            32                32             All 32 bits Load word
 Rdd = memubh(Rs)                         32                64           Bytes 0,2,4,6 Bytes 1,3,5,7 zeroed
 Rdd = membh(Rs)                          32                64           Bytes 0,2,4,6 Bytes 1,3,5,7 sign-extended
 Rdd = memd(Rs)                           64                64             All 64 bits Load doubleword
 Ryy = memh_fifo(Rs)                      16                64           High 16 bits  Shift vector and load halfword
 deallocframe                             64                64             All 64 bits See Chapter 7
 dealloc_return                           64                64             All 64 bits See Chapter 7
80-N2040-45 Rev. B                                                                                                    81
Hexagon V67 Programmer’s Reference Manual                                                                                   Memory
1 The memubh and membh instructions load contiguous bytes from memory (either 2 or 4 bytes) and unpack these bytes into a
  vector of halfwords. The instructions are useful when bytes are used as input into halfword vector operations, which is common in
  video and image processing..
                        NOTE         The memory load instructions belong to instruction class LD, and can execute
                                     only in Slots 0 or 1.
        5.3         Memory stores
                    Memory can be stored in byte, halfword, word, or doubleword sizes. The syntax used is
                    memX, where X denotes the data type.
                    Table 5-3 summarizes the supported store instructions.
                    Table 5-3         Store instructions
                                                         Source         Destination
                                 Syntax                    Size              Size                     Comment
                                                          (bits)            (bits)
                     memb(Rs) = Rt                          32                 8          Store byte (bits 7:0)
                     memb(Rs) = #s8                          8                 8          Store byte
                     memh(Rs) = Rt                          32                16          Store lower half (bits 15:0)
                     memh(Rs) = Rt.H                        32                16          Store upper half (bits 31:16)
                     memh(Rs) = #s8                          8                16          Sign-extend 8 to 16 bits
                     memw(Rs) = Rt                          32                32          Store word
                     memw(Rs) = #s8                          8                32          Sign-extend 8 to 32 bits
                     memd(Rs) = Rtt                         64                64          Store doubleword
                     allocframe(#u11)                       64                64          See Chapter 7
                        NOTE         The memory store instructions belong to instruction class ST, and can execute
                                     only in slot 0 or – when part of a dual store (Section 5.4) – slot 1.
        5.4         Dual stores
                    Two memory store instructions can appear in the same instruction packet. The resulting
                    operation is considered a dual store. For example:
                         {
                         memw(R5) = R2                  // dual store
                         memh(R6) = R3
                         }
                    Unlike most packetized operations, dual stores are not executed in parallel (Section 3.3.1).
                    Instead, the store instruction in Slot 1 effectively executes first, followed by the store
                    instruction in Slot 0.
80-N2040-45 Rev. B                                                                                                                82
Hexagon V67 Programmer’s Reference Manual                                                                  Memory
                      NOTE      The store instructions in a dual store must belong to instruction class ST
                                (Section 5.3), and can execute only in Slots 0 and 1.
       5.5        Slot 1 store with slot 0 load
                  A slot 1 store operation with a slot 0 load operation can appear in a packet. The packet
                  attribute :mem_noshuf inhibits the instruction reordering that would otherwise be done by
                  the assembler. For example:
                       {
                           memw(R5) = R2         // slot 1 store
                           R3 = memh(R6)         // slot 0 load
                       }:mem_noshuf
                  Unlike most packetized operations, these memory operations are not executed in parallel
                  (Section 3.3.1). Instead, the store instruction in Slot 1 effectively executes first, followed
                  by the load instruction in Slot 0. If the addresses of the two operations are overlapping, the
                  load receives the newly stored data. This feature is supported in processor versions V65 or
                  greater.
       5.6        New-value stores
                  A memory store instruction can store a register that is assigned a new value in the same
                  instruction packet (Section 3.3). This feature is expressed in assembly language by
                  appending the suffix “.new” to the source register. For example:
                       {
                       R2 = memh(R4+#8)                // load halfword
                       memw(R5) = R2.new               // store newly-loaded value
                       }
                  New-value store instructions have the following restrictions:
                          If an instruction uses auto-increment or absolute-set addressing mode
                           (Section 5.8), its address register cannot be used as the new-value register.
                          If an instruction produces a 64-bit result, its result registers cannot be used as the
                           new-value register.
                          If the instruction that sets a new-value register is conditional (Section 6.1.2), it
                           must always be executed.
                      NOTE      The new-value store instructions belong to instruction class NV, and can
                                execute only in Slot 0.
80-N2040-45 Rev. B                                                                                              83
Hexagon V67 Programmer’s Reference Manual                                                            Memory
         5.7        Mem-ops
                    Mem-ops perform basic arithmetic, logical, and bit operations directly on memory
                    operands, without the need for a separate load or store. Mem-ops can be performed on
                    byte, halfword, or word sizes. Table 5-4 lists the mem-ops.
                    Table 5-4    Mem-ops
                                      Syntax                                   Operation
                     memXX(Rs+#u6) [+-|&] = Rt                  Arithmetic/logical on memory
                     memXX(Rs+#u6) [+-] = #u5                   Arithmetic on memory
                     memXX(Rs+#u6) = clrbit(#u5)                Clear bit in memory
                     memXX(Rs+#u6) = setbit(#u5)                Set bit in memory
                        NOTE    The mem-op instructions belong to instruction class MEMOP, and can
                                execute only in Slot 0.
         5.8        Addressing modes
                    Table 5-5 summarizes the supported addressing modes.
Table 5-5       Addressing modes
                 Mode                            Syntax                                Operation 1
 Absolute                           memXX(##address)                     EA = address
 Absolute-set                       memXX(Re=##address)                  EA = address
                                                                         Re = address
 Absolute with register offset      memXX(Ru<<#u2+##U32)                 EA = imm + (Ru << #u2)
 Global-pointer-relative            memXX(GP+#immediate)                 EA = GP + immediate
                                    memXX(#immediate)
 Indirect                           memXX(Rs)                            EA = Rs
 Indirect with offset               memXX(Rs+#s11)                       EA = Rs + imm
 Indirect with register offset      memXX(Rs+Ru<<#u2)                    EA = Rs + (Ru << #u2)
 Indirect                           memXX(Rx++#s4)                       EA = Rx;
 with auto-increment immediate                                           Rx += (imm)
 Indirect                           memXX(Rx++Mu)                        EA = Rx;
 with auto-increment register                                            Rx += Mu
 Circular                           memXX(Rx++#s4:circ(Mu))              EA = Rx;
 with auto-increment immediate                                           Rx = circ_add(Rx,imm,Mu)
80-N2040-45 Rev. B                                                                                       84
Hexagon V67 Programmer’s Reference Manual                                                                 Memory
Table 5-5       Addressing modes
                 Mode                                    Syntax                        Operation 1
 Circular                                memXX(Rx++I:circ(Mu))            EA = Rx;
 with auto-increment register                                             Rx = circ_add(Rx,I,Mu)
 Bit-reversed                            memXX(Rx++Mu:brev)               EA = Rx.H + bit_reverse(Rx.L)
 with auto-increment register                                             Rx += Mu
1 EA (Effective Address) is equivalent to VA (Virtual Address).
       5.8.1       Absolute
                   The absolute addressing mode uses a 32-bit constant value as the effective memory
                   address. For example:
                        R2 = memw(##100000)                  // load R2 with word from addr 100000
                        memw(##200000) = R4                  // store R4 to word at addr 200000
       5.8.2       Absolute-set
                   The absolute-set addressing mode assigns a 32-bit constant value to the specified general
                   register, then uses the assigned value as the effective memory address. For example:
                        R2 = memw(R1=##400000)                  // load R2 with word from addr 400000
                                                                // and load R1 with value 400000
                        memw(R3=##600000) = R4                  // store R4 to word at addr 600000
                                                                // and load R3 with value 600000
       5.8.3       Absolute with register offset
                   The absolute with register offset addressing mode performs an arithmetic left shift of a 32-
                   bit general register value by the amount specified in a 2-bit unsigned immediate value, and
                   then adds the shifted result to an unsigned 32-bit constant value to create the 32-bit
                   effective memory address. For example:
                        R2 = memh(R3 << #3 + ##100000) // load R2 with signed halfword
                                                                      // from addr [100000 + (R3 << 3)]
                   The 32-bit constant value is the base address, and the shifted result is the byte offset.
                       NOTE        This addressing mode is useful for loading an element from a global table,
                                   where the immediate value is the name of the table, and the register holds the
                                   index of the element.
80-N2040-45 Rev. B                                                                                              85
Hexagon V67 Programmer’s Reference Manual                                                                 Memory
     5.8.4        Global pointer relative
                  The global pointer relative addressing mode adds an unsigned offset value to the Hexagon
                  processor global data pointer GP to create the 32-bit effective memory address. This
                  addressing mode accesses global and static data in C.
                  Global pointer relative addresses can be expressed two ways in assembly language:
                          By explicitly adding an unsigned offset value to register GP
                          By specifying only an immediate value as the instruction operand
                   For example:
                       R2 = memh(GP+#100)              // load R2 with signed halfword
                                                       // from [GP + 100 bytes]
                       R3 = memh(#2000)                // load R3 with signed halfword
                                                       // from [GP + #2000 - _SDA_BASE]
                  Specifying only an immediate value causes the assembler and linker to automatically
                  subtract the value of the special symbol _SDA_BASE_ from the immediate value, and use
                  the result as the effective offset from GP.
                  The global data pointer is programmed in the GDP field of register GP (Section 2.2.8).
                  This field contains an unsigned 26-bit value which specifies the most significant 26 bits of
                  the 32-bit global data pointer. (The least significant 6 bits of the pointer are defined to
                  always be zero.)
                  The memory area referenced by the global data pointer is known as the global data area. It
                  can be up to 512 KB in length, and – because of the way the global data pointer is
                  defined – must be aligned to a 64-byte boundary in virtual memory.
                  When expressed in assembly language, the offset values used in global pointer relative
                  addressing always specify byte offsets from the global data pointer. The offsets must be
                  integral multiples of the size of the instruction data type.
                  Table 5-6 lists the offset ranges for global pointer relative addressing.
                  Table 5-6      Offset ranges (global pointer relative)
                                                               Offset Must Be
                      Data Type          Offset Range
                                                                 Multiple Of
                   doubleword            0 ... 524280                 8
                   word                  0 ... 262140                 4
                   halfword              0 ... 131070                 2
                   byte                  0 ... 65535                  1
                      NOTE      When using global pointer relative addressing, the immediate operand should
                                be a symbol in the .sdata or .sbss section to ensure that the offset is valid.
80-N2040-45 Rev. B                                                                                            86
Hexagon V67 Programmer’s Reference Manual                                                               Memory
     5.8.5        Indirect
                  The indirect addressing mode uses a 32-bit value stored in a general register as the
                  effective memory address. For example:
                       R2 = memub(R1)          // load R2 with unsigned byte from addr R1
     5.8.6        Indirect with offset
                  The indirect with offset addressing mode adds a signed offset value to a general register
                  value to create the 32-bit effective memory address. For example:
                       R2 = memh(R3 + #100)             // load R2 with signed halfword
                                                        // from [R3 + 100 bytes]
                  When expressed in assembly language, the offset values always specify byte offsets from
                  the general register value. The offsets must be integral multiples of the size of the
                  instruction data type.
                  Table 5-7 lists the offset ranges for indirect with offset addressing.
                  Table 5-7     Offset ranges (indirect with offset)
                                                               Offset Must Be
                      Data Type          Offset Range
                                                                 Multiple Of
                   doubleword            -8192 ... 8184               8
                   word                  -4096 ... 4092               4
                   halfword              -2048 ... 2046               2
                   byte                  -1024 ... 1023               1
                      NOTE     The offset range is smaller for conditional instructions (Section 5.9).
     5.8.7        Indirect with register offset
                  The indirect with register offset addressing mode adds a 32-bit general register value to
                  the result created by performing an arithmetic left shift of a second 32-bit general register
                  value by the amount specified in a 2-bit unsigned immediate value, forming the 32-bit
                  effective memory address. For example:
                       R2 = memh(R3+R4<<#1)             // load R2 with signed halfword
                                                        // from [R3 + (R4 << 1)]
                  The register values always specify byte addresses.
80-N2040-45 Rev. B                                                                                           87
Hexagon V67 Programmer’s Reference Manual                                                                Memory
     5.8.8        Indirect with auto-increment immediate
                  The indirect with auto-increment immediate addressing mode uses a 32-bit value stored in
                  a general register to specify the effective memory address. However, after the address is
                  accessed, a signed value (known as the increment) is added to the register so it specifies a
                  different memory address (which is accessed in a subsequent instruction). For example:
                       R2 = memw(R3++#4)          // R3 contains the effective address
                                                  // R3 is then incremented by 4
                  When expressed in assembly language, the increment values always specify byte offsets
                  from the general register value. The offsets must be integral multiples of the size of the
                  instruction data type.
                  Table 5-8 lists the increment ranges for indirect with auto-increment immediate
                  addressing.
                  Table 5-8      Increment ranges (indirect with auto-inc immediate)
                                              Increment            Increment Must Be
                         Data Type
                                                 Range                 Multiple Of
                   doubleword                  -64 ... 56                  8
                   word                        -32 ... 28                  4
                   halfword                    -16 ... 14                  2
                   byte                          -8 ... 7                  1
     5.8.9        Indirect with auto-increment register
                  The indirect with auto-increment register addressing mode is functionally equivalent to
                  indirect with auto-increment immediate, but uses a modifier register Mx (Section 2.2.4)
                  instead of an immediate value to hold the increment. For example:
                       R2 = memw(R0++M1)          // The effective addr is the value of R0.
                                                  // Next, M1 is added to R0 and the result
                                                  // is stored in R0.
                  When auto-incrementing with a modifier register, the increment is a signed 32-bit value
                  which is added to the general register. This offers two advantages over auto-increment
                  immediate:
                          A larger increment range
                          Variable increments (since the modifier register can be programmed at runtime)
                  The increment value always specifies a byte offset from the general register value.
                      NOTE      The signed 32-bit increment range is identical for all instruction data types
                                (doubleword, word, halfword, byte).
80-N2040-45 Rev. B                                                                                            88
Hexagon V67 Programmer’s Reference Manual                                                                Memory
    5.8.10        Circular with auto-increment immediate
                  The circular with auto-increment immediate addressing mode is a variant of indirect with
                  auto-increment addressing – it accesses data buffers in a modulo wrap-around fashion.
                  Circular addressing is commonly used in data stream processing.
                  Circular addressing is expressed in assembly language with the address modifier
                  “:circ(Mx)”, where Mx specifies a modifier register which is programmed to specify
                  the circular buffer (Section 2.2.4). For example:
                       R0 = memb(R2++#4:circ(M0))               // load from R2 in circ buf specified
                                                                // by M0
                       memw(R2++#8:circ(M1)) = R0               // store to R2 in circ buf specified
                                                                // by M1
                  Circular addressing is set up by programming the following elements:
                         The Length field of the Mx register is set to the length (in bytes) of the circular
                           buffer to be accessed. A circular buffer can be from 4 to (128K-1) bytes long.
                          The K field of the Mx register is always set to 0.
                          The circular start register CSx that corresponds to Mx (CS0 for M0, CS1 for M1)
                           is set to the start address of the circular buffer.
                  In circular addressing, after memory is accessed at the address specified in the general
                  register, the general register is incremented by the immediate increment value and then
                  modulo’d by the circular buffer length to implement wrap-around access of the buffer.
                  When expressed in assembly language, the increment values always specify byte offsets
                  from the general register value. The offsets must be integral multiples of the size of the
                  instruction data type.
                  Table 5-9 lists the increment ranges for circular with auto-increment immediate
                  addressing.
                  Table 5-9      Increment ranges (circular with auto-inc immediate)
                                                 Increment            Increment Must Be
                         Data Type
                                                   Range                   Multiple Of
                   doubleword                     -64 ... 56                   8
                   word                           -32 ... 28                   4
                   halfword                       -16 ... 14                   2
                   byte                            -8 ... 7                    1
80-N2040-45 Rev. B                                                                                            89
Hexagon V67 Programmer’s Reference Manual                                                              Memory
                  When programming a circular buffer the following rules apply:
                        The start address must be aligned to the native access size of the buffer elements.
                         ABS(Increment) < Length. The absolute value of the increment must be less than
                          the buffer length.
                         Access size < (Length-1). The memory access size (1 for byte, 2 for halfword, 4
                          for word, 8 for doubleword) must be less than (Length-1).
                         Buffers must not wrap around in the 32-bit address space.
                     NOTE     If any of these rules are not followed the execution result is undefined.
                  For example, a 150-byte circular buffer can be set up and accessed as follows:
                      R4.H = #0                              // K = 0
                      R4.L = #150                            // length = 150
                      M0 = R4
                      R2 = ##cbuf                            // start addr = cbuf
                      CS0 = R2
                      R0 = memb(R2++#4:circ(M0))             //  Load byte from circ buf
                                                             //  specified by M0/CS0
                                                             //  inc R2 by 4 after load
                                                             //  wrap R2 around if >= 150
                  The following C function precisely describes the behavior of the circular add function:
                      unsigned int
                      fcircadd(unsigned int pointer, int offset,
                       unsigned int M_reg, unsigned int CS_reg)
                      {
                      unsigned int length;
                      int new_pointer, start_addr, end_addr;
                      length = (M_reg&0x01ffff); // lower 17-bits gives buffer size
                      new_pointer = pointer+offset;
                      start_addr = CS_reg;
                      end_addr = CS_reg + lenth;
                      if (new_pointer >= end_addr) {
                          new_pointer -= length;
                      } else if (new_pointer < start_addr) {
                          new_pointer += length;
                      }
                      return (new_pointer);
                      }
80-N2040-45 Rev. B                                                                                         90
Hexagon V67 Programmer’s Reference Manual                                                                  Memory
    5.8.11        Circular with auto-increment register
                  The circular with auto-increment register addressing mode is functionally equivalent to
                  circular with auto-increment immediate, but uses a register instead of an immediate value
                  to hold the increment.
                  Register increments are specified in circular addressing instructions by using the symbol I
                  as the increment (instead of an immediate value). For example:
                       R0 = memw(R2++I:circ(M1))              // load byte with incr of I*4 from
                                                              // circ buf specified by M1/CS1
                  When auto-incrementing with a register, the increment is a signed 11-bit value which is
                  added to the general register. This offers two advantages over circular addressing with
                  immediate increments:
                          Larger increment ranges
                          Variable increments (since the increment register can be programmed at runtime)
                  The circular register increment value is programmed in the I field of the modifier register
                  Mx (Section 2.2.4) as part of setting up the circular data access. This register field holds the
                  signed 11-bit increment value.
                  Increment values are expressed in units of the buffer element data type, and are
                  automatically scaled at runtime to the proper data access size.
                  Table 5-10 lists the increment ranges for circular with auto-increment register addressing.
                  Table 5-10 Increment ranges (circular with auto-inc register)
                                              Increment            Increment Must Be
                       Data Type
                                                Range                  Multiple Of
                   doubleword               -8192 ... 8184                  8
                   word                     -4096 ... 4092                  4
                   halfword                 -2048 ... 2046                  2
                   byte                     -1024 ... 1023                  1
                  When programming a circular buffer (with either a register or immediate increment), all
                  the rules that apply to circular addressing must be followed – for details see
                  Section 5.8.10.
                      NOTE     If any of these rules are not followed the execution result is undefined.
80-N2040-45 Rev. B                                                                                               91
Hexagon V67 Programmer’s Reference Manual                                                                Memory
    5.8.12        Bit-reversed with auto-increment register
                  The bit-reversed with auto-increment register addressing mode is a variant of indirect with
                  auto-increment addressing – it accesses data buffers using an address value which is the
                  bit-wise reversal of the value stored in the general register. Fast Fourier transforms (FFT)
                  and Viterbi encoding use bit-reversed addressing.
                  The bit-wise reversal of a 32-bit address value is defined as follows:
                          The lower 16 bits are transformed by exchanging bit 0 with bit 15, bit 1 with bit
                           14, and so on.
                          The upper 16 bits remain unchanged.
                  Bit-reversed addressing is expressed in assembly language with the address modifier
                  “:brev”. For example:
                       R2 = memub(R0++M1:brev)           // The address is (R0.H | bitrev(R0.L))
                                                        // The orginal R0 (not reversed) is added
                                                         // to M1 and written back to R0
                  The initial values for the address and increment must be set in bit-reversed form, with the
                  hardware bit-reversing the bit-reversed address value to form the effective address.
                  The buffer length for a bit-reversed buffer must be an integral power of 2, with a
                  maximum length of 64K bytes.
                  To support bit-reversed addressing, buffers must be properly aligned in memory. A bit-
                  reversed buffer is properly aligned when its starting byte address is aligned to a power of 2
                  greater than or equal to the buffer size (in bytes). For example:
                       int bitrev_buf[256] __attribute__((aligned(1024)));
                  The bit-reversed buffer declared above is aligned to 1024 bytes because the buffer size is
                  1024 bytes (256 integer words  4 bytes), and 1024 is an integral power of 2.
                  The buffer location pointer for a bit-reversed buffer must be initialized so the least-
                  significant 16 bits of the address value are bit-reversed.
                  The increment value must be initialized to the following value:
                       bitreverse(buffer_size_in_bytes / 2)
                  ...where bitreverse is defined as bit-reversing the least-significant 16 bits while leaving
                  the remaining bits unchanged.
                      NOTE     To simplify the initialization of the bit-reversed pointer, bit-reversed buffers
                               can be aligned to a 64K byte boundary. This has the advantage of allowing the
                               bit-reversed pointer to be initialized to the base address of the bit-reversed
                               buffer, with no bit-reversing required for the least-significant 16 bits of the
                               pointer value (which are all set to 0 by the 64K alignment).
                               Since buffers allocated on the stack only have an alignment of 8 bytes or less,
                               in most cases bit-reversed buffers should not be declared on the stack.
80-N2040-45 Rev. B                                                                                             92
Hexagon V67 Programmer’s Reference Manual                                                               Memory
                  After a bit-reversed memory access is completed, the general register is incremented by
                  the register increment value. The value in the general register is never affected by the bit-
                  reversal that is performed as part of the memory access.
                      NOTE       The Hexagon processor supports only register increments for bit-reversed
                                 addressing – it does not support immediate increments.
       5.9        Conditional load/stores
                  Some load and store instructions can be executed conditionally based on predicate values
                  which were set in a previous instruction. The compiler generates conditional loads and
                  stores to increase instruction-level parallelism.
                  Conditional loads and stores are expressed in assembly language with the instruction
                  prefix “if (pred_expr)”, where pred_expr specifies a predicate register expression
                  (Section 6.1). For example:
                            if (P0) R0 = memw(R2)                       // conditional load
                            if (!P2) memh(R3 + #100) = R1               // conditional store
                            if (P1.new) R3 = memw(R3++#4)               // conditional load
                  Not all addressing modes are supported in conditional loads and stores. Table 5-11 shows
                  which modes are supported.
                  Table 5-11      Addressing modes (conditional load/store)
                                  Addressing Mode                   Conditional
                   Absolute                                            Yes
                   Absolute-set                                        No
                   Absolute with register offset                       No
                   Global pointer relative                             No
                   Indirect                                            Yes
                   Indirect with offset                                Yes
                   Indirect with register offset                       Yes
                   Indirect with auto-increment immediate              Yes
                   Indirect with auto-increment register               No
                   Circular with auto-increment immediate              No
                   Circular with auto-increment register               No
                   Bit-reversed with auto-increment register           No
                  When a conditional load or store instruction uses indirect-with-offset addressing mode, the
                  offset range is smaller than the range normally defined for indirect-with-offset addressing
                  (Section 5.8.6).
80-N2040-45 Rev. B                                                                                           93
Hexagon V67 Programmer’s Reference Manual                                                            Memory
                  Table 5-12 lists the conditional and normal offset ranges for indirect-with-offset
                  addressing.
                  Table 5-12 Conditional offset ranges (indirect with offset)
                                        Offset Range         Offset Range          Offset Must Be
                      Data Type
                                        (Conditional)           (Normal)             Multiple Of
                   doubleword             0 ... 504           -8192 ... 8184              8
                   word                   0 ... 252           -4096 ... 4092              4
                   halfword               0 ... 126           -2048 ... 2046              2
                   byte                   0 ... 63            -1024 ... 1023              1
                      NOTE     For more information on conditional execution see Chapter 6.
     5.10         Cache memory
                  The Hexagon processor has a cache-based memory architecture:
                          A level 1 instruction cache holds recently-fetched instructions.
                          A level 1 data cache holds recently-accessed data memory.
                  Load/store operations that access memory through the level 1 caches are referred to as
                  cached accesses.
                  Load/stores that bypass the level 1 caches are referred to as uncached accesses.
                  Specific memory areas can be configured so they perform cached or uncached accesses.
                  This configuration is performed by the Hexagon processor’s memory management unit
                  (MMU). The operating system is responsible for programming the MMU.
                  Two types of caching are supported (as cache modes):
                          Write-through caching keep the cache data consistent with external memory by
                           always writing to the memory any data that is stored in the cache.
                          Write-back caching allows data to be stored in the cache without being
                           immediately written to external memory. Cached data that is inconsistent with
                           external memory is referred to as dirty.
                  The Hexagon processor includes dedicated cache maintenance instructions which can be
                  used to push dirty data out to external memory.
80-N2040-45 Rev. B                                                                                       94
Hexagon V67 Programmer’s Reference Manual                                                               Memory
    5.10.1        Uncached memory
                  In some cases load/store operations need to bypass the cache memories and be serviced
                  externally (for example, when accessing memory-mapped I/O, registers, and peripheral
                  devices, or other system defined entities). The operating system is responsible for
                  configuring the MMU to generate uncached memory accesses.
                  Uncached memory is categorized into two distinct types:
                          Device-type is for accessing memory that has side-effects (such as a memory-
                           mapped FIFO peripheral). The hardware ensures that interrupts do not cancel a
                           pending device access. The hardware does not re-order device accesses. Mark
                           peripheral control registers as device-type.
                          Uncached-type is for memory-like memory. No side effects are associated with an
                           access. The hardware can load from uncached memory multiple times. The
                           hardware can re-order uncached accesses.
                  For instruction accesses, device-type memory is functionally identical to uncached-type
                  memory. For data accesses, they are different.
                  Code can be executed directly from the L2 cache, bypassing the L1 cache.
    5.10.2        Tightly coupled memory
                  The Hexagon processor supports tightly-coupled instruction memory at Level 1, which is
                  defined as memory with similar access properties to the instruction cache.
                  Tightly-coupled memory is also supported at level 2, which is defined as backing store to
                  the primary caches.
                  For more information see Chapter 9.
    5.10.3        Cache maintenance operations
                  The Hexagon processor includes dedicated cache maintenance instructions which can be
                  used to invalidate cache data or push dirty data out to external memory.
                  The cache maintenance instructions operate on specific memory addresses. If the
                  instruction causes an address error (due to a privilege violation), the processor raises an
                  exception.
                      NOTE     The exception to this rule is dcfetch, which never causes a processor
                               exception.
                  Whenever maintenance operations are performed on the instruction cache, the isync
                  instruction (Section 5.11) must be executed immediately afterwards. This instruction
                  ensures that the maintenance operations are observed by subsequent instructions.
80-N2040-45 Rev. B                                                                                            95
Hexagon V67 Programmer’s Reference Manual                                                                            Memory
                  Table 5-13 lists the cache maintenance instructions.
                  Table 5-13 Cache instructions (user-level)
                                                  Permitted In
                          Syntax                                                             Operation
                                                     Packet
                   icinva(Rs)                        Solo 1         Instruction cache invalidate.
                                                                    Look up instruction cache at address Rs.
                                                                    If address is in cache, invalidate it.
                   dccleaninva(Rs)                   Slot 1         Data cache clean and invalidate.
                                                    empty or        Look up data cache at address Rs.
                                                  ALU32 only        If address is in cache and has dirty data, flush that
                                                                    data out to memory. The cache line is then
                                                                    invalidated, whether or not dirty data was written.
                   dccleana(Rs)                      Slot 1         Data cache clean.
                                                    empty or        Look up data cache at address Rs.
                                                  ALU32 only        If address is in cache and has dirty data, flush that
                                                                    data out to memory.
                   dcinva(Rs)                        Slot 1         Equivalent to dccleaninva(Rs).
                                                    empty or
                                                  ALU32 only
                   dcfetch(Rs)                      Normal 2        Data cache prefetch.
                                                                    Prefetch data at address Rs into data cache.
                                                                    NOTE - This instruction does not cause an exception.
                   l2fetch(Rs,Rt)                  ALU32 or         L2 cache prefetch.
                                                  XTYPE only        Prefetch data from memory specified by Rs and Rt
                                                                    into L2 cache.
                  1 Solo means that the instruction must not be grouped with other instructions in a packet.
                  2 Normal means that the normal instruction-grouping constraints apply.
    5.10.4        L2 cache operations
                  The cache maintenance operations (Section 5.10.3) operate on both the L1 and L2 caches.
                  The data cache coherency operations (including clean, invalidate, and clean and
                  invalidate) affect both the L1 and L2 caches, and ensure that the memory hierarchy
                  remains coherent.
                  However, the instruction cache invalidate operation affects only the L1 cache. Therefore,
                  invalidating instructions that may be in the L1 or L2 caches requires a two-step procedure:
                      1. Use icinva to invalidate instructions from the L1 cache.
                      2. Use dcinva separately to invalidate instructions from the L2 cache.
80-N2040-45 Rev. B                                                                                                        96
Hexagon V67 Programmer’s Reference Manual                                                                  Memory
    5.10.5        Cache line zero
                  The Hexagon processor includes the instruction dczeroa. This instruction allocates a line
                  in the L1 data cache and clears it (by storing all zeros). The behavior is as follows:
                          The Rs register value must be 32-byte aligned. If it is unaligned, the processor
                           raises an unaligned error exception.
                          In the case of a cache hit, the specified cache line is cleared (i.e., written with all
                           zeros) and made dirty.
                          In the case of a cache miss, the specified cache line is not fetched from external
                           memory. Instead, the line is allocated in the data cache, cleared, and made dirty.
                  This instruction is useful in optimizing write-only data. It allows for the use of write-back
                  pages – which are the most power and performance efficient – without the need to initially
                  fetch the line to be written. This removes unnecessary read bandwidth and latency.
                      NOTE      dczeroa has the same exception behavior as write-back stores.
                                A packet with dczeroa must have Slot 1 either empty or containing an
                                ALU32 instruction.
    5.10.6        Cache prefetch
                  The Hexagon processor supports the following types of cache prefetching:
                          Hardware-based instruction cache prefetching
                          Software-based data cache prefetching
                          Software-based L2FETCH
                          Hardware-based data cache prefetching
                  Hardware-based instruction cache prefetching
                  L1 and L2 instruction cache prefetching can be enabled or disabled on a per-thread basis –
                  this is done by setting the HFI field in the user status register (Section 2.2.3).
                  Software-based data cache prefetching
                  The Hexagon processor includes the instruction dcfetch. This instruction queries the L1
                  data cache based on the address specified in the instruction:
                          If the address is present in the cache, no action is taken.
                          If the cache line for the address is missing, the processor attempts to fill the cache
                           line from the next level of memory. The thread does not stall, but rather continues
                           executing while the cache line fill occurs in the background.
                          If the address is invalid, no exception is generated and the dcfetch instruction is
                           treated as a NOP.
80-N2040-45 Rev. B                                                                                               97
Hexagon V67 Programmer’s Reference Manual                                                                Memory
                  Software-based L2FETCH
                  More powerful L2 prefetching – of data or instructions – is provided by the l2fetch
                  instruction, which specifies an area of memory that is prefetched by the Hexagon
                  processor’s hardware prefetch engine. l2fetch specifies two registers (Rs and Rt) as
                  operands. Rs contains the 32-bit virtual start address of the memory area to be prefetched.
                  Rt contains three bit fields which further specify the memory area:
                          Rt[15:8] – Width, which specifies the width (in bytes) of a block of memory to
                           fetch.
                          Rt[7:0] – Height, which specifies the number of Width-sized blocks to fetch.
                          Rt[31:16] – Stride, which specifies an unsigned byte offset that increments the
                           pointer after each Width-sized block is fetched.
                  The l2fetch instruction is non-blocking: it initiates a prefetch operation which is
                  performed in the background by the prefetch engine while the thread continues to execute
                  Hexagon processor instructions.
                  The prefetch engine requests all lines in the specified memory area. If the line(s) of
                  interest are already resident in the L2 cache, the prefetch engine performs no action. If the
                  lines are not in the L2 cache, the prefetch engine attempts to fetch them.
                  The prefetch engine makes a best effort to prefetch the requested data, and attempts to
                  perform prefetching at a lower priority than demand fetches. This prevents the prefetch
                  engine from adding bus traffic when the system is under a heavy load.
                  If a program executes an l2fetch instruction while the prefetch operation from a
                  previous l2fetch is still active, the prefetch engine halts the current prefetch operation.
                      NOTE      Executing l2fetch with any bit field operand programmed to zero cancels all
                                prefetch activity.
                  The status of the current prefetch operation is maintained in the PFA field of the user
                  status register (Section 2.2.3). This field can determine whether a prefetch operation is
                  complete.
                  With respect to MMU permissions and error checking, the l2fetch instruction behaves
                  similarly to a load instruction. If the virtual address causes a processor exception, the
                  exception is taken. This differs from the dcfetch instruction, which is treated as a NOP in
                  the presence of a translation/protection error.
                      NOTE      Prefetches are dropped when the generated prefetch address resides on a
                                different page than the start address. The programmer must use sufficiently
                                large pages to ensure this does not occur.
                  Figure 5-2 shows two examples of using the l2fetch instruction. The first shows a ‘box’
                  prefetch, where a 2-D range of memory is defined within a larger frame. The second
                  example shows a prefetch for a large linear memory area of size (Lines * 128).
80-N2040-45 Rev. B                                                                                            98
Hexagon V67 Programmer’s Reference Manual                                                                        Memory
                              L2FETCH for box prefetch                           L2FETCH for large linear prefetch
                           31                                                    31             16 15     8 7       0
                                         16 15      8 7       0
                      Rt        Stride       Width     Height              Rt            128          128     Lines
                      Rs             Start Address                         Rs               Start Address
                                               Stride
                                           Width
                                         Prefetch
                            Height                                            128* Lines
                                           Area
                  Figure 5-2 L2FETCH instruction
                  Hardware-based data cache prefetching
                  L1 data cache prefetching can be enabled or disabled on a per-thread basis – this is done
                  by setting the HFD field in the user status register (Section 2.2.3).
                  When data cache prefetching is enabled, the Hexagon processor observes patterns of data
                  cache misses, and attempts to predict future misses based on any recurring patterns of
                  misses where the addresses are separated by a constant stride. If such patterns are found,
                  the processor attempts to automatically prefetch future cache lines.
                  Data cache prefetching can be user-enabled at four levels of aggressiveness:
                          HFD = 00: No prefetching
                          HFD = 01: Prefetch up to 4 lines for misses originating from a load, with a post-
                           update addressing mode that occurs within a hardware loop
                          HFD = 10: Prefetch up to 4 lines for misses originating from loads that occur
                           within a hardware loop
                          HFD = 11: Prefetch up to 8 lines for misses originating from loads
80-N2040-45 Rev. B                                                                                                    99
Hexagon V67 Programmer’s Reference Manual                                                                     Memory
     5.11         Memory ordering
                  Some devices may require synchronization of stores and loads when they are accessed. In
                  this case a set of processor instructions enable programmer control of the synchronization
                  and ordering of memory accesses.
                  Table 5-14 lists the memory-ordering instructions.
                  Table 5-14 Memory ordering instructions
                       Syntax                                            Operation
                   isync            Instruction synchronize.
                                    Execute this instruction after any instruction cache maintenance operation.
                   syncht           Synchronize transactions.
                                    Perform “heavyweight” synchronization. Ensure that all previous program
                                    transactions (e.g., memw_locked, cached and uncached load/store) have
                                    completed before execution resumes past this instruction.
                                    syncht ensures that outstanding memory operations from all threads are
                                    complete before the syncht instruction is committed.
                   barrier          Set memory barrier.
                                    Ensure proper ordering between the program accesses performed before the
                                    instruction and those performed after the instruction.
                                    All accesses before the barrier are globally observable before any access
                                    occurring after the barrier can be observed.
                                    barrier ensures that all outstanding memory operations from the thread
                                    executing the barrier are complete before the instruction is committed.
                  Data memory accesses and program memory accesses are treated separately and held in
                  separate caches. Software should ensure coherency between data and program code if
                  necessary.
                  For example, with generated or self-modified code, the modified code is placed in the data
                  cache and can be inconsistent with program cache. The software must explicitly force
                  modified data cache lines to memory (either by using a write-through policy, or through
                  explicit cache clean instructions). Then use a barrier instruction to ensure completion of
                  the stores. Finally, invalidate relevant instruction cache contents so the new instructions
                  can be re-fetched.
80-N2040-45 Rev. B                                                                                               100
Hexagon V67 Programmer’s Reference Manual                                                                    Memory
                  Here is the recommended code sequence to change and then execute an instruction:
                       ICINVA(R1)              //  clear code from instruction cache
                       ISYNC                   //  ensure that ICINVA is finished
                       MEMW(R1)=R0             //  write the new instruction
                       DCCLEANINVA(R1)         //  force data out of data cache
                       SYNCHT                  //  ensure that it’s in memory
                       JUMPR R1                //  can now execute code at R1
                      NOTE     The memory-ordering instructions must not be grouped with other
                               instructions in a packet, otherwise the behavior is undefined.
                               This code sequence differs from the one used in previous processor versions.
     5.12         Atomic operations
                  The Hexagon processor includes an LL/SC (Load Locked / Store Conditional) mechanism
                  to provide the atomic read-modify-write operation that is necessary to implement
                  synchronization primitives such as semaphores and mutexes.
                  These primitives are used to synchronize the execution of different software programs
                  running concurrently on the Hexagon processor. They can also be used to provide atomic
                  memory support between the Hexagon processor and external blocks.
                  Table 5-15 describes the atomic instructions.
                  Table 5-15 Atomic instructions
                                    Syntax                                        Description
                        Rd = memw_locked(Rs)                Load locked word.
                                                            Reserve lock on word at address Rs.
                        memw_locked(Rs,Pd) = Rt             Store conditional word.
                                                            If no other atomic operation has been performed at
                                                            the address (i.e., atomicity is ensured), perform the
                                                            store to the word at address Rs and return TRUE in
                                                            Pd; otherwise return FALSE.
                                                            TRUE indicates that the LL and SC operations have
                                                            been performed atomically.
                        Rdd = memd_locked(Rs)               Load locked doubleword.
                                                            Reserve lock on doubleword at address Rs.
                        memd_locked(Rs,Pd) = Rtt            Store conditional doubleword.
                                                            If no other atomic operation has been performed at
                                                            the address (i.e., atomicity is ensured), perform the
                                                            store to the doubleword at address Rs and return
                                                            TRUE in Pd; otherwise return FALSE.
                                                            TRUE indicates that the LL and SC operations have
                                                            been performed atomically.
80-N2040-45 Rev. B                                                                                                101
Hexagon V67 Programmer’s Reference Manual                                                            Memory
                  Here is the recommended code sequence to acquire a mutex:
                       // assume mutex address is held in R0
                       // assume R1,R3,P0,P1 are scratch
                       lockMutex:
                       R3 = #1
                       lock_test_spin:
                       R1 = memw_locked(R0)                  // do normal test to wait
                       P1 = cmp.eq(R1,#0)                    // for lock to be available
                       if (!P1) jump lock_test_spin
                       memw_locked(R0,P0) = r3               // do store conditional (SC)
                       if (!P0) jump lock_test_spin          // was LL and SC done atomically?
                  Here is the recommended code sequence to release a mutex:
                       // assume mutex address is held in R0
                       // assume R1 is scratch
                       R1 = #0
                       memw(R0) = R1
                  Atomic memX_locked operations are supported for external accesses that use the AXI bus
                  and support atomic operations. To perform load-locked operations with external memory,
                  the operating system must define the memory page as uncacheable, otherwise the
                  processor behavior is undefined.
                  If a load locked operation is performed on an address that does not support atomic
                  operations, the behavior is undefined.
                  For atomic operations on cacheable memory, the page attributes must be set to cacheable
                  and write-back, otherwise the behavior is undefined. Cacheable memory must be used
                  when threads need to synchronize with each other.
                      NOTE     External memX_locked operations are not supported on the AHB bus. If they
                               are performed on the AHB bus, the behavior is undefined.
80-N2040-45 Rev. B                                                                                      102
          6         Conditional Execution
                  The Hexagon processor uses a conditional execution model based on compare instructions
                  that set predicate bits in one of four 8-bit predicate registers (P0-P3). These predicate bits
                  can be used to conditionally execute certain instructions.
                  Conditional scalar operations examine only the least-significant bit in a predicate register,
                  while conditional vector operations examine multiple bits in the register.
                  Branch instructions are the main consumers of the predicate registers.
       6.1        Scalar predicates
                  Scalar predicates are 8-bit values which are used in conditional instructions to represent
                  truth values:
                          0xFF represents true
                          0x00 represents false
                  The Hexagon processor provides the four 8-bit predicate registers P0-P3 to hold scalar
                  predicates (Section 2.2.5). These registers are assigned values by the predicate-generating
                  instructions, and examined by the predicate-consuming instructions.
80-N2040-45 Rev. B                                                                                           103
Hexagon V67 Programmer’s Reference Manual                                                     Conditional Execution
     6.1.1        Generating scalar predicates
                  The following instructions generate scalar predicates:
                         Compare byte, halfword, word, doubleword
                         Compare single- and double-precision floating point
                         Classify floating-point value
                         Compare bitmask
                         Bounds check
                         TLB match
                         Store conditional
                  Table 6-1 lists the scalar predicate-generating instructions.
                  Table 6-1     Scalar predicate-generating instructions
                                    Syntax                                          Operation
                   Pd =  cmpb.eq(Rs,{Rt,#u8})                Equal (signed).
                   Pd =  cmph.eq(Rs,{Rt,#s8})                Compare register Rs to Rt or a signed immediate for
                   Pd =  [!]cmp.eq(Rs,{Rt,#s10})             equality. Assign Pd the resulting truth value.
                   Pd =  cmp.eq(Rss,Rtt)
                   Pd =  sfcmp.eq(Rs,Rt)
                   Pd =  dfcmp.eq(Rss,Rtt)
                   Pd =  cmpb.gt(Rs,{Rt,#s8}                 Greater than (signed).
                   Pd =  cmph.gt(Rs,{Rt,#s8})                Compare register Rs to Rt or a signed immediate for
                   Pd =  [!]cmp.gt(Rs,{Rt,#s10})             signed greater than. Assign Pd the resulting truth
                   Pd =  cmp.gt(Rss,Rtt)                     value.
                   Pd =  sfcmp.gt(Rs,Rt)
                   Pd =  dfcmp.gt(Rss,Rtt)
                   Pd =  cmpb.gtu(Rs,{Rt,#u7})               Greater than (unsigned).
                   Pd =  cmph.gtu(Rs,{Rt,#u7})               Compare register Rs to Rt or an unsigned immediate
                   Pd =  [!]cmp.gtu(Rs,{Rt,#u9})             for unsigned greater than. Assign Pd the resulting
                   Pd =  cmp.gtu(Rss,Rtt)                    truth value.
                   Pd = cmp.ge(Rs,#s8)                       Greater than or equal (signed).
                   Pd = sfcmp.ge(Rs,Rt)                      Compare register Rs to Rt or a signed immediate for
                   Pd = dfcmp.ge(Rss,Rtt)                    signed greater than or equal. Assign Pd the resulting
                                                             truth value.
                   Pd = cmp.geu(Rs,#u8)                      Greater than or equal (unsigned).
                                                             Compare register Rs to an unsigned immediate for
                                                             unsigned greater than or equal. Assign Pd the
                                                             resulting truth value.
                   Pd = cmp.lt(Rs,Rt)                        Less than (signed).
                                                             Compare register Rs to Rt for signed less than.
                                                             Assign Pd the resulting truth value.
                   Pd = cmp.ltu(Rs,Rt)                       Less than (unsigned).
                                                             Compare register Rs to Rt for unsigned less than.
                                                             Assign Pd the resulting truth value.
80-N2040-45 Rev. B                                                                                               104
Hexagon V67 Programmer’s Reference Manual                                                      Conditional Execution
                  Table 6-1  Scalar predicate-generating instructions (Continued)
                   Pd = sfcmp.uo(Rs,Rt)                   Unordered (signed).
                   Pd = dfcmp.uo(Rss,Rtt)                 Determine if register Rs or Rt is set to the value NaN.
                                                          Assign Pd the resulting truth value.
                   Pd=sfclass(Rs,#u5)                     Classify value (signed).
                   Pd=dfclass(Rss,#u5)                    Determine if register Rs is set to any of the specified
                                                          classes. Assign Pd the resulting truth value.
                   Pd = [!]tstbit(Rs,{Rt,#u5})            Test if bit set.
                                                          Rt or an unsigned immediate specifies a bit position.
                                                          Test if the bit in Rs that is specified by the bit position
                                                          is set. Assign Pd the resulting truth value.
                   Pd = [!]bitsclr(Rs,{Rt,#u6})           Test if bits clear.
                                                          Rt or an unsigned immediate specifies a bitmask.
                                                          Test if the bits in Rs that are specified by the bitmask
                                                          are all clear. Assign Pd the resulting truth value.
                   Pd = [!]bitsset(Rs,Rt)                 Test if bits set.
                                                          Rt specifies a bitmask.
                                                          Test if the bits in Rs that are specified by the bitmask
                                                          are all set. Assign Pd the resulting truth value.
                   memw_locked(Rs,Pd) = Rt                Store conditional.
                   memd_locked(Rs,Pd) = Rtt               If no other atomic operation has been performed at
                                                          the address (i.e., atomicity is ensured), perform the
                                                          store to the word at address Rs. Assign Pd the
                                                          resulting truth value.
                   Pd = boundscheck(Rs,Rtt)               Bounds check.
                                                          Determine if Rs falls in the numeric range defined by
                                                          Rtt. Assign Pd the resulting truth value.
                   Pd = tlbmatch(Rss,Rt)                  Determine if TLB entry in Rss matches the ASID:PPN
                                                          specified in Rt. Assign Pd the resulting truth value.
                     NOTE   One of the compare instructions (cmp.eq) includes a variant which stores a
                            binary predicate value (0 or 1) in a general register not a predicate register.
80-N2040-45 Rev. B                                                                                                  105
Hexagon V67 Programmer’s Reference Manual                                                      Conditional Execution
     6.1.2        Consuming scalar predicates
                  Certain instructions can be conditionally executed based on the value of a scalar predicate
                  (or alternatively specify a scalar predicate as an input to their operation).
                  The conditional instructions that consume scalar predicates examine only the least-
                  significant bit of the predicate value. In the simplest case, this bit value directly determines
                  whether the instruction is executed:
                          1 indicates that the instruction is executed
                          0 indicates that the instruction is not executed
                  If a conditional instruction includes the operator ! in its predicate expression, the logical
                  negation of the bit value determines whether the instruction is executed.
                  Conditional instructions are expressed in assembly language with the instruction prefix
                  “if (pred_expr)”, where pred_expr specifies the predicate expression. For example:
                       if  (P0) jump target                   //   jump if P0 is true
                       if  (!P2) R2 = R5                      //   assign register if !P2 is true
                       if  (P1) R0 = sub(R2,R3)               //   conditionally subtract if P1
                       if  (P2) R0 = memw(R2)                 //   conditionally load word if P2
                  The following instructions can be used as conditional instructions:
                          Jumps and calls (Section 8.3)
                          Many load and store instructions (Section 5.9)
                          Logical instructions (including AND/OR/XOR)
                          Shift halfword
                          32-bit add/subtract by register or short immediate
                          Sign and zero extend
                          32-bit register transfer and 64-bit combine word
                          Register transfer immediate
                          Deallocate frame and return
                  When a conditional load or store is executed and the predicate expression is false, the
                  instruction is cancelled (including any exceptions that might occur). For example, if a
                  conditional load uses an address with a memory permission violation, and the predicate
                  expression is false, the load does not execute and the exception is not raised.
                  The mux instruction accepts a predicate as one of its basic operands:
                       Rd = mux(Ps,Rs,Rt)
                  mux selects either Rs or Rt based on the least significant bit in Ps. If the least-significant
                  bit in Ps is a 1, Rd is set to Rs, otherwise it is set to Rt.
80-N2040-45 Rev. B                                                                                              106
Hexagon V67 Programmer’s Reference Manual                                                    Conditional Execution
     6.1.3        Auto-AND predicates
                  If multiple compare instructions in a packet write to the same predicate register, the result
                  is the logical AND of the individual compare results. For example:
                       {
                       P0 = cmp(A)                                  // if A && B then jump
                       P0 = cmp(B)
                       if (P0.new) jump:T taken_path
                       }
                  To perform the corresponding OR operation, the following instructions can be used to
                  compute the negation of an existing compare (using De Morgan’s law):
                          Pd = !cmp.{eq,gt}(Rs, {#s10,Rt} )
                          Pd = !cmp.gtu(Rs, {#u9,Rt} )
                          Pd = !tstbit(Rs, {#u5,Rt} )
                          Pd = !bitsclr(Rs, {#u6,Rt} )
                          Pd = !bitsset(Rs,Rt)
                  Auto-AND predicates have the following restrictions:
                          If a packet contains endloopN, it cannot perform an auto-AND with predicate
                           register P3.
                          If a packet contains a register transfer from a general register to a predicate
                           register, no other instruction in the packet can write to the same predicate register.
                           (As a result, a register transfer to P3:0 or C5:4 cannot be grouped with any other
                           predicate-writing instruction.)
                          The instructions spNloop0, decbin, tlbmatch, memw_locked, memd_locked,
                           add:carry, sub:carry, sfcmp, and dfcmp cannot be grouped with another
                           instruction that sets the same predicate register.
                      NOTE      A register transfer from a predicate register to a predicate register has the
                                same auto-AND behavior as a compare instruction.
80-N2040-45 Rev. B                                                                                            107
Hexagon V67 Programmer’s Reference Manual                                                     Conditional Execution
     6.1.4        Dot-new predicates
                  The Hexagon processor can generate and use a scalar predicate in the same instruction
                  packet (Section 3.3). This feature is expressed in assembly language by appending the
                  suffix “.new” to the specified predicate register. For example:
                       if (P0.new) R3 = memw(R4)
                  To see how dot-new predicates are used, consider the following C statement and the
                  corresponding assembly code that is generated from it by the compiler:
                  C statement
                       if (R2 == 4)
                       R3 = *R4;
                       else
                       R5 = 5;
                  Assembly code
                       {
                       P0 = cmp.eq(R2,#4)
                       if (P0.new) R3 = memw(R4)
                       if (!P0.new) R5 = #5
                       }
                  In the assembly code a scalar predicate is generated and then consumed twice within the
                  same instruction packet.
                  The following conditions apply to using dot-new predicates:
                          The predicate must be generated by an instruction in the same packet. The
                           assembler normally enforces this restriction, but if the processor executes a packet
                           that violates this restriction, the execution result is undefined.
                          A single packet can contain both the dot-new and normal forms of predicates. The
                           normal form examines the old value in the predicate register, rather than the
                           newly-generated value. For example:
                             {
                                P0 = cmp.eq(R2,#4)
                                if (P0.new) R3 = memw(R4)              // use newly-generated P0 value
                                if (P0) R5 = #5                        // use previous P0 value
                             }
80-N2040-45 Rev. B                                                                                             108
Hexagon V67 Programmer’s Reference Manual                                                   Conditional Execution
     6.1.5        Dependency constraints
                  Two instructions in an instruction packet should not write to the same destination register
                  (Section 3.3.5). An exception to this rule is if the two instructions are conditional, and
                  only one of them ever has the predicate expression value true when the packet is
                  executed.
                  For example, the following packet is valid as long as P2 and P3 never both evaluate to
                  true when the packet is executed:
                       {
                          if (P2) R3 = #4              // P2, P3, or both must be false
                          if (P3) R3 = #7
                       }
                  Because predicate values change at runtime, the programmer is responsible for ensuring
                  that such packets are always valid during program execution. If they are invalid, the
                  processor takes the following actions:
                          When writing to general registers, an error exception is raised.
                          When writing to predicate or control registers, the result is undefined.
       6.2        Vector predicates
                  The predicate registers are also used for conditional vector operations. Unlike scalar
                  predicates, vector predicates contain multiple truth values which are generated by vector
                  predicate-generating operations.
                  For example, a vector compare instruction compares each element of a vector and assigns
                  the compare results to a predicate register. Each bit in the predicate vector contains a truth
                  value indicating the outcome of a separate compare performed by the vector instruction.
                  The vector mux instruction uses a vector predicate to selectively merge elements from two
                  separate vectors into a single destination vector. This operation is useful for enabling the
                  vectorization of loops with control flow (i.e., branches).
                  The vector instructions that use predicates are described in the following sections.
     6.2.1        Vector compare
                  A vector compare instruction inputs two 64-bit vectors, performs separate compares for
                  each pair of vector elements, and generates a predicate value which contains a bit vector of
                  truth values.
80-N2040-45 Rev. B                                                                                            109
Hexagon V67 Programmer’s Reference Manual                                                   Conditional Execution
                  Figure 6-1 shows an example of a vector byte compare.
                                                                                             Rss
                                                                                             Rtt
                       cmp     cmp       cmp      cmp     cmp     cmp    cmp      cmp
                                        1    0   1   0   1   0   1   0      Pd
                                        7                            0
                  Figure 6-1 Vector byte compare
                  In Figure 6-1 two 64-bit vectors of bytes (contained in Rss and Rtt) are being compared.
                  The result is assigned as a vector predicate to the destination register Pd.
                  In the example vector predicate shown in Figure 6-1, every other compare result in the
                  predicate is true (i.e., 1).
                  Figure 6-2 shows how a vector halfword compare generates a vector predicate.
                                                                                             Rss
                                                                                             Rtt
                             cmp                cmp             cmp             cmp
                                           1   1   0   0   1   1   0   0         Pd
                                           7                           0
                  Figure 6-2 Vector halfword compare
                  In Figure 6-2 two 64-bit vectors of halfwords are being compared. The result is assigned
                  as a vector predicate to the destination register Pd.
                  Because a vector halfword compare yields only four truth values, each truth value is
                  encoded as two bits in the generated vector predicate.
80-N2040-45 Rev. B                                                                                           110
Hexagon V67 Programmer’s Reference Manual                                                     Conditional Execution
     6.2.2        Vector mux instruction
                  A vector mux instruction conditionally selects the elements from two vectors. The
                  instruction takes as input two source vectors and a predicate register. For each byte in the
                  vector, the corresponding bit in the predicate register chooses from one of the two input
                  vectors. The combined result is written to the destination register.
                  Figure 6-3 shows the operation of the vector mux instruction.
                                                                                                Rss
                                                                                                Rtt
                        mux      mux      mux     mux      mux      mux      mux      mux
                    P[7]     P[6]     P[5]    P[4]     P[3]     P[2]     P[1]     P[0]
                                                                                               Rdd
                  Figure 6-3 Vector mux instruction
                  Table 6-2 defines the vector mux instruction.
                  Table 6-2      Vector mux instruction
                                        Syntax                                       Operation
                        Rdd = vmux(Ps,Rss,Rtt)                       Select bytes from Rss and Rtt
                  Changing the order of the source operands in a mux instruction enables both senses of the
                  result to be formed. For example:
                       R1:0 = vmux(P0,R3:2,R5:4)               // choose bytes from R3:2 if true
                       R1:0 = vmux(P0,R5:4,R3:2)               // choose bytes from R3:2 if false
                      NOTE      By replicating the predicate bits generated by word or halfword compares, the
                                vector mux instruction can be used to select words or halfwords.
80-N2040-45 Rev. B                                                                                             111
Hexagon V67 Programmer’s Reference Manual                                               Conditional Execution
     6.2.3        Using vector conditionals
                  Vector conditional support vectorizes loops with conditional statements.
                  Consider the following C statement:
                      for (i=0; i<8; i++) {
                      if (A[i]) {
                          B[i] = C[i];
                      }
                      }
                  Assuming arrays of bytes, this code can be vectorized as follows:
                      R1:0 = memd(R_A)                    // R1:0 holds A[7]-A[0]
                      R3 = #0                           // clear R3:2
                      R2 = #0
                      P0 = vcmpb.eq(R1:0,R3:2)            // compare bytes in A to zero
                      R5:4 = memd(R_B)                    // R5:4 holds B[7]-B[0]
                      R7:6 = memd(R_C)                    // R7:6 holds C[7]-C[0]
                      R3:2 = vmux(P0,R7:6,R5:4)           // if (A[i]) B[i]=C[i]
                      memd(R_B) = R3:2                    // store B[7]-B[0]
80-N2040-45 Rev. B                                                                                       112
Hexagon V67 Programmer’s Reference Manual                                                        Conditional Execution
       6.3        Predicate operations
                  The Hexagon processor provides a set of operations for manipulating and moving
                  predicate registers.
                  Table 6-3 lists the predicate register instructions.
                  Table 6-3     Predicate register instructions
                                    Syntax                                          Operation
                      Pd = Ps                                 Transfer predicate Ps to Pd
                      Pd = Rs                                 Transfer register Rs to predicate Pd
                      Rd = Ps                                 Transfer predicate Ps to register Rd
                      Pd = and(Ps,[!]Pt)                      Set Pd to bitwise AND of Ps and [NOT] Pt
                      Pd = or(Ps,[!]Pt)                       Set Pd to bitwise OR of Ps and [NOT] Pt
                      Pd = and(Ps, and(Pt,[!]Pu)              Set Pd to AND of Ps and (AND of Pt and [NOT] Pu)
                      Pd = and(Ps, or(Pt,[!]Pu)               Set Pd to AND of Ps and (OR of Pt and [NOT] Pu)
                      Pd = or(Ps, and(Pt,[!]Pu)               Set Pd to OR of Ps and (AND of Pt and [NOT] Pu)
                      Pd = or(Ps, or(Pt,[!]Pu)                Set Pd to OR of Ps and (OR of Pt and [NOT] Pu)
                      Pd = not(Ps)                            Set Pd to bitwise inversion of Ps
                      Pd = xor(Ps,Pt)                         Set Pd to bitwise exclusive OR of Ps and Pt
                      Pd = any8(Ps)                           Set Pd to 0xFF if any bit in Ps is 1, 0x00 otherwise
                      Pd = all8(Ps)                           Set Pd to 0x00 if any bit in Ps is 0, 0xFF otherwise
                     NOTE      These instructions belong to instruction class CR.
                               Predicate registers can be transferred to and from the general registers either
                               individually or as register quadruples (Section 2.2.5).
80-N2040-45 Rev. B                                                                                                 113
          7 Software Stack
                  The Hexagon processor includes dedicated registers and instructions to support a call
                  stack for subroutine execution.
                  The stack structure follows standard C conventions.
       7.1        Stack structure
                  The stack is defined to grow from high addresses to low addresses. The stack pointer
                  register SP points to the data element that is currently on the top of the stack.
80-N2040-45 Rev. B                                                                                      114
Hexagon V67 Programmer’s Reference Manual                                                        Software Stack
                  Figure 7-1 shows the stack structure.
                                                  Stack in Memory
                                                      Saved LR
                                                      Saved FP
                    Higher Address
                                                   Procedure Local
                                                    Data on Stack
                                                                                     Stack frame
                                                      Saved LR
                                                      Saved FP                           FP register
                                                   Procedure Local
                                                    Data on Stack
                                                                                         SP register
                    Lower Address
                                                  Unallocated Stack
                  Figure 7-1 Stack structure
                      NOTE    The Hexagon processor supports three dedicated stack instructions:
                              allocframe, deallocframe, and dealloc_return (Section 7.5).
                              The SP address must always remain 8-byte aligned for the stack instructions
                              to work properly.
       7.2        Stack frames
                  The stack stores stack frames, which are data structures that store state information on the
                  active subroutines in a program (i.e., those that were called but have not yet returned).
                  Each stack frame corresponds to an active subroutine in the program.
                  A stack frame contains the following elements:
80-N2040-45 Rev. B                                                                                          115
Hexagon V67 Programmer’s Reference Manual                                                        Software Stack
                          The local variables and data used by the subroutine
                          The return address for the subroutine call (pushed from the link register LR)
                          The address of the previous stack frame allocated on the stack (pushed from the
                           frame pointer register FP)
                  The frame pointer register FP always contains the address of the saved frame pointer in
                  the current stack frame. It facilitates debugging by enabling a debugger to examine the
                  stack in memory and easily determine the call sequence, function parameters, etc.
                      NOTE     For leaf functions it is often unnecessary to save FP and LR. In this case FP
                               contains the frame pointer of the calling function, not the current function.
       7.3        Stack protection
                  The Hexagon V6x processor supports the following features to protect the integrity of the
                  software stack:
                          Stack bounds checking
                          Stack smashing protection
     7.3.1        Stack bounds checking
                  Stack bounds checking prevents a stack frame from being allocated past the lower
                  boundary of the software stack.
                  FRAMELIMIT is a 32-bit control register which stores a memory address that specifies the
                  lower bound of the memory area reserved for the software stack. When the allocframe
                  instruction allocates a new stack frame, it compares the new stack pointer value in SP with
                  the stack bound value in FRAMELIMIT. If SP is less than FRAMELIMIT, the Hexagon
                  processor raises exception 0x27 (Section 8.10).
                      NOTE     Stack bounds checking is performed when the processor is in User and Guest
                               modes, but not in Monitor mode.
     7.3.2        Stack smashing protection
                  Stack smashing is a technique used by malicious code to gain control over an executing
                  program. Malicious code causes buffer overflows to occur in a procedure’s local data, with
                  the goal of modifying the subroutine return address stored in a stack frame so it points to
                  the malicious code instead of the intended return code.
                  Stack smashing protection prevents this from happening by scrambling the subroutine
                  return address whenever a new stack frame is allocated, and then unscrambling the return
                  address when the frame is deallocated. Because the value in FRAMEKEY changes regularly
                  and varies from device to device, it becomes difficult to pre-calculate a malicious return
                  address.
80-N2040-45 Rev. B                                                                                           116
Hexagon V67 Programmer’s Reference Manual                                                            Software Stack
                  FRAMEKEY is a 32-bit control register which scrambles return addresses stored on the
                  stack:
                         In the allocframe instruction, the 32-bit return address in link register LR is
                          XOR-scrambled with the value in FRAMEKEY before it is stored in the new stack
                          frame.
                         In deallocframe and dealloc_return, the return address loaded from the stack
                          frame is unscrambled with the value in FRAMEKEY before it is stored in LR.
                  After a processor reset, the default value of FRAMEKEY is 0. If this value is not changed,
                  stack smashing protection is effectively disabled.
                     NOTE      Each hardware thread has its own instance of the FRAMEKEY register.
       7.4        Stack registers
                  Table 7-1 lists the stack registers.
                  Table 7-1     Stack registers
                      Register               Name                           Description                    Alias
                         SP         Stack pointer          Points to topmost stack element in memory        R29
                         FP         Frame pointer          Points to previous stack frame on stack          R30
                         LR         Link register         Contains return address of subroutine call        R31
                    FRAMELIMIT      Frame limit register   Contains lowest address of stack area            C16
                    FRAMEKEY        Frame key register     Contains scrambling key for return addresses     C17
                     NOTE      SP, FP, and LR are aliases of three general registers (Section 2.1). These
                               general registers are conventionally dedicated for use as stack registers.
80-N2040-45 Rev. B                                                                                              117
Hexagon V67 Programmer’s Reference Manual                                                                  Software Stack
       7.5        Stack instructions
                  The Hexagon processor includes the instructions allocframe and deallocframe to
                  efficiently allocate and deallocate stack frames on the call stack.
                  Table 7-2 describes these instructions.
                  Table 7-2      Stack instructions
                             Syntax                                         Operation
                    allocframe(#u11:3)         Allocate stack frame.
                                               Use this instruction after a call. It first XORs the values in LR
                                               and FRAMEKEY, and pushes the resulting scrambled return
                                               address and FP to the top of stack.
                                               Next, it subtracts an unsigned immediate from SP in order to
                                               allocate room for local variables. If the resulting SP is less than
                                               FRAMELIMIT, the processor raises exception 0x27. Otherwise,
                                               SP is set to the new value, and FP is set to the address of the
                                               old frame pointer on the stack.
                                               The immediate operand as expressed in assembly syntax
                                               specifies the byte offset. This value must be 8-byte aligned. The
                                               valid range is from 0 to 16 KB.
                    deallocframe               Deallocate stack frame.
                                               Use this instruction before a return to free a stack frame. It first
                                               loads the saved FP and LR values from the address at FP, and
                                               XORs the restored LR with the value in FRAMEKEY to
                                               unscramble the return address. SPis then pointed back to the
                                               previous frame.
                    dealloc_return             Subroutine return with stack frame deallocate.
                                               Perform deallocframe operation, and then perform
                                               subroutine return (Section 8.3.3) to the target address loaded
                                               from LR by deallocframe.
                      NOTE      allocframe and deallocframe load and store the LR and FP registers on the
                                stack as a single aligned 64-bit register pair (i.e., LR:FP).
80-N2040-45 Rev. B                                                                                                    118
          8 Program Flow
                  The Hexagon processor supports the following program flow facilities:
                         Conditional instructions
                         Hardware loops
                         Software branches
                         Pauses
                         Exceptions
                  Software branches include jumps, calls, and returns. Several types of jumps are supported:
                         Speculative jumps
                         Compare jumps
                         Register transfer jumps
                         Dual jumps
       8.1        Conditional instructions
                  Many Hexagon processor instructions can be conditionally executed. For example:
                      if (P0) R0 = memw(R2)             // conditionally load word if P0
                      if (!P1) jump label               // conditionally jump if not P1
                  The following instructions can be specified as conditional:
                         Jumps and calls
                         Many load and store instructions
                         Logical instructions (including AND/OR/XOR)
                         Shift halfword
                         32-bit add/subtract by register or short immediate
                         Sign and zero extend
                         32-bit register transfer and 64-bit combine word
                         Register transfer immediate
                         Deallocate frame and return
                  For more information, see Section 5.9 and Chapter 6.
80-N2040-45 Rev. B                                                                                       119
Hexagon V67 Programmer’s Reference Manual                                                           Program Flow
       8.2        Hardware loops
                  The Hexagon processor includes hardware loop instructions which can perform loop
                  branches with zero overhead. For example:
                          loop0(start,#3)                   // loop 3 times
                       start:
                            { R0 = mpyi(R0,R0) } :endloop0
                  Two sets of hardware loop instructions are provided – loop0 and loop1 – to enable
                  hardware loops to be nested one level deep. For example:
                       // Sum the rows of a 100x200 matrix.
                          loop1(outer_start,#100)
                       outer_start:
                            R0 = #0
                            loop0(inner_start,#200)
                       inner_start:
                               R3 = memw(R1++#4)
                               { R0 = add(R0,R3) }:endloop0
                            { memw(R2++#4) = R0 }:endloop1
                  Use the hardware loop instructions as follows:
                          Use loop0 for non-nested loops,.
                          For nested loops, use loop0 for the inner loop, and loop1 for the outer loop.
                      NOTE      If a program must create loops nested more than one level deep, the two
                                innermost loops can be implemented as hardware loops, with the remaining
                                outer loops implemented as software branches.
                  Each hardware loop is associated with a pair of dedicated loop registers:
                          The loop start address register SAn is set to the address of the first instruction in
                           the loop (which is typically expressed in assembly language as a label).
                          The loop count register LCn is set to a 32-bit unsigned value which specifies the
                           number of loop iterations to perform. When the PC reaches the end of the loop,
                           LCn is examined to determine whether the loop should repeat or exit.
                  The hardware loop setup instruction sets both of these registers at once – typically there is
                  no need to set them individually. However, because the loop registers completely specify
                  the hardware loop state, they can be saved and restored (either automatically by a
                  processor interrupt or manually by the programmer), enabling a suspended hardware loop
                  to be resumed normally once its loop registers are reloaded with the saved values.
                  The Hexagon processor provides two sets of loop registers for the two hardware loops:
                          SA0 and LC0 are used by loop0
                          SA1 and LC1 are used by loop1
80-N2040-45 Rev. B                                                                                             120
Hexagon V67 Programmer’s Reference Manual                                                              Program Flow
                  Table 8-1 lists the hardware loop instructions.
                  Table 8-1      Loop instructions
                           Syntax                                            Description
                    loopN(start, Rs)        Hardware loop with register loop count.
                                            Set registers SAn and LCn for hardware loop N:
                                             SAn is assigned the specified start address of the loop.
                                               LCn is assigned the value of general register Rs.
                                            NOTE - The loop start operand is encoded as a PC-relative
                                            immediate value.
                    loopN(start, #count)    Hardware loop with immediate loop count.
                                            Set registers SAn and LCn for hardware loop N:
                                             SAn is assigned the specified start address of the loop.
                                               LCn is assigned the specified immediate value (0-1023).
                                            NOTE - The loop start operand is encoded as a PC-relative
                                            immediate value.
                    :endloopN               Hardware loop end instruction.
                                            Performs the following operation:
                                                 if (LCn > 1) {PC = SAn; LCn = LCn-1}
                                            NOTE: This instruction appears in assembly as a suffix appended to the
                                            last packet in the loop. It is encoded in the last packet.
                    SAn = Rs                Set loop start address to general register Rs
                    LCn = Rs                Set loop count to general register Rs
                      NOTE      The loop instructions are assigned to instruction class CR.
     8.2.1        Loop setup
                  To set up a hardware loop, the loop registers SAn and LCn must be set to the proper values.
                  This can be done in two ways:
                          A loopN instruction
                          Register transfers to SAn and LCn
                  The loopN instruction performs all the work of setting SAn and LCn. For example:
                          loop0(start,#3)                      // SA0=&start, LC0=3
                       start:
                            { R0 = mpyi(R0,R0) } :endloop0
                  In this example the hardware loop (consisting of a single multiply instruction) is executed
                  three times. The loop0 instruction sets register SA0 to the address value of label start,
                  and LC0 to 3.
80-N2040-45 Rev. B                                                                                               121
Hexagon V67 Programmer’s Reference Manual                                                           Program Flow
                  Loop counts are limited to the range 0-1023 when they are expressed as immediate values
                  in loopN. If the desired loop count exceeds this range, it must be specified as a register
                  value. For example:
                  Using loopN:
                          R1 = #20000;
                          loop0(start,R1)                   // LC0=20000, SA0=&start
                       start:
                             { R0 = mpyi(R0,R0) } :endloop0
                  Using register transfers:
                          R1 = #20000
                          LC0 = R1                          // LC0=20000
                          R1 = #start
                          SA0 = R1                          // SA0=&start
                       start:
                             { R0 = mpyi(R0,R0) } :endloop0
                  If a loopN instruction is located too far from its loop start address, the PC-relative offset
                  value that specifies the start address can exceed the maximum range of the instruction’s
                  start-address operand. If this occurs, either move the loopN instruction closer to the loop
                  start, or specify the loop start address as a 32-bit constant (Section 10.9). For example:
                  Using 32-bit constants:
                          R1 = #20000;
                          loop0(##start,R1)                 // LC0=20000, SA0=&start
                          ...
     8.2.2        Loop end
                  The loop end instruction indicates the last packet in a hardware loop. It is expressed in
                  assembly language by appending the packet with the symbol “:endloopN”, where N
                  specifies the hardware loop (0 or 1). For example:
                          loop0(start,#3)
                       start:
                             { R0 = mpyi(R0,R0) } :endloop0              // last packet in loop
                  The last instruction in the loop must always be expressed in assembly language as a packet
                  (using curly braces), even if it is the only instruction in the packet.
                  Nested hardware loops can specify the same instruction as the end of both the inner and
                  outer loops. For example:
                       // Sum the rows of a 100x200 matrix.
                       // Software pipeline the outer loop.
                              p0 = cmp.gt(R0,R0)                          // p0 = false
                              loop1(outer_start,#100)
                       outer_start:
                              { if (p0) memw(R2++#4) = R0
                                 p0 = cmp.eq(R0,R0)                       // p0 = true
80-N2040-45 Rev. B                                                                                           122
Hexagon V67 Programmer’s Reference Manual                                                         Program Flow
                                 R0 = #0
                                 loop0(inner_start,#200) }
                       inner_start:
                              R3 = memw(R1++#4)
                              { R0 = add(R0,R3) }:endloop0:endloop1
                              memw(R2++#4) = R0
                  Though endloopN behaves like a regular instruction (by implementing the loop test and
                  branch), it does not execute in any instruction slot, and does not count as an instruction in
                  the packet. Therefore a single instruction packet which is marked as a loop end can
                  perform up to six operations:
                          Four regular instructions (the normal limit for an instruction packet)
                          The endloop0 test and branch
                          The endloop1 test and branch
                      NOTE      The endloopN instruction is encoded in the instruction packet (Section 10.6).
     8.2.3        Loop execution
                  After a hardware loop is set up, the loop body always executes at least once regardless of
                  the specified loop count (because the loop count is not examined until the last instruction
                  in the loop). Therefore, if a loop must be optionally executed zero times, it must be
                  preceded with an explicit conditional branch. For example:
                          loop0(start,R1)
                          P0 = cmp.eq(R1,#0)
                          if (P0) jump skip
                       start:
                            { R0 = mpyi(R0,R0) } :endloop0
                       skip:
                  In this example a hardware loop is set up with the loop count in R1, but if the value in R1
                  is zero a software branch skips over the loop body.
                  After the loop end instruction of a hardware loop is executed, the Hexagon processor
                  examines the value in the corresponding loop count register:
                          If the value is greater than 1, the processor decrements the loop count register and
                           performs a zero-cycle branch to the loop start address.
                          If the value is less than or equal to 1, the processor resumes program execution at
                           the instruction immediately following the loop end instruction.
                      NOTE      Because nested hardware loops can share the same loop end instruction, the
                                processor may examine both loop count registers in a single operation.
80-N2040-45 Rev. B                                                                                           123
Hexagon V67 Programmer’s Reference Manual                                                         Program Flow
     8.2.4        Pipelined hardware loops
                  Software pipelined loops are common for VLIW architectures such as the Hexagon
                  processor. They offer increased code performance in loops by overlapping multiple loop
                  iterations.
                  A software pipeline has three sections:
                          A prologue in which the loop is primed
                          A kernel (or steady-state) portion
                          An epilogue which drains the pipeline
                  This is best illustrated with a simple example, as shown in Table 8-2.
                  Table 8-2      Software pipelined loop
                       int foo(int *A, int *result)
                       {
                              int i;
                              for (i=0;i<100;i++) {
                                   result[i]= A[i]*A[i];
                              }
                       }
                       foo:
                       {           R3 = R1
                                   loop0(.kernel,#98)                // Decrease loop count by 2
                       }
                                   R1 = memw(R0++#4)                 // 1st prologue stage
                       {           R1 = memw(R0++#4)                 // 2nd prologue stage
                                   R2 = mpyi(R1,R1)
                       }
                                   .falign
                       .kernel:
                       {           R1 = memw(R0++#4)                 // kernel
                                   R2 = mpyi(R1,R1)
                                   memw(R3++#4) = R2
                       }:endloop0
                       {           R2 = mpyi(R1,R1)                  // 1st epilogue stage
                                   memw(R3++#4) = R2
                       }
                                   memw(R3++#4) = R2                 // 2nd epilogue stage
                                   jumpr lr
                  In Table 8-2 the kernel section of the pipelined loop performs three iterations of the loop
                  in parallel:
80-N2040-45 Rev. B                                                                                          124
Hexagon V67 Programmer’s Reference Manual                                                           Program Flow
                          The load for iteration N+2
                          The multiply for iteration N+1
                          The store for iteration N
                  One drawback to software pipelining is the extra code necessary for the prologue and
                  epilogue sections of a pipelined loop.
                  To address this issue the Hexagon processor provides the spNloop0 instruction, where the
                  “N” in the instruction name indicates a digit in the range 1-3. For example:
                         P3 = sp2loop0(start,#10)               // Set up pipelined loop
                  spNloop0 is a variant of the loop0 instruction: it sets up a normal hardware loop using
                  SA0 and LC0, but also performs the following additional operations:
                          When the spNloop0 instruction is executed, it assigns the truth value false to the
                           predicate register P3.
                          After the associated loop has executed N times, P3 is automatically set to true.
                  This feature (which is known as automatic predicate control) enables the store instructions
                  in the kernel section of a pipelined loop to be conditionally executed by P3 and thus –
                  because of the way spNloop0 controls P3 – not be executed during the pipeline warm-up.
                  This can reduce the code size of many software pipelined loops by eliminating the need
                  for prologue code.
                  spNloop0 cannot be used to eliminate the epilogue code from a pipelined loop; however,
                  in some cases it is possible to do this through the use of programming techniques.
                  Typically, the issue affecting the removal of epilogue code is load safety. If the kernel
                  section of a pipelined loop can safely access past the end of its arrays – either because it is
                  known to be safe, or because the arrays are padded at the end – epilogue code is
                  unnecessary. However, if load safety cannot be ensured, explicit epilogue code is required
                  to drain the software pipeline.
                  Table 8-3 shows how spNloop0 and load safety simplify the code shown in Table 8-2.
80-N2040-45 Rev. B                                                                                            125
Hexagon V67 Programmer’s Reference Manual                                                      Program Flow
                  Table 8-3    Software pipelined loop (using spNloop0)
                      int foo(int *A, int *result)
                      {
                            int i;
                            for (i=0;i<100;i++) {
                                 result[i]= A[i]*A[i];
                            }
                      }
                      foo:
                      { // load safety assumed
                                 P3 = sp2loop0(.kernel,#102)             // set up pipelined loop
                                 R3 = R1
                      }
                      .falign
                      .kernel:
                      {          R1 = memw(R0++#4)                       // kernel
                                 R2 = mpyi(R1,R1)
                                 if (P3) memw(R3++#4) = R2
                      }:endloop0
                                 jumpr lr
                     NOTE     The count value that spNloop0 uses to control the P3 setting is stored in the
                              user status register USR.LPCFG.
     8.2.5        Loop restrictions
                  Hardware loops have the following restrictions:
                         The loop setup packet in loopN or spNloop0 (Section 8.2.4) cannot contain a
                          speculative indirect jump, new-value compare jump, or dealloc_return.
                         The last packet in a hardware loop cannot contain any program flow instructions
                          (including jumps or calls).
                         The loop end packet in loop0 cannot contain any instruction that changes SA0 or
                          LC0. Similarly, the loop end packet in loop1 cannot contain any instruction that
                          changes SA1 or LC1.
                         The loop end packet in spNloop0 cannot contain any instruction that changes P3.
                     NOTE     SA1 and LC1 can be changed at the end of loop0, while SA0 and LC0 can be
                              changed at the end of loop1.
80-N2040-45 Rev. B                                                                                        126
Hexagon V67 Programmer’s Reference Manual                                                              Program Flow
       8.3        Software branches
                  Unlike hardware loops, software branches use an explicit instruction to perform a branch
                  operation. Software branches include the following instructions:
                           Jumps
                           Calls
                           Returns
                  The target address for branch instructions can be specified as register indirect or PC-
                  relative offsets. PC-relative offsets are normally less than 32 bits, but can be specified as
                  32 bits by using the appropriate syntax in the target operand (Section 8.3.4).
                  Branch instructions can be unconditional or conditional, with the execution of conditional
                  instructions controlled by a predicate expression.
                  Table 8-4 summarizes the software branch instructions.
                  Table 8-4      Software branch instructions
                               Syntax                                        Operation
                    [if (pred_expr)] jump label   Branch to address specified by register Rs or PC-relative offset.
                    [if (pred_expr)] jumpr Rs     Can be conditionally executed.
                    [if (pred_expr)] call label   Branch to address specified by register Rs or PC-relative offset.
                    [if (pred_expr)] callr Rs     Store subroutine return address in link register LR.
                                                  Can be conditionally executed.
                    [if (pred_expr)] jumpr LR     Branch to subroutine return address contained in link register LR.
                                                  Can be conditionally executed.
80-N2040-45 Rev. B                                                                                                127
Hexagon V67 Programmer’s Reference Manual                                                                 Program Flow
     8.3.1        Jumps
                  Jump instructions change the program flow to a target address which can be specified by
                  either a register or a PC-relative immediate value. Jump instructions can be conditional
                  based on the value of a predicate expression.
                  Table 8-5 lists the jump instructions.
                  Table 8-5        Jump instructions
                            Syntax                                         Operation
                    jump label                Direct jump.
                                              Branch to address specified by label.
                                              Label is encoded as PC-relative signed immediate value.
                    jumpr Rs                  Indirect jump.
                                              Branch to address contained in general register Rs.
                    if ([!]Ps) jump label     Conditional jump.
                    if ([!]Ps) jumpr Rs       Perform jump if predicate expression evaluates to true.
                      NOTE        Conditional jumps can be specified as speculative (Section 8.4).
     8.3.2        Calls
                  Call instructions are used to jump to subroutines. The instruction performs a jump to the
                  target address and also stores the return address in the link register LR.
                  The forms of call are functionally similar to jump instructions and include both PC-
                  relative and register indirect in both unconditional and conditional forms.
                  Table 8-6 lists the call instructions.
                  Table 8-6        Call instructions
                            Syntax                                          Operation
                    call label               Direct subroutine call.
                                             Branch to address specified by label, and store return address in register
                                             LR. Label is encoded as PC-relative signed immediate value.
                    callr Rs                 Indirect subroutine call.
                                             Branch to address contained in general register Rs, and store return
                                             address in register LR.
                    if ([!]Ps) call label    Conditional call.
                    if ([!]Ps) callr Rs      If predicate expression evaluates to true, perform subroutine call to
                                             specified target address.
80-N2040-45 Rev. B                                                                                                    128
Hexagon V67 Programmer’s Reference Manual                                                                Program Flow
     8.3.3        Returns
                  Return instructions are used to return from a subroutine. The instruction performs an
                  indirect jump to the subroutine return address stored in link register LR.
                  Returns are implemented as jump register indirect instructions, and support both
                  unconditional and conditional forms.
                  Table 8-7 lists the return instructions.
                  Table 8-7        Return instructions
                                  Syntax                                         Operation
                     jumpr LR                         Subroutine return.
                                                      Branch to subroutine return address contained in link register
                                                      LR.
                    if ([!]Ps) jumpr LR               Conditional subroutine return.
                                                      If predicate expression evaluates to true, perform subroutine
                                                      return to specified target address.
                    dealloc_return                    Subroutine return with stack frame deallocate.
                                                      Perform deallocframe operation (Section 7.5) and then
                                                      perform subroutine return to the target address loaded by
                                                      deallocframe from the link register.
                    if ([!]Ps) dealloc_return         Conditional subroutine return with stack frame deallocate.
                                                      If predicate expression evaluates to true, perform
                                                      deallocframe and then subroutine return to the target
                                                      address loaded by deallocframe from the link register.
                      NOTE       The link register LR is an alias of general register R31. Therefore subroutine
                                 returns can be performed with the instruction jumpr R31.
                                 The conditional subroutine returns (including dealloc_return) can be
                                 specified as speculative (Section 8.4).
80-N2040-45 Rev. B                                                                                                  129
Hexagon V67 Programmer’s Reference Manual                                                          Program Flow
     8.3.4        Extended branches
                  When a jump or call instruction specifies a PC-relative offset as the branch target, the
                  offset value is normally encoded in significantly less than 32 bits. This can limit the ability
                  for programs to specify “long” branches which span a large range of the processor’s
                  memory address space.
                  To support long branches, the jump and call instructions have special versions which
                  encode a full 32-bit value as the PC-relative offset.
                      NOTE     Such instructions use an extra word to store the 32-bit offset (Section 10.9).
                  The size of a PC-relative branch offset is expressed in assembly language by optionally
                  prefixing the target label with the symbol “##” or “#”:
                          “##” specifies that the assembler must use a 32-bit offset
                          “#” specifies that the assembler must not use a 32-bit offset
                          No “#” specifies that the assembler use a 32-bit offset only if necessary
                  For example:
                       jump ##label         // 32-bit offset
                       call #label          // non 32-bit offset
                       jump label           // offset size determined by assembler
     8.3.5        Branches to and from packets
                  Instruction packets are atomic: even if they contain multiple instructions, they can be
                  referenced only by the address of the first instruction in the packet. Therefore, branches to
                  a packet can target only the packet’s first instruction.
                  Packets can contain up to two branches (Section 8.7). The branch destination can target
                  the current packet or the beginning of another packet.
                  A branch does not interrupt the execution of the current packet: all the instructions in the
                  packet are executed, even if they appear in the assembly source after the branch
                  instruction.
                  If a packet is at the end of a hardware loop, it cannot contain a branch instruction.
80-N2040-45 Rev. B                                                                                            130
Hexagon V67 Programmer’s Reference Manual                                                                 Program Flow
       8.4        Speculative jumps
                  Conditional instructions normally depend on predicates that are generated in a previous
                  instruction packet. However, dot-new predicates (Section 6.1.4) enable conditional
                  instructions to use a predicate generated in the same packet that contains the conditional
                  instruction.
                  When dot-new predicates are used with a conditional jump, the resulting instruction is
                  called a speculative jump. For example:
                        {
                            P0 = cmp.eq(R9,#16)                   // single-packet compare-and-jump
                            IF (P0.new) jumpr:t R11               // ... enabled by use of P0.new
                        }
                  Speculative jumps require the programmer to specify a direction hint in the jump
                  instruction, which indicates whether the conditional jump is expected to be taken or not.
                  The hint initializes the Hexagon processor’s dynamic branch predictor. Whenever the
                  predictor is wrong, the speculative jump instruction takes two cycles to execute instead of
                  one (due to a pipeline stall).
                  Hints can improve program performance by indicating how speculative jumps are
                  expected to execute over the course of a program: the more often the specified hint
                  indicates how the instruction actually executes, the better the performance.
                  Hints are expressed in assembly language by appending the suffix “:t” or “:nt” to the
                  jump instruction symbol. For example:
                            jump:t – The jump instruction will most often be taken
                            jump:nt – The jump instruction will most often be not taken
                  In addition to dot-new predicates, speculative jumps also accept conditional arithmetic
                  expressions (=0, !=0, >=0, <=0) involving the general register Rs.
                  Table 8-8 lists the speculative jump instructions.
                  Table 8-8       Speculative jump instructions
                                 Syntax                                         Operation
                    if ([!]Ps.new) jump:t label     Speculative direct jump.
                    if ([!]Ps.new) jump:nt label    If predicate expression evaluates to true, jump to address
                                                    specified by label.
                    if ([!]Ps.new) jumpr:t Rs       Speculative indirect jump.
                    if ([!]Ps.new) jumpr:nt Rs      If predicate expression evaluates to true, jump to address in
                                                    register Rs.
                    if (Rs == #0) jump:t label      Speculative direct jump.
                    if (Rs == #0) jump:nt label     If predicate Rs = 0 is true, jump to address specified by label.
                    if (Rs != #0) jump:t label      Speculative direct jump.
                    if (Rs != #0) jump:nt label     If predicate Rs != 0 is true, jump to address specified by label.
80-N2040-45 Rev. B                                                                                                    131
Hexagon V67 Programmer’s Reference Manual                                                               Program Flow
                  Table 8-8      Speculative jump instructions (Continued)
                                Syntax                                         Operation
                    if (Rs >= #0) jump:t label      Speculative direct jump.
                    if (Rs >= #0) jump:nt label     If predicate Rs >= 0 is true, jump to address specified by
                                                    label.
                    if (Rs <= #0) jump:t label      Speculative direct jump.
                    if (Rs <= #0) jump:nt label     If predicate Rs <= 0 is true, jump to address specified by
                                                    label.
                      NOTE      The hints :t and :nt interact with the predicate value to determine the
                                instruction cycle count.
                                Speculative indirect jumps are not supported with register Rs predicates.
       8.5        Compare jumps
                  To reduce code size the Hexagon processor supports a compound instruction which
                  combines a compare with a speculative jump in a single 32-bit instruction.
                  For example:
                        {
                        p0 = cmp.eq (R2,R5)                      // single-instr compare-and-jump
                        if (p0.new) jump:nt target               // enabled by compound instr
                        }
                  The register operands used in a compare jump are limited to R0-R7 or R16-R23
                  (Table 10-3).
                  The compare and jump instructions that can be used in a compare jump are limited to the
                  instructions listed in Table 8-9. The compare can use predicate P0 or P1, while the jump
                  must specify the same predicate that is set in the compare.
                  A compare jump instruction is expressed in assembly source as two independent compare
                  and jump instructions in a packet. The assembler translates the two instructions into a
                  single compound instruction.
80-N2040-45 Rev. B                                                                                               132
Hexagon V67 Programmer’s Reference Manual                                                       Program Flow
                  Table 8-9       Compare jump instructions
                          Compare Instruction                    Jump Instruction
                    Pd = cmp.eq (Rs, Rt)                IF (Pd.new) jump:t label
                    Pd = cmp.gt (Rs, Rt)                IF (Pd.new) jump:nt label
                    Pd = cmp.gtu (Rs, Rt)               IF (!Pd.new) jump:t label
                    Pd = cmp.eq (Rs,#U5)                IF (!Pd.new) jump:nt label
                    Pd = cmp.gt (Rs,#U5)
                    Pd = cmp.gtu (Rs,#U5)
                    Pd = cmp.eq (Rs,#-1)
                    Pd = cmp.gt (Rs,#-1)
                    Pd = tstbit (Rs, #0)
     8.5.1        New-value compare jumps
                  A compare jump instruction can access a register that is assigned a new value in the same
                  instruction packet (Section 3.3). This feature is expressed in assembly language by the
                  following changes:
                           Appending the suffix “.new” to the new-value register in the compare
                           Rewriting the compare jump so its constituent compare and jump operations
                            appear as a single conditional instruction
                  For example:
                       // load-compare-and-jump packet enabled by new-value compare jump
                       {
                       R0 = memw(R2+#8)
                       if (cmp.eq(R0.new,#0)) jump:nt target
                       }
                  New-value compare jump instructions have the following restrictions:
80-N2040-45 Rev. B                                                                                        133
Hexagon V67 Programmer’s Reference Manual                                                             Program Flow
                            They are limited to the instruction forms listed in Table 8-10.
                            They cannot be combined with another jump instruction in the same packet.
                            If an instruction produces a 64-bit result or performs a floating-point operation
                             (Section 1.3.4), its result registers cannot be used as the new-value register.
                            If an instruction uses auto-increment or absolute-set addressing mode
                             (Section 5.8), its address register cannot be used as the new-value register.
                            If the instruction that sets a new-value register is conditional (Section 6.1.2), it
                             must always be executed.
                  If the specified jump direction hint is wrong (Section 8.4), a new-value compare jump
                  takes three cycles to execute instead of one. While this penalty is one cycle longer than in
                  a regular speculative jump, the overall performance is still better than using a regular
                  speculative jump (which must execute an extra packet in all cases).
                      NOTE         New-value compare jump instructions are assigned to instruction class NV,
                                   which can execute only in Slot 0. The instruction that assigns the new value
                                   must execute in Slot 1, 2, or 3.
                  Table 8-10 New-value compare jump instructions
                    if ([!]cmp.eq (Rs.new, Rt)) jump:[hint] label
                    if ([!]cmp.gt (Rs.new, Rt)) jump:[hint] label
                    if ([!]cmp.gtu (Rs.new, Rt)) jump:[hint] label
                    if ([!]cmp.gt (Rs, Rt.new)) jump:[hint] label
                    if ([!]cmp.gtu (Rs, Rt.new)) jump:[hint] label
                    if ([!]cmp.eq (Rs.new, #u5)) jump:[hint] label
                    if ([!]cmp.gt (Rs.new, #u5)) jump:[hint] label
                    if ([!]cmp.gtu (Rs.new ,#u5)) jump:[hint] label
                    if ([!]cmp.eq (Rs.new, #-1)) jump:[hint] label
                    if ([!]cmp.gt (Rs.new, #-1)) jump:[hint] label
                    if ([!]tstbit (Rs.new, #0)) jump:[hint] label
       8.6        Register transfer jumps
                  To reduce code size the Hexagon processor supports a compound instruction which
                  combines a register transfer with an unconditional jump in a single 32-bit instruction.
                  For example:
                        {
                        jump target             // jump to label “target”
                        R1 = R2                 // assign contents of reg R2 to R1
                        }
80-N2040-45 Rev. B                                                                                                134
Hexagon V67 Programmer’s Reference Manual                                                                 Program Flow
                  The source and target register operands in the register transfer are limited to R0-R7 or
                  R16-R23 (Table 10-3).
                  The target address in the jump is a scaled 9-bit PC-relative address value (as opposed to
                  the 22-bit value in the regular unconditional jump instruction).
                  A register transfer jump instruction is expressed in assembly source as two independent
                  instructions in a packet. The assembler translates the instructions into a single compound
                  instruction.
                  Table 8-11 lists the register transfer jump instructions.
                  Table 8-11        Register transfer jump instructions
                            Syntax                                          Operation
                    jump label; Rd=Rs         Register transfer jump.
                                              Perform register transfer and branch to address specified by label.
                                              Label is encoded as PC-relative 9-bit signed immediate value.
                    jump label; Rd=#u6        Register transfer immediate jump.
                                              Perform register transfer (of 6-bit unsigned immediate value) and
                                              branch to address specified by label.
                                              Label is encoded as PC-relative 9-bit signed immediate value.
       8.7        Dual jumps
                  Two software branch instructions (referred to here as “jumps”) can appear in the same
                  instruction packet, under the conditions listed in Table 8-12.
                  The first jump is defined as the jump instruction at the lower address, and the second jump
                  as the jump instruction at the higher address.
                  Unlike most packetized operations, dual jumps are not executed in parallel (Section 3.3.1).
                  Instead, the two jumps are processed in a well-defined order in a packet:
                        1. The predicate in the first jump is evaluated.
                        2. If the first jump is taken, the second jump is ignored.
                        3. If the first jump is not taken, the second jump is performed.
                  Table 8-12 Dual jump instructions
                                                                                            First jump   Second jump
                                 Instruction                       Description
                                                                                            in packet?    in packet?
                    jump                                   Direct jump                          No            Yes
                    if ([!]Ps[.new]) jump                  Conditional jump                     Yes           Yes
                    call                                   Direct calls                         No            Yes
                    if ([!]Ps) call
                    Pd=cmp.xx ; if ([!]Pd.new) jump        Compare jump                         Yes           Yes
80-N2040-45 Rev. B                                                                                                  135
Hexagon V67 Programmer’s Reference Manual                                                               Program Flow
                  Table 8-12 Dual jump instructions
                                                                                         First jump    Second jump
                                 Instruction                       Description
                                                                                         in packet?     in packet?
                    if ([!]cmp.xx(Rs.new, Rt)) jump        New-value compare jump            No              No
                    jumpr                                  Indirect jumps                    No              No
                    if ([!]Ps[.new]) jumpr                 Indirect calls
                    callr                                  dealloc_return
                    if ([!]Ps) callr
                    dealloc_return
                    if ([!]Ps[.new]) dealloc_return
                    endloopN                               Hardware loop end                 No              No
                      NOTE        If a call is ignored in a dual jump, the link register LR is not changed.
       8.8        Hint indirect jump target
                  Because it obtains the jump target address from a register, the jumpr instruction
                  (Section 8.3.1) normally causes the processor to stall for one cycle.
                  To avoid the stall penalty caused by a jumpr instruction, the Hexagon processor supports
                  the jump hint instruction hintjr, which can be specified before the jumpr instruction.
                  The hintjr instruction indicates that the program is about to execute a jumpr to the
                  address contained in the specified register.
                  Table 8-13 lists the speculative jump instructions.
                  Table 8-13 Jump hint instruction
                                Syntax                                         Operation
                    hintjr(Rs)                       Inform processor that jumpr(Rs) instruction is about to be
                                                     performed.
                      NOTE        In order to prevent a stall, the hintjr instruction must be executed at least 2
                                  packets before the corresponding jumpr instruction.
                                  The hintjr instruction is not needed for jumpr instructions used as returns
                                  (Section 8.3.3), because in this case the Hexagon processor automatically
                                  predicts the jump targets based on the most recent nested call instructions.
80-N2040-45 Rev. B                                                                                                136
Hexagon V67 Programmer’s Reference Manual                                                         Program Flow
       8.9        Pauses
                  Pauses suspend the execution of a program for a period of time, and put it into low-power
                  mode. The program remains suspended for the duration specified in the instruction.
                  The pause instruction accepts an unsigned 8-bit immediate operand which specifies the
                  pause duration in terms of cycles. The maximum possible duration is 263 cycles (255+8).
                  Hexagon processor interrupts cause a program to exit the paused state before its specified
                  duration has elapsed.
                  The pause instruction is useful for implementing user-level low-power synchronization
                  operations (such as spin locks).
                  Table 8-14 lists the pause instruction.
                  Table 8-14 Pause instruction
                             Syntax                                     Operation
                    pause(#u8)                Suspend program in low-power mode for specified cycle
                                              duration.
     8.10         Exceptions
                  Exceptions are internally-generated disruptions to the program flow.
                  The Hexagon processor OS handles fatal exceptions by terminating the execution of the
                  application system. The user is responsible for fixing the problem and recompiling their
                  applications.
                  The error messages generated by exceptions include the following information to assist in
                  locating the problem:
                          Cause code – Hexadecimal value indicating the type of exception that occurred
                          User IP – PC value indicating the instruction executed when exception occurred
                          Bad VA – Virtual address indicating the data accessed when exception occurred
                      NOTE     The cause code, user IP, and Bad VA values are stored in the Hexagon
                               processor system control registers SSR[7:0], ELR, and BADVA respectively.
                  If multiple exceptions occur simultaneously, the exception with the lowest error code
                  value has the highest exception priority.
                  If a packet contains multiple loads, or a load and a store, and both operations have an
                  exception of any type, then all Slot 1 exceptions are processed before any Slot 0 exception
                  is processed.
                      NOTE     V65 defines an additional event (with cause code 0x17) to indicate an
                               instruction-cache error.
80-N2040-45 Rev. B                                                                                         137
Hexagon V67 Programmer’s Reference Manual                                                           Program Flow
                  Table 8-15 lists the exceptions for the V67 processor.
                  Table 8-15 V67 exceptions
                    Cause
                              Event Type                     Event Description                     Notes
                    Code
                      0x0   Reset            Software thread reset.                          Non-maskable,
                                                                                             Highest Priority
                     0x01   Precise,         Unrecoverable BIU error (bus error, timeout, L2 Non-maskable
                            Unrecoverable parity error, etc.).
                     0x03   Precise,         Double exception (exception occurs while        Non-maskable
                            Unrecoverable SSR[EX]=1).
                     0x11   Precise          Privilege violation: User/Guest mode execute to Non-maskable
                                             page with no execute permissions (X=0).
                     0x12   Precise          Privilege violation: User mode execute to a     Non-maskable
                                             page with no user permissions (X=1, U=0).
                     0x15   Precise          Invalid packet.                                 Non-maskable
                     0x16   Precise          Illegal execution of coprocessor instruction.   Non-maskable
                     0x17   Precise          Instruction cache error.                        Non-maskable
                    0x1A    Precise          Privilege violation: Executing a guest mode     Non-maskable
                                             instruction in user mode.
                    0x1B    Precise          Privilege violation: Executing a supervisor     Non-maskable
                                             instruction in user/guest mode.
                    0x1D    Precise,         Packet with multiple writes to the same         Non-maskable
                            Unrecoverable destination register.
                    0x1E    Precise,         Program counter values that are not properly    Non-maskable
                            Unrecoverable aligned.
                     0x20   Precise          Load to misaligned address.                     Non-maskable
                     0x21   Precise          Store to misaligned address.                    Non-maskable
                     0x22   Precise          Privilege violation: User/Guest mode Read to    Non-maskable
                                             page with no read permission (R=0).
                     0x23   Precise          Privilege violation: User/Guest mode Write to   Non-maskable
                                             page with no write permissions (W=0).
                     0x24   Precise          Privilege violation: User mode Read to page     Non-maskable
                                             with no user permission (R=1, U=0).
                     0x25   Precise          Privilege violation: User mode Write to page    Non-maskable
                                             with no user permissions (W=1, U=0).
                     0x26   Precise          Coprocessor VMEM address error.                 Non-maskable
                     0x27   Precise          Stack overflow: Allocframe instruction exceeded Non-maskable,
                                             FRAMELIMIT.
                     0x42   Imprecise        Data abort.                                     Non-maskable
                     0x43   Imprecise        NMI.                                            Non-maskable
                     0x44   Imprecise        Multiple TLB match.                             Non-maskable
                     0x45   Imprecise        Livelock exception.                             Non-maskable
                     0x60   TLB miss-X       Due to missing Fetch address on PC-page.        Non-maskable
80-N2040-45 Rev. B                                                                                            138
Hexagon V67 Programmer’s Reference Manual                                                            Program Flow
                  Table 8-15 V67 exceptions (Continued)
                    Cause
                              Event Type                 Event Description                          Notes
                    Code
                     0x61   TLB miss-X     Due to missing Fetch on second page from         Non-maskable
                                           packet that spans pages.
                     0x62   TLB miss-X     Due to icinva.                                   Non-maskable
                            Reserved
                     0x70   TLB miss-RW    Due to memory read.                              Non-maskable
                     0x71   TLB miss-RW    Due to memory write.                             Non-maskable
                            Reserved
                     #u8    Trap0          Software Trap0 instruction.                      Non-maskable
                     #u8    Trap1          Software Trap1 instruction.                      Non-maskable
                            Reserved
                     0x80   Debug          Single-step debug exception.
                            Reserved
                    0xBF    Floating-Point Execution of Floating-Point instruction resulted Non-maskable
                                           in exception.
                    0xC0    Interrupt0     General external interrupt.                      Maskable, highest
                                                                                            priority general
                                                                                            interrupt
                    0xC1    Interrupt 1    General external interrupt                       Maskable
                    0xC2    Interrupt 2    General external interrupt                       VIC0 Interface
                    0xC3    Interrupt 3    General external interrupt                       VIC1 Interface
                    0xC4    Interrupt 4    General external interrupt                       VIC2 Interface
                    0xC5    Interrupt 5    General external interrupt                       VIC3 Interface
                    0xC6    Interrupt 6    General external interrupt
                    0xC7    Interrupt 7    General external interrupt                       Lowest-priority
                                                                                            interrupt
80-N2040-45 Rev. B                                                                                            139
          9 PMU Events
                  The Hexagon processor can collect execution statistics on the applications it executes. The
                  statistics summarize the various types of Hexagon processor events that occurred while
                  the application was running.
                  Execution statistics can be collected in hardware or software:
                      Statistics can be collected in hardware with the Performance Monitor Unit (PMU),
                       which is defined as part of the Hexagon processor architecture.
                      Statistics can be collected in software using the Hexagon simulator. The simulator
                       statistics are presented in the same format used by the PMU.
                  Execution statistics are expressed in terms of processor events. This chapter defines the
                  event symbols, along with their associated numeric codes.
                      NOTE       Because the types of execution events vary across the Hexagon processor
                                 versions, different types of statistics are collected for each version. This
                                 chapter lists the event symbols defined for version V67.
80-N2040-45 Rev. B                                                                                            140
Hexagon V67 Programmer’s Reference Manual                                                             PMU Events
       9.1        V67 processor event symbols
                  Table 9-1 defines the symbols that are used to represent processor events for the V67
                  Hexagon processor.
Table 9-1     V67 processor events symbols
 Event                    Symbol                                              Definition
  0x0   N/A                                         This event never causes a counter update.
 0x01 COUNTER0_OVERFLOW                             Counter0 overflow. This can be used as the event detected
                                                    by counter1 to build an effective 64-bit counter.
 0x02 COUNTER2_OVERFLOW                             Counter2 overflow. This can be used as the event detected
                                                    by counter3 to build an effective 64-bit counter.
 0x03 COMMITTED_PKT_ANY                             Thread committed a packet. Packets executed.
 0x04 COMMITTED_PKT_BSB                             Packet committed 2 cycles after previous packet in the same
                                                    thread.
 0x05 COUNTER4_OVERFLOW                             Counter4 overflow. This can be used as the event detected
                                                    by counter5 to build an effective 64-bit counter.
 0x06 COUNTER6_OVERFLOW                             Counter6 overflow. This can be used as the event detected
                                                    by counter7 to build an effective 64-bit counter.
 0x07 COMMITTED_PKT_B2B                             Packet committed 1 cycle after previous packet in the same
                                                    thread.
 0x08 COMMITTED_PKT_SMT                             Two packets committed in the same cycle.
 0x0a CYCLES_5_THREAD_RUNNING                       Processor cycles that exactly 5 thread is running. Running
                                                    means not in wait or stop
 0x0b CYCLES_6_THREAD_RUNNING                       Processor cycles that exactly 6 thread is running. Running
                                                    means not in wait or stop.
 0x12 ICACHE_DEMAND_MISS                            Icache demand miss. Includes secondary miss.
 0x13 DCACHE_DEMAND_MISS                            Dcache cacheable demand primary or secondary miss.
                                                    Includes dczero stall. Excludes uncacheables, prefetches,
                                                    and no allocate store misses.
 0x14 DCACHE_STORE_MISS                             Dcache cacheable store miss.
 0x17 CU_PKT_READY_NOT_DISPATCHED                   Packets that were ready at the CU scheduler but were not
                                                    scheduled because its thread was not picked or an
                                                    intercluster resource conflict.
 0x18 COMMITTED_PKT_5_THREAD_RUNNING                Committed packets with 5 threads running. Not in stop/wait.
 0x19 COMMITTED_PKT_6_THREAD_RUNNING                Committed packets with 6 threads running. Not in stop/wait.
 0x1c   IU_L1S_ACCESS                               IU L1S load. Demand or prefetch.
 0x1d IU_L1S_PREFETCH                               IU L1S prefetch80-N2040-45 Rev. B.
 0x1e IU_L1S_AXIS_STALL                             IU L1S stall due to AXI slave.
  0x1f  IU_L1S_NO_GRANT                             IU request to L1S and no grant from VU.
80-N2040-45 Rev. B                                                                                             141
Hexagon V67 Programmer’s Reference Manual                                                        PMU Events
Table 9-1     V67 processor events symbols
 Event                  Symbol                                          Definition
 0x20 ANY_IU_REPLAY                        Any IU stall other than icache miss. Includes jump register
                                           stall, fetchcross stall, ITLB miss stall, etc. Excludes CU
                                           replay.
 0x21 ANY_DU_REPLAY                        Any DU replay. Bank conflict, store buffer full, etc. Excludes
                                           stalls due to cache misses.
 0x23 ISSUED_PACKETS                       Speculatively issued packets delivered from IU.
 0x24 LOOPCACHE_PACKETS                    Committed packets which were cloned from the packet queue
                                           during a pinned hardware loop.
 0x25 COMMITTED_PKT_1_THREAD_RUNNING       Committed packets with 1 thread running. Not in stop/wait.
 0x26 COMMITTED_PKT_2_THREAD_RUNNING       Committed packets with 2 threads running. Not in stop/wait.
 0x27 COMMITTED_PKT_3_THREAD_RUNNING       Committed packets with 3 threads running. Not in stop/wait.
 0x2a COMMITTED_INSTS                      Committed instructions. Increments by up to 8 per cycle.
                                           Duplex counts as two instructions. Does not include
                                           endloops.
 0x2b COMMITTED_TC1_INSTS                  Committed tc1 class instructions. Increments by up to 8 per
                                           cycle. Duplex of two tc1 instructions counts as two tc1
                                           instructions.
 0x2c   COMMITTED_PRIVATE_INSTS            Committed instructions that have per-cluster (private)
                                           execution resources. Increments by up to 8 per cycle. Duplex
                                           of two private instructions counts as two private instructions.
  0x2f  COMMITTED_PKT_4_THREAD_RUNNING     Committed packets with 4 threads running. Not in stop/wait.
 0x30 COMMITTED_LOADS                      Committed load instructions. Includes cached and uncached.
                                           Increments by 2 for dual loads. Excludes prefetches,
                                           memops, and coprocessor loads.
 0x31 COMMITTED_STORES                     Committed store instructions. Includes cached and uncached.
                                           Increments by 2 for dual stores. Excludes memops and
                                           coprocessor stores.
 0x32 COMMITTED_MEMOPS                     Committed memop instructions. Cached or uncached.
 0x37 COMMITTED_PROGRAM_FLOW_INSTS         Committed packet contains program flow instrunctions.
                                           Includes cr jumps, endloop, j, jr, dealloc_return, system/trap,
                                           superset of event 56. Dual jumps count as two.
 0x38 COMMITTED_PKT_CHANGED_FLOW           Committed packet resulted in change-of-flow. Any taken
                                           jump. Includes endloop and dealloc_return.
 0x39 COMMITTED_PKT_ENDLOOP                Committed packet contains an endloop which was taken.
 0x3b CYCLES_1_THREAD_RUNNING              Processor cycles that exactly 1 thread is running. Running
                                           means not in wait or stop.
 0x3c   CYCLES_2_THREAD_RUNNING            Processor cycles that exactly 2 threads are running. Running
                                           means not in wait or stop.
 0x3d CYCLES_3_THREAD_RUNNING              Processor cycles that exactly 3 threads are running. Running
                                           means not in wait or stop.
80-N2040-45 Rev. B                                                                                      142
Hexagon V67 Programmer’s Reference Manual                                                     PMU Events
Table 9-1     V67 processor events symbols
 Event                  Symbol                                         Definition
 0x3e CYCLES_4_THREAD_RUNNING              Processor cycles that exactly 4 threads are running. Running
                                           means not in wait or stop.
  0x3f  AXI_LINE128_READ_REQUEST           128-byte line read requests issued by primary AXI master.
 0x40 AXI_READ_REQUEST                     All read requests issued by primary AXI master. Includes full
                                           line and partial line.
 0x41 AXI_LINE32_READ_REQUEST              32-byte line read requests issued by primary AXI master.
 0x42 AXI_WRITE_REQUEST                    All write requests issued by primary AXI master. Includes full
                                           line and partial line.
 0x43 AXI_LINE32_WRITE_REQUEST             32-byte line write requests issued by primary AXI master, all
                                           bytes valid
 0x44 AHB_READ_REQUEST                     Read requests issued by AHB master.
 0x45 AHB_WRITE_REQUEST                    Write requests issued by AHB master.
 0x46 AXI_LINE128_WRITE_REQUEST            128-byte line write requests issued by primary AXI master, all
                                           bytes valid.
 0x47 AXI_SLAVE_MULTI_BEAT_ACCESS          AXI slave multi-beat access.
 0x48 AXI_SLAVE_SINGLE_BEAT_ACCESS         AXI slave single-beat access.
 0x49 AXI2_READ_REQUEST                    All read requests issued by secondary AXI master. Includes
                                           full line and partial line.
 0x4a AXI2_LINE32_READ_REQUEST             32-byte line read requests issued by secondary AXI master.
 0x4b AXI2_WRITE_REQUEST                   All write requests issued by secondary AXI master. Includes
                                           full line and partial line.
 0x4c   AXI2_LINE32_WRITE_REQUEST          32-byte line Write requests issued by secondary AXI master.
 0x4d AXI2_CONGESTION                      Secondary AXI command or data queue is full and an
                                           operation is stuck at the head of the secondary AXI master
                                           command queue.
 0x50 COMMITTED_FPS                        Committed floating point instructions. Increments by 2 for dual
                                           fp ops. Excludes conversions.
 0x51 REDIRECT_BIMODAL_MISPREDICT          Mispredict bimodal branch direction caused a control flow
                                           redirect.
 0x52 REDIRECT_TARGET_MISPREDICT           Mispredict branch target caused a control flow redirect.
                                           Includes RAS mispredict. Excludes indirect jumps and calls
                                           other than JUMPR R31 returns. Excludes direction
                                           mispredicts.
 0x53 REDIRECT_LOOP_MISPREDICT             Mispredict hardware loopend caused a control flow redirect.
                                           Can only happen when the loop has relatively few packets
                                           and the loop count is 2 or less.
 0x54 REDIRECT_MISC                        Control flow redirect for a reason other than events 81, 82,
                                           and 83. Includes exceptions, traps, interrupts, non-R31
                                           jumps, multiple initloops in flight, and others.
 0x56 NUM_PACKET_CRACKED                   Number of packets cracked.
80-N2040-45 Rev. B                                                                                      143
Hexagon V67 Programmer’s Reference Manual                                                       PMU Events
Table 9-1     V67 processor events symbols
 Event                  Symbol                                         Definition
 0x58 JTLB_MISS                            Instruction or data address translation request missed in the
                                           JTLB.
 0x5a COMMITTED_PKT_RETURN                 Committed a return instruction. Includes canceled returns.
 0x5b COMMITTED_PKT_INDIRECT_JUMP          Committed an indirect jump or call instruction. Includes
                                           canceled instructions. Does not include JUMPR R31 returns.
 0x5c   COMMITTED_BIMODAL_BRANCH_INSTS     Committed bimodal branch. Includes .old and .new.
                                           Increments by 2 for dual jumps.
  0x5f  VTCM_SCALAR_FIFO_FULL_CYCLES       Cycles cluster could issue scalar memory access to VTCM
                                           scalar FIFO.
 0x61 DU_L1S_LOAD_ACCESS                   Scalar Load to L1S.
 0x62 ICACHE_ACCESS                        Number of I-cache line fetches.
 0x63 BTB_HIT                              BTB hit.
 0x64 BTB_MISS                             BTB miss.
 0x65 IU_DEMAND_SECONDARY_MISS             Icache secondary misses.
 0x67 FAST_FETCH_KILLED                    Fast-fetch killed (after an I-cache access).
 0x69 FETCHED_PACKETS_DROPPED              Dropped packets because unable to deliver to CU.
 0x6b IU_PREFETCHES_SENT_TO_L2             IU prefetches sent to L2. Counts cachelines not dropped by
                                           L2. Excludes replayed prefetches and only counts ones L2
                                           accepts.
 0x6c   ITLB_MISS                          ITLB miss. which goes to JTLB.
 0x72 FETCH_2_CYCLE                        2-cycle actual (returns, loop end, fallthrough, BTB).
 0x73 FETCH_3_CYCLE                        3-cycle actual.
 0x75 L2_IU_SECONDARY_MISS                 L2 secondary misses from IU.
 0x76 L2_IU_ACCESS                         L2 cacheable access from IU. Any access to the L2 cache
                                           that was the result of an IU command, either demand or L1
                                           prefetch access. Excludes any prefetch generated in the L2.
                                           Excludes L2Fetch, tcm accesses and uncacheables. Address
                                           must target primary AXI.
 0x77 L2_IU_MISS                           L2 misses from IU. Of the events qualified by 0x76, the ones
                                           that resulted in an L2 miss (demand miss or L1 prefetch
                                           miss). A L2 miss is any condition that prevents the immediate
                                           return of data to the IU, excluding pipeline conflicts.
 0x78 L2_IU_PREFETCH_ACCESS                Pre-fetch from the IU to L2. Any IU pre-fetch access sent to
                                           the L2 cache. Access must be L2 cacheable and target
                                           primary AXI. This does not include L2Fetch generated
                                           accesses.
 0x79 L2_IU_PREFETCH_MISS                  L2 prefetch from IU miss. Of the events qualified by 0x78, the
                                           ones that resulted in an L2 miss.
80-N2040-45 Rev. B                                                                                     144
Hexagon V67 Programmer’s Reference Manual                                                       PMU Events
Table 9-1     V67 processor events symbols
 Event                  Symbol                                         Definition
 0x7c   L2_DU_READ_ACCESS                  L2 cacheable read access from DU. Any read access from
                                           DU that may cause a lookup in the L2 cache. Includes loads,
                                           l1 prefetch, dcfetch. Excludes initial L2fetch command,
                                           uncacheables, tcm, and coprocessor loads. Must target AXI
                                           primary.
 0x7d L2_DU_READ_MISS                      L2 read miss from DU. Of the events qualified by 0x7C, any
                                           that resulted in L2 miss. i.e., the line was not previously
                                           allocated in the L2 cache and is fetched from backing
                                           memory.
 0x7e L2FETCH_ACCESS                       L2fetch access from DU. Any access to the L2 cache from the
                                           L2 prefetch engine that was initiated by programing the
                                           L2Fetch engine. Includes only the cache inquire and fetch if
                                           not present commands.
  0x7f  L2FETCH_MISS                       L2fetch miss from a programed inquiry. Of the events
                                           qualified by 0x7E, the ones that resulted in L2 miss. i.e., the
                                           line was not previously allocated in the L2 cache and is
                                           fetched from backing memory.
 0x81 L2_ACCESS                            All requests to the L2. Does not include internally generated
                                           accesses like L2Fetch, however the programing of the
                                           L2Fetch engine would be counted. Accesses target Odd or
                                           Even interleave, and may be L2 cacheable or TCM.
 0x82 L2_PIPE_CONFLICT                     Request not taken by the L2 due to a pipe conflict. The
                                           conflict can be a tag bank, data bank, or other pipeline
                                           conflict.
 0x83 L2_TAG_ARRAY_CONFLICT                Of the items in event 130, the ones caused by a conflict with
                                           the tag array.
 0x87 TCM_DU_ACCESS                        TCM access from DU. DU access to the L2 TCM space. HVX
                                           requests are excluded.
 0x88 TCM_DU_READ_ACCESS                   TCM read access from DU. DU read access to the L2 TCM
                                           space. HVX requests are excluded.
 0x89 TCM_IU_ACCESS                        TCM access from IU. IU access to the L2 TCM space.
 0x8a L2_CASTOUT                           L2 cast out. Triggers when L2 evicts a dirty line due to an
                                           allocation. not triggered on cache operations.
 0x8b L2_DU_STORE_ACCESS                   L2 cacheable store access from DU. Any store access from
                                           DU that may cause a lookup in the L2 cache. Excludes cache
                                           operations, uncacheables, TCMs, and coprocessor stores.
                                           Must target primary AXI.
 0x8c   L2_DU_STORE_MISS                   L2 miss from DU. Of the events qualified by 0x8B, the ones
                                           that resulted in a miss. Specifically the cases where the line is
                                           not in cache or a coalesce buffer
 0x8d L2_DU_PREFETCH_ACCESS                L2 prefetch access from DU. Of the events qualified by 0x7C,
                                           the ones which are Dcfetch and dhwprefetch. These are L2
                                           cacheable targeting AXI primary.
80-N2040-45 Rev. B                                                                                       145
Hexagon V67 Programmer’s Reference Manual                                                      PMU Events
Table 9-1     V67 processor events symbols
 Event                  Symbol                                        Definition
 0x8e L2_DU_PREFETCH_MISS                  L2 prefetch miss from DU. Of the events qualified by 0x8D,
                                           which ones missed the L2
 0x90 L2_DU_LOAD_SECONDARY_MISS            L2 load secondary miss from DU. Hit busy line in the
                                           scoreboard which prevented a return. Busy condition may
                                           include pipeline bubbles caused by back to back loads, as
                                           may be seen on L1UC loads.
 0x91 L2FETCH_COMMAND                      L2fetch command. Excludes stop command.
 0x92 L2FETCH_COMMAND_KILLED               L2fetch command killed because a stop command was
                                           issued. Increments once for each L2fetch commands that is
                                           killed. If multiple commands are queued to the L2Fetch
                                           engine, the kill of each one is recorded.
 0x93 L2FETCH_COMMAND_OVERWRITE            L2fetch command overwrite. Kills old L2fetch and replaces
                                           with new one.
 0x94 L2FETCH_ACCESS_CREDIT_FAIL           L2fetch access could not get a credit. L2fetch is blocked
                                           because of a missing L2fetch or L2evict credit.
 0x95 AXI_SLAVE_READ_BUSY                  AXI slave read access hit a busy line.
 0x96 AXI_SLAVE_WRITE_BUSY                 AXI slave write access hit a busy line.
 0x97 L2_ACCESS_EVEN                       Of the events in 0x81, the number of accesses made to the
                                           even L2 cache.
 0x98 CLADE_HIGH_PRIO_L2_ACCESS            IU or DU request for a high priority CLADE region. Not
                                           counted for L2 Fetch.
 0x99 CLADE_LOW_PRIO_L2_ACCESS             IU or DU request for a low priority CLADE region. Not counted
                                           for L2 Fetch.
 0x9a CLADE_HIGH_PRIO_L2_MISS              CLADE high priority L2 Access that missed in L2.
 0x9b CLADE_LOW_PRIO_L2_MISS               CLADE low priority L2 Access that missed in L2.
 0x9c   CLADE_HIGH_PRIO_EXCEPTION          CLADE high priority decode that had an exception.
 0x9d CLADE_LOW_PRIO_EXCEPTION             CLADE low priority decode that had an exception.
 0x9e AXI2_SLAVE_READ_BUSY                 AXI secondary slave read access hit a busy line.
  0x9f  AXI2_SLAVE_WRITE_BUSY              AXI secondary slave write access hit a busy line.
 0xa0 ANY_DU_STALL                         Any DU stall. Increments once when the thread has any DU
                                           stall (dcache miss or dtlb miss).
 0xa1 DU_BANK_CONFLICT_REPLAY              DU bank conflict replay. Dual memory access to the same
                                           bank but different lines.
 0xa2 DU_CREDIT_REPLAY                     Number of times the packet took a replay because there were
                                           insufficient QOS DU credits available.
 0xa3 L2_FIFO_FULL_REPLAY                  Counts L2 even/odd FIFO full replays.
 0xa4 DU_STORE_BUFFER_FULL_REPLAY          First packet puts access in DU store buffer (memop,
                                           store.new, load/store bank conflict, store/store bank conflict).
                                           Any later packet tries to use store buffer before the first one
                                           evicts, and so must replay so the store buffer can drain.
80-N2040-45 Rev. B                                                                                       146
Hexagon V67 Programmer’s Reference Manual                                                        PMU Events
Table 9-1     V67 processor events symbols
 Event                  Symbol                                         Definition
 0xa7 DU_SNOOP_REQUEST                     DU snoop requests that were accepted.
 0xa8 DU_FILL_REPLAY                       A fill has a index conflict with an instruction from the same
                                           thread in pipeline. Fills and demands might be from different
                                           threads if there is a prefetch from the deferral queue or a fill
                                           has not be acknowledged for too long and forces itself in to
                                           the pipeline.
 0xab DU_EVICTIONS_SENT_TO_L2              Number of dirty line evictions sent from DU to L2fifo, includes
                                           dirty line evictions caused by cacheops and dczeroes.
 0xac   DU_READ_TO_L2                      DU read to L2. Total of everything that brings data from L2.
                                           Includes prefeches (dcfetch and hwprefetch). Excludes
                                           coprocessor loads.
 0xad DU_WRITE_TO_L2                       DU write to L2. Total of everything that is written out of DU to
                                           the L2 array. Includes dczeroa. Excludes dcclean, dccleaninv,
                                           tag writes, and coprocessor stores.
 0xae DCZERO_DATA_WRITE_IN_PIPE_REPLAY Number of replays taken by a packet because of a dczero
                                           zero-write in progress occupying the pipe.
  0xaf  DCZERO_COMMITTED                   Commited a dczeroa instruction.
 0xb0 L2ITCM_IU_READ                       L2ITCM access from IU. This includes IU demands fetches
                                           and IU prefetches. This event is NOT included in any other L2
                                           events.
 0xb1 L2ITCM_DU_READ                       L2ITCM read access from DU. This includes all demands and
                                           prefetches. This event is NOT included in any other L2
                                           events.
 0xb2 L2ITCM_DU_WRITE                      L2ITCM write accesses from DU. This includes stores, and
                                           dczeroa events. This event does NOT include any cacheops.
                                           This event is NOT included in any other L2 events.
 0xb3 DTLB_MISS                            DTLB miss that goes to JTLB. When both slots miss to
                                           different pages, increments by 2. When both slots miss to the
                                           same page, only counts S1, since S1 goes first and fills for
                                           S0.
 0xb4 L2ITCM_BIMODAL_WRITES_SUCCESS        Number of successful bimodal writes into L2ITCM.
 0xb6 STORE_BUFFER_HIT_REPLAY              Store buffer hit replay due to a packet with 2 stores going to
                                           the same bank but different cachelines, followed by a load
                                           from an address that was pushed into the store buffer.
 0xb7 STORE_BUFFER_FORCE_REPLAY            The store buffer must drain, forcing the current packet to
                                           replay. This usually happens on an cache index match
                                           between the current packet and store buffer. Could also be a
                                           store buffer timeout.
 0xb8 TAG_WRITE_CONFLICT_REPLAY            Counts intercluster tag write conflicts.
 0xb9 SMT_BANK_CONFLICT                    Counts inter-thread SMT bank conflicts.
80-N2040-45 Rev. B                                                                                       147
Hexagon V67 Programmer’s Reference Manual                                                      PMU Events
Table 9-1     V67 processor events symbols
 Event                  Symbol                                         Definition
 0xba PORT_CONFLICT_REPLAY                 Counts all port conflict replays including the same cluster
                                           replays caused due to high priority fills and store buffer force
                                           drains, and intercluster ones as well.
 0xbb L2ITCM_BIMODAL_WRITES_DROPPED        Number of bimodal writes into L2ITCM that were dropped.
 0xbc   L2ITCM_IU_PREFETCH_READ            L2ITCM access from IU prefetches. This includes only
                                           prefetches from IU. This events is included in event 176,
                                           L2ITCM_IU_READ. It is not included in any other L2 events.
 0xbd PAGE_CROSS_REPLAY                    Page cross replay. Page cross from valid packet that caused
                                           replay. Excludes pdkill packets. Counts twice if both slots
                                           cause a page cross.
  0xbf  DU_DEMAND_SECONDARY_MISS           DU demand secondary miss.
 0xc0   DU_MISC_REPLAY                     All DU replays not counted by other replay events. This event
                                           should count every time ANY_DU_REPLAY counts and no
                                           other DU replay event counts.
 0xc1   GUARDBUF_SETMATCH_CRACKING_REP Number of replays taken by a younger access due to an index
        LAY                                match with a guard buffer entry. If the younger access hits in
                                           D$, then only the guard buffer entry of the other thread is
                                           checked, otherwise an index match with either thread's guard
                                           buffer entry results in this replay.
 0xc2   GUARDBUF_STATEWRITE_FINALCRACK_ Number of replays taken by the final crack of a thread if the
        REPLAY                             first crack was doing a write-back store to a clean line
                                           (including store misses causing allocation).
 0xc3   DCFETCH_COMMITTED                  Dcfetch committed. Includes hit and dropped. Does not
                                           include convert-to-prefetches.
 0xc4   DCFETCH_HIT                        Dcfetch hit in dcache. Includes hit valid or reserved line.
 0xc5   DCFETCH_MISS                       Dcfetch missed in L1. Counts the dcfetch issued to L2 FIFO.
 0xc6   DCACHE_EVICTION_IN_PIPE_REPLAY     Number of replays taken by a packet because of an eviction
                                           in progress occupying the pipe.
 0xc7   STBUF_MATCH_PARTIAL_CRACK_REPLA Number of replays taken by a partial crack store due to a
        Y                                  dword match with an existing store buffer entry.
 0xc8   DU_LOAD_UNCACHEABLE                Uncacheable load in L1 cache. Counts twice for dual
                                           uncachable loads.
 0xc9   DU_DUAL_LOAD_UNCACHEABLE           Dual uncacheable loads in L1 cache.
 0xca   DU_STORE_UNCACHEABLE               Uncacheable store in L1 cache. Counts twice for dual
                                           uncachable stores. Excludes uncached memops.
 0xce   AXI_LINE64_READ_REQUEST            64-byte line read requests issued by primary AXI master.
  0xcf  AXI_LINE64_WRITE_REQUEST           64-byte line write requests issued by primary AXI master. All
                                           bytes valid.
 0xd1 AHB_8_READ_REQUEST                   An 8 byte AHB read was made.
80-N2040-45 Rev. B                                                                                       148
Hexagon V67 Programmer’s Reference Manual                                                      PMU Events
Table 9-1     V67 processor events symbols
 Event                  Symbol                                        Definition
 0xd3 L2FETCH_COMMAND_PAGE_TERMINATI       L2fetch command terminated because it could not get a page
        ON                                 translation from VA to PA. Includes termination dues to
                                           permission errors. i.e., address translation could fail because
                                           the VA to PA is not in the TLB, or the properties in the
                                           translation are not acceptable and the command terminates.
 0xd5 L2_DU_STORE_COALESCE                 Events from 139 that were coalesced.
 0xd6 L2_STORE_LINK                        Counts the number of times a new store links to something
                                           else in the scoreboard.
 0xd7 L2_SCOREBOARD_70_PERCENT_FULL        Increments by 1 every cycle that the L2 scoreboard is at least
                                           70% full. For a 32-entry scoreboard, this would mean 23 or
                                           more entries are consumed. This event continues to count
                                           even if the scoreboard is more than 80% full. For more than
                                           one interleave, this event only considers the scoreboard that
                                           has the most entries consumed.
 0xd8 L2_SCOREBOARD_80_PERCENT_FULL        Increments by 1 every cycle that the L2 scoreboard is at least
                                           80% full. For a 32-entry scoreboard, this would mean 26 or
                                           more entries are consumed. This event continues to count
                                           even if the scoreboard is more than 90% full. For more than
                                           one interleave, this event only considers the scoreboard that
                                           has the most entries consumed.
 0xd9 L2_SCOREBOARD_90_PERCENT_FULL        Increments by 1 every cycle that the L2 scoreboard is at least
                                           90% full. For a 32-entry scoreboard, this would mean 29 or
                                           more entries are consumed. For more than one interleave,
                                           this event only considers the scoreboard that has the most
                                           entries consumed.
 0xda L2_SCOREBOARD_FULL_REJECT            The L2 scoreboard is too full to accept a selector request and
                                           the selector has a request.
 0xdc   L2_EVICTION_BUFFERS_FULL           Counts every cycle when all eviction buffers in any interleave
                                           are occupied.
 0xdd AHB_MULTI_BEAT_READ_REQUEST          A 32 byte multi-beat AHB read was made.
  0xdf  L2_DU_LOAD_SECONDARY_MISS_ON_S     Of the events in 0x90, the ones where the primary miss was a
        W_PREFETCH                         DCFETCH or L2FETCH.
 0xe0 L2FETCH_DROP                         L2Fetch data dropped since prior eviction has not completed
 0xe5 THREAD_OFF_PVIEW_CYCLES              Cycles cluster could not commit due to thread off or wait.
 0xe6 ARCH_LOCK_PVIEW_CYCLES               Cycles cluster could not commit due to kernel lock or TLB
                                           lock.
 0xe7 REDIRECT_PVIEW_CYCLES                Cycles cluster could not commit due to redirects such as
                                           branch mispredict.
 0xe8 IU_NO_PKT_PVIEW_CYCLES               Cycles cluster could not commit due to IQ being empty.
 0xe9 DU_CACHE_MISS_PVIEW_CYCLES           Cycles cluster could not commit due to D-cache cacheable
                                           miss.
80-N2040-45 Rev. B                                                                                      149
Hexagon V67 Programmer’s Reference Manual                                                      PMU Events
Table 9-1     V67 processor events symbols
 Event                  Symbol                                         Definition
 0xea DU_BUSY_OTHER_PVIEW_CYCLES           Cycles cluster could not commit due to DU replay or DU
                                           bubble or DTLB miss.
 0xeb CU_BUSY_PVIEW_CYCLES                 Cycles cluster could not commit due to register interlock,
                                           register port conflict, bubbles due to timing class such as
                                           tc_3stall, no B2B HVX, or HVX FIFO full.
 0xec   SMT_DU_CONFLICT_PVIEW_CYCLES       Cycles cluster could not commit because of a DU resource
                                           conflict.
 0xed COPROC_BUSY_PVIEW_CYCLES             Cycles cluster could not commit because of the coprocessor
                                           is busy
 0xee DU_UNCACHED_PVIEW_CYCLES             Cycles cluster could not commit due to D-cache uncacheable
                                           access.
  0xef  SYSTEM_BUSY_PVIEW_CYCLES           Cycles cluster could not commit due to system level stalls
                                           including DMA synchronization, ETM full, Qtimer read not
                                           ready, AXI bus busy, and global cache op synchronization.
80-N2040-45 Rev. B                                                                                     150
      10 Instruction Encoding
                  This chapter describes the binary encoding of Hexagon processor instructions and
                  instruction packets.
     10.1         Instructions
                  All Hexagon processor instructions are encoded in a 32-bit instruction word. The
                  instruction word format varies according to the instruction type.
                  The instruction words contain two types of bit fields:
                          Common fields appear in every processor instruction, and are defined the same in
                           all instructions.
                          Instruction-specific fields appear only in some instructions, or vary in definition
                           across the instruction set.
                  Table 10-1 lists the instruction bit fields.
                  Table 10-1 Instruction fields
                        Name                             Description                      Type
                   ICLASS             Instruction class                            Common
                   Parse              Packet / loop bits
80-N2040-45 Rev. B                                                                                           151
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Encoding
                  Table 10-1 Instruction fields
                        Name                           Description                         Type
                   MajOp             Major opcode                                   Instruction-
                   Maj                                                              specific
                   MinOp             Minor opcode
                   Min
                   RegType           Register type (32-bit, 64-bit)
                   Type              Operand type (byte, halfword, etc.)
                   Amode             Addressing mode
                   dn                Destination register operand
                   sn                Source register operand
                   tn                Source register operand #2
                   xn                Source and destination register operand
                   un                Predicate or modifier register operand
                   sH                Source register bit field (Rs.H or Rs.L)
                   tH                Source register #2 bit field (Rt.H or Rt.L)
                   UN                Unsigned operand
                   Rs                No source register read
                   P                 Predicate expression
                   PS                Predicate sense (Pu or !Pu)
                   DN                Dot-new predicate
                   PT                Predict taken
                   sm80-N2040-45     Supervisor mode only
                   Rev. B
                      NOTE     In some cases instruction-specific fields are used to encode instruction
                               attributes other than the ones described for the fields in Table 10-1.
                  Reserved bits
                  Some instructions contain reserved bits which are not currently used to encode instruction
                  attributes. Set these bits to 0 to ensure compatibility with any future changes in the
                  instruction encoding.
                      NOTE     Reserved bits appear as ‘-’ characters in the instruction encoding tables.
     10.2         Sub-instructions
                  To reduce code size the Hexagon processor supports the encoding of certain pairs of
                  instructions in a single 32-bit container. Instructions encoded this way are called sub-
                  instructions, and the containers are called duplexes (Section 10.3).
                  Sub-instructions are limited to certain commonly-used instructions:
80-N2040-45 Rev. B                                                                                             152
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Encoding
                         Arithmetic and logical operations
                         Register transfer
                         Loads and stores
                         Stack frame allocation/deallocation
                         Subroutine return
                  Table 10-2 lists the sub-instructions along with the group identifiers that are used to
                  encode them in duplexes.
                  Sub-instructions can access only a subset of the general registers (R0-R7, R16-R23).
                  Table 10-3 lists the sub-instruction register encodings.
                     NOTE     Certain sub-instructions implicitly access registers such as SP (R29).
Table 10-2 Sub-instructions
     Group                               Instruction                                    Description
       L1           Rd = memw(Rs+#u4:2)                                  Word load
       L1           Rd = memub(Rs+#u4:0)                                 Unsigned byte load
     Group                               Instruction                                    Instruction
       L2           Rd = memh/memuh(Rs+#u3:1)                            Halfword loads
       L2           Rd = memb(Rs+#u3:0)                                  Signed byte load
       L2           Rd = memw(r29+#u5:2)                                 Load word from stack
       L2           Rdd = memd(r29+#u5:3)                                Load pair from stack
       L2           deallocframe                                         Dealloc stack frame
       L2           if ([!]P0) dealloc_return                            Dealloc stack frame and return
                    if ([!]P0.new) dealloc_return:nt
       L2           jumpr R31                                            Return
                    if ([!]P0) jumpr R31
                    if ([!]P0.new) jumpr:nt R31
     Group                               Instruction                                    Instruction
       S1           memw(Rs+#u4:2) = Rt                                  Store word
       S1           memb(Rs+#u4:0) = Rt                                  Store byte
     Group                               Instruction                                    Instruction
       S2           memh(Rs+#u3:1) = Rt                                  Store halfword
       S2           memw(r29+#u5:2) = Rt                                 Store word to stack
       S2           memd(r29+#s6:3) = Rtt                                Store pair to stack
       S2           memw(Rs+#u4:2) = #U1                                 Store immediate word #0 or #1
       S2           memb(Rs+#u4) = #U1                                   Store immediate byte #0 or #1
       S2           allocframe(#u5:3)                                    Allocate stack frame
     Group                               Instruction                                    Instruction
        A           Rx = add(Rx,#s7)                                     Add immediate
        A           Rd = Rs                                              Transfer
80-N2040-45 Rev. B                                                                                             153
Hexagon V67 Programmer’s Reference Manual                                 Instruction Encoding
Table 10-2 Sub-instructions (Continued)
     Group                          Instruction                      Description
        A           Rd = #u6                           Set to unsigned immediate
        A           Rd = #-1                           Set to -1
        A           if ([!]P0[.new]) Rd = #0           Conditional clear
        A           Rd = add(r29,#u6:2)                Add immediate to stack pointer
        A           Rx = add(Rx,Rs)                    Register add
        A           P0 = cmp.eq(Rs,#u2)                Compare register equal immed
        A           Rdd = combine(#0,Rs)               Combine zero and register into pair
        A           Rdd = combine(Rs,#0)               Combine register and zero into pair
        A           Rdd = combine(#u2,#U2)             Combine immediates into pair
        A           Rd = add(Rs,#1)                    Add and Subtract 1
                    Rd = add(Rs,#-1)
        A           Rd = sxth/sxtb/zxtb/zxth(Rs)       Sign- and zero-extends
        A           Rd = and(Rs,#1)                    And with 1
                  Table 10-3 Sub-instruction registers
                       Register          Encoding
                   Rs,Rt,Rd,Rx   0000   =  R0
                                 0001   =  R1
                                 0010   =  R2
                                 0011   =  R3
                                 0100   =  R4
                                 0101   =  R5
                                 0110   =  R6
                                 0111   =  R7
                                 1000   =  R16
                                 1001   =  R17
                                 1010   =  R18
                                 1011   =  R19
                                 1100   =  R20
                                 1101   =  R21
                                 1110   =  R22
                                 1111   =  R23
                   Rdd,Rtt       000  =   R1:0
                                 001  =   R3:2
                                 010  =   R5:4
                                 011  =   R7:6
                                 100  =   R17:16
                                 101  =   R19:18
                                 110  =   R21:20
                                 111  =   R23:22
80-N2040-45 Rev. B                                                                         154
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Encoding
     10.3         Duplexes
                  A duplex is encoded as a 32-bit instruction with bits [15:14] set to 00. The sub-instructions
                  (Section 10.2) that comprise a duplex are encoded as 13-bit fields in the duplex.
                  Table 10-4 shows the encoding details for a duplex.
                  An instruction packet can contain one duplex and up to two other (non-duplex)
                  instructions. The duplex must always appear as the last word in a packet.
                  The sub-instructions in a duplex are always executed in Slot 0 and Slot 1.
                  Table 10-4 Duplex instruction
                        Bits               Name                              Description
                   15:14           Parse bits          00 = Duplex type, ends the packet and indicates that
                                                       word contains two sub-instructions
                   12:0            Sub-insn low        Encodes Slot 0 sub-instruction
                   28:16           Sub-insn high       Encodes Slot 1 sub-instruction
                   31:29, 13       4-bit ICLASS        Indicates which group the low and high sub-instructions
                                                       below to.
                  Table 10-5 lists the duplex ICLASS field values, which specify the group of each sub-
                  instruction in a duplex.
                  Table 10-5 Duplex ICLASS field
                      ICLASS         Low Slot 0 subinsn type     High Slot 1 subinsn type
                         0x0                  L1-type                    L1-type
                         0x1                  L2-type                    L1-type
                         0x2                  L2-type                    L2-type
                         0x3                  A-type                      A-type
                         0x4                  L1-type                     A-type
                         0x5                  L2-type                     A-type
                         0x6                  S1-type                     A-type
                         0x7                  S2-type                     A-type
                         0x8                  S1-type                    L1-type
                         0x9                  S1-type                    L2-type
                        0xA                   S1-type                    S1-type
                        0xB                   S2-type                    S1-type
                        0xC                   S2-type                    L1-type
                        0xD                   S2-type                    L2-type
                        0xE                   S2-type                    S2-type
                         0xF                 Reserved                   Reserved
80-N2040-45 Rev. B                                                                                             155
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Encoding
                  Duplexes have the following grouping constraints:
                         Constant extenders enable the range of an instruction’s immediate operand to be
                          expanded to 32 bits (Section 10.9). The following sub-instructions can be
                          expanded with a constant extender:
                               •   Rx = add(Rx,#s7)
                               •   Rd = #u6
                          A duplex can contain only one constant-extended instruction, and it must appear
                          in the Slot 1 position.
                         If a duplex contains two instructions with the same sub-instruction group, the
                          instructions must be ordered in the duplex as follows: when the sub-instructions
                          are treated as 13-bit unsigned integer values, the instruction corresponding to the
                          numerically smaller value must be encoded in the Slot 1 position of the duplex.1
                         Sub-instructions must conform to any slot assignment grouping rules that apply to
                          the individual instructions, even if a duplex pattern exists which violates those
                          assignments. One exception to this rule exists:
                               •   jumpr R31 must appear in the Slot 0 position
                  1 The sub-instruction register and immediate fields are assumed to be 0 when performing this
                    comparison.
80-N2040-45 Rev. B                                                                                              156
Hexagon V67 Programmer’s Reference Manual                                                    Instruction Encoding
     10.4         Instruction classes
                  The instruction class (Section 3.2) is encoded in the four most-significant bits of the
                  instruction word (31:28). These bits are referred to as the instruction’s ICLASS field.
                  Table 10-6 lists the encoding values for the instruction classes. The Slots column indicates
                  which slots can receive the instruction class.
                  Table 10-6 Instruction class encoding
                       Encoding                 Instruction Class                  Slots
                      0000           Constant extender (Section 10.9)                –
                      0001           J                                              2,3
                      0010           J                                              2,3
                      0011           LD                                             0,1
                                     ST
                      0100           LD                                             0,1
                                     ST
                                     (conditional or GP-relative)
                      0101           J                                              2,3
                      0110           CR                                              3
                      0111           ALU32                                        0,1,2,3
                      1000           XTYPE                                          2,3
                      1001           LD                                             0,1
                      1010           ST                                              0
                      1011           ALU32                                        0,1,2,3
                      1100           XTYPE                                          2,3
                      1101           XTYPE                                          2,3
                      1110           XTYPE                                          2,3
                      1111           ALU32                                        0,1,2,3
                  For details on encoding the individual class types see Chapter 11.
80-N2040-45 Rev. B                                                                                            157
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Encoding
     10.5         Instruction packets
                  Instruction packets are encoded using two bits of the instruction word (15:14), which are
                  referred to as the instruction word’s Parse field. The field values have the following
                  definitions:
                           ‘11’ indicates that an instruction is the last instruction in a packet (i.e., the
                            instruction word at the highest address).
                           ‘01’ or ‘10’ indicate that an instruction is not the last instruction in a packet.
                           ‘00’indicates a duplex (Section 10.3)
                  If any sequence of four consecutive instructions occurs without one of them containing
                  ‘11’ or ‘00’, the processor will raise an error exception (illegal opcode).
                  Figure 10-1 shows the location of the Parse field in an instruction word.
                     31                                                                   16
                     15                                                                    0
                      P    P
                    Packet / Loop Parse Bits:
                    01, 10 = not end of packet
                    11 = end of packet
                    00 = duplex
                  Figure 10-1 Instruction packet encoding
                  The following examples show how the Parse field encodes instruction packets:
                       { A ; B}
                          01 11                      // Parse fields of instrs A,B
                       { A ; B ; C}
                          01 01 11                   // Parse fields of instrs A,B,C
                       { A ; B ; C ; D}
                          01 01 01 11                // Parse fields of instrs A,B,C,D
80-N2040-45 Rev. B                                                                                               158
Hexagon V67 Programmer’s Reference Manual                                                    Instruction Encoding
     10.6         Loop packets
                  In addition to encoding the last instruction in a packet, the instruction word’s Parse field
                  (Section 10.5) encodes the last packet in a hardware loop.
                  The Hexagon processor supports two hardware loops, labelled 0 and 1 (Section 8.2). The
                  last packet in these loops is subject to the following restrictions:
                           The last packet in a hardware loop 0 must contain two or more instruction words.
                           The last packet in a hardware loop 1 must contain three or more instruction words.
                  If the last packet in a loop is expressed in assembly language with fewer than the required
                  number of words, the assembler automatically adds one or two NOP instructions to the
                  encoded packet so it contains the minimum required number of instruction words.
                  The Parse fields in a packet’s first and second instruction words (i.e., the words at the
                  lowest addresses) encode whether the packet is the last packet in a hardware loop.
                  Table 10-7 shows how the Parse fields encode loop packets.
                  Table 10-7 Loop packet encoding
                                                        Parse Field in     Parse Field in
                             Packet
                                                      First Instruction Second Instruction
                   Not last in loop                         01 or 11         01 or 11 1
                   Last in loop 0                             10              01 or 11
                   Last in loop 1                             01                10
                   Last in loops 0 & 1                        10                10
                  1  Not applicable for single-instruction packets.
                  The following examples show how the Parse field encodes loop packets:
                       { A       B}:endloop0
                          10     11                                       // Parse fields of instrs A,B
                       { A       B      C}:endloop0
                          10     01     11                                // Parse fields of instrs A,B,C
                       { A       B      C      D}:endloop0
                          10     01     01    11                        // Parse fields of instrs A,B,C,D
                       { A       B      C}:endloop1
                          01     10     11                              // Parse fields of instrs A,B,C
                       { A       B      C      D}:endloop1
                          01     10     01    11                        // Parse fields of instrs A,B,C,D
                       { A       B      C}:endloop0:endloop1
                          10     10     11                              // Parse fields of instrs A,B,C
                       { A       B      C      D}:endloop0:endloop1
                          10     10     01    11                        // Parse fields of instrs A,B,C,D
80-N2040-45 Rev. B                                                                                            159
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Encoding
     10.7         Immediate values
                  To conserve encoding space, the Hexagon processor often stores immediate values in
                  instruction fields that are smaller (in bit size) than the values actually needed in the
                  instruction operation.
                  When an instruction operates on one of its immediate operands, the processor
                  automatically extends the immediate value to the bit size required by the operation:
                          Signed immediate values are sign-extended
                          Unsigned immediate values are zero-extended
     10.8         Scaled immediates
                  To minimize the number of bits used in instruction words to store certain immediate
                  values, the Hexagon processor stores the values as scaled immediates. Scaled immediate
                  values are used when an immediate value must represent integral multiples of a power of 2
                  in a specific range.
                  For example, consider an instruction operand whose possible values are the following:
                           -32, -28, -24, -20, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 28
                  Encoding the full range of integers -32..28 would normally require 6 bits. However, if the
                  operand is stored as a scaled immediate, it can first be shifted right by two bits, with only
                  the four remaining bits being stored in the instruction word. When the operand is fetched
                  from the instruction word, the processor automatically shifts the value left by two bits to
                  recreate the original operand value.
                      NOTE     The scaled immediate value in the example above is represented notationally
                               as #s4:2. For more information see Section 1.4.
                  Scaled immediate values are commonly used to encode address offsets which apply to
                  data types of varying size. For example, Table 10-8 shows how the byte offsets used in
                  immediate-with-offset addressing mode are stored as 11-bit scaled immediate values. This
                  enables the offsets to span the same range of data elements regardless of the data type.
                  Table 10-8 Scaled immediate encoding (indirect offsets)
                                   Offset Size   Scale     Offset Size        Offset Range       Offset Range
                     Data Type
                                    (Stored)      Bits      (Effective)          (Bytes)          (Elements)
                   byte                11           0           11            -1024 ... 1023     -1024 ... 1023
                   halfword            11           1           12            -2048 ... 2046     -1024 ... 1023
                   word                11           2           13            -4096 ... 4092     -1024 ... 1023
                   doubleword          11           3           14            -8192 ... 8184     -1024 ... 1023
80-N2040-45 Rev. B                                                                                              160
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Encoding
     10.9         Constant extenders
                  To support the use of 32-bit operands in a number of instructions, the Hexagon processor
                  defines an instruction word which exists solely to extend the bit range of an immediate or
                  address operand that is contained in an adjacent instruction in a packet. These instruction
                  words are called constant extenders.
                  For example, the absolute addressing mode specifies a 32-bit constant value as the
                  effective address. Instructions using this addressing mode are encoded in a single packet
                  containing both the normal instruction word and a second word with a constant extender
                  that increases the range of the instruction’s normal constant operand to a full 32 bits.
                      NOTE      Constant extended operands can encode symbols.
                  A constant extender is encoded as a 32-bit instruction with the 4-bit ICLASS field set to 0
                  and the 2-bit Parse field set to its usual value (Section 10.5). The remaining 26 bits in the
                  instruction word store the data bits that are prepended to an operand as small as 6 bits in
                  order to create a full 32-bit value.
                  Table 10-9 shows the encoding details.
                  Table 10-9 Constant extender encoding
                        Bits               Name                                  Description
                   31:28            ICLASS               Instruction class = 0000
                   27:16            Extender high        High 12 bits of 26-bit constant extension
                   15:14            Parse                Parse bits
                   13:0             Extender low         Low 14 bits of 26-bit constant extension
                  Within a packet, a constant extender must be positioned immediately before the
                  instruction that it extends: in terms of memory addresses, the extender word must reside at
                  address (<instr_address> - 4).
                  The constant extender effectively serves as a prefix for an instruction: it is not executed in
                  a slot, nor does it consume any slot resources. All packets must contain four or fewer
                  words, and the constant extender occupies one word.
                  If the instruction operand to be extended is longer than 6 bits, the overlapping bits in the
                  base instruction must be encoded as zeros. The value in the constant extender always
                  supplies the upper 26 bits.
                  Table 10-10 lists the instructions that work with constant extenders.
                  The Regclass field in the table lists the values that bits [27:24] must be set to in the
                  instruction word to identify the instruction as one that may include a constant extender.
                      NOTE      In cases where the base instruction encodes two constant operands, the
                                extended immediate is the one specified in the table.
                                Constant extenders appear in disassembly listings as Hexagon instructions
                                with the name immext.
80-N2040-45 Rev. B                                                                                                161
Hexagon V67 Programmer’s Reference Manual                                    Instruction Encoding
Table 10-10 Constant extender instructions
   ICLASS      Regclass                            Instructions
 LD           ---1      Rd = mem{b,ub,h,uh,w,d}(##U32)
                        if ([!]Pt[.new]) Rd = mem{b,ub,h,uh,w,d} (Rs + ##U32)
                        // predicated loads
 LD           ----      Rd  = mem{b,ub,h,uh,w,d} (Rs + ##U32)
                        Rd  = mem{b,ub,h,uh,w,d} (Re=##U32)
                        Rd  = mem{b,ub,h,uh,w,d} (Rt<<#u2 + ##U32)
                        if  ([!]Pt[.new]) Rd = mem{b,ub,h,uh,w,d} (##U32)
 ST           ---0      mem{b,h,w,d}(##U32) = Rs[.new]       // GP-stores
                        if ([!]Pt[.new]) mem{b,h,w,d}(Rs + ##U32) = Rt[.new]
                        // predicated stores
 ST           ----      mem{b,h,w,d}(Rs + ##U32) = Rt[.new]
                        mem{b,h,w,d}(Rd=##U32) = Rt[.new]
                        mem{b,h,w,d}(Ru<<#u2 + ##U32) = Rt[.new]
                        if ([!]Pt[.new]) mem{b,h,w,d}(##U32) = Rt[.new]
 MEMOP        ----      [if [!]Ps] memw(Rs + #u6) = ##U32       // constant store
                        memw(Rs + Rt<<#u2) = ##U32              // constant store
 NV           ----      if (cmp.xx(Rs.new,##U32)) jump:hint target
 ALU32        ----      Rd = ##u32
                        Rdd = combine(Rs,##u32)
                        Rdd = combine(##u32,Rs)
                        Rdd = combine(##u32,#s8)
                        Rdd = combine(#s8,##u32)
                        Rd = mux (Pu, Rs,##u32)
                        Rd = mux (Pu, ##u32, Rs)
                        Rd = mux(Pu,##u32,#s8)
                        if ([!]Pu[.new]) Rd = add(Rs,##u32)
                        if ([!]Pu[.new]) Rd = ##u32
                        Pd = [!]cmp.eq (Rs,##u32)
                        Pd = [!]cmp.gt (Rs,##u32)
                        Pd = [!]cmp.gtu (Rs,##u32)
                        Rd = [!]cmp.eq(Rs,##u32)
                        Rd = and(Rs,##u32)
                        Rd = or(Rs,##u32)
                        Rd = sub(##u32,Rs)
 ALU32        ----      Rd = add(Rs,##s32)
 XTYPE        00--      Rd  = mpyi(Rs,##u32)
                        Rd  += mpyi(Rs,##u32)
                        Rd  -= mpyi(Rs,##u32)
                        Rx  += add(Rs,##u32)
                        Rx  -= add(Rs,##u32)
 ALU32        ---- 1    Rd = ##u32
                        Rd = add(Rs,##s32)
 J            1---      jump (PC + ##s32)
                        call (PC + ##s32)
                        if ([!]Pu) call (PC + ##s32)
80-N2040-45 Rev. B                                                                            162
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Encoding
Table 10-10 Constant extender instructions (Continued)
   ICLASS       Regclass                                               Instructions
 CR            ----             Pd = spNloop0(PC+##s32,Rs/#U10)
                                loop0/1 (PC+##s32,#Rs/#U10)
 XTYPE         1---             Rd = add(pc,##s32)
                                Rd = add(##u32,mpyi(Rs,#u6))
                                Rd = add(##u32,mpyi(Rs,Rt))
                                Rd = add(Rs,add(Rt,##u32))
                                Rd = add(Rs,sub(##u32,Rt))
                                Rd = sub(##u32,add(Rs,Rt))
                                Rd = or(Rs,and(Rt,##u32))
                                Rx = add/sub/and/or (##u32,asl/asr/lsr(Rx,#U5))
                                Rx = add/sub/and/or (##u32,asl/asr/lsr(Rs,Rx))
                                Rx = add/sub/and/or (##u32,asl/asr/lsr(Rx,Rs))
                                Pd = cmpb/h.{eq,gt,gtu} (Rs,##u32)
1 Constant extension is only for a Slot 1 sub-instruction.
                        NOTE        If a constant extender is encoded in a packet for an instruction that does not
                                    accept a constant extender, the execution result is undefined. The assembler
                                    normally ensures that only valid constant extenders are generated.
                    Encoding 32-bit address operands in load/stores
                    Two methods exist for encoding a 32-bit absolute address in a load or store instruction:
                    1) For unconditional load/stores, use the GP-relative load/store instruction. The assembler
                    encodes the absolute 32-bit address as follows:
                             The upper 26 bits are encoded in a constant extender
                             The lower 6 bits are encoded in the 6 operand bits contained in the GP-relative
                              instruction
                    In this case the 32-bit value encoded must be a plain address, and the value stored in the
                    GP register is ignored.
                        NOTE        When a constant extender is explicitly specified with a GP-relative load/store,
                                    the processor ignores the value in GP and creates the effective address directly
                                    from the 32-bit constant value.
                    2) For conditional load/store instructions that have their base address encoded only by a 6-
                    bit immediate operand, a constant extender must be explicitly specified; otherwise, the
                    execution result is undefined. The assembler ensures that these instructions always include
                    a constant extender.
                    This case applies also to instructions that use the absolute-set addressing mode or
                    absolute-plus-register-offset addressing mode.
80-N2040-45 Rev. B                                                                                                 163
Hexagon V67 Programmer’s Reference Manual                                                    Instruction Encoding
                  Encoding 32-bit immediate operands
                  The immediate operands of certain instructions use scaled immediates (Section 10.8) to
                  increase their addressable range. When constant extenders are used, scaled immediates are
                  not scaled by the processor. Instead, the assembler must encode the full 32-bit unscaled
                  value as follows:
                          The upper 26 bits are encoded in the constant extender
                          The lower 6 bits are encoded in the base instruction in the least-significant bit
                           positions of the immediate operand field.
                          Any overlapping bits in the base instruction are encoded as zeros.
                  Encoding 32-bit jump/call target addresses
                  When a jump/call has a constant extender, the resulting target address is forced to a 32-bit
                  alignment (i.e., bits 1:0 in the address are cleared by hardware). The resulting jump/call
                  operation will never cause an alignment violation.
   10.10          New-value operands
                  Instructions that include a new-value register operand specify in their encodings which
                  instruction in the packet has its destination register accessed as the new-value register.
                  New-value consumers include a 3-bit instruction field named Nt which specifies this
                  information.
                          Nt[0] is reserved and should always be encoded as zero. A nonzero value
                           produces undefined results.
                          Nt[2:1] encodes the distance (in instructions) from the producer to the consumer,
                           as follows:
                              Nt[2:1] = 00            // reserved
                              Nt[2:1] = 01            // producer is +1 instruction ahead of consumer
                              Nt[2:1] = 10            // producer is +2 instructions ahead of consumer
                              Nt[2:1] = 11            // producer is +3 instructions ahead of consumer
                  “ahead” is defined here as the instruction encoded at a lower memory address than the
                  consumer instruction, not counting empty slots or constant extenders. For example, the
                  following producer/consumer relationship would be encoded with Nt[2:1] set to 01.
                       ...
                       <producer instruction word>
                       <consumer constant extender word>
                       <consumer instruction word>
                       ...
                      NOTE     Instructions with 64-bit register pair destinations cannot produce new-values.
                               The assembler flags this case with an error, as the result is undefined.
80-N2040-45 Rev. B                                                                                            164
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Encoding
   10.11          Instruction mapping
                  Some Hexagon processor instructions are encoded by the assembler as variants of other
                  instructions. This is done for operations that are functionally equivalent to other
                  instructions, but are still defined as separate instructions because of their programming
                  utility as common operations.
                  Table 10-11 lists some of the instructions that are mapped to other instructions.
                  Table 10-11 Instruction mapping
                         Instruction                          Mapping
                   Rd = not(Rs)            Rd = sub(#-1,Rs)
                   Rd = neg(Rs)            Rd = sub(#0,Rs)
                   Rdd = Rss               Rdd = combine(Rss.H32, Rss.L32)
80-N2040-45 Rev. B                                                                                             165
      11 Instruction Set
                  This chapter describes the instruction set for version 6 of the Hexagon processor.
                  The instructions are listed alphabetically within instruction categories. The following
                  information is provided for each instruction:
                       ■  Instruction name
                       ■  A brief description of the instruction
                       ■  A high-level functional description (syntax and behavior) with all possible
                          operand types
                       ■  Instruction class and slot information for grouping instructions in packets
                       ■  Notes on miscellaneous issues
                       ■  Any C intrinsic functions that provide access to the instruction
                       ■  Instruction encoding
     11.1         Instruction categories
                       ■  ALU32 — 32-bit ALU operations
                          ❒   ALU — Arithmetic and Logical
                          ❒   PERM — Permute
                          ❒   PRED — Predicate
                       ■  CR — Control registers, looping
                       ■  JR — Jump from Register
                       ■  J — Jump
                       ■  LD — Load
                       ■  MEMOP — Memory operations
                       ■  NV — New-value operations
                          ❒   J — New-value jumps
                          ❒   ST — New-value stores
                       ■  ST — Store operations
                       ■  SYSTEM
80-N2040-45 Rev. B                                                                                        166
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                          ❒    User Instructions
                        ■ XTYPE — 32-bit and 64-bit operations
                          ❒    ALU — Arithmetic and Logical
                          ❒    BIT — Bit
                          ❒    COMPLEX — Complex
                          ❒    FP — Floating point
                          ❒    MPY — Multiply
                          ❒    PERM — Permute
                          ❒    PRED — Predicate
                          ❒    SHIFT — Shift
                  Table 11-1 lists the symbols used to specify the instruction syntax.
                  Table 11-1    Instruction syntax symbols
                   Symbol           Example                         Meaning
                   =                R2 = R3;                         Assignment of RHS to LHS
                   ;                R2 = R3;                         Marks the end of an instruction or group of
                                                                     instructions
                   {...}              {R2 = R3; R5 = R6;}              Indicates a group of parallel instructions.
                   #                #100                             Immediate constant value
                   ##               ##2147483647                     32-bit immediate constant value
                   0x               R2 = #0x1fe;                     Indicates hexadecimal number
                   MEMxx            R2 = MEMxx(R3)                   Access memory. xx specifies the size and
                                                                     type of access.
                   :sat             R2 = add(r1,r2):sat              Perform optional saturation
                   :rnd             R2 = mpy(r1.h,r2.h):rnd          Perform optional rounding
                   :<<16            R2 = add(r1.l,r2.l):<<16         Shift left by a halfword
80-N2040-45 Rev. B                                                                                                167
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                  Table 11-2 lists the symbols used to specify instruction operands.
                  Table 11-2    Instruction operand symbols
                   Symbol        Example                      Meaning
                   #uN            R2 = #u16                   Unsigned N-bit immediate value
                   #sN            R2 = add(R3,#s16)           Signed N-bit immediate value
                   #mN            Rd = mpyi(Rs,#m9)           Signed N-bit immediate value
                   #uN:S          R2 = memh(#u16:1)           Unsigned N-bit immediate value representing
                                                              integral multiples of 2S in specified range
                   #sN:S          Rd = memw(Rs++#s4:2)        Signed N-bit immediate value representing
                                                              integral multiples of 2S in specified range
                   #rN:S          call #r22:2                 Same as #sN:S, but value is offset from PC of
                                                              current packet
                   ##             call ##32                   Same as #, but associated value (u,s,m,r) is 32
                                                              bits
                  When an instruction contains more than one immediate operand, the operand symbols are
                  specified in upper and lower case (e.g., #uN and #UN) to indicate where they appear in the
                  instruction encodings.
                  The instruction behavior is specified using a superset of the C language. Table 11-3 lists
                  symbols not defined in C which are used to specify the instruction behavior.
                  Table 11-3    Instruction behavior symbols
                   Symbol        Example                      Meaning
                   usat_N         usat_16(Rs)                 Saturate a value to an unsigned N-bit
                   sat_N          sat_16(Rs)                  Saturate a value to a signed N-bit number
                   sxt x->y       sxt32->64(Rs)               Sign-extend value from x to y bits
                   zxt x->y       zxt32->64(Rs)               Zero-extend value from x to y bits
                   >>>            Rss >>> offset              Logical right shift
80-N2040-45 Rev. B                                                                                                168
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
     11.1         ALU32
                  The ALU32 instruction class includes instructions which perform arithmetic and logical
                  operations on 32-bit data.
                  ALU32 instructions are executable on any slot.
    11.1.1        ALU32/ALU
                  The ALU32/ALU instruction subclass includes instructions which perform arithmetic and
                  logical operations on individual 32-bit items.
        Add
                  Add a source register either to another source register or to a signed 16-bit immediate
                  value. Store result in destination register. Source and destination registers are 32 bits. If the
                  result overflows 32 bits, it wraps around. Optionally saturate result to a signed value
                  between 0x80000000 and 0x7fffffff.
                  For 64-bit versions of this operation, see the XTYPE add instructions.
                   Syntax                                Behavior
                   Rd=add(Rs,#s16)                       apply_extension(#s);
                                                         Rd=Rs+#s;
                   Rd=add(Rs,Rt)                         Rd=Rs+Rt;
                   Rd=add(Rs,Rt):sat                     Rd=sat_32(Rs+Rt);
                  Class: ALU32 (slots 0,1,2,3)
                  Notes
                       ■   If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=add(Rs,#s16)                       Word32 Q6_R_add_RI(Word32 Rs, Word32 Is16)
                   Rd=add(Rs,Rt)                         Word32 Q6_R_add_RR(Word32 Rs, Word32 Rt)
                   Rd=add(Rs,Rt):sat                     Word32 Q6_R_add_RR_sat(Word32 Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                                               169
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                   Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7 6 5 4 3 2  1 0
   ICLASS                                s5        Parse                           d5
 1  0  1  1  i  i   i   i i    i  i s  s  s  s  s  P   P i  i   i  i i i i i i d d d  d d Rd=add(Rs,#s16)
   ICLASS   P     MajOp     MinOp        s5        Parse          t5               d5
 1  1  1  1 0  0   1   1  0   0  0  s  s  s  s  s  P   P -  t   t  t t t - - - d d d  d d Rd=add(Rs,Rt)
 1  1  1  1 0  1   1   0  0   1  0  s  s  s  s  s  P   P -  t   t  t t t - - - d d d  d d Rd=add(Rs,Rt):sat
                   Field name         Description
                   MajOp              Major Opcode
                   MinOp              Minor Opcode
                   P                  Predicated
                   ICLASS             Instruction Class
                   Parse              Packet/Loop parse bits
                   d5                 Field to encode register d
                   s5                 Field to encode register s
                   t5                 Field to encode register t
80-N2040-45 Rev. B                                                                                            170
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Logical operations
                  Perform bitwise logical operations (AND, OR, XOR, NOT) either on two source registers
                  or on a source register and a signed 10-bit immediate value. Store result in destination
                  register. Source and destination registers are 32 bits.
                  For 64-bit versions of these operations, see the XTYPE logical instructions.
                   Syntax                                   Behavior
                   Rd=and(Rs,#s10)                          apply_extension(#s);
                                                            Rd=Rs&#s;
                   Rd=and(Rs,Rt)                            Rd=Rs&Rt;
                   Rd=and(Rt,~Rs)                           Rd = (Rt & ~Rs);
                   Rd=not(Rs)                               Assembler mapped to: "Rd=sub(#-1,Rs)"
                   Rd=or(Rs,#s10)                           apply_extension(#s);
                                                            Rd=Rs|#s;
                   Rd=or(Rs,Rt)                             Rd=Rs|Rt;
                   Rd=or(Rt,~Rs)                            Rd = (Rt | ~Rs);
                   Rd=xor(Rs,Rt)                            Rd=Rs^Rt;
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rd=and(Rs,#s10)                          Word32 Q6_R_and_RI(Word32 Rs, Word32 Is10)
                   Rd=and(Rs,Rt)                            Word32 Q6_R_and_RR(Word32 Rs, Word32 Rt)
                   Rd=and(Rt,~Rs)                           Word32 Q6_R_and_RnR(Word32 Rt, Word32 Rs)
                   Rd=not(Rs)                               Word32 Q6_R_not_R(Word32 Rs)
                   Rd=or(Rs,#s10)                           Word32 Q6_R_or_RI(Word32 Rs, Word32 Is10)
                   Rd=or(Rs,Rt)                             Word32 Q6_R_or_RR(Word32 Rs, Word32 Rt)
                   Rd=or(Rt,~Rs)                            Word32 Q6_R_or_RnR(Word32 Rt, Word32 Rs)
                   Rd=xor(Rs,Rt)                            Word32 Q6_R_xor_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4 3  2 1  0
   ICLASS   Rs   MajOp    MinOp        s5       Parse                              d5
 0  1  1  1 0  1   1  0 0   0   i s  s  s  s  s P   P  i  i   i  i i i  i i  i d d  d d  d Rd=and(Rs,#s10)
 0  1  1  1 0  1   1  0 1   0   i s  s  s  s  s P   P  i  i   i  i i i  i i  i d d  d d  d Rd=or(Rs,#s10)
   ICLASS   P    MajOp    MinOp        s5       Parse           t5                 d5
80-N2040-45 Rev. B                                                                                             171
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
 1  1 1  1  0  0   0 1  0  0  0   s  s  s  s  s  P  P  -  t   t t t t - - - d d d d d Rd=and(Rs,Rt)
 1  1 1  1  0  0   0 1  0  0  1   s  s  s  s  s  P  P  -  t   t t t t - - - d d d d d Rd=or(Rs,Rt)
 1  1 1  1  0  0   0 1  0  1  1   s  s  s  s  s  P  P  -  t   t t t t - - - d d d d d Rd=xor(Rs,Rt)
 1  1 1  1  0  0   0 1  1  0  0   s  s  s  s  s  P  P  -  t   t t t t - - - d d d d d Rd=and(Rt,~Rs)
 1  1 1  1  0  0   0 1  1  0  1   s  s  s  s  s  P  P  -  t   t t t t - - - d d d d d Rd=or(Rt,~Rs)
                  Field name        Description
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Rs                No Rs read
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  P                 Predicated
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                         172
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Negate
                  Perform arithmetic negation on a source register. Store result in destination register.
                  Source and destination registers are 32 bits.
                  For 64-bit and saturating versions of this instruction, see the XTYPE-class negate
                  instructions.
                   Syntax                              Behavior
                   Rd=neg(Rs)                          Assembler mapped to: "Rd=sub(#0,Rs)"
                  Class: N/A
                  Intrinsics
                   Rd=neg(Rs)                          Word32 Q6_R_neg_R(Word32 Rs)
80-N2040-45 Rev. B                                                                                            173
Hexagon V67 Programmer’s Reference Manual                                                   Instruction Set
          Nop
                  Perform no operation. This instruction is used for padding and alignment.
                  Within a packet it can be positioned in any slot 0-3.
                   Syntax                                   Behavior
                   nop
                  Class: ALU32 (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1  0
   ICLASS   Rs   MajOp                           Parse
 0  1  1  1 1  1   1  1  -  -  -  -  -  -  -   - P   P -  -   - -  - - - - - - - -  - - nop
                  Field name        Description
                  MajOp             Major Opcode
                  Rs                No Rs read
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                      174
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Subtract
                  Subtract a source register from either another source register or from a signed 10-bit
                  immediate value. Store result in destination register. Source and destination registers are
                  32 bits. If the result underflows 32 bits, it wraps around. Optionally saturate result to a
                  signed value between 0x8000_0000 and 0x7fff_ffff.
                  For 64-bit versions of this operation, see the XTYPE subtract instructions.
                   Syntax                                   Behavior
                   Rd=sub(#s10,Rs)                          apply_extension(#s);
                                                            Rd=#s-Rs;
                   Rd=sub(Rt,Rs)                            Rd=Rt-Rs;
                   Rd=sub(Rt,Rs):sat                        Rd=sat_32(Rt - Rs);
                  Class: ALU32 (slots 0,1,2,3)
                  Notes
                        ■   If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=sub(#s10,Rs)                          Word32 Q6_R_sub_IR(Word32 Is10, Word32 Rs)
                   Rd=sub(Rt,Rs)                            Word32 Q6_R_sub_RR(Word32 Rt, Word32 Rs)
                   Rd=sub(Rt,Rs):sat                        Word32 Q6_R_sub_RR_sat(Word32 Rt, Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2  1  0
   ICLASS   Rs   MajOp     MinOp        s5        Parse                             d5
 0  1  1  1 0  1   1  0  0   1   i s  s  s  s  s  P   P i i   i  i i i  i i  i d d  d  d  d Rd=sub(#s10,Rs)
   ICLASS   P    MajOp     MinOp        s5        Parse         t5                  d5
 1  1  1  1 0  0   1  1  0   0  1  s  s  s  s  s  P   P - t   t  t t t  - -  - d d  d  d  d Rd=sub(Rt,Rs)
 1  1  1  1 0  1   1  0  1   1  0  s  s  s  s  s  P   P - t   t  t t t  - -  - d d  d  d  d Rd=sub(Rt,Rs):sat
                  Field name         Description
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  Rs                 No Rs read
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  P                  Predicated
                  ICLASS             Instruction Class
80-N2040-45 Rev. B                                                                                               175
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
80-N2040-45 Rev. B                                                    176
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Sign extend
                  Sign-extend the least-significant byte or halfword from the source register and place the
                  32-bit result in the destination register.
                                  Rd=sxth(Rs)                                  Rd=sxtb(Rs)
                                                              Rs                                         Rs
                        Sign-extend                           Rd           Sign-extend                   Rd
                   Syntax                                    Behavior
                   Rd=sxtb(Rs)                               Rd = sxt8->32(Rs);
                   Rd=sxth(Rs)                               Rd = sxt16->32(Rs);
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rd=sxtb(Rs)                               Word32 Q6_R_sxtb_R(Word32 Rs)
                   Rd=sxth(Rs)                               Word32 Q6_R_sxth_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7  6 5  4 3  2 1  0
   ICLASS   Rs   MajOp     MinOp        s5        Parse C                            d5
 0  1  1  1 0  0   0  0  1   0  1  s  s  s  s  s  P   P 0  -   - -  - -  -  - -  d d  d d  d Rd=sxtb(Rs)
 0  1  1  1 0  0   0  0  1   1  1  s  s  s  s  s  P   P 0  -   - -  - -  -  - -  d d  d d  d Rd=sxth(Rs)
                  Field name         Description
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  Rs                 No Rs read
                  C                  Conditional
                  ICLASS             Instruction Class
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  s5                 Field to encode register s
80-N2040-45 Rev. B                                                                                               177
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Transfer immediate
                  Assign an immediate value to a 32-bit destination register.
                  Two types of assignment are supported. The first sign-extends a 16-bit signed immediate
                  value to 32 bits. The second assigns a 16-bit unsigned immediate value to either the upper
                  or lower 16 bits of the destination register, leaving the other 16 bits unchanged.
                                                 Rd=#s16
                                  Sign-Extend                     16-bit immediate
                                                Rx.H=#u16
                               16-bit immediate                      Unchanged
                                                Rx.L=#u16
                                   Unchanged                      16-bit immediate
                   Syntax                                   Behavior
                   Rd=#s16                                  apply_extension(#s);
                                                            Rd=#s;
                   Rdd=#s8                                  if ("#s8<0") {
                                                                Assembler mapped to: "Rdd=combine(#-1,#s8)";
                                                            } else {
                                                                Assembler mapped to: "Rdd=combine(#0,#s8)";
                                                            }
                   Rx.[HL]=#u16                             Rx.h[01]=#u;
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rd=#s16                                  Word32 Q6_R_equals_I(Word32 Is16)
                   Rdd=#s8                                  Word64 Q6_P_equals_I(Word32 Is8)
                   Rx.H=#u16                                Word32 Q6_Rh_equals_I(Word32 Rx, Word32 Iu16)
                   Rx.L=#u16                                Word32 Q6_Rl_equals_I(Word32 Rx, Word32 Iu16)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7  6 5 4  3 2  1 0
   ICLASS   Rs   MajOp     MinOp         x5     Parse
 0  1  1  1 0  0   0  1  i   i  1   x  x x  x x P   P  i  i   i i  i  i   i i i i  i  i i i Rx.L=#u16
 0  1  1  1 0  0   1  0  i   i  1   x  x x  x x P   P  i  i   i i  i  i   i i i i  i  i i i Rx.H=#u16
   ICLASS   Rs   MajOp     MinOp                Parse                                d5
 0  1  1  1 1  0   0  0  i   i   -  i  i  i i i P   P  i  i   i i  i  i   i i i d  d d  d d Rd=#s16
80-N2040-45 Rev. B                                                                                              178
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  Rs           No Rs read
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  x5           Field to encode register x
80-N2040-45 Rev. B                                                    179
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
          Transfer register
                  Transfer a source register to a destination register. Source and destination registers are
                  either 32 bits or 64 bits.
                   Syntax                                   Behavior
                   Rd=Rs                                    Rd=Rs;
                   Rdd=Rss                                  Assembler mapped to:
                                                            "Rdd=combine(Rss.H32,Rss.L32)"
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rd=Rs                                    Word32 Q6_R_equals_R(Word32 Rs)
                   Rdd=Rss                                  Word64 Q6_P_equals_P(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS   Rs   MajOp    MinOp        s5        Parse C                           d5
 0  1  1  1 0  0   0  0 0   1  1  s  s  s  s  s  P   P 0  -   - -  - -  - -  - d d  d d  d Rd=Rs
                  Field name        Description
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Rs                No Rs read
                  C                 Conditional
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                            180
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Vector add halfwords
                  Add the two 16-bit halfwords of Rs to the two 16-bit halfwords of Rt. The results are
                  optionally saturated to signed or unsigned 16-bit values.
                   Syntax                                    Behavior
                   Rd=vaddh(Rs,Rt)[:sat]                     for (i=0;i<2;i++) {
                                                                  Rd.h[i]=[sat_16](Rs.h[i]+Rt.h[i]);
                                                             }
                   Rd=vadduh(Rs,Rt):sat                      for (i=0;i<2;i++) {
                                                                  Rd.h[i]=usat_16(Rs.uh[i]+Rt.uh[i]);
                                                             }
                  Class: ALU32 (slots 0,1,2,3)
                  Notes
                        ■   If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=vaddh(Rs,Rt)                           Word32 Q6_R_vaddh_RR(Word32 Rs, Word32 Rt)
                   Rd=vaddh(Rs,Rt):sat                       Word32 Q6_R_vaddh_RR_sat(Word32 Rs, Word32 Rt)
                   Rd=vadduh(Rs,Rt):sat                      Word32 Q6_R_vadduh_RR_sat(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6 5  4 3 2  1 0
   ICLASS   P    MajOp     MinOp        s5        Parse          t5                  d5
 1  1  1  1 0  1   1  0  0   0  0  s  s  s  s  s  P   P -  t   t  t t  t -  - - d  d d  d d Rd=vaddh(Rs,Rt)
 1  1  1  1 0  1   1  0  0   0  1  s  s  s  s  s  P   P -  t   t  t t  t -  - - d  d d  d d Rd=vaddh(Rs,Rt):sat
 1  1  1  1 0  1   1  0  0   1  1  s  s  s  s  s  P   P -  t   t  t t  t -  - - d  d d  d d Rd=vadduh(Rs,Rt):sat
                  Field name         Description
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  P                  Predicated
                  ICLASS             Instruction Class
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  s5                 Field to encode register s
                  t5                 Field to encode register t
80-N2040-45 Rev. B                                                                                               181
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Vector average halfwords
                  VAVGH adds the two 16-bit halfwords of Rs to the two 16-bit halfwords of Rd, and shifts
                  the result right by 1 bit. Optionally, a rounding constant is added before shifting.
                  VNAVGH subtracts the two 16-bit halfwords of Rt from the two 16-bit halfwords of Rs,
                  and shifts the result right by 1 bit. For vector negative average with rounding, see the
                  XTYPE VNAVGH instruction.
                   Syntax                                   Behavior
                   Rd=vavgh(Rs,Rt)                          for (i=0;i<2;i++) {
                                                                 Rd.h[i]=((Rs.h[i]+Rt.h[i])>>1);
                                                            }
                   Rd=vavgh(Rs,Rt):rnd                      for (i=0;i<2;i++) {
                                                                 Rd.h[i]=((Rs.h[i]+Rt.h[i]+1)>>1);
                                                            }
                   Rd=vnavgh(Rt,Rs)                         for (i=0;i<2;i++) {
                                                                 Rd.h[i]=((Rt.h[i]-Rs.h[i])>>1);
                                                            }
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rd=vavgh(Rs,Rt)                          Word32 Q6_R_vavgh_RR(Word32 Rs, Word32 Rt)
                   Rd=vavgh(Rs,Rt):rnd                      Word32 Q6_R_vavgh_RR_rnd(Word32 Rs, Word32 Rt)
                   Rd=vnavgh(Rt,Rs)                         Word32 Q6_R_vnavgh_RR(Word32 Rt, Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS   P    MajOp     MinOp       s5        Parse          t5                  d5
 1  1  1  1 0  1   1  1  -   0  0 s  s  s  s  s  P   P -  t   t  t t  t -  - - d  d d  d d Rd=vavgh(Rs,Rt)
 1  1  1  1 0  1   1  1  -   0  1 s  s  s  s  s  P   P -  t   t  t t  t -  - - d  d d  d d Rd=vavgh(Rs,Rt):rnd
 1  1  1  1 0  1   1  1  -   1  1 s  s  s  s  s  P   P -  t   t  t t  t -  - - d  d d  d d Rd=vnavgh(Rt,Rs)
                  Field name        Description
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  P                 Predicated
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             182
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Vector subtract halfwords
                  Subtract each of the two halfwords in 32-bit vector Rs from the corresponding halfword in
                  vector Rt. Optionally saturate each 16-bit addition to either a signed or unsigned 16-bit
                  value.
                  Applying saturation to the VSUBH instruction clamps the result to the signed range
                  0x8000 to 0x7fff, whereas applying saturation to VSUBUH ensures that the unsigned
                  result is in the range 0 to 0xffff. Use VSUBH when saturation is not needed,
                   Syntax                                   Behavior
                   Rd=vsubh(Rt,Rs)[:sat]                    for (i=0;i<2;i++) {
                                                                 Rd.h[i]=[sat_16](Rt.h[i]-Rs.h[i]);
                                                            }
                   Rd=vsubuh(Rt,Rs):sat                     for (i=0;i<2;i++) {
                                                                 Rd.h[i]=usat_16(Rt.uh[i]-Rs.uh[i]);
                                                            }
                  Class: ALU32 (slots 0,1,2,3)
                  Notes
                        ■   If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=vsubh(Rt,Rs)                          Word32 Q6_R_vsubh_RR(Word32 Rt, Word32 Rs)
                   Rd=vsubh(Rt,Rs):sat                      Word32 Q6_R_vsubh_RR_sat(Word32 Rt, Word32 Rs)
                   Rd=vsubuh(Rt,Rs):sat                     Word32 Q6_R_vsubuh_RR_sat(Word32 Rt, Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1  0
   ICLASS   P    MajOp     MinOp        s5        Parse         t5                  d5
 1  1  1  1 0  1   1  0  1   0  0  s  s  s  s  s  P   P - t   t  t t  t -  - - d  d d  d  d Rd=vsubh(Rt,Rs)
 1  1  1  1 0  1   1  0  1   0  1  s  s  s  s  s  P   P - t   t  t t  t -  - - d  d d  d  d Rd=vsubh(Rt,Rs):sat
 1  1  1  1 0  1   1  0  1   1  1  s  s  s  s  s  P   P - t   t  t t  t -  - - d  d d  d  d Rd=vsubuh(Rt,Rs):sat
                  Field name         Description
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  P                  Predicated
                  ICLASS             Instruction Class
                  Parse              Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                               183
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
80-N2040-45 Rev. B                                                    184
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Zero extend
                  Zero-extend the least significant byte or halfword from Rs and place the 32-bit result in
                  Rd.
                                 Rd=zxth(Rs)                                  Rd=zxtb(Rs)
                                                             Rs                                         Rs
                         0x0000                              Rd            0x000000                     Rd
                   Syntax                                   Behavior
                   Rd=zxtb(Rs)                              Assembler mapped to: "Rd=and(Rs,#255)"
                   Rd=zxth(Rs)                              Rd = zxt16->32(Rs);
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rd=zxtb(Rs)                              Word32 Q6_R_zxtb_R(Word32 Rs)
                   Rd=zxth(Rs)                              Word32 Q6_R_zxth_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6 5  4 3  2 1  0
   ICLASS   Rs   MajOp    MinOp        s5        Parse C                            d5
 0  1  1  1 0  0   0  0 1   1  0  s  s  s  s  s  P   P 0  -   - -  - -  -  - -  d d  d d  d Rd=zxth(Rs)
                  Field name        Description
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Rs                No Rs read
                  C                 Conditional
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                              185
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
    11.1.2        ALU32/PERM
                  The ALU32/PERM instruction subclass includes instructions which rearrange or perform
                  format conversion on vector data types.
        Combine words into doubleword
                  Combine halfwords or words into larger values.
                  In a halfword combine, either the high or low halfword of the first source register is
                  transferred to the most-significant halfword of the destination register, while either the
                  high or low halfword of the second source register is transferred to the least-significant
                  halfword of the destination register. Source and destination registers are 32 bits.
                  In a word combine, the first source register is transferred to the most-significant word of
                  the destination register, while the second source register is transferred to the least-
                  significant word of the destination register. Source registers are 32 bits and the destination
                  register is 64 bits.
                  In a variant of word combine, signed 8-bit immediate values (instead of registers) are
                  transferred to the most- and least-significant words of the 64-bit destination register.
                  Optionally one of the immediate values can be 32 bits.
                          Rd=combine(Rt.[HL],Rs.[HL])
        Rt.H               Rt.L              Rs.H              Rs.L
                                                                                        Rdd=combine(Rs,Rt)
                   Mux                                 Mux                         Rs                             Rt
                                                           Rd                                                        Rdd
                   Syntax                               Behavior
                   Rd=combine(Rt.[HL],Rs.[HL])           Rd = (Rt.uh[01]<<16) | Rs.uh[01];
                   Rdd=combine(#s8,#S8)                  apply_extension(#s);
                                                         Rdd.w[0]=#S;
                                                         Rdd.w[1]=#s;
                   Rdd=combine(#s8,#U6)                  apply_extension(#U);
                                                         Rdd.w[0]=#U;
                                                         Rdd.w[1]=#s;
                   Rdd=combine(#s8,Rs)                   apply_extension(#s);
                                                         Rdd.w[0]=Rs;
                                                         Rdd.w[1]=#s;
                   Rdd=combine(Rs,#s8)                   apply_extension(#s);
                                                         Rdd.w[0]=#s;
                                                         Rdd.w[1]=Rs;
80-N2040-45 Rev. B                                                                                              186
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Syntax                                    Behavior
                   Rdd=combine(Rs,Rt)                        Rdd.w[0]=Rt;
                                                             Rdd.w[1]=Rs;
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rd=combine(Rt.H,Rs.H)                     Word32 Q6_R_combine_RhRh(Word32 Rt, Word32 Rs)
                   Rd=combine(Rt.H,Rs.L)                     Word32 Q6_R_combine_RhRl(Word32 Rt, Word32 Rs)
                   Rd=combine(Rt.L,Rs.H)                     Word32 Q6_R_combine_RlRh(Word32 Rt, Word32 Rs)
                   Rd=combine(Rt.L,Rs.L)                     Word32 Q6_R_combine_RlRl(Word32 Rt, Word32 Rs)
                   Rdd=combine(#s8,#S8)                      Word64 Q6_P_combine_II(Word32 Is8, Word32 IS8)
                   Rdd=combine(#s8,Rs)                       Word64 Q6_P_combine_IR(Word32 Is8, Word32 Rs)
                   Rdd=combine(Rs,#s8)                       Word64 Q6_P_combine_RI(Word32 Rs, Word32 Is8)
                   Rdd=combine(Rs,Rt)                        Word64 Q6_P_combine_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3  2 1  0
   ICLASS   Rs   MajOp     MinOp        s5        Parse                             d5
 0  1  1  1 0  0   1  1  -   0  0  s  s  s  s  s  P   P 1  i   i  i i i  i i  i d d  d d  d Rdd=combine(Rs,#s8)
 0  1  1  1 0  0   1  1  -   0  1  s  s  s  s  s  P   P 1  i   i  i i i  i i  i d d  d d  d Rdd=combine(#s8,Rs)
   ICLASS   Rs   MajOp     MinOp                  Parse                             d5
 0  1  1  1 1  1   0  0 0    I   I I  I  I   I  I P   P I  i   i  i i i  i i  i d d  d d  d Rdd=combine(#s8,#S8)
 0  1  1  1 1  1   0  0 1    -   - I  I  I   I  I P   P I  i   i  i i i  i i  i d d  d d  d Rdd=combine(#s8,#U6)
   ICLASS   P    MajOp     MinOp        s5        Parse          t5                 d5
 1  1  1  1 0  0   1  1 1    0  0  s  s  s  s  s  P   P -  t   t  t t t  - -  - d d  d d  d Rd=combine(Rt.H,Rs.H)
 1  1  1  1 0  0   1  1 1    0  1  s  s  s  s  s  P   P -  t   t  t t t  - -  - d d  d d  d Rd=combine(Rt.H,Rs.L)
 1  1  1  1 0  0   1  1 1    1  0  s  s  s  s  s  P   P -  t   t  t t t  - -  - d d  d d  d Rd=combine(Rt.L,Rs.H)
 1  1  1  1 0  0   1  1 1    1  1  s  s  s  s  s  P   P -  t   t  t t t  - -  - d d  d d  d Rd=combine(Rt.L,Rs.L)
 1  1  1  1 0  1   0  1 0    -   - s  s  s  s  s  P   P -  t   t  t t t  - -  - d d  d d  d Rdd=combine(Rs,Rt)
                  Field name         Description
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  Rs                 No Rs read
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  P                  Predicated
                  ICLASS             Instruction Class
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  s5                 Field to encode register s
                  t5                 Field to encode register t
80-N2040-45 Rev. B                                                                                                187
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
          Mux
                  Select between two source registers based on the least-significant bit of a predicate
                  register. If the bit is 1, transfer the first source register to the destination register;
                  otherwise, transfer the second source register. Source and destination registers are 32 bits.
                  In a variant of mux, signed 8-bit immediate values can be used instead of registers for
                  either or both source operands.
                  For 64-bit versions of this instruction, see the XTYPE vmux instruction.
                   Syntax                                    Behavior
                   Rd=mux(Pu,#s8,#S8)                        PREDUSE_TIMING;
                                                             apply_extension(#s);
                                                             (Pu[0]) ? (Rd=#s):(Rd=#S);
                   Rd=mux(Pu,#s8,Rs)                         PREDUSE_TIMING;
                                                             apply_extension(#s);
                                                             (Pu[0]) ? (Rd=#s):(Rd=Rs);
                   Rd=mux(Pu,Rs,#s8)                         PREDUSE_TIMING;
                                                             apply_extension(#s);
                                                             (Pu[0]) ? (Rd=Rs):(Rd=#s);
                   Rd=mux(Pu,Rs,Rt)                          PREDUSE_TIMING;
                                                             (Pu[0]) ? (Rd=Rs):(Rd=Rt);
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rd=mux(Pu,#s8,#S8)                        Word32 Q6_R_mux_pII(Byte Pu, Word32 Is8, Word32
                                                             IS8)
                   Rd=mux(Pu,#s8,Rs)                         Word32 Q6_R_mux_pIR(Byte Pu, Word32 Is8, Word32
                                                             Rs)
                   Rd=mux(Pu,Rs,#s8)                         Word32 Q6_R_mux_pRI(Byte Pu, Word32 Rs, Word32
                                                             Is8)
                   Rd=mux(Pu,Rs,Rt)                          Word32 Q6_R_mux_pRR(Byte Pu, Word32 Rs, Word32
                                                             Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6    5  4 3 2  1  0
   ICLASS   Rs   MajOp         u2       s5        Parse                                 d5
 0  1  1  1 0  0   1  1   0  u   u  s s  s  s   s P   P 0  i   i  i i  i  i  i    i d d d  d  d Rd=mux(Pu,Rs,#s8)
 0  1  1  1 0  0   1  1   1  u   u  s s  s  s   s P   P 0  i   i  i i  i  i  i    i d d d  d  d Rd=mux(Pu,#s8,Rs)
   ICLASS   Rs          u1                        Parse                                 d5
 0  1  1  1 1  0   1  u   u  I    I I I  I  I   I P   P I  i   i  i i  i  i  i    i d d d  d  d Rd=mux(Pu,#s8,#S8)
   ICLASS   P    MajOp                  s5        Parse          t5            u2       d5
 1  1  1  1 0  1   0  0    - -    - s s  s  s   s P   P -  t   t  t t  t  - u    u  d d d  d  d Rd=mux(Pu,Rs,Rt)
80-N2040-45 Rev. B                                                                                                  188
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  Rs           No Rs read
                  MajOp        Major Opcode
                  P            Predicated
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  u1           Field to encode register u
                  u2           Field to encode register u
80-N2040-45 Rev. B                                                    189
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Shift word by 16
                  ASLH performs an arithmetic left shift of the 32-bit source register by 16 bits (one
                  halfword). The lower 16 bits of the destination are zero-filled.
                                                             Rs
                                            0x0000           Rd
                  ASRH performs an arithmetic right shift of the 32-bit source register by 16 bits (one
                  halfword). The upper 16 bits of the destination are sign-extended.
                                                             Rs
                        Sign-extend                          Rd
                   Syntax                                   Behavior
                   Rd=aslh(Rs)                              Rd=Rs<<16;
                   Rd=asrh(Rs)                              Rd=Rs>>16;
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rd=aslh(Rs)                              Word32 Q6_R_aslh_R(Word32 Rs)
                   Rd=asrh(Rs)                              Word32 Q6_R_asrh_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS   Rs   MajOp     MinOp       s5       Parse C                            d5
 0  1  1  1 0  0   0  0  0   0  0 s  s  s  s  s P   P 0   -   - -  - -  - -  - d d  d d  d Rd=aslh(Rs)
 0  1  1  1 0  0   0  0  0   0  1 s  s  s  s  s P   P 0   -   - -  - -  - -  - d d  d d  d Rd=asrh(Rs)
                  Field name        Description
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Rs                No Rs read
                  C                 Conditional
80-N2040-45 Rev. B                                                                                             190
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
80-N2040-45 Rev. B                                                    191
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Pack high and low halfwords
                  Pack together the most-significant halfwords from Rs and Rt into the most-significant
                  word of register pair Rdd, and the least-significant halfwords from Rs and Rt into the
                  least-significant halfword of Rdd.
                                       Rs                                        Rt
                                                                                               Rdd
                   Syntax                                   Behavior
                   Rdd=packhl(Rs,Rt)                        Rdd.h[0]=Rt.h[0];
                                                            Rdd.h[1]=Rs.h[0];
                                                            Rdd.h[2]=Rt.h[1];
                                                            Rdd.h[3]=Rs.h[1];
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rdd=packhl(Rs,Rt)                        Word64 Q6_P_packhl_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2  1 0
   ICLASS   P    MajOp    MinOp        s5        Parse          t5                  d5
 1  1  1  1 0  1   0  1 1   -   - s  s  s  s  s  P   P -  t   t  t t t  - -  - d d  d  d d Rdd=packhl(Rs,Rt)
                  Field name        Description
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  P                 Predicated
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             192
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
     11.1.3       ALU32/PRED
                  The ALU32/PRED instruction subclass includes instructions which perform conditional
                  arithmetic and logical operations based on the values stored in a predicate register, and
                  which produce predicate results. They are executable on any slot.
          Conditional add
                  If the least-significant bit of predicate Pu is set, add a 32-bit source register to either
                  another register or an immediate value. The result is placed in 32-bit destination register. If
                  the predicate is false, the instruction does nothing.
                   Syntax                                   Behavior
                   if ([!]Pu[.new]) Rd=add(Rs,#s8)          if([!]Pu[.new][0]){
                                                                 apply_extension(#s);
                                                                 Rd=Rs+#s;
                                                            } else {
                                                                 NOP;
                                                            }
                   if ([!]Pu[.new]) Rd=add(Rs,Rt)           if([!]Pu[.new][0]){
                                                                 Rd=Rs+Rt;
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: ALU32 (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7 6   5  4 3 2  1 0
                                                       D
   ICLASS   Rs   MajOp  PS     u2       s5       Parse N                              d5
 0  1  1  1 0  1   0  0  0   u   u s s  s  s  s  P   P 0  i   i  i i  i  i i    i d d d  d d if (Pu) Rd=add(Rs,#s8)
 0  1  1  1 0  1   0  0  0   u   u s s  s  s  s  P   P 1  i   i  i i  i  i i    i d d d  d d if (Pu.new) Rd=add(Rs,#s8)
 0  1  1  1 0  1   0  0  1   u   u s s  s  s  s  P   P 0  i   i  i i  i  i i    i d d d  d d if (!Pu) Rd=add(Rs,#s8)
                                                                                           d ifRd=add(Rs,#s8)
                                                                                                (!Pu.new)
 0  1  1  1 0  1   0  0  1   u   u s s  s  s  s  P   P 1  i   i  i i  i  i i    i d d d  d
   ICLASS   P    MajOp     MinOp        s5       Parse D
                                                       N        t5      PS   u2       d5
 1  1  1  1 1  0   1  1  0   -   0 s s  s  s  s  P   P 0  t   t  t t  t 0  u   u  d d d  d d if (Pu) Rd=add(Rs,Rt)
 1  1  1  1 1  0   1  1  0   -   0 s s  s  s  s  P   P 0  t   t  t t  t 1  u   u  d d d  d d if (!Pu) Rd=add(Rs,Rt)
 1  1  1  1 1  0   1  1  0   -   0 s s  s  s  s  P   P 1  t   t  t t  t 0  u   u  d d d  d d if (Pu.new) Rd=add(Rs,Rt)
 1  1  1  1 1  0   1  1  0   -   0 s s  s  s  s  P   P 1  t   t  t t  t 1  u   u  d d d  d d if (!Pu.new) Rd=add(Rs,Rt)
                  Field name         Description
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  Rs                 No Rs read
                  DN                 Dot-new
                  PS                 Predicate sense
80-N2040-45 Rev. B                                                                                                   193
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  DN           Dot-new
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  P            Predicated
                  PS           Predicate sense
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  u2           Field to encode register u
80-N2040-45 Rev. B                                                    194
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Conditional shift halfword
                  Conditionally shift a halfword.
                  ASLH performs an arithmetic left shift of the 32-bit source register by 16 bits (one
                  halfword). The lower 16 bits of the destination are zero-filled.
                                                             Rs
                                            0x0000           Rd
                  ASRH performs an arithmetic right shift of the 32-bit source register by 16 bits (one
                  halfword). The upper 16 bits of the destination are sign-extended.
                                                             Rs
                        Sign-extend                          Rd
                   Syntax                                   Behavior
                   if ([!]Pu[.new]) Rd=aslh(Rs)             if([!]Pu[.new][0]){
                                                                 Rd=Rs<<16;
                                                            } else {
                                                                 NOP;
                                                            }
                   if ([!]Pu[.new]) Rd=asrh(Rs)             if([!]Pu[.new][0]){
                                                                 Rd=Rs>>16;
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: ALU32 (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5 4 3 2  1 0
   ICLASS   Rs   MajOp     MinOp       s5       Parse C       S dn  u2             d5
 0  1  1  1 0  0   0  0  0   0  0 s  s  s  s  s P   P 1   -   0 0  u  u -  - - d d d  d d if (Pu) Rd=aslh(Rs)
 0  1  1  1 0  0   0  0  0   0  0 s  s  s  s  s P   P 1   -   0 1  u  u -  - - d d d  d d if (Pu.new) Rd=aslh(Rs)
 0  1  1  1 0  0   0  0  0   0  0 s  s  s  s  s P   P 1   -   1 0  u  u -  - - d d d  d d if (!Pu) Rd=aslh(Rs)
80-N2040-45 Rev. B                                                                                                195
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
 0  1 1  1  0  0   0 0  0  0  0   s  s  s  s  s  P  P 1   -  1 1  u u - - - d d d d d if (!Pu.new) Rd=aslh(Rs)
 0  1 1  1  0  0   0 0  0  0  1   s  s  s  s  s  P  P 1   -  0 0  u u - - - d d d d d if (Pu) Rd=asrh(Rs)
 0  1 1  1  0  0   0 0  0  0  1   s  s  s  s  s  P  P 1   -  0 1  u u - - - d d d d d if (Pu.new) Rd=asrh(Rs)
 0  1 1  1  0  0   0 0  0  0  1   s  s  s  s  s  P  P 1   -  1 0  u u - - - d d d d d if (!Pu) Rd=asrh(Rs)
 0  1 1  1  0  0   0 0  0  0  1   s  s  s  s  s  P  P 1   -  1 1  u u - - - d d d d d if (!Pu.new) Rd=asrh(Rs)
                  Field name        Description
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Rs                No Rs read
                  C                 Conditional
                  S                 Predicate sense
                  dn                Dot-new
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  u2                Field to encode register u
80-N2040-45 Rev. B                                                                                           196
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          Conditional combine
                  If the least-significant bit of predicate Pu is set, the most-significant word of destination
                  Rdd is taken from the first source register Rs, while the least-significant word is taken
                  from the second source register Rt. If the predicate is false, this instruction does nothing.
                   Syntax                                   Behavior
                   if ([!]Pu[.new])                         if ([!]Pu[.new][0]) {
                   Rdd=combine(Rs,Rt)                            Rdd.w[0]=Rt;
                                                                 Rdd.w[1]=Rs;
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: ALU32 (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7 6  5 4  3 2  1  0
                                                       D
   ICLASS   P    MajOp     MinOp       s5        Parse N        t5      PS  u2       d5
 1  1  1  1 1  1   0  1  0   0  0 s  s  s  s  s  P   P 0  t   t  t t  t 0  u  u d  d d  d  d if (Pu) Rdd=combine(Rs,Rt)
                                                                                             if (!Pu)
 1  1  1  1 1  1   0  1  0   0  0 s  s  s  s  s  P   P 0  t   t  t t  t 1  u  u d  d d  d  d Rdd=combine(Rs,Rt)
                                                                                           d ifRdd=combine(Rs,Rt)
                                                                                                (Pu.new)
 1  1  1  1 1  1   0  1  0   0  0 s  s  s  s  s  P   P 1  t   t  t t  t 0  u  u d  d d  d
                                                                                           d ifRdd=combine(Rs,Rt)
                                                                                                (!Pu.new)
 1  1  1  1 1  1   0  1  0   0  0 s  s  s  s  s  P   P 1  t   t  t t  t 1  u  u d  d d  d
                  Field name        Description
                  DN                Dot-new
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  P                 Predicated
                  PS                Predicate sense
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u2                Field to encode register u
80-N2040-45 Rev. B                                                                                                 197
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
          Conditional logical operations
                  If the least-significant bit of predicate Pu is set, do a logical operation on the source
                  values. The result is placed in 32-bit destination register. If the predicate is false, the
                  instruction does nothing.
                   Syntax                                   Behavior
                   if ([!]Pu[.new]) Rd=and(Rs,Rt)           if([!]Pu[.new][0]){
                                                                 Rd=Rs&Rt;
                                                            } else {
                                                                 NOP;
                                                            }
                   if ([!]Pu[.new]) Rd=or(Rs,Rt)            if([!]Pu[.new][0]){
                                                                 Rd=Rs|Rt;
                                                            } else {
                                                                 NOP;
                                                            }
                   if ([!]Pu[.new]) Rd=xor(Rs,Rt)           if([!]Pu[.new][0]){
                                                                 Rd=Rs^Rt;
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: ALU32 (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7 6  5 4  3  2 1  0
                                                       D
   ICLASS   P    MajOp     MinOp       s5        Parse N        t5      PS  u2       d5
 1  1  1  1 1  0   0  1  -   0  0 s  s  s  s  s  P   P 0  t   t  t t  t 0  u  u d  d  d d  d if (Pu) Rd=and(Rs,Rt)
 1  1  1  1 1  0   0  1  -   0  0 s  s  s  s  s  P   P 0  t   t  t t  t 1  u  u d  d  d d  d if (!Pu) Rd=and(Rs,Rt)
 1  1  1  1 1  0   0  1  -   0  0 s  s  s  s  s  P   P 1  t   t  t t  t 0  u  u d  d  d d  d if (Pu.new) Rd=and(Rs,Rt)
 1  1  1  1 1  0   0  1  -   0  0 s  s  s  s  s  P   P 1  t   t  t t  t 1  u  u d  d  d d  d if (!Pu.new) Rd=and(Rs,Rt)
 1  1  1  1 1  0   0  1  -   0  1 s  s  s  s  s  P   P 0  t   t  t t  t 0  u  u d  d  d d  d if (Pu) Rd=or(Rs,Rt)
 1  1  1  1 1  0   0  1  -   0  1 s  s  s  s  s  P   P 0  t   t  t t  t 1  u  u d  d  d d  d if (!Pu) Rd=or(Rs,Rt)
 1  1  1  1 1  0   0  1  -   0  1 s  s  s  s  s  P   P 1  t   t  t t  t 0  u  u d  d  d d  d if (Pu.new) Rd=or(Rs,Rt)
 1  1  1  1 1  0   0  1  -   0  1 s  s  s  s  s  P   P 1  t   t  t t  t 1  u  u d  d  d d  d if (!Pu.new) Rd=or(Rs,Rt)
 1  1  1  1 1  0   0  1  -   1  1 s  s  s  s  s  P   P 0  t   t  t t  t 0  u  u d  d  d d  d if (Pu) Rd=xor(Rs,Rt)
 1  1  1  1 1  0   0  1  -   1  1 s  s  s  s  s  P   P 0  t   t  t t  t 1  u  u d  d  d d  d if (!Pu) Rd=xor(Rs,Rt)
 1  1  1  1 1  0   0  1  -   1  1 s  s  s  s  s  P   P 1  t   t  t t  t 0  u  u d  d  d d  d if (Pu.new) Rd=xor(Rs,Rt)
 1  1  1  1 1  0   0  1  -   1  1 s  s  s  s  s  P   P 1  t   t  t t  t 1  u  u d  d  d d  d if (!Pu.new) Rd=xor(Rs,Rt)
                  Field name        Description
                  DN                Dot-new
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  P                 Predicated
                  PS                Predicate sense
                  ICLASS            Instruction Class
80-N2040-45 Rev. B                                                                                                  198
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  u2           Field to encode register u
80-N2040-45 Rev. B                                                    199
Hexagon V67 Programmer’s Reference Manual                                                                Instruction Set
          Conditional subtract
                  If the least-significant bit of predicate Pu is set, subtract a 32-bit source register Rt from
                  register Rs. The result is placed in a 32-bit destination register. If the predicate is false, the
                  instruction does nothing.
                   Syntax                                   Behavior
                   if ([!]Pu[.new]) Rd=sub(Rt,Rs)           if([!]Pu[.new][0]){
                                                                 Rd=Rt-Rs;
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: ALU32 (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7 6  5 4  3  2  1  0
   ICLASS   P    MajOp     MinOp       s5        Parse D        t5      PS  u2       d5
                                                       N
 1  1  1  1 1  0   1  1  0   -  1 s  s  s  s  s  P   P 0  t   t  t t  t 0  u  u d  d  d  d  d if (Pu) Rd=sub(Rt,Rs)
 1  1  1  1 1  0   1  1  0   -  1 s  s  s  s  s  P   P 0  t   t  t t  t 1  u  u d  d  d  d  d if (!Pu) Rd=sub(Rt,Rs)
 1  1  1  1 1  0   1  1  0   -  1 s  s  s  s  s  P   P 1  t   t  t t  t 0  u  u d  d  d  d  d if (Pu.new) Rd=sub(Rt,Rs)
 1  1  1  1 1  0   1  1  0   -  1 s  s  s  s  s  P   P 1  t   t  t t  t 1  u  u d  d  d  d  d if (!Pu.new) Rd=sub(Rt,Rs)
                  Field name        Description
                  DN                Dot-new
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  P                 Predicated
                  PS                Predicate sense
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u2                Field to encode register u
80-N2040-45 Rev. B                                                                                                   200
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
          Conditional sign extend
                  Conditionally sign-extend the least-significant byte or halfword from Rs and put the 32-bit
                  result in Rd.
                                  Rd=sxth(Rs)                                  Rd=sxtb(Rs)
                                                             Rs                                             Rs
                        Sign-extend                          Rd            Sign-extend                     Rd
                   Syntax                                   Behavior
                   if ([!]Pu[.new]) Rd=sxtb(Rs)             if([!]Pu[.new][0]){
                                                                 Rd=sxt8->32(Rs);
                                                            } else {
                                                                 NOP;
                                                            }
                   if ([!]Pu[.new]) Rd=sxth(Rs)             if([!]Pu[.new][0]){
                                                                 Rd=sxt16->32(Rs);
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: ALU32 (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6  5  4 3  2 1  0
   ICLASS   Rs   MajOp     MinOp        s5        Parse C     S dn  u2               d5
 0  1  1  1 0  0   0  0  1   0  1  s  s  s  s  s  P   P 1 -   0 0  u  u  -  - -  d d  d d  d if (Pu) Rd=sxtb(Rs)
 0  1  1  1 0  0   0  0  1   0  1  s  s  s  s  s  P   P 1 -   0 1  u  u  -  - -  d d  d d  d if (Pu.new) Rd=sxtb(Rs)
 0  1  1  1 0  0   0  0  1   0  1  s  s  s  s  s  P   P 1 -   1 0  u  u  -  - -  d d  d d  d if (!Pu) Rd=sxtb(Rs)
 0  1  1  1 0  0   0  0  1   0  1  s  s  s  s  s  P   P 1 -   1 1  u  u  -  - -  d d  d d  d if (!Pu.new) Rd=sxtb(Rs)
 0  1  1  1 0  0   0  0  1   1  1  s  s  s  s  s  P   P 1 -   0 0  u  u  -  - -  d d  d d  d if (Pu) Rd=sxth(Rs)
 0  1  1  1 0  0   0  0  1   1  1  s  s  s  s  s  P   P 1 -   0 1  u  u  -  - -  d d  d d  d if (Pu.new) Rd=sxth(Rs)
 0  1  1  1 0  0   0  0  1   1  1  s  s  s  s  s  P   P 1 -   1 0  u  u  -  - -  d d  d d  d if (!Pu) Rd=sxth(Rs)
 0  1  1  1 0  0   0  0  1   1  1  s  s  s  s  s  P   P 1 -   1 1  u  u  -  - -  d d  d d  d if (!Pu.new) Rd=sxth(Rs)
                  Field name         Description
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  Rs                 No Rs read
                  C                  Conditional
                  S                  Predicate sense
                  dn                 Dot-new
                  ICLASS             Instruction Class
80-N2040-45 Rev. B                                                                                                   201
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  u2           Field to encode register u
80-N2040-45 Rev. B                                                    202
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          Conditional transfer
                  If the LSB of predicate Pu is set, transfer register Rs or a signed immediate into
                  destination Rd. If the predicate is false, this instruction does nothing.
                   Syntax                                   Behavior
                   if ([!]Pu[.new]) Rd=#s12                 apply_extension(#s);
                                                            if ([!]Pu[.new][0]) Rd=#s;
                                                            else NOP;
                   if ([!]Pu[.new]) Rd=Rs                   Assembler mapped to: "if ([!]Pu[.new])
                                                            Rd=add(Rs,#0)"
                   if ([!]Pu[.new]) Rdd=Rss                 Assembler mapped to: "if ([!]Pu[.new])
                                                            Rdd=combine(Rss.H32,Rss.L32)"
                  Class: ALU32 (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4  3 2  1  0
                                                       D
   ICLASS   Rs   MajOp  PS   u2                  Parse N                            d5
 0  1  1  1 1  1   1  0  0  u  u 0   i  i   i  i P   P 0  i   i i  i i  i i  i d  d d  d  d if (Pu) Rd=#s12
 0  1  1  1 1  1   1  0  0  u  u 0   i  i   i  i P   P 1  i   i i  i i  i i  i d  d d  d  d if (Pu.new) Rd=#s12
 0  1  1  1 1  1   1  0  1  u  u 0   i  i   i  i P   P 0  i   i i  i i  i i  i d  d d  d  d if (!Pu) Rd=#s12
 0  1  1  1 1  1   1  0  1  u  u 0   i  i   i  i P   P 1  i   i i  i i  i i  i d  d d  d  d if (!Pu.new) Rd=#s12
                  Field name        Description
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Rs                No Rs read
                  DN                Dot-new
                  PS                Predicate sense
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u2                Field to encode register u
80-N2040-45 Rev. B                                                                                                 203
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
          Conditional zero extend
                  Conditionally zero-extend the least-significant byte or halfword from Rs and put the 32-bit
                  result in Rd.
                                 Rd=zxth(Rs)                                   Rd=zxtb(Rs)
                                                             Rs                                             Rs
                         0x0000                              Rd             0x000000                       Rd
                   Syntax                                   Behavior
                   if ([!]Pu[.new]) Rd=zxtb(Rs)             if([!]Pu[.new][0]){
                                                                 Rd=zxt8->32(Rs);
                                                            } else {
                                                                 NOP;
                                                            }
                   if ([!]Pu[.new]) Rd=zxth(Rs)             if([!]Pu[.new][0]){
                                                                 Rd=zxt16->32(Rs);
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: ALU32 (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6  5  4 3  2 1  0
   ICLASS   Rs   MajOp    MinOp        s5        Parse C      S dn  u2               d5
 0  1  1  1 0  0   0  0 1   0  0  s  s  s  s  s  P   P 1  -   0 0  u  u  -  - -  d d  d d  d if (Pu) Rd=zxtb(Rs)
 0  1  1  1 0  0   0  0 1   0  0  s  s  s  s  s  P   P 1  -   0 1  u  u  -  - -  d d  d d  d if (Pu.new) Rd=zxtb(Rs)
 0  1  1  1 0  0   0  0 1   0  0  s  s  s  s  s  P   P 1  -   1 0  u  u  -  - -  d d  d d  d if (!Pu) Rd=zxtb(Rs)
 0  1  1  1 0  0   0  0 1   0  0  s  s  s  s  s  P   P 1  -   1 1  u  u  -  - -  d d  d d  d if (!Pu.new) Rd=zxtb(Rs)
 0  1  1  1 0  0   0  0 1   1  0  s  s  s  s  s  P   P 1  -   0 0  u  u  -  - -  d d  d d  d if (Pu) Rd=zxth(Rs)
 0  1  1  1 0  0   0  0 1   1  0  s  s  s  s  s  P   P 1  -   0 1  u  u  -  - -  d d  d d  d if (Pu.new) Rd=zxth(Rs)
 0  1  1  1 0  0   0  0 1   1  0  s  s  s  s  s  P   P 1  -   1 0  u  u  -  - -  d d  d d  d if (!Pu) Rd=zxth(Rs)
 0  1  1  1 0  0   0  0 1   1  0  s  s  s  s  s  P   P 1  -   1 1  u  u  -  - -  d d  d d  d if (!Pu.new) Rd=zxth(Rs)
                  Field name        Description
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Rs                No Rs read
                  C                 Conditional
                  S                 Predicate sense
                  dn                Dot-new
                  ICLASS            Instruction Class
80-N2040-45 Rev. B                                                                                                   204
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  u2           Field to encode register u
80-N2040-45 Rev. B                                                    205
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Compare
                  The register form compares two 32-bit registers for unsigned greater than, greater than, or
                  equal.
                  The immediate form compares a register against a signed or unsigned immediate value.
                  The 8-bit predicate register Pd is set to all 1's or all 0's depending on the result. For 64-bit
                  versions of this instruction, see the XTYPE compare instructions.
                   Syntax                                Behavior
                   Pd=[!]cmp.eq(Rs,#s10)                 apply_extension(#s);
                                                         Pd=Rs[!]=#s ? 0xff : 0x00;
                   Pd=[!]cmp.eq(Rs,Rt)                   Pd=Rs[!]=Rt ? 0xff : 0x00;
                   Pd=[!]cmp.gt(Rs,#s10)                 apply_extension(#s);
                                                         Pd=Rs<=#s ? 0xff : 0x00;
                   Pd=[!]cmp.gt(Rs,Rt)                   Pd=Rs<=Rt ? 0xff : 0x00;
                   Pd=[!]cmp.gtu(Rs,#u9)                 apply_extension(#u);
                                                         Pd=Rs.uw[0]<=#u.uw[0] ? 0xff : 0x00;
                   Pd=[!]cmp.gtu(Rs,Rt)                  Pd=Rs.uw[0]<=Rt.uw[0] ? 0xff : 0x00;
                   Pd=cmp.ge(Rs,#s8)                     Assembler mapped to: "Pd=cmp.gt(Rs,#s8-1)"
                   Pd=cmp.geu(Rs,#u8)                    if ("#u8==0") {
                                                              Assembler mapped to: "Pd=cmp.eq(Rs,Rs)";
                                                         } else {
                                                              Assembler mapped to: "Pd=cmp.gtu(Rs,#u8-1)";
                                                         }
                   Pd=cmp.lt(Rs,Rt)                      Assembler mapped to: "Pd=cmp.gt(Rt,Rs)"
                   Pd=cmp.ltu(Rs,Rt)                     Assembler mapped to: "Pd=cmp.gtu(Rt,Rs)"
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Pd=!cmp.eq(Rs,#s10)                   Byte Q6_p_not_cmp_eq_RI(Word32 Rs, Word32 Is10)
                   Pd=!cmp.eq(Rs,Rt)                     Byte Q6_p_not_cmp_eq_RR(Word32 Rs, Word32 Rt)
                   Pd=!cmp.gt(Rs,#s10)                   Byte Q6_p_not_cmp_gt_RI(Word32 Rs, Word32 Is10)
                   Pd=!cmp.gt(Rs,Rt)                     Byte Q6_p_not_cmp_gt_RR(Word32 Rs, Word32 Rt)
                   Pd=!cmp.gtu(Rs,#u9)                   Byte Q6_p_not_cmp_gtu_RI(Word32 Rs, Word32 Iu9)
                   Pd=!cmp.gtu(Rs,Rt)                    Byte Q6_p_not_cmp_gtu_RR(Word32 Rs, Word32 Rt)
                   Pd=cmp.eq(Rs,#s10)                    Byte Q6_p_cmp_eq_RI(Word32 Rs, Word32 Is10)
                   Pd=cmp.eq(Rs,Rt)                      Byte Q6_p_cmp_eq_RR(Word32 Rs, Word32 Rt)
                   Pd=cmp.ge(Rs,#s8)                     Byte Q6_p_cmp_ge_RI(Word32 Rs, Word32 Is8)
                   Pd=cmp.geu(Rs,#u8)                    Byte Q6_p_cmp_geu_RI(Word32 Rs, Word32 Iu8)
                   Pd=cmp.gt(Rs,#s10)                    Byte Q6_p_cmp_gt_RI(Word32 Rs, Word32 Is10)
80-N2040-45 Rev. B                                                                                              206
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                   Pd=cmp.gt(Rs,Rt)                          Byte Q6_p_cmp_gt_RR(Word32 Rs, Word32 Rt)
                   Pd=cmp.gtu(Rs,#u9)                        Byte Q6_p_cmp_gtu_RI(Word32 Rs, Word32 Iu9)
                   Pd=cmp.gtu(Rs,Rt)                         Byte Q6_p_cmp_gtu_RR(Word32 Rs, Word32 Rt)
                   Pd=cmp.lt(Rs,Rt)                          Byte Q6_p_cmp_lt_RR(Word32 Rs, Word32 Rt)
                   Pd=cmp.ltu(Rs,Rt)                         Byte Q6_p_cmp_ltu_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3  2 1   0
   ICLASS   Rs   MajOp     MinOp        s5        Parse                                  d2
 0  1  1  1 0  1   0  1 0    0   i s  s  s  s  s  P   P i  i   i  i i i  i i  i 0 0  0 d   d Pd=cmp.eq(Rs,#s10)
 0  1  1  1 0  1   0  1 0    0   i s  s  s  s  s  P   P i  i   i  i i i  i i  i 1 0  0 d   d Pd=!cmp.eq(Rs,#s10)
 0  1  1  1 0  1   0  1 0    1   i s  s  s  s  s  P   P i  i   i  i i i  i i  i 0 0  0 d   d Pd=cmp.gt(Rs,#s10)
 0  1  1  1 0  1   0  1 0    1   i s  s  s  s  s  P   P i  i   i  i i i  i i  i 1 0  0 d   d Pd=!cmp.gt(Rs,#s10)
 0  1  1  1 0  1   0  1 1    0  0  s  s  s  s  s  P   P i  i   i  i i i  i i  i 0 0  0 d   d Pd=cmp.gtu(Rs,#u9)
 0  1  1  1 0  1   0  1 1    0  0  s  s  s  s  s  P   P i  i   i  i i i  i i  i 1 0  0 d   d Pd=!cmp.gtu(Rs,#u9)
   ICLASS   P    MajOp     MinOp        s5        Parse          t5                      d2
 1  1  1  1 0  0   1  0  -   0  0  s  s  s  s  s  P   P -  t   t  t t t  - -  - 0 0  0 d   d Pd=cmp.eq(Rs,Rt)
 1  1  1  1 0  0   1  0  -   0  0  s  s  s  s  s  P   P -  t   t  t t t  - -  - 1 0  0 d   d Pd=!cmp.eq(Rs,Rt)
 1  1  1  1 0  0   1  0  -   1  0  s  s  s  s  s  P   P -  t   t  t t t  - -  - 0 0  0 d   d Pd=cmp.gt(Rs,Rt)
 1  1  1  1 0  0   1  0  -   1  0  s  s  s  s  s  P   P -  t   t  t t t  - -  - 1 0  0 d   d Pd=!cmp.gt(Rs,Rt)
 1  1  1  1 0  0   1  0  -   1  1  s  s  s  s  s  P   P -  t   t  t t t  - -  - 0 0  0 d   d Pd=cmp.gtu(Rs,Rt)
 1  1  1  1 0  0   1  0  -   1  1  s  s  s  s  s  P   P -  t   t  t t t  - -  - 1 0  0 d   d Pd=!cmp.gtu(Rs,Rt)
                  Field name         Description
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  Rs                 No Rs read
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  P                  Predicated
                  ICLASS             Instruction Class
                  Parse              Packet/Loop parse bits
                  d2                 Field to encode register d
                  s5                 Field to encode register s
                  t5                 Field to encode register t
80-N2040-45 Rev. B                                                                                               207
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Compare to general register
                  The register form compares two 32-bit registers for unsigned greater than, greater than, or
                  equal. The immediate form compares a register against a signed or unsigned immediate
                  value. The resulting zero or one is placed in a general register.
                   Syntax                                   Behavior
                   Rd=[!]cmp.eq(Rs,#s8)                     apply_extension(#s);
                                                            Rd=(Rs[!]=#s);
                   Rd=[!]cmp.eq(Rs,Rt)                      Rd=(Rs[!]=Rt);
                  Class: ALU32 (slots 0,1,2,3)
                  Intrinsics
                   Rd=!cmp.eq(Rs,#s8)                       Word32 Q6_R_not_cmp_eq_RI(Word32 Rs, Word32 Is8)
                   Rd=!cmp.eq(Rs,Rt)                        Word32 Q6_R_not_cmp_eq_RR(Word32 Rs, Word32 Rt)
                   Rd=cmp.eq(Rs,#s8)                        Word32 Q6_R_cmp_eq_RI(Word32 Rs, Word32 Is8)
                   Rd=cmp.eq(Rs,Rt)                         Word32 Q6_R_cmp_eq_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS   Rs   MajOp     MinOp       s5        Parse                             d5
 0  1  1  1 0  0   1  1  -   1  0 s  s  s  s  s  P   P 1  i   i  i i i  i i  i d d  d d  d Rd=cmp.eq(Rs,#s8)
 0  1  1  1 0  0   1  1  -   1  1 s  s  s  s  s  P   P 1  i   i  i i i  i i  i d d  d d  d Rd=!cmp.eq(Rs,#s8)
   ICLASS   P    MajOp     MinOp       s5        Parse          t5                 d5
 1  1  1  1 0  0   1  1 0    1  0 s  s  s  s  s  P   P -  t   t  t t t  - -  - d d  d d  d Rd=cmp.eq(Rs,Rt)
 1  1  1  1 0  0   1  1 0    1  1 s  s  s  s  s  P   P -  t   t  t t t  - -  - d d  d d  d Rd=!cmp.eq(Rs,Rt)
                  Field name        Description
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Rs                No Rs read
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  P                 Predicated
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             208
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
     11.2         CR
                  The CR instruction class includes instructions which manage control registers, including
                  hardware looping, modulo addressing, and status flags.
                  CR instructions are executable on slot 3.
        End loop instructions
                  The endloop instructions mark the end of a hardware loop. If the Loop Count (LC) register
                  indicates that a loop should continue to iterate, the LC register is decremented and the
                  program flow changes to the address in the Start Address (SA) register.
                  The endloopN instruction is actually a pseudo-instruction encoded in bits 15:14 of each
                  instruction. Therefore, no distinct 32-bit encoding exists for this instruction.
                   Syntax                               Behavior
                   endloop0                             if (USR.LPCFG) {
                                                             if (USR.LPCFG==1) {
                                                                 P3=0xff;
                                                             }
                                                             USR.LPCFG=USR.LPCFG-1;
                                                        }
                                                        if (LC0>1) {
                                                             PC=SA0;
                                                             LC0=LC0-1;
                                                        }
                   endloop01                            if (USR.LPCFG) {
                                                             if (USR.LPCFG==1) {
                                                                 P3=0xff;
                                                             }
                                                             USR.LPCFG=USR.LPCFG-1;
                                                        }
                                                        if (LC0>1) {
                                                             PC=SA0;
                                                             LC0=LC0-1;
                                                        } else {
                                                             if (LC1>1) {
                                                                 PC=SA1;
                                                                 LC1=LC1-1;
                                                             }
                                                        }
                   endloop1                             if (LC1>1) {
                                                             PC=SA1;
                                                             LC1=LC1-1;
                                                        }
                  Class: N/A
                  Notes
                       ■   This instruction cannot be grouped in a packet with any program flow
                           instructions.
80-N2040-45 Rev. B                                                                                             209
Hexagon V67 Programmer’s Reference Manual                                                   Instruction Set
                   ■   The Next PC value is the address immediately following the last instruction in the
                       packet containing this instruction.
                   ■   The PC value is the address of the start of the packet
80-N2040-45 Rev. B                                                                                      210
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Corner detection acceleration
                  The FASTCORNER9 instruction takes the Ps and Pt values and treats them as a circular
                  bit string. If any contiguous nine bits are set around the circle, the result is true, false
                  otherwise. The sense may be optionally inverted. This instruction accelerates FAST corner
                  detection.
                   Syntax                                   Behavior
                   Pd=[!]fastcorner9(Ps,Pt)                 PREDUSE_TIMING;
                                                            tmp.h[0]=(Ps<<8)|Pt;
                                                            tmp.h[1]=(Ps<<8)|Pt;
                                                            for (i = 1; i < 9; i++) {
                                                                tmp &= tmp >> 1;
                                                            }
                                                            Pd = tmp == 0 ? 0xff : 0x00;
                  Class: CR (slot 2,3)
                  Notes
                        ■  This instruction may execute on either slot2 or slot3, even though it is a CR-type
                  Intrinsics
                   Pd=!fastcorner9(Ps,Pt)                   Byte Q6_p_not_fastcorner9_pp(Byte Ps, Byte Pt)
                   Pd=fastcorner9(Ps,Pt)                    Byte Q6_p_fastcorner9_pp(Byte Ps, Byte Pt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8 7 6 5 4 3 2  1   0
   ICLASS      sm                            s2   Parse              t2                  d2
 0  1  1  0 1  0   1  1  0  0  0  0  -  -  s    s P   P 1 -   - -  t    t 1 - - 1 -  - d   d Pd=fastcorner9(Ps,Pt)
 0  1  1  0 1  0   1  1  0  0  0  1  -  -  s    s P   P 1 -   - -  t    t 1 - - 1 -  - d   d Pd=!fastcorner9(Ps,Pt)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s2                Field to encode register s
                  t2                Field to encode register t
80-N2040-45 Rev. B                                                                                                  211
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Logical reductions on predicates
                  The ANY8 instruction sets a destination predicate register to 0xff if any of the low 8 bits
                  in source predicate register Ps are set. Otherwise, the predicate is set to 0x00.
                  The ALL8 instruction sets a destination predicate register to 0xff if all of the low 8 bits in
                  the source predicate register Ps are set. Otherwise, the predicate is set to 0x00.
                   Syntax                                   Behavior
                   Pd=all8(Ps)                              PREDUSE_TIMING;
                                                            (Ps==0xff) ? (Pd=0xff) : (Pd=0x00);
                   Pd=any8(Ps)                              PREDUSE_TIMING;
                                                            Ps ? (Pd=0xff) : (Pd=0x00);
                  Class: CR (slot 2,3)
                  Notes
                        ■  This instruction may execute on either slot2 or slot3, even though it is a CR-type
                  Intrinsics
                   Pd=all8(Ps)                              Byte Q6_p_all8_p(Byte Ps)
                   Pd=any8(Ps)                              Byte Q6_p_any8_p(Byte Ps)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1   0
   ICLASS      sm                            s2   Parse                                 d2
 0  1  1  0 1  0   1  1  1 0  0  0   -  -  s    s P   P 0 -   - -  - -  - -  - - -  - d   d Pd=any8(Ps)
 0  1  1  0 1  0   1  1  1 0  1  0   -  -  s    s P   P 0 -   - -  - -  - -  - - -  - d   d Pd=all8(Ps)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s2                Field to encode register s
80-N2040-45 Rev. B                                                                                               212
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Looping instructions
                  loopN is a single instruction which sets up a hardware loop. The N in the instruction name
                  indicates the set of loop registers to use. Loop0 is the innermost loop, while loop1 is the
                  outer loop.The loopN instruction first sets the Start Address (SA) register based on a PC-
                  relative immediate add. The relative immediate is added to the PC and stored in SA. The
                  Loop Count (LC) register is set to either an unsigned immediate or to a register value.
                   Syntax                                   Behavior
                   loop0(#r7:2,#U10)                        apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            SA0=PC+#r;
                                                            LC0=#U;
                                                            USR.LPCFG=0;
                   loop0(#r7:2,Rs)                          apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            SA0=PC+#r;
                                                            LC0=Rs;
                                                            USR.LPCFG=0;
                   loop1(#r7:2,#U10)                        apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            SA1=PC+#r;
                                                            LC1=#U;
                   loop1(#r7:2,Rs)                          apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            SA1=PC+#r;
                                                            LC1=Rs;
                  Class: CR (slot 3)
                  Notes
                        ■  This instruction cannot execute in the last address of a hardware loop.
                        ■  The Next PC value is the address immediately following the last instruction in the
                           packet containing this instruction.
                        ■  The PC value is the address of the start of the packet
                        ■  A PC-relative address is formed by taking the decoded immediate value and
                           adding it to the current PC value.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS      sm                      s5       Parse
 0  1  1  0 0  0   0 0   0 0  0   s  s  s  s  s P   P  -  i   i i  i i -  - -  i i -  - -  loop0(#r7:2,Rs)
 0  1  1  0 0  0   0 0   0 0  1   s  s  s  s  s P   P  -  i   i i  i i -  - -  i i -  - -  loop1(#r7:2,Rs)
   ICLASS      sm                               Parse
 0  1  1  0 1  0   0 1   0 0  0   I  I  I  I  I P   P  -  i   i i  i i I  I I  i i -  I I  loop0(#r7:2,#U10)
 0  1  1  0 1  0   0 1   0 0  1   I  I  I  I  I P   P  -  i   i i  i i I  I I  i i -  I I  loop1(#r7:2,#U10)
80-N2040-45 Rev. B                                                                                              213
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  sm           Supervisor mode only
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  s5           Field to encode register s
80-N2040-45 Rev. B                                                    214
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Add to PC
                  Add an immediate value to the Program Counter (PC) and place the result in a destination
                  register. This instruction is typically used with a constant extender to add a 32-bit
                  immediate value to PC.
                   Syntax                                   Behavior
                   Rd=add(pc,#u6)                           Rd=PC+apply_extension(#u);
                  Class: CR (slot 3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1  0
   ICLASS      sm                                Parse                             d5
 0  1  1  0 1  0   1 0  0   1 0  0   1  0  0  1  P   P -  i   i i  i i i  - -  d d d  d  d Rd=add(pc,#u6)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
80-N2040-45 Rev. B                                                                                             215
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
        Pipelined loop instructions
                  spNloop0 is a single instruction which sets up a hardware loop with automatic predicate
                  control. This features saves code size by enabling many software pipelined loops to be
                  generated without prologue code. Upon executing this instruction, the P3 register is
                  automatically cleared. After the loop has executed N times (where N is selectable from 1-
                  3), the P3 register is set. The intent is that store instructions in the loop are predicated with
                  P3 and thus not enabled during the pipeline warm-up.
                  In the spNloop0 instruction the loop 0 (inner-loop) registers are used. This instruction sets
                  the Start Address (SA0) register based on a PC-relative immediate add. The relative
                  immediate is added to the PC and stored in SA0. The Loop Count (LC0) is set to either an
                  unsigned immediate or to a register value. The predicate P3 is cleared. The USR.LPCFG
                  bits are set based on the N value.
                   Syntax                                 Behavior
                   p3=sp1loop0(#r7:2,#U10)                 apply_extension(#r);
                                                           #r=#r & ~PCALIGN_MASK;
                                                           SA0=PC+#r;
                                                           LC0=#U;
                                                           USR.LPCFG=1;
                                                           P3=0;
                   p3=sp1loop0(#r7:2,Rs)                   apply_extension(#r);
                                                           #r=#r & ~PCALIGN_MASK;
                                                           SA0=PC+#r;
                                                           LC0=Rs;
                                                           USR.LPCFG=1;
                                                           P3=0;
                   p3=sp2loop0(#r7:2,#U10)                 apply_extension(#r);
                                                           #r=#r & ~PCALIGN_MASK;
                                                           SA0=PC+#r;
                                                           LC0=#U;
                                                           USR.LPCFG=2;
                                                           P3=0;
                   p3=sp2loop0(#r7:2,Rs)                   apply_extension(#r);
                                                           #r=#r & ~PCALIGN_MASK;
                                                           SA0=PC+#r;
                                                           LC0=Rs;
                                                           USR.LPCFG=2;
                                                           P3=0;
                   p3=sp3loop0(#r7:2,#U10)                 apply_extension(#r);
                                                           #r=#r & ~PCALIGN_MASK;
                                                           SA0=PC+#r;
                                                           LC0=#U;
                                                           USR.LPCFG=3;
                                                           P3=0;
                   p3=sp3loop0(#r7:2,Rs)                   apply_extension(#r);
                                                           #r=#r & ~PCALIGN_MASK;
                                                           SA0=PC+#r;
                                                           LC0=Rs;
                                                           USR.LPCFG=3;
                                                           P3=0;
80-N2040-45 Rev. B                                                                                                 216
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Class: CR (slot 3)
                  Notes
                       ■   The predicate generated by this instruction cannot be used as a .new predicate, nor
                           can it be automatically AND’d with another predicate.
                       ■   This instruction cannot execute in the last address of a hardware loop.
                       ■   The Next PC value is the address immediately following the last instruction in the
                           packet containing this instruction.
                       ■   The PC value is the address of the start of the packet
                       ■   A PC-relative address is formed by taking the decoded immediate value and
                           adding it to the current PC value.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6  5 4  3  2  1 0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  0   0 0  1  0  1   s  s  s  s  s  P   P -  i  i  i i i - -  -  i i  -  - - p3=sp1loop0(#r7:2,Rs)
 0  1  1  0 0  0   0 0  1  1  0   s  s  s  s  s  P   P -  i  i  i i i - -  -  i i  -  - - p3=sp2loop0(#r7:2,Rs)
 0  1  1  0 0  0   0 0  1  1  1   s  s  s  s  s  P   P -  i  i  i i i - -  -  i i  -  - - p3=sp3loop0(#r7:2,Rs)
   ICLASS      sm                                Parse
 0  1  1  0 1  0   0 1  1  0  1   I  I  I   I  I P   P -  i  i  i i i I I  I  i i  -  I I p3=sp1loop0(#r7:2,#U10)
 0  1  1  0 1  0   0 1  1  1  0   I  I  I   I  I P   P -  i  i  i i i I I  I  i i  -  I I p3=sp2loop0(#r7:2,#U10)
 0  1  1  0 1  0   0 1  1  1  1   I  I  I   I  I P   P -  i  i  i i i I I  I  i i  -  I I p3=sp3loop0(#r7:2,#U10)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                              217
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Logical operations on predicates
                  Perform bitwise logical operations on predicate registers.
                   Syntax                             Behavior
                   Pd=Ps                              Assembler mapped to: "Pd=or(Ps,Ps)"
                   Pd=and(Ps,and(Pt,[!]Pu))           PREDUSE_TIMING;
                                                      Pd = Ps & Pt & (~Pu);
                   Pd=and(Ps,or(Pt,[!]Pu))            PREDUSE_TIMING;
                                                      Pd = Ps & (Pt | (~Pu));
                   Pd=and(Pt,[!]Ps)                   PREDUSE_TIMING;
                                                      Pd=Pt & (~Ps);
                   Pd=not(Ps)                         PREDUSE_TIMING;
                                                      Pd=~Ps;
                   Pd=or(Ps,and(Pt,[!]Pu))            PREDUSE_TIMING;
                                                      Pd = Ps | (Pt & (~Pu));
                   Pd=or(Ps,or(Pt,[!]Pu))             PREDUSE_TIMING;
                                                      Pd = Ps | Pt | (~Pu);
                   Pd=or(Pt,[!]Ps)                    PREDUSE_TIMING;
                                                      Pd=Pt | (~Ps);
                   Pd=xor(Ps,Pt)                      PREDUSE_TIMING;
                                                      Pd=Ps ^ Pt;
                  Class: CR (slot 2,3)
                  Notes
                       ■  This instruction may execute on either slot2 or slot3, even though it is a CR-type
                  Intrinsics
                   Pd=Ps                              Byte Q6_p_equals_p(Byte Ps)
                   Pd=and(Ps,and(Pt,!Pu))             Byte Q6_p_and_and_ppnp(Byte Ps, Byte Pt, Byte Pu)
                   Pd=and(Ps,and(Pt,Pu))              Byte Q6_p_and_and_ppp(Byte Ps, Byte Pt, Byte Pu)
                   Pd=and(Ps,or(Pt,!Pu))              Byte Q6_p_and_or_ppnp(Byte Ps, Byte Pt, Byte Pu)
                   Pd=and(Ps,or(Pt,Pu))               Byte Q6_p_and_or_ppp(Byte Ps, Byte Pt, Byte Pu)
                   Pd=and(Pt,!Ps)                     Byte Q6_p_and_pnp(Byte Pt, Byte Ps)
                   Pd=and(Pt,Ps)                      Byte Q6_p_and_pp(Byte Pt, Byte Ps)
                   Pd=not(Ps)                         Byte Q6_p_not_p(Byte Ps)
                   Pd=or(Ps,and(Pt,!Pu))              Byte Q6_p_or_and_ppnp(Byte Ps, Byte Pt, Byte Pu)
                   Pd=or(Ps,and(Pt,Pu))               Byte Q6_p_or_and_ppp(Byte Ps, Byte Pt, Byte Pu)
80-N2040-45 Rev. B                                                                                           218
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
                   Pd=or(Ps,or(Pt,!Pu))                     Byte Q6_p_or_or_ppnp(Byte Ps, Byte Pt, Byte Pu)
                   Pd=or(Ps,or(Pt,Pu))                      Byte Q6_p_or_or_ppp(Byte Ps, Byte Pt, Byte Pu)
                   Pd=or(Pt,!Ps)                            Byte Q6_p_or_pnp(Byte Pt, Byte Ps)
                   Pd=or(Pt,Ps)                             Byte Q6_p_or_pp(Byte Pt, Byte Ps)
                   Pd=xor(Ps,Pt)                            Byte Q6_p_xor_pp(Byte Ps, Byte Pt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8 7   6  5 4 3 2 1   0
   ICLASS      sm                            s2   Parse              t2                    d2
 0  1  1  0 1  0   1 1  0  0  0  0   -  -  s    s P   P 0 -   - -  t    t -    - - - - - d   d Pd=and(Pt,Ps)
   ICLASS      sm                            s2   Parse              t2     u2             d2
 0  1  1  0 1  0   1 1  0  0  0  1   -  -  s    s P   P 0 -   - -  t    t u   u  - - - - d   d Pd=and(Ps,and(Pt,Pu))
   ICLASS      sm                            s2   Parse              t2                    d2
 0  1  1  0 1  0   1 1  0  0  1  0   -  -  s    s P   P 0 -   - -  t    t -    - - - - - d   d Pd=or(Pt,Ps)
   ICLASS      sm                            s2   Parse              t2     u2             d2
 0  1  1  0 1  0   1 1  0  0  1  1   -  -  s    s P   P 0 -   - -  t    t u   u  - - - - d   d Pd=and(Ps,or(Pt,Pu))
   ICLASS      sm                            s2   Parse              t2                    d2
 0  1  1  0 1  0   1 1  0  1  0  0   -  -  s    s P   P 0 -   - -  t    t -    - - - - - d   d Pd=xor(Ps,Pt)
   ICLASS      sm                            s2   Parse              t2     u2             d2
 0  1  1  0 1  0   1 1  0  1  0  1   -  -  s    s P   P 0 -   - -  t    t u   u  - - - - d   d Pd=or(Ps,and(Pt,Pu))
   ICLASS      sm                            s2   Parse              t2                    d2
 0  1  1  0 1  0   1 1  0  1  1  0   -  -  s    s P   P 0 -   - -  t    t -    - - - - - d   d Pd=and(Pt,!Ps)
   ICLASS      sm                            s2   Parse              t2     u2             d2
 0  1  1  0 1  0   1 1  0  1  1  1   -  -  s    s P   P 0 -   - -  t    t u   u  - - - - d   d Pd=or(Ps,or(Pt,Pu))
 0  1  1  0 1  0   1 1  1  0  0  1   -  -  s    s P   P 0 -   - -  t    t u   u  - - - - d   d Pd=and(Ps,and(Pt,!Pu))
 0  1  1  0 1  0   1 1  1  0  1  1   -  -  s    s P   P 0 -   - -  t    t u   u  - - - - d   d Pd=and(Ps,or(Pt,!Pu))
   ICLASS      sm                            s2   Parse                                    d2
 0  1  1  0 1  0   1 1  1  1  0  0   -  -  s    s P   P 0 -   - -  -    - -    - - - - - d   d Pd=not(Ps)
   ICLASS      sm                            s2   Parse              t2     u2             d2
 0  1  1  0 1  0   1 1  1  1  0  1   -  -  s    s P   P 0 -   - -  t    t u   u  - - - - d   d Pd=or(Ps,and(Pt,!Pu))
   ICLASS      sm                            s2   Parse              t2                    d2
 0  1  1  0 1  0   1 1  1  1  1  0   -  -  s    s P   P 0 -   - -  t    t -    - - - - - d   d Pd=or(Pt,!Ps)
   ICLASS      sm                            s2   Parse              t2     u2             d2
 0  1  1  0 1  0   1 1  1  1  1  1   -  -  s    s P   P 0 -   - -  t    t u   u  - - - - d   d Pd=or(Ps,or(Pt,!Pu))
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s2                Field to encode register s
                  t2                Field to encode register t
                  u2                Field to encode register u
80-N2040-45 Rev. B                                                                                                   219
Hexagon V67 Programmer’s Reference Manual                                                                  Instruction Set
          User control register transfer
                  Move 32- or 64-bit values between a user control register and a general register. The user
                  control registers include SA, LC, Predicates, M, USR, PC, UGP, GP, and CS, and
                  UPCYCLE. The figure shows the user control registers and their register field encodings.
                  Registers can be moved as singles or as aligned 64-bit pairs.
                  The PC register is not writable. A program flow instruction must be used to change the PC
                  value.
                     0       SA0             8          USR          16                    24
                     1       LC0             9           PC
                     2       SA1             10         UGP
                     3       LC1             11         GP
                                                                            Reserved              Reserved
                     4       P3:0            12         CS0
                     5     Reserved          13         CS1
                     6        M0             14     UPCYCLELO
                     7        M1                    UPCYCLEHI
                                             15                      23                     31
                   Syntax                                     Behavior
                   Cd=Rs                                      Cd=Rs;
                   Cdd=Rss                                    Cdd=Rss;
                   Rd=Cs                                      Rd=Cs;
                   Rdd=Css                                    Rdd=Css;
                  Class: CR (slot 3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8 7   6   5  4 3 2    1 0
   ICLASS      sm                       s5        Parse                                  d5
 0  1  1  0 0  0   1   0 0 0   1   s  s  s  s   s P   P   - -   - -  -  - -   -   -  d d d    d d Cd=Rs
 0  1  1  0 0  0   1   1 0 0   1   s  s  s  s   s P   P   - -   - -  -  - -   -   -  d d d    d d Cdd=Rss
 0  1  1  0 1  0   0   0 0 0   0   s  s  s  s   s P   P   - -   - -  -  - -   -   -  d d d    d d Rdd=Css
 0  1  1  0 1  0   1   0 0 0   0   s  s  s  s   s P   P   - -   - -  -  - -   -   -  d d d    d d Rd=Cs
                  Field name         Description
                  sm                 Supervisor mode only
                  ICLASS             Instruction Class
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  s5                 Field to encode register s
80-N2040-45 Rev. B                                                                                                     220
Hexagon V67 Programmer’s Reference Manual                                                                  Instruction Set
      11.3        JR
                  The JR instruction class includes instructions to change the program flow to a new
                  location contained in a register.
                  JR instructions are executable on slot 2.
          Call subroutine from register
                  Change the program flow to a subroutine. This instruction first transfers the Next Program
                  Counter (NPC) value into the Link Register, and then jumps to a target address contained
                  in a register.
                  This instruction can only appear in slot 2.
                   Syntax                                   Behavior
                   callr Rs                                 LR=NPC;
                                                            PC=Rs;
                                                            ;
                   if ([!]Pu) callr Rs                      ;
                                                            if ([!]Pu[0]) {
                                                                LR=NPC;
                                                                PC=Rs;
                                                            ;
                                                            }
                  Class: JR (slot 2)
                  Notes
                        ■  This instruction can be conditionally executed based on the value of a predicate
                           register. If the instruction is preceded by 'if Pn', the instruction only executes if the
                           least-significant bit of the predicate register is 1. Similarly, if the instruction is
                           preceded by 'if !Pn', the instruction is executed only if the least-significant bit of
                           Pn is 0.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8  7 6 5   4  3 2  1  0
   ICLASS                               s5       Parse
 0  1  0  1 0  0   0 0   1 0  1   s  s   s s  s  P   P -  -   - -  -    - - - -   -  -  - -   - callr Rs
   ICLASS                               s5       Parse               u2
 0  1  0  1 0  0   0 1   0 0  0   s  s   s s  s  P   P -  -   - -  u   u  - - -   -  -  - -   - if (Pu) callr Rs
 0  1  0  1 0  0   0 1   0 0  1   s  s   s s  s  P   P -  -   - -  u   u  - - -   -  -  - -   - if (!Pu) callr Rs
                  Field name        Description
                  ICLASS            Instruction Class
80-N2040-45 Rev. B                                                                                                     221
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  Parse        Packet/Loop parse bits
                  s5           Field to encode register s
                  u2           Field to encode register u
80-N2040-45 Rev. B                                                    222
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Hint an indirect jump address
                  Provide a hint indicating that there will soon be an indirect JUMPR to the address
                  specified in Rs.
                   Syntax                                   Behavior
                   hintjr(Rs)                               ;
                  Class: JR (slot 2)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4  3 2 1 0
   ICLASS                              s5        Parse
 0  1  0  1 0  0   1 0  1  0  1   s  s  s  s  s  P   P -  -   - -  - - - - - -  - - - - hintjr(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                             223
Hexagon V67 Programmer’s Reference Manual                                                                  Instruction Set
          Jump to address from register
                  Change the program flow to a target address. This instruction changes the Program
                  Counter to a target address contained in a register.
                  This instruction can appear only in slot 2.
                   Syntax                                   Behavior
                   if ([!]Pu) jumpr Rs                      Assembler mapped to: "if ([!]Pu) ""jumpr"":nt
                                                            ""Rs"
                   if ([!]Pu[.new]) jumpr:<hint> Rs }
                                                            {
                                                            if([!]Pu[.new][0]){
                                                                PC=Rs;
                                                            ;
                                                            }
                   jumpr Rs                                 PC=Rs;
                  Class: JR (slot 2)
                  Notes
                       ■   This instruction can be conditionally executed based on the value of a predicate
                           register. If the instruction is preceded by 'if Pn', the instruction only executes if the
                           least-significant bit of the predicate register is 1. Similarly, if the instruction is
                           preceded by 'if !Pn', the instruction is executed only if the least-significant bit of
                           Pn is 0.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8  7 6 5   4  3 2  1  0
   ICLASS                               s5       Parse
 0  1  0  1 0  0   1 0  1  0  0   s  s   s s  s  P   P -  -   - -  -    - - - -   -  -  - -   - jumpr Rs
   ICLASS                               s5       Parse               u2
 0  1  0  1 0  0   1 1  0  1  0   s  s   s s  s  P   P -  0   0 -  u   u  - - -   -  -  - -   - if (Pu) jumpr:nt Rs
 0  1  0  1 0  0   1 1  0  1  0   s  s   s s  s  P   P -  0   1 -  u   u  - - -   -  -  - -   - if (Pu.new) jumpr:nt Rs
 0  1  0  1 0  0   1 1  0  1  0   s  s   s s  s  P   P -  1   0 -  u   u  - - -   -  -  - -   - if (Pu) jumpr:t Rs
 0  1  0  1 0  0   1 1  0  1  0   s  s   s s  s  P   P -  1   1 -  u   u  - - -   -  -  - -   - if (Pu.new) jumpr:t Rs
 0  1  0  1 0  0   1 1  0  1  1   s  s   s s  s  P   P -  0   0 -  u   u  - - -   -  -  - -   - if (!Pu) jumpr:nt Rs
 0  1  0  1 0  0   1 1  0  1  1   s  s   s s  s  P   P -  0   1 -  u   u  - - -   -  -  - -   - if (!Pu.new) jumpr:nt Rs
 0  1  0  1 0  0   1 1  0  1  1   s  s   s s  s  P   P -  1   0 -  u   u  - - -   -  -  - -   - if (!Pu) jumpr:t Rs
 0  1  0  1 0  0   1 1  0  1  1   s  s   s s  s  P   P -  1   1 -  u   u  - - -   -  -  - -   - if (!Pu.new) jumpr:t Rs
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  u2                Field to encode register u
80-N2040-45 Rev. B                                                                                                       224
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
     11.4         J
                  The J instruction class includes branch instructions (jumps and calls) that obtain the target
                  address from a (PC-relative) immediate address value.
                  J instructions are executable on slot 2 and slot 3.
        Call subroutine
                  Change the program flow to a subroutine. This instruction first transfers the Next Program
                  Counter (NPC) value into the Link Register, and then jumps to the target address.
                  This instruction can appear in slots 2 or 3.
                   Syntax                                  Behavior
                   call #r22:2                              apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            LR=NPC;
                                                            PC=PC+#r;
                                                            ;
                   if ([!]Pu) call #r15:2                   apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            ;
                                                            if ([!]Pu[0]) {
                                                                LR=NPC;
                                                                PC=PC+#r;
                                                            ;
                                                            }
                  Class: J (slots 2,3)
                  Notes
                        ■  This instruction can be conditionally executed based on the value of a predicate
                           register. If the instruction is preceded by 'if Pn', the instruction only executes if the
                           least-significant bit of the predicate register is 1. Similarly, if the instruction is
                           preceded by 'if !Pn', the instruction is executed only if the least-significant bit of
                           Pn is 0.
                        ■  The Next PC value is the address immediately following the last instruction in the
                           packet containing this instruction.
                        ■  The PC value is the address of the start of the packet
                        ■  A PC-relative address is formed by taking the decoded immediate value and
                           adding it to the current PC value.
80-N2040-45 Rev. B                                                                                                 225
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7 6 5 4 3 2 1 0
   ICLASS                                        Parse
 0  1  0  1 1  0   1  i  i  i  i  i  i  i   i  i P   P i  i  i  i i    i i i i i i i i 0 call #r22:2
   ICLASS                                        Parse       D      u2
                                                             N
 0  1  0  1 1  1   0 1   i  i 0   i  i  i   i  i P   P i  -  0  - u   u  i i i i i i i - if (Pu) call #r15:2
 0  1  0  1 1  1   0 1   i  i 1   i  i  i   i  i P   P i  -  0  - u   u  i i i i i i i - if (!Pu) call #r15:2
                  Field name        Description
                  ICLASS            Instruction Class
                  DN                Dot-new
                  Parse             Packet/Loop parse bits
                  u2                Field to encode register u
80-N2040-45 Rev. B                                                                                              226
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Compare and jump
                  Compare two registers, or a register and immediate value, and write a predicate with the
                  result. Then use the predicate result to conditionally jump to a PC-relative target address.
                  The registers available as operands are restricted to R0-R7 and R16-R23. The predicate
                  destination is restricted to P0 and P1.
                  In assembly syntax, this instruction appears as two instructions in the packet: a compare
                  and a separate conditional jump. The assembler may convert adjacent compare and jump
                  instructions into compound compare-jump form.
                   Syntax                               Behavior
                   p[01]=cmp.eq(Rs,#-1); if              P[01]=(Rs==-1) ? 0xff : 0x00 if
                   ([!]p[01].new) jump:<hint>            ([!]P[01].new[0]) {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.eq(Rs,#U5); if              P[01]=(Rs==#U) ? 0xff : 0x00 if
                   ([!]p[01].new) jump:<hint>            ([!]P[01].new[0]) {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.eq(Rs,Rt); if               P[01]=(Rs==Rt) ? 0xff : 0x00 if
                   ([!]p[01].new) jump:<hint>            ([!]P[01].new[0]) {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.gt(Rs,#-1); if              P[01]=(Rs>-1) ? 0xff : 0x00 if ([!]P[01].new[0])
                   ([!]p[01].new) jump:<hint>            {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.gt(Rs,#U5); if              P[01]=(Rs>#U) ? 0xff : 0x00 if ([!]P[01].new[0])
                   ([!]p[01].new) jump:<hint>            {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.gt(Rs,Rt); if               P[01]=(Rs>Rt) ? 0xff : 0x00 if ([!]P[01].new[0])
                   ([!]p[01].new) jump:<hint>            {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.gtu(Rs,#U5); if             P[01]=(Rs.uw[0]>#U) ? 0xff : 0x00 if
                   ([!]p[01].new) jump:<hint>            ([!]P[01].new[0]) {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
80-N2040-45 Rev. B                                                                                            227
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                   Syntax                                   Behavior
                   p[01]=cmp.gtu(Rs,Rt); if                 P[01]=(Rs.uw[0]>Rt) ? 0xff : 0x00 if
                   ([!]p[01].new) jump:<hint>               ([!]P[01].new[0]) {
                   #r9:2                                        apply_extension(#r);
                                                                #r=#r & ~PCALIGN_MASK;
                                                                PC=PC+#r;
                                                            }
                   p[01]=tstbit(Rs,#0); if                  P[01]=(Rs & 1) ? 0xff : 0x00 if ([!]P[01].new[0])
                   ([!]p[01].new) jump:<hint>               {
                   #r9:2                                        apply_extension(#r);
                                                                #r=#r & ~PCALIGN_MASK;
                                                                PC=PC+#r;
                                                            }
                  Class: J (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4  3  2 1  0
   ICLASS                                 s4     Parse
                                                                                            p0=cmp.eq(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 0  -   - - 0  0  i i  i i  i  i i  - (p0.new) jump:nt #r9:2
                                                                                            p0=cmp.gt(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 0  -   - - 0  1  i i  i i  i  i i  -
                                                                                            (p0.new) jump:nt #r9:2
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 0  -   - - 1  1  i i  i i  i  i i  - p0=tstbit(Rs,#0); if (p0.new)
                                                                                            jump:nt #r9:2
                                                                                            p0=cmp.eq(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 1  -   - - 0  0  i i  i i  i  i i  -
                                                                                            (p0.new) jump:t #r9:2
                                                                                            p0=cmp.gt(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 1  -   - - 0  1  i i  i i  i  i i  -
                                                                                            (p0.new) jump:t #r9:2
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 1  -   - - 1  1  i i  i i  i  i i  - p0=tstbit(Rs,#0); if (p0.new)
                                                                                            jump:t #r9:2
                                                                                            p0=cmp.eq(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 0  -   - - 0  0  i i  i i  i  i i  -
                                                                                            (!p0.new) jump:nt #r9:2
                                                                                            p0=cmp.gt(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 0  -   - - 0  1  i i  i i  i  i i  -
                                                                                            (!p0.new) jump:nt #r9:2
                                                                                            p0=tstbit(Rs,#0); if
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 0  -   - - 1  1  i i  i i  i  i i  -
                                                                                            (!p0.new) jump:nt #r9:2
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 1  -   - - 0  0  i i  i i  i  i i  - p0=cmp.eq(Rs,#-1); if
                                                                                            (!p0.new) jump:t #r9:2
                                                                                            p0=cmp.gt(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 1  -   - - 0  1  i i  i i  i  i i  -
                                                                                            (!p0.new) jump:t #r9:2
                                                                                            p0=tstbit(Rs,#0); if
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 1  -   - - 1  1  i i  i i  i  i i  - (!p0.new) jump:t #r9:2
                                                                                            p0=cmp.eq(Rs,#U5); if
 0  0  0  1 0  0   0 0  0  0   i  i  s  s    s s P   P 0  I   I I  I I  i i  i  i i  i i  - (p0.new) jump:nt #r9:2
                                                                                            p0=cmp.eq(Rs,#U5); if
 0  0  0  1 0  0   0 0  0  0   i  i  s  s    s s P   P 1  I   I I  I I  i i  i  i i  i i  -
                                                                                            (p0.new) jump:t #r9:2
                                                                                            p0=cmp.eq(Rs,#U5); if
 0  0  0  1 0  0   0 0  0  1   i  i  s  s    s s P   P 0  I   I I  I I  i i  i  i i  i i  -
                                                                                            (!p0.new) jump:nt #r9:2
 0  0  0  1 0  0   0 0  0  1   i  i  s  s    s s P   P 1  I   I I  I I  i i  i  i i  i i  - p0=cmp.eq(Rs,#U5); if
                                                                                            (!p0.new) jump:t #r9:2
                                                                                            p0=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   0 0  1  0   i  i  s  s    s s P   P 0  I   I I  I I  i i  i  i i  i i  - (p0.new) jump:nt #r9:2
                                                                                            p0=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   0 0  1  0   i  i  s  s    s s P   P 1  I   I I  I I  i i  i  i i  i i  - (p0.new) jump:t #r9:2
                                                                                            p0=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   0 0  1  1   i  i  s  s    s s P   P 0  I   I I  I I  i i  i  i i  i i  -
                                                                                            (!p0.new) jump:nt #r9:2
                                                                                            p0=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   0 0  1  1   i  i  s  s    s s P   P 1  I   I I  I I  i i  i  i i  i i  -
                                                                                            (!p0.new) jump:t #r9:2
80-N2040-45 Rev. B                                                                                                    228
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7 6 5 4 3 2 1 0
                                                                                         p0=cmp.gtu(Rs,#U5); if
 0  0  0  1 0  0   0 1  0  0   i  i  s  s    s s P   P 0  I  I  I    I I i i i i i i i -
                                                                                         (p0.new) jump:nt #r9:2
                                                                                         p0=cmp.gtu(Rs,#U5); if
 0  0  0  1 0  0   0 1  0  0   i  i  s  s    s s P   P 1  I  I  I    I I i i i i i i i -
                                                                                         (p0.new) jump:t #r9:2
                                                                                         p0=cmp.gtu(Rs,#U5); if
 0  0  0  1 0  0   0 1  0  1   i  i  s  s    s s P   P 0  I  I  I    I I i i i i i i i -
                                                                                         (!p0.new) jump:nt #r9:2
                                                                                         p0=cmp.gtu(Rs,#U5); if
 0  0  0  1 0  0   0 1  0  1   i  i  s  s    s s P   P 1  I  I  I    I I i i i i i i i - (!p0.new) jump:t #r9:2
                                                                                         p1=cmp.eq(Rs,#-1); if
 0  0  0  1 0  0   1 1  1  0   i  i  s  s    s s P   P 0  -  -  -    0 0 i i i i i i i -
                                                                                         (p1.new) jump:nt #r9:2
 0  0  0  1 0  0   1 1  1  0   i  i  s  s    s s P   P 0  -  -  -    0 1 i i i i i i i - p1=cmp.gt(Rs,#-1); if
                                                                                         (p1.new) jump:nt #r9:2
                                                                                         p1=tstbit(Rs,#0); if (p1.new)
 0  0  0  1 0  0   1 1  1  0   i  i  s  s    s s P   P 0  -  -  -    1 1 i i i i i i i -
                                                                                         jump:nt #r9:2
                                                                                         p1=cmp.eq(Rs,#-1); if
 0  0  0  1 0  0   1 1  1  0   i  i  s  s    s s P   P 1  -  -  -    0 0 i i i i i i i -
                                                                                         (p1.new) jump:t #r9:2
                                                                                         p1=cmp.gt(Rs,#-1); if
 0  0  0  1 0  0   1 1  1  0   i  i  s  s    s s P   P 1  -  -  -    0 1 i i i i i i i -
                                                                                         (p1.new) jump:t #r9:2
                                                                                         p1=tstbit(Rs,#0); if (p1.new)
 0  0  0  1 0  0   1 1  1  0   i  i  s  s    s s P   P 1  -  -  -    1 1 i i i i i i i - jump:t #r9:2
                                                                                         p1=cmp.eq(Rs,#-1); if
 0  0  0  1 0  0   1 1  1  1   i  i  s  s    s s P   P 0  -  -  -    0 0 i i i i i i i - (!p1.new) jump:nt #r9:2
 0  0  0  1 0  0   1 1  1  1   i  i  s  s    s s P   P 0  -  -  -    0 1 i i i i i i i - p1=cmp.gt(Rs,#-1); if
                                                                                         (!p1.new) jump:nt #r9:2
 0  0  0  1 0  0   1 1  1  1   i  i  s  s    s s P   P 0  -  -  -    1 1 i i i i i i i - p1=tstbit(Rs,#0); if
                                                                                         (!p1.new) jump:nt #r9:2
                                                                                         p1=cmp.eq(Rs,#-1); if
 0  0  0  1 0  0   1 1  1  1   i  i  s  s    s s P   P 1  -  -  -    0 0 i i i i i i i -
                                                                                         (!p1.new) jump:t #r9:2
 0  0  0  1 0  0   1 1  1  1   i  i  s  s    s s P   P 1  -  -  -    0 1 i i i i i i i - p1=cmp.gt(Rs,#-1); if
                                                                                         (!p1.new) jump:t #r9:2
                                                                                         p1=tstbit(Rs,#0); if
 0  0  0  1 0  0   1 1  1  1   i  i  s  s    s s P   P 1  -  -  -    1 1 i i i i i i i - (!p1.new) jump:t #r9:2
                                                                                         p1=cmp.eq(Rs,#U5); if
 0  0  0  1 0  0   1 0  0  0   i  i  s  s    s s P   P 0  I  I  I    I I i i i i i i i -
                                                                                         (p1.new) jump:nt #r9:2
                                                                                         p1=cmp.eq(Rs,#U5); if
 0  0  0  1 0  0   1 0  0  0   i  i  s  s    s s P   P 1  I  I  I    I I i i i i i i i - (p1.new) jump:t #r9:2
                                                                                         p1=cmp.eq(Rs,#U5); if
 0  0  0  1 0  0   1 0  0  1   i  i  s  s    s s P   P 0  I  I  I    I I i i i i i i i - (!p1.new) jump:nt #r9:2
                                                                                         p1=cmp.eq(Rs,#U5); if
 0  0  0  1 0  0   1 0  0  1   i  i  s  s    s s P   P 1  I  I  I    I I i i i i i i i -
                                                                                         (!p1.new) jump:t #r9:2
                                                                                         p1=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   1 0  1  0   i  i  s  s    s s P   P 0  I  I  I    I I i i i i i i i -
                                                                                         (p1.new) jump:nt #r9:2
                                                                                         p1=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   1 0  1  0   i  i  s  s    s s P   P 1  I  I  I    I I i i i i i i i -
                                                                                         (p1.new) jump:t #r9:2
                                                                                         p1=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   1 0  1  1   i  i  s  s    s s P   P 0  I  I  I    I I i i i i i i i - (!p1.new) jump:nt #r9:2
                                                                                         p1=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   1 0  1  1   i  i  s  s    s s P   P 1  I  I  I    I I i i i i i i i - (!p1.new) jump:t #r9:2
                                                                                         p1=cmp.gtu(Rs,#U5); if
 0  0  0  1 0  0   1 1  0  0   i  i  s  s    s s P   P 0  I  I  I    I I i i i i i i i - (p1.new) jump:nt #r9:2
                                                                                         p1=cmp.gtu(Rs,#U5); if
 0  0  0  1 0  0   1 1  0  0   i  i  s  s    s s P   P 1  I  I  I    I I i i i i i i i -
                                                                                         (p1.new) jump:t #r9:2
                                                                                         p1=cmp.gtu(Rs,#U5); if
 0  0  0  1 0  0   1 1  0  1   i  i  s  s    s s P   P 0  I  I  I    I I i i i i i i i -
                                                                                         (!p1.new) jump:nt #r9:2
                                                                                         p1=cmp.gtu(Rs,#U5); if
 0  0  0  1 0  0   1 1  0  1   i  i  s  s    s s P   P 1  I  I  I    I I i i i i i i i -
                                                                                         (!p1.new) jump:t #r9:2
   ICLASS                                 s4     Parse            t4
                                                                                         p0=cmp.eq(Rs,Rt); if
 0  0  0  1 0  1   0 0  0  0   i  i  s  s    s s P   P 0 0   t  t    t t i i i i i i i -
                                                                                         (p0.new) jump:nt #r9:2
                                                                                         p1=cmp.eq(Rs,Rt); if
 0  0  0  1 0  1   0 0  0  0   i  i  s  s    s s P   P 0 1   t  t    t t i i i i i i i -
                                                                                         (p1.new) jump:nt #r9:2
                                                                                         p0=cmp.eq(Rs,Rt); if
 0  0  0  1 0  1   0 0  0  0   i  i  s  s    s s P   P 1 0   t  t    t t i i i i i i i -
                                                                                         (p0.new) jump:t #r9:2
80-N2040-45 Rev. B                                                                                                 229
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
                                                                                      p1=cmp.eq(Rs,Rt); if
 0  0 0  1  0  1   0 0  0  0   i  i  s  s  s  s  P  P 1  1    t t t t i i i i i i i -
                                                                                      (p1.new) jump:t #r9:2
                                                                                      p0=cmp.eq(Rs,Rt); if
 0  0 0  1  0  1   0 0  0  1   i  i  s  s  s  s  P  P 0  0    t t t t i i i i i i i -
                                                                                      (!p0.new) jump:nt #r9:2
                                                                                      p1=cmp.eq(Rs,Rt); if
 0  0 0  1  0  1   0 0  0  1   i  i  s  s  s  s  P  P 0  1    t t t t i i i i i i i -
                                                                                      (!p1.new) jump:nt #r9:2
                                                                                      p0=cmp.eq(Rs,Rt); if
 0  0 0  1  0  1   0 0  0  1   i  i  s  s  s  s  P  P 1  0    t t t t i i i i i i i - (!p0.new) jump:t #r9:2
                                                                                      p1=cmp.eq(Rs,Rt); if
 0  0 0  1  0  1   0 0  0  1   i  i  s  s  s  s  P  P 1  1    t t t t i i i i i i i -
                                                                                      (!p1.new) jump:t #r9:2
 0  0 0  1  0  1   0 0  1  0   i  i  s  s  s  s  P  P 0  0    t t t t i i i i i i i - p0=cmp.gt(Rs,Rt); if
                                                                                      (p0.new) jump:nt #r9:2
                                                                                      p1=cmp.gt(Rs,Rt); if
 0  0 0  1  0  1   0 0  1  0   i  i  s  s  s  s  P  P 0  1    t t t t i i i i i i i -
                                                                                      (p1.new) jump:nt #r9:2
                                                                                      p0=cmp.gt(Rs,Rt); if
 0  0 0  1  0  1   0 0  1  0   i  i  s  s  s  s  P  P 1  0    t t t t i i i i i i i -
                                                                                      (p0.new) jump:t #r9:2
                                                                                      p1=cmp.gt(Rs,Rt); if
 0  0 0  1  0  1   0 0  1  0   i  i  s  s  s  s  P  P 1  1    t t t t i i i i i i i -
                                                                                      (p1.new) jump:t #r9:2
                                                                                      p0=cmp.gt(Rs,Rt); if
 0  0 0  1  0  1   0 0  1  1   i  i  s  s  s  s  P  P 0  0    t t t t i i i i i i i - (!p0.new) jump:nt #r9:2
                                                                                      p1=cmp.gt(Rs,Rt); if
 0  0 0  1  0  1   0 0  1  1   i  i  s  s  s  s  P  P 0  1    t t t t i i i i i i i - (!p1.new) jump:nt #r9:2
 0  0 0  1  0  1   0 0  1  1   i  i  s  s  s  s  P  P 1  0    t t t t i i i i i i i - p0=cmp.gt(Rs,Rt); if
                                                                                      (!p0.new) jump:t #r9:2
 0  0 0  1  0  1   0 0  1  1   i  i  s  s  s  s  P  P 1  1    t t t t i i i i i i i - p1=cmp.gt(Rs,Rt); if
                                                                                      (!p1.new) jump:t #r9:2
                                                                                      p0=cmp.gtu(Rs,Rt); if
 0  0 0  1  0  1   0 1  0  0   i  i  s  s  s  s  P  P 0  0    t t t t i i i i i i i -
                                                                                      (p0.new) jump:nt #r9:2
                                                                                      p1=cmp.gtu(Rs,Rt); if
 0  0 0  1  0  1   0 1  0  0   i  i  s  s  s  s  P  P 0  1    t t t t i i i i i i i -
                                                                                      (p1.new) jump:nt #r9:2
 0  0 0  1  0  1   0 1  0  0   i  i  s  s  s  s  P  P 1  0    t t t t i i i i i i i - p0=cmp.gtu(Rs,Rt); if
                                                                                      (p0.new) jump:t #r9:2
                                                                                      p1=cmp.gtu(Rs,Rt); if
 0  0 0  1  0  1   0 1  0  0   i  i  s  s  s  s  P  P 1  1    t t t t i i i i i i i - (p1.new) jump:t #r9:2
                                                                                      p0=cmp.gtu(Rs,Rt); if
 0  0 0  1  0  1   0 1  0  1   i  i  s  s  s  s  P  P 0  0    t t t t i i i i i i i -
                                                                                      (!p0.new) jump:nt #r9:2
                                                                                      p1=cmp.gtu(Rs,Rt); if
 0  0 0  1  0  1   0 1  0  1   i  i  s  s  s  s  P  P 0  1    t t t t i i i i i i i - (!p1.new) jump:nt #r9:2
                                                                                      p0=cmp.gtu(Rs,Rt); if
 0  0 0  1  0  1   0 1  0  1   i  i  s  s  s  s  P  P 1  0    t t t t i i i i i i i -
                                                                                      (!p0.new) jump:t #r9:2
                                                                                      p1=cmp.gtu(Rs,Rt); if
 0  0 0  1  0  1   0 1  0  1   i  i  s  s  s  s  P  P 1  1    t t t t i i i i i i i -
                                                                                      (!p1.new) jump:t #r9:2
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s4                Field to encode register s
                  t4                Field to encode register t
80-N2040-45 Rev. B                                                                                            230
Hexagon V67 Programmer’s Reference Manual                                                                   Instruction Set
          Jump to address
                  Change the program flow to a target address. This instruction changes the Program
                  Counter to a target address which is relative to the PC address. The offset from the current
                  PC address is contained in the instruction encoding.
                  A speculated jump instruction includes a hint ("taken" or "not taken") which specifies the
                  expected value of the conditional expression. If the actual generated value of the predicate
                  differs from this expected value, the jump instruction incurs a performance penalty.
                  This instruction can appear in slots 2 or 3.
                   Syntax                                    Behavior
                   if ([!]Pu) jump #r15:2                    Assembler mapped to: "if ([!]Pu) ""jump"":nt
                                                             ""#r15:2"
                   if ([!]Pu) jump:<hint> #r15:2             ;
                                                             if ([!]Pu[0]) {
                                                                 apply_extension(#r);
                                                                 #r=#r & ~PCALIGN_MASK;
                                                                 PC=PC+#r;
                                                             ;
                                                             }
                   jump #r22:2                               apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                  Class: J (slots 0,1,2,3)
                  Notes
                        ■   This instruction can be conditionally executed based on the value of a predicate
                            register. If the instruction is preceded by 'if Pn', the instruction only executes if the
                            least-significant bit of the predicate register is 1. Similarly, if the instruction is
                            preceded by 'if !Pn', the instruction is executed only if the least-significant bit of
                            Pn is 0.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8  7 6 5   4  3 2  1  0
   ICLASS                                         Parse
 0  1  0  1 1  0   0  i   i  i i   i  i   i  i  i P   P i  i   i i  i    i i i i   i  i  i i   - jump #r22:2
                                                               D
   ICLASS                                         Parse   PT N        u2
 0  1  0  1 1  1   0 0    i  i 0   i  i   i  i  i P   P i  0   0 - u    u  i i i   i  i  i i   - if (Pu) jump:nt #r15:2
 0  1  0  1 1  1   0 0    i  i 0   i  i   i  i  i P   P i  1   0 - u    u  i i i   i  i  i i   - if (Pu) jump:t #r15:2
 0  1  0  1 1  1   0 0    i  i 1   i  i   i  i  i P   P i  0   0 - u    u  i i i   i  i  i i   - if (!Pu) jump:nt #r15:2
 0  1  0  1 1  1   0 0    i  i 1   i  i   i  i  i P   P i  1   0 - u    u  i i i   i  i  i i   - if (!Pu) jump:t #r15:2
80-N2040-45 Rev. B                                                                                                       231
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  DN           Dot-new
                  PT           Predict-taken
                  Parse        Packet/Loop parse bits
                  u2           Field to encode register u
80-N2040-45 Rev. B                                                    232
Hexagon V67 Programmer’s Reference Manual                                                                  Instruction Set
          Jump to address conditioned on new predicate
                  Perform speculated jump.
                  Jump if the LSB of the newly-generated predicate is true. The predicate must be generated
                  in the same packet as the speculated jump instruction.
                  A speculated jump instruction includes a hint ("taken" or "not taken") which specifies the
                  expected value of the conditional expression. If the actual generated value of the predicate
                  differs from this expected value, the jump instruction incurs a performance penalty.
                  This instruction can appear in slots 2 or 3.
                   Syntax                                    Behavior
                   if ([!]Pu.new) jump:<hint>                }
                   #r15:2                                    {
                                                             if([!]Pu.new[0]){
                                                                 apply_extension(#r);
                                                                 #r=#r & ~PCALIGN_MASK;
                                                                 PC=PC+#r;
                                                             ;
                                                             }
                  Class: J (slots 0,1,2,3)
                  Notes
                        ■   This instruction can be conditionally executed based on the value of a predicate
                            register. If the instruction is preceded by 'if Pn', the instruction only executes if the
                            least-significant bit of the predicate register is 1. Similarly, if the instruction is
                            preceded by 'if !Pn', the instruction is executed only if the least-significant bit of
                            Pn is 0.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7  6  5   4  3 2  1  0
                                                               D
   ICLASS                                         Parse   PT N      u2
 0  1  0  1 1  1   0  0   i  i 0   i  i   i  i  i P   P i  0   1 - u  u  i  i  i   i  i  i i   - if (Pu.new) jump:nt #r15:2
 0  1  0  1 1  1   0  0   i  i 0   i  i   i  i  i P   P i  1   1 - u  u  i  i  i   i  i  i i   - if (Pu.new) jump:t #r15:2
 0  1  0  1 1  1   0  0   i  i 1   i  i   i  i  i P   P i  0   1 - u  u  i  i  i   i  i  i i   - if (!Pu.new) jump:nt #r15:2
 0  1  0  1 1  1   0  0   i  i 1   i  i   i  i  i P   P i  1   1 - u  u  i  i  i   i  i  i i   - if (!Pu.new) jump:t #r15:2
                  Field name         Description
                  ICLASS             Instruction Class
                  DN                 Dot-new
                  PT                 Predict-taken
                  Parse              Packet/Loop parse bits
                  u2                 Field to encode register u
80-N2040-45 Rev. B                                                                                                        233
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Jump to address condition on register value
                  Perform register-conditional jump.
                  Jump if the specified register expression is true.
                  A register-conditional jump includes a hint ("taken" or "not taken") which specifies the
                  expected value of the register expression. If the actual generated value of the expression
                  differs from this expected value, the jump instruction incurs a performance penalty.
                  This instruction can appear only in slot 3.
                   Syntax                               Behavior
                   if (Rs!=#0) jump:nt #r13:2           if (Rs != 0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs!=#0) jump:t #r13:2            if (Rs != 0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs<=#0) jump:nt #r13:2           if (Rs<=0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs<=#0) jump:t #r13:2            if (Rs<=0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs==#0) jump:nt #r13:2           if (Rs == 0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs==#0) jump:t #r13:2            if (Rs == 0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs>=#0) jump:nt #r13:2           if (Rs>=0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs>=#0) jump:t #r13:2            if (Rs>=0) {
                                                            PC=PC+#r;
                                                        }
                  Class: J (slot 3)
                  Notes
                       ■   This instruction will be deprecated in a future version.
80-N2040-45 Rev. B                                                                                           234
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  0   0 1  0  0   i  s  s  s  s  s  P   P i 0   i  i i i i i i i i i i - if (Rs!=#0) jump:nt #r13:2
 0  1  1  0 0  0   0 1  0  0   i  s  s  s  s  s  P   P i 1   i  i i i i i i i i i i - if (Rs!=#0) jump:t #r13:2
 0  1  1  0 0  0   0 1  0  1   i  s  s  s  s  s  P   P i 0   i  i i i i i i i i i i - if (Rs>=#0) jump:nt #r13:2
 0  1  1  0 0  0   0 1  0  1   i  s  s  s  s  s  P   P i 1   i  i i i i i i i i i i - if (Rs>=#0) jump:t #r13:2
 0  1  1  0 0  0   0 1  1  0   i  s  s  s  s  s  P   P i 0   i  i i i i i i i i i i - if (Rs==#0) jump:nt #r13:2
 0  1  1  0 0  0   0 1  1  0   i  s  s  s  s  s  P   P i 1   i  i i i i i i i i i i - if (Rs==#0) jump:t #r13:2
 0  1  1  0 0  0   0 1  1  1   i  s  s  s  s  s  P   P i 0   i  i i i i i i i i i i - if (Rs<=#0) jump:nt #r13:2
 0  1  1  0 0  0   0 1  1  1   i  s  s  s  s  s  P   P i 1   i  i i i i i i i i i i - if (Rs<=#0) jump:t #r13:2
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                             235
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
          Transfer and jump
                  Move an unsigned immediate or register value into a destination register and
                  unconditionally jump. In assembly syntax, this instruction appears as two instructions in
                  the packet, a transfer and a separate jump. The assembler may convert adjacent transfer
                  and jump instructions into compound transfer-jump form.
                   Syntax                                   Behavior
                   Rd=#U6 ; jump #r9:2                      apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            Rd=#U;
                                                            PC=PC+#r;
                   Rd=Rs ; jump #r9:2                       apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            Rd=Rs;
                                                            PC=PC+#r;
                  Class: J (slots 2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7 6 5 4 3 2 1 0
   ICLASS                                 d4     Parse
 0  0  0  1 0  1   1 0   -  -  i  i  d  d    d d P   P I  I   I I    I I i i i i i i i - Rd=#U6 ; jump #r9:2
   ICLASS                                 s4     Parse            d4
 0  0  0  1 0  1   1 1   -  -  i  i  s  s    s s P   P -  -  d  d   d  d i i i i i i i - Rd=Rs ; jump #r9:2
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d4                Field to encode register d
                  s4                Field to encode register s
80-N2040-45 Rev. B                                                                                            236
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
     11.5         LD
                  The LD instruction class includes load instructions, which are used to load values into
                  registers.
                  LD instructions are executable on slot 0 and slot 1.
        Load doubleword
                  Load a 64-bit doubleword from memory and place in a destination register pair.
                   Syntax                             Behavior
                   Rdd=memd(Re=#U6)                    apply_extension(#U);
                                                       EA=#U;
                                                       Rdd = *EA;
                                                       Re=#U;
                   Rdd=memd(Rs+#s11:3)                 apply_extension(#s);
                                                       EA=Rs+#s;
                                                       Rdd = *EA;
                   Rdd=memd(Rs+Rt<<#u2)                EA=Rs+(Rt<<#u);
                                                       Rdd = *EA;
                   Rdd=memd(Rt<<#u2+#U6)               apply_extension(#U);
                                                       EA=#U+(Rt<<#u);
                                                       Rdd = *EA;
                   Rdd=memd(Rx++#s4:3)                 EA=Rx;
                                                       Rx=Rx+#s;
                                                       Rdd = *EA;
                   Rdd=memd(Rx++#s4:3:circ(Mu))        EA=Rx;
                                                       Rx=Rx=circ_add(Rx,#s,MuV);
                                                       Rdd = *EA;
                   Rdd=memd(Rx++I:circ(Mu))            EA=Rx;
                                                       Rx=Rx=circ_add(Rx,I<<3,MuV);
                                                       Rdd = *EA;
                   Rdd=memd(Rx++Mu)                    EA=Rx;
                                                       Rx=Rx+MuV;
                                                       Rdd = *EA;
                   Rdd=memd(Rx++Mu:brev)               EA=Rx.h[1] | brev(Rx.h[0]);
                                                       Rx=Rx+MuV;
                                                       Rdd = *EA;
                   Rdd=memd(gp+#u16:3)                 apply_extension(#u);
                                                       EA=(Constant_extended ? (0) : GP)+#u;
                                                       Rdd = *EA;
80-N2040-45 Rev. B                                                                                          237
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Class: LD (slots 0,1)
                  Intrinsics
                   Rdd=memd(Rx++#s4:3:circ(Mu))             Word32 Q6_R_memd_IM_circ(void** StartAddress,
                                                            Word32 Is4_3, Word32 Mu, void* BaseAddress)
                   Rdd=memd(Rx++I:circ(Mu))                 Word32 Q6_R_memd_M_circ(void** StartAddress,
                                                            Word32 Mu, void* BaseAddress)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS                              s5        Parse          t5                 d5
 0  0  1  1 1  0   1  0  1   1 0  s  s  s  s  s  P   P  i t   t  t t t  i -  - d d  d d  d Rdd=memd(Rs+Rt<<#u2)
                               U
   ICLASS                 Type N                 Parse                             d5
 0  1  0  0 1   i   i 1  1   1 0  i  i   i  i  i P   P  i i   i  i i i  i i  i d d  d d  d Rdd=memd(gp+#u16:3)
                               U
   ICLASS    Amode      Type   N       s5        Parse                             d5
 1  0  0  1 0   i   i 1  1   1 0  s  s  s  s  s  P   P  i i   i  i i i  i i  i d d  d d  d Rdd=memd(Rs+#s11:3)
                               U
   ICLASS    Amode      Type           x5        Parse u1                          d5
                               N
 1  0  0  1 1  0   0  1  1   1 0  x  x  x  x  x  P   P u 0    -  - 0 i  i i  i d d  d d  d Rdd=memd(Rx++#s4:3:circ
                                                                                           (Mu))
 1  0  0  1 1  0   0  1  1   1 0  x  x  x  x  x  P   P u 0    -  - 1 - 0  -  - d d  d d  d Rdd=memd(Rx++I:circ(Mu)
                                                                                           )
                               U
   ICLASS    Amode      Type           e5        Parse                             d5
                               N
 1  0  0  1 1  0   1  1  1   1 0  e  e  e  e  e  P   P 0  1   I  I I I  - I  I d d  d d  d Rdd=memd(Re=#U6)
                               U
   ICLASS    Amode      Type           x5        Parse                             d5
                               N
 1  0  0  1 1  0   1  1  1   1 0  x  x  x  x  x  P   P 0  0   -  - - i  i i  i d d  d d  d Rdd=memd(Rx++#s4:3)
                               U
   ICLASS    Amode      Type            t5       Parse                             d5
                               N
 1  0  0  1 1  1   0  1  1   1 0  t  t   t  t  t P   P  i 1   I  I I I  i I  I d d  d d  d Rdd=memd(Rt<<#u2+#U6)
                               U
   ICLASS    Amode      Type           x5        Parse u1                          d5
                               N
 1  0  0  1 1  1   0  1  1   1 0  x  x  x  x  x  P   P u 0    -  - - - 0  -  - d d  d d  d Rdd=memd(Rx++Mu)
 1  0  0  1 1  1   1  1  1   1 0  x  x  x  x  x  P   P u 0    -  - - - 0  -  - d d  d d  d Rdd=memd(Rx++Mu:brev)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  e5                Field to encode register e
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                             238
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  t5           Field to encode register t
                  u1           Field to encode register u
                  x5           Field to encode register x
80-N2040-45 Rev. B                                                    239
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Load doubleword conditionally
                  Load a 64-bit doubleword from memory and place in a destination register pair.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                                   Behavior
                   if ([!]Pt[.new]) Rdd=memd(#u6)           apply_extension(#u);
                                                            EA=#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rdd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         apply_extension(#u);
                   Rdd=memd(Rs+#u6:3)                       EA=Rs+#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rdd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         EA=Rx;
                   Rdd=memd(Rx++#s4:3)                      if([!]Pt[.new][0]){
                                                                  Rx=Rx+#s;
                                                                  Rdd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pv[.new])                         EA=Rs+(Rt<<#u);
                   Rdd=memd(Rs+Rt<<#u2)                     if ([!]Pv[.new][0]) {
                                                                  Rdd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                  Class: LD (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6 5 4 3 2  1 0
   ICLASS                              s5       Parse            t5                 d5
                                                                                         d ifRdd=memd(Rs+Rt<<#u2)
                                                                                              (Pv)
 0  0  1  1 0  0   0  0 1   1 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d
                                                                                           if (!Pv)
 0  0  1  1 0  0   0  1 1   1 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d d Rdd=memd(Rs+Rt<<#u2)
                                                                                         d ifRdd=memd(Rs+Rt<<#u2)
                                                                                              (Pv.new)
 0  0  1  1 0  0   1  0 1   1 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d
                                                                                         d ifRdd=memd(Rs+Rt<<#u2)
                                                                                              (!Pv.new)
 0  0  1  1 0  0   1  1 1   1 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d
                   Pr
               Se ed
   ICLASS      ns Ne     Type U        s5       Parse       t2                      d5
                              N
                e w
                                                                                         d ifRdd=memd(Rs+#u6:3)
                                                                                              (Pt)
 0  1  0  0 0  0   0  1 1   1 0   s  s  s  s  s P   P 0   t    t  i i  i i  i i d d d  d
80-N2040-45 Rev. B                                                                                                240
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7 6 5 4 3 2  1 0
                                                                                          if (Pt.new)
 0  1  0  0 0  0   1 1  1   1 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rdd=memd(Rs+#u6:3)
                                                                                          if (!Pt)
 0  1  0  0 0  1   0 1  1   1 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rdd=memd(Rs+#u6:3)
                                                                                          if (!Pt.new)
 0  1  0  0 0  1   1 1  1   1 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rdd=memd(Rs+#u6:3)
                              U
   ICLASS    Amode     Type   N        x5        Parse            t2               d5
                                                                                          if (Pt)
 1  0  0  1 1  0   1 1  1   1 0   x  x  x  x  x  P   P 1 0   0  t    t i i i i d d d  d d
                                                                                          Rdd=memd(Rx++#s4:3)
 1  0  0  1 1  0   1 1  1   1 0   x  x  x  x  x  P   P 1 0   1  t    t i i i i d d d  d d if (!Pt)
                                                                                          Rdd=memd(Rx++#s4:3)
                                                                                          if (Pt.new)
 1  0  0  1 1  0   1 1  1   1 0   x  x  x  x  x  P   P 1 1   0  t    t i i i i d d d  d d
                                                                                          Rdd=memd(Rx++#s4:3)
                                                                                          if (!Pt.new)
 1  0  0  1 1  0   1 1  1   1 0   x  x  x  x  x  P   P 1 1   1  t    t i i i i d d d  d d
                                                                                          Rdd=memd(Rx++#s4:3)
                              U
   ICLASS    Amode     Type                      Parse            t2               d5
                              N
 1  0  0  1 1  1   1 1  1   1 0   i  i  i   i  i P   P 1 0   0  t    t i 1 - - d d d  d d if (Pt) Rdd=memd(#u6)
 1  0  0  1 1  1   1 1  1   1 0   i  i  i   i  i P   P 1 0   1  t    t i 1 - - d d d  d d if (!Pt) Rdd=memd(#u6)
 1  0  0  1 1  1   1 1  1   1 0   i  i  i   i  i P   P 1 1   0  t    t i 1 - - d d d  d d if (Pt.new) Rdd=memd(#u6)
                                                                                        d ifRdd=memd(#u6)
                                                                                             (!Pt.new)
 1  0  0  1 1  1   1 1  1   1 0   i  i  i   i  i P   P 1 1   1  t    t i 1 - - d d d  d
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t2                Field to encode register t
                  t5                Field to encode register t
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               241
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
        Load byte
                  Load a signed byte from memory. The byte at the effective address in memory is placed in
                  the least-significant 8 bits of the destination register. The destination register is then sign-
                  extended from 8 bits to 32.
                   Syntax                                Behavior
                   Rd=memb(Re=#U6)                        apply_extension(#U);
                                                          EA=#U;
                                                          Rd = *EA;
                                                          Re=#U;
                   Rd=memb(Rs+#s11:0)                     apply_extension(#s);
                                                          EA=Rs+#s;
                                                          Rd = *EA;
                   Rd=memb(Rs+Rt<<#u2)                    EA=Rs+(Rt<<#u);
                                                          Rd = *EA;
                   Rd=memb(Rt<<#u2+#U6)                   apply_extension(#U);
                                                          EA=#U+(Rt<<#u);
                                                          Rd = *EA;
                   Rd=memb(Rx++#s4:0)                     EA=Rx;
                                                          Rx=Rx+#s;
                                                          Rd = *EA;
                   Rd=memb(Rx++#s4:0:circ(Mu))            EA=Rx;
                                                          Rx=Rx=circ_add(Rx,#s,MuV);
                                                          Rd = *EA;
                   Rd=memb(Rx++I:circ(Mu))                EA=Rx;
                                                          Rx=Rx=circ_add(Rx,I<<0,MuV);
                                                          Rd = *EA;
                   Rd=memb(Rx++Mu)                        EA=Rx;
                                                          Rx=Rx+MuV;
                                                          Rd = *EA;
                   Rd=memb(Rx++Mu:brev)                   EA=Rx.h[1] | brev(Rx.h[0]);
                                                          Rx=Rx+MuV;
                                                          Rd = *EA;
                   Rd=memb(gp+#u16:0)                     apply_extension(#u);
                                                          EA=(Constant_extended ? (0) : GP)+#u;
                                                          Rd = *EA;
                  Class: LD (slots 0,1)
                  Intrinsics
                   Rd=memb(Rx++#s4:0:circ(Mu))           Word32 Q6_R_memb_IM_circ(void** StartAddress,
                                                         Word32 Is4_0, Word32 Mu, void* BaseAddress)
                   Rd=memb(Rx++I:circ(Mu))               Word32 Q6_R_memb_M_circ(void** StartAddress,
                                                         Word32 Mu, void* BaseAddress)
80-N2040-45 Rev. B                                                                                               242
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2  1 0
   ICLASS                              s5        Parse          t5               d5
 0  0  1  1 1  0   1  0  0   0 0  s  s  s  s  s  P   P  i t   t  t t t i - - d d d  d d Rd=memb(Rs+Rt<<#u2)
   ICLASS                 Type U                 Parse                           d5
                               N
 0  1  0  0 1   i   i 1  0   0 0  i  i   i  i  i P   P  i i   i  i i i i i i d d d  d d Rd=memb(gp+#u16:0)
   ICLASS    Amode      Type   U       s5        Parse                           d5
                               N
 1  0  0  1 0   i   i 1  0   0 0  s  s  s  s  s  P   P  i i   i  i i i i i i d d d  d d Rd=memb(Rs+#s11:0)
                               U
   ICLASS    Amode      Type           x5        Parse u1                        d5
                               N
                                                                                        Rd=memb(Rx++#s4:0:circ(
 1  0  0  1 1  0   0  1  0   0 0  x  x  x  x  x  P   P u 0    -  - 0 i i i i d d d  d d
                                                                                        Mu))
 1  0  0  1 1  0   0  1  0   0 0  x  x  x  x  x  P   P u 0    -  - 1 - 0 - - d d d  d d Rd=memb(Rx++I:circ(Mu))
                               U
   ICLASS    Amode      Type           e5        Parse                           d5
                               N
 1  0  0  1 1  0   1  1  0   0 0  e  e  e  e  e  P   P 0  1   I  I I I - I I d d d  d d Rd=memb(Re=#U6)
                               U
   ICLASS    Amode      Type           x5        Parse                           d5
                               N
 1  0  0  1 1  0   1  1  0   0 0  x  x  x  x  x  P   P 0  0   -  - - i i i i d d d  d d Rd=memb(Rx++#s4:0)
                               U
   ICLASS    Amode      Type            t5       Parse                           d5
                               N
 1  0  0  1 1  1   0  1  0   0 0  t  t   t  t  t P   P  i 1   I  I I I i I I d d d  d d Rd=memb(Rt<<#u2+#U6)
                               U
   ICLASS    Amode      Type           x5        Parse u1                        d5
                               N
 1  0  0  1 1  1   0  1  0   0 0  x  x  x  x  x  P   P u 0    -  - - - 0 - - d d d  d d Rd=memb(Rx++Mu)
 1  0  0  1 1  1   1  1  0   0 0  x  x  x  x  x  P   P u 0    -  - - - 0 - - d d d  d d Rd=memb(Rx++Mu:brev)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                          243
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
          Load byte conditionally
                  Load a signed byte from memory. The byte at the effective address in memory is placed in
                  the least-significant 8 bits of the destination register. The destination register is then sign-
                  extended from 8 bits to 32.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                                   Behavior
                   if ([!]Pt[.new]) Rd=memb(#u6)            apply_extension(#u);
                                                            EA=#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         apply_extension(#u);
                   Rd=memb(Rs+#u6:0)                        EA=Rs+#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         EA=Rx;
                   Rd=memb(Rx++#s4:0)                       if([!]Pt[.new][0]){
                                                                  Rx=Rx+#s;
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pv[.new])                         EA=Rs+(Rt<<#u);
                   Rd=memb(Rs+Rt<<#u2)                      if ([!]Pv[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                  Class: LD (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6 5 4 3  2  1 0
   ICLASS                              s5       Parse            t5                  d5
                                                                                             if (Pv)
 0  0  1  1 0  0   0  0 0   0 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d  d  d d Rd=memb(Rs+Rt<<#u2)
                                                                                          d ifRd=memb(Rs+Rt<<#u2)
                                                                                                (!Pv)
 0  0  1  1 0  0   0  1 0   0 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d  d  d
                                                                                          d ifRd=memb(Rs+Rt<<#u2)
                                                                                                (Pv.new)
 0  0  1  1 0  0   1  0 0   0 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d  d  d
                                                                                             if (!Pv.new)
 0  0  1  1 0  0   1  1 0   0 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d  d  d d Rd=memb(Rs+Rt<<#u2)
                   Pr
               Se
                  ed          U
   ICLASS      ns        Type          s5       Parse       t2                       d5
                  Ne          N
                e  w
80-N2040-45 Rev. B                                                                                                  244
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7 6 5 4 3 2  1 0
 0  1  0  0 0  0   0 1  0   0 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d if (Pt) Rd=memb(Rs+#u6:0)
                                                                                          if (Pt.new)
 0  1  0  0 0  0   1 1  0   0 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memb(Rs+#u6:0)
                                                                                          if (!Pt)
 0  1  0  0 0  1   0 1  0   0 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memb(Rs+#u6:0)
                                                                                          if (!Pt.new)
 0  1  0  0 0  1   1 1  0   0 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memb(Rs+#u6:0)
                              U
   ICLASS    Amode     Type            x5        Parse            t2               d5
                              N
 1  0  0  1 1  0   1 1  0   0 0   x  x  x  x  x  P   P 1 0   0  t    t i i i i d d d  d d if (Pt)
                                                                                          Rd=memb(Rx++#s4:0)
 1  0  0  1 1  0   1 1  0   0 0   x  x  x  x  x  P   P 1 0   1  t    t i i i i d d d  d d if (!Pt)
                                                                                          Rd=memb(Rx++#s4:0)
 1  0  0  1 1  0   1 1  0   0 0   x  x  x  x  x  P   P 1 1   0  t    t i i i i d d d  d d if (Pt.new)
                                                                                          Rd=memb(Rx++#s4:0)
                                                                                          if (!Pt.new)
 1  0  0  1 1  0   1 1  0   0 0   x  x  x  x  x  P   P 1 1   1  t    t i i i i d d d  d d
                                                                                          Rd=memb(Rx++#s4:0)
                              U
   ICLASS    Amode     Type                      Parse            t2               d5
                              N
 1  0  0  1 1  1   1 1  0   0 0   i  i  i   i  i P   P 1 0   0  t    t i 1 - - d d d  d d if (Pt) Rd=memb(#u6)
 1  0  0  1 1  1   1 1  0   0 0   i  i  i   i  i P   P 1 0   1  t    t i 1 - - d d d  d d if (!Pt) Rd=memb(#u6)
 1  0  0  1 1  1   1 1  0   0 0   i  i  i   i  i P   P 1 1   0  t    t i 1 - - d d d  d d if (Pt.new) Rd=memb(#u6)
 1  0  0  1 1  1   1 1  0   0 0   i  i  i   i  i P   P 1 1   1  t    t i 1 - - d d d  d d if (!Pt.new) Rd=memb(#u6)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t2                Field to encode register t
                  t5                Field to encode register t
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               245
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
        Load byte into shifted vector
                  Shift a 64-bit vector right by one byte. Insert a byte from memory into the vacated upper
                  byte of the vector.
                    Mem
                                                                     Ryy
                                                          Ryy
                   Syntax                               Behavior
                   Ryy=memb_fifo(Re=#U6)                apply_extension(#U);
                                                        EA=#U;
                                                        {
                                                             tmpV = *EA;
                                                             Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                        }
                                                        ;
                                                        Re=#U;
                   Ryy=memb_fifo(Rs)                    Assembler mapped to: "Ryy=memb_fifo""(Rs+#0)"
                   Ryy=memb_fifo(Rs+#s11:0)             apply_extension(#s);
                                                        EA=Rs+#s;
                                                        {
                                                             tmpV = *EA;
                                                             Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                        }
                                                        ;
                   Ryy=memb_fifo(Rt<<#u2+#U6)           apply_extension(#U);
                                                        EA=#U+(Rt<<#u);
                                                        {
                                                             tmpV = *EA;
                                                             Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                        }
                                                        ;
80-N2040-45 Rev. B                                                                                          246
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                   Syntax                                   Behavior
                   Ryy=memb_fifo(Rx++#s4:0)                 EA=Rx;
                                                            Rx=Rx+#s;
                                                            {
                                                                tmpV = *EA;
                                                                Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                            }
                                                            ;
                   Ryy=memb_fifo(Rx++#s4:0:circ(Mu          EA=Rx;
                   ))                                       Rx=Rx=circ_add(Rx,#s,MuV);
                                                            {
                                                                tmpV = *EA;
                                                                Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                            }
                                                            ;
                   Ryy=memb_fifo(Rx++I:circ(Mu))            EA=Rx;
                                                            Rx=Rx=circ_add(Rx,I<<0,MuV);
                                                            {
                                                                tmpV = *EA;
                                                                Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                            }
                                                            ;
                   Ryy=memb_fifo(Rx++Mu)                    EA=Rx;
                                                            Rx=Rx+MuV;
                                                            {
                                                                tmpV = *EA;
                                                                Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                            }
                                                            ;
                   Ryy=memb_fifo(Rx++Mu:brev)               EA=Rx.h[1] | brev(Rx.h[0]);
                                                            Rx=Rx+MuV;
                                                            {
                                                                tmpV = *EA;
                                                                Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
                                                            }
                                                            ;
                  Class: LD (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1  0
                               U
   ICLASS    Amode      Type   N       s5       Parse                              y5
 1  0  0  1 0   i   i 0  1   0 0  s  s  s  s  s P   P  i  i   i i  i i i  i i  y y y  y  y Ryy=memb_fifo(Rs+#s11:0
                                                                                           )
                               U
   ICLASS    Amode      Type           x5       Parse u1                           y5
                               N
 1  0  0  1 1  0   0  0  1   0 0  x  x  x  x  x P   P u 0     - -  0 i i  i i  y y y  y  y Ryy=memb_fifo(Rx++#s4:0
                                                                                           :circ(Mu))
 1  0  0  1 1  0   0  0  1   0 0  x  x  x  x  x P   P u 0     - -  1 - 0  - -  y y y  y  y Ryy=memb_fifo(Rx++I:circ(
                                                                                           Mu))
                               U
   ICLASS    Amode      Type           e5       Parse                              y5
                               N
 1  0  0  1 1  0   1  0  1   0 0  e  e  e  e  e P   P 0  1    I I  I I -  I I  y y y  y  y Ryy=memb_fifo(Re=#U6)
                               U
   ICLASS    Amode      Type           x5       Parse                              y5
                               N
80-N2040-45 Rev. B                                                                                                247
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2  1 0
                                                                                       Ryy=memb_fifo(Rx++#s4:0
 1  0  0  1 1  0   1 0  1   0 0   x  x  x  x  x  P   P 0  0   - - - i i i i y y y  y y
                                                                                       )
                              U
   ICLASS    Amode     Type             t5       Parse                          y5
                              N
                                                                                       Ryy=memb_fifo(Rt<<#u2+#
 1  0  0  1 1  1   0 0  1   0 0   t  t   t  t  t P   P  i 1   I I I I i I I y y y  y y
                                                                                       U6)
                              U
   ICLASS    Amode     Type   N        x5        Parse u1                       y5
 1  0  0  1 1  1   0 0  1   0 0   x  x  x  x  x  P   P u 0    - - - - 0 - - y y y  y y Ryy=memb_fifo(Rx++Mu)
                                                                                       Ryy=memb_fifo(Rx++Mu:br
 1  0  0  1 1  1   1 0  1   0 0   x  x  x  x  x  P   P u 0    - - - - 0 - - y y y  y y ev)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  x5                Field to encode register x
                  y5                Field to encode register y
80-N2040-45 Rev. B                                                                                         248
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
        Load half into shifted vector
                  Shift a 64-bit vector right by one halfword. Insert a halfword from memory into the
                  vacated upper halfword of the vector.
                     Mem
                                                                     Ryy
                                                         Ryy
                   Syntax                               Behavior
                   Ryy=memh_fifo(Re=#U6)                apply_extension(#U);
                                                        EA=#U;
                                                        {
                                                             tmpV = *EA;
                                                             Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                        }
                                                        ;
                                                        Re=#U;
                   Ryy=memh_fifo(Rs)                    Assembler mapped to: "Ryy=memh_fifo""(Rs+#0)"
                   Ryy=memh_fifo(Rs+#s11:1)             apply_extension(#s);
                                                        EA=Rs+#s;
                                                        {
                                                             tmpV = *EA;
                                                             Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                        }
                                                        ;
                   Ryy=memh_fifo(Rt<<#u2+#U6)           apply_extension(#U);
                                                        EA=#U+(Rt<<#u);
                                                        {
                                                             tmpV = *EA;
                                                             Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                        }
                                                        ;
80-N2040-45 Rev. B                                                                                        249
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                   Syntax                                   Behavior
                   Ryy=memh_fifo(Rx++#s4:1)                 EA=Rx;
                                                            Rx=Rx+#s;
                                                            {
                                                                tmpV = *EA;
                                                                Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                            }
                                                            ;
                   Ryy=memh_fifo(Rx++#s4:1:circ(Mu          EA=Rx;
                   ))                                       Rx=Rx=circ_add(Rx,#s,MuV);
                                                            {
                                                                tmpV = *EA;
                                                                Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                            }
                                                            ;
                   Ryy=memh_fifo(Rx++I:circ(Mu))            EA=Rx;
                                                            Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                            {
                                                                tmpV = *EA;
                                                                Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                            }
                                                            ;
                   Ryy=memh_fifo(Rx++Mu)                    EA=Rx;
                                                            Rx=Rx+MuV;
                                                            {
                                                                tmpV = *EA;
                                                                Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                            }
                                                            ;
                   Ryy=memh_fifo(Rx++Mu:brev)               EA=Rx.h[1] | brev(Rx.h[0]);
                                                            Rx=Rx+MuV;
                                                            {
                                                                tmpV = *EA;
                                                                Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
                                                            }
                                                            ;
                  Class: LD (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1  0
                               U
   ICLASS    Amode      Type   N       s5       Parse                              y5
 1  0  0  1 0   i   i 0  0   1 0  s  s  s  s  s P   P  i  i   i i  i i i  i i  y y y  y  y Ryy=memh_fifo(Rs+#s11:1
                                                                                           )
                               U
   ICLASS    Amode      Type           x5       Parse u1                           y5
                               N
 1  0  0  1 1  0   0  0  0   1 0  x  x  x  x  x P   P u 0     - -  0 i i  i i  y y y  y  y Ryy=memh_fifo(Rx++#s4:1
                                                                                           :circ(Mu))
 1  0  0  1 1  0   0  0  0   1 0  x  x  x  x  x P   P u 0     - -  1 - 0  - -  y y y  y  y Ryy=memh_fifo(Rx++I:circ(
                                                                                           Mu))
                               U
   ICLASS    Amode      Type           e5       Parse                              y5
                               N
 1  0  0  1 1  0   1  0  0   1 0  e  e  e  e  e P   P 0  1    I I  I I -  I I  y y y  y  y Ryy=memh_fifo(Re=#U6)
                               U
   ICLASS    Amode      Type           x5       Parse                              y5
                               N
80-N2040-45 Rev. B                                                                                                250
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2  1 0
                                                                                       Ryy=memh_fifo(Rx++#s4:1
 1  0  0  1 1  0   1 0  0   1 0   x  x  x  x  x  P   P 0  0   - - - i i i i y y y  y y
                                                                                       )
                              U
   ICLASS    Amode     Type             t5       Parse                          y5
                              N
                                                                                       Ryy=memh_fifo(Rt<<#u2+#
 1  0  0  1 1  1   0 0  0   1 0   t  t   t  t  t P   P  i 1   I I I I i I I y y y  y y
                                                                                       U6)
                              U
   ICLASS    Amode     Type   N        x5        Parse u1                       y5
 1  0  0  1 1  1   0 0  0   1 0   x  x  x  x  x  P   P u 0    - - - - 0 - - y y y  y y Ryy=memh_fifo(Rx++Mu)
                                                                                       Ryy=memh_fifo(Rx++Mu:br
 1  0  0  1 1  1   1 0  0   1 0   x  x  x  x  x  P   P u 0    - - - - 0 - - y y y  y y ev)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  x5                Field to encode register x
                  y5                Field to encode register y
80-N2040-45 Rev. B                                                                                         251
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Load halfword
                  Load a signed halfword from memory. The 16-bit halfword at the effective address in
                  memory is placed in the least-significant 16 bits of the destination register. The destination
                  register is then sign-extended from 16 bits to 32.
                   Syntax                              Behavior
                   Rd=memh(Re=#U6)                      apply_extension(#U);
                                                        EA=#U;
                                                        Rd = *EA;
                                                        Re=#U;
                   Rd=memh(Rs+#s11:1)                   apply_extension(#s);
                                                        EA=Rs+#s;
                                                        Rd = *EA;
                   Rd=memh(Rs+Rt<<#u2)                  EA=Rs+(Rt<<#u);
                                                        Rd = *EA;
                   Rd=memh(Rt<<#u2+#U6)                 apply_extension(#U);
                                                        EA=#U+(Rt<<#u);
                                                        Rd = *EA;
                   Rd=memh(Rx++#s4:1)                   EA=Rx;
                                                        Rx=Rx+#s;
                                                        Rd = *EA;
                   Rd=memh(Rx++#s4:1:circ(Mu))          EA=Rx;
                                                        Rx=Rx=circ_add(Rx,#s,MuV);
                                                        Rd = *EA;
                   Rd=memh(Rx++I:circ(Mu))              EA=Rx;
                                                        Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                        Rd = *EA;
                   Rd=memh(Rx++Mu)                      EA=Rx;
                                                        Rx=Rx+MuV;
                                                        Rd = *EA;
                   Rd=memh(Rx++Mu:brev)                 EA=Rx.h[1] | brev(Rx.h[0]);
                                                        Rx=Rx+MuV;
                                                        Rd = *EA;
                   Rd=memh(gp+#u16:1)                   apply_extension(#u);
                                                        EA=(Constant_extended ? (0) : GP)+#u;
                                                        Rd = *EA;
                  Class: LD (slots 0,1)
                  Intrinsics
                   Rd=memh(Rx++#s4:1:circ(Mu))         Word32 Q6_R_memh_IM_circ(void** StartAddress,
                                                       Word32 Is4_1, Word32 Mu, void* BaseAddress)
                   Rd=memh(Rx++I:circ(Mu))             Word32 Q6_R_memh_M_circ(void** StartAddress,
                                                       Word32 Mu, void* BaseAddress)
80-N2040-45 Rev. B                                                                                             252
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2  1 0
   ICLASS                              s5        Parse          t5               d5
 0  0  1  1 1  0   1  0  0   1 0  s  s  s  s  s  P   P  i t   t  t t t i - - d d d  d d Rd=memh(Rs+Rt<<#u2)
   ICLASS                 Type U                 Parse                           d5
                               N
 0  1  0  0 1   i   i 1  0   1 0  i  i   i  i  i P   P  i i   i  i i i i i i d d d  d d Rd=memh(gp+#u16:1)
   ICLASS    Amode      Type   U       s5        Parse                           d5
                               N
 1  0  0  1 0   i   i 1  0   1 0  s  s  s  s  s  P   P  i i   i  i i i i i i d d d  d d Rd=memh(Rs+#s11:1)
                               U
   ICLASS    Amode      Type           x5        Parse u1                        d5
                               N
                                                                                        Rd=memh(Rx++#s4:1:circ(
 1  0  0  1 1  0   0  1  0   1 0  x  x  x  x  x  P   P u 0    -  - 0 i i i i d d d  d d
                                                                                        Mu))
 1  0  0  1 1  0   0  1  0   1 0  x  x  x  x  x  P   P u 0    -  - 1 - 0 - - d d d  d d Rd=memh(Rx++I:circ(Mu))
                               U
   ICLASS    Amode      Type           e5        Parse                           d5
                               N
 1  0  0  1 1  0   1  1  0   1 0  e  e  e  e  e  P   P 0  1   I  I I I - I I d d d  d d Rd=memh(Re=#U6)
                               U
   ICLASS    Amode      Type           x5        Parse                           d5
                               N
 1  0  0  1 1  0   1  1  0   1 0  x  x  x  x  x  P   P 0  0   -  - - i i i i d d d  d d Rd=memh(Rx++#s4:1)
                               U
   ICLASS    Amode      Type            t5       Parse                           d5
                               N
 1  0  0  1 1  1   0  1  0   1 0  t  t   t  t  t P   P  i 1   I  I I I i I I d d d  d d Rd=memh(Rt<<#u2+#U6)
                               U
   ICLASS    Amode      Type           x5        Parse u1                        d5
                               N
 1  0  0  1 1  1   0  1  0   1 0  x  x  x  x  x  P   P u 0    -  - - - 0 - - d d d  d d Rd=memh(Rx++Mu)
 1  0  0  1 1  1   1  1  0   1 0  x  x  x  x  x  P   P u 0    -  - - - 0 - - d d d  d d Rd=memh(Rx++Mu:brev)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                          253
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          Load halfword conditionally
                  Load a signed halfword from memory. The 16-bit halfword at the effective address in
                  memory is placed in the least-significant 16 bits of the destination register. The destination
                  register is then sign-extended from 16 bits to 32.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                                   Behavior
                   if ([!]Pt[.new]) Rd=memh(#u6)            apply_extension(#u);
                                                            EA=#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         apply_extension(#u);
                   Rd=memh(Rs+#u6:1)                        EA=Rs+#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         EA=Rx;
                   Rd=memh(Rx++#s4:1)                       if([!]Pt[.new][0]){
                                                                  Rx=Rx+#s;
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pv[.new])                         EA=Rs+(Rt<<#u);
                   Rd=memh(Rs+Rt<<#u2)                      if ([!]Pv[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                  Class: LD (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6 5 4 3 2  1 0
   ICLASS                              s5       Parse            t5                 d5
                                                                                            if (Pv)
 0  0  1  1 0  0   0  0 0   1  0  s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d d Rd=memh(Rs+Rt<<#u2)
                                                                                         d ifRd=memh(Rs+Rt<<#u2)
                                                                                               (!Pv)
 0  0  1  1 0  0   0  1 0   1  0  s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d
                                                                                         d ifRd=memh(Rs+Rt<<#u2)
                                                                                               (Pv.new)
 0  0  1  1 0  0   1  0 0   1  0  s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d
                                                                                            if (!Pv.new)
 0  0  1  1 0  0   1  1 0   1  0  s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d d Rd=memh(Rs+Rt<<#u2)
                   Pr
               Se
                  ed           U
   ICLASS      ns        Type          s5       Parse       t2                      d5
                  Ne           N
                e  w
80-N2040-45 Rev. B                                                                                                 254
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7 6 5 4 3 2  1 0
 0  1  0  0 0  0   0 1  0   1 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d if (Pt) Rd=memh(Rs+#u6:1)
                                                                                          if (Pt.new)
 0  1  0  0 0  0   1 1  0   1 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memh(Rs+#u6:1)
                                                                                          if (!Pt)
 0  1  0  0 0  1   0 1  0   1 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memh(Rs+#u6:1)
                                                                                          if (!Pt.new)
 0  1  0  0 0  1   1 1  0   1 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memh(Rs+#u6:1)
                              U
   ICLASS    Amode     Type            x5        Parse            t2               d5
                              N
 1  0  0  1 1  0   1 1  0   1 0   x  x  x  x  x  P   P 1 0   0  t    t i i i i d d d  d d if (Pt)
                                                                                          Rd=memh(Rx++#s4:1)
 1  0  0  1 1  0   1 1  0   1 0   x  x  x  x  x  P   P 1 0   1  t    t i i i i d d d  d d if (!Pt)
                                                                                          Rd=memh(Rx++#s4:1)
 1  0  0  1 1  0   1 1  0   1 0   x  x  x  x  x  P   P 1 1   0  t    t i i i i d d d  d d if (Pt.new)
                                                                                          Rd=memh(Rx++#s4:1)
                                                                                          if (!Pt.new)
 1  0  0  1 1  0   1 1  0   1 0   x  x  x  x  x  P   P 1 1   1  t    t i i i i d d d  d d
                                                                                          Rd=memh(Rx++#s4:1)
                              U
   ICLASS    Amode     Type                      Parse            t2               d5
                              N
 1  0  0  1 1  1   1 1  0   1 0   i  i  i   i  i P   P 1 0   0  t    t i 1 - - d d d  d d if (Pt) Rd=memh(#u6)
 1  0  0  1 1  1   1 1  0   1 0   i  i  i   i  i P   P 1 0   1  t    t i 1 - - d d d  d d if (!Pt) Rd=memh(#u6)
 1  0  0  1 1  1   1 1  0   1 0   i  i  i   i  i P   P 1 1   0  t    t i 1 - - d d d  d d if (Pt.new) Rd=memh(#u6)
 1  0  0  1 1  1   1 1  0   1 0   i  i  i   i  i P   P 1 1   1  t    t i 1 - - d d d  d d if (!Pt.new) Rd=memh(#u6)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t2                Field to encode register t
                  t5                Field to encode register t
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               255
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
        Memory Copy
                  Copy Mu + 1 (length) bytes from the address in Rt (source base) to the address in Rs
                  (destination base). The source base, destination base, and length values must be aligned to
                  the L2 cache-line size. Behavior is undefined for non-aligned values and for source or
                  destination buffers partially in illegal space.
                  In addition to normal translation exceptions, a coprocessor memory exception occurs if
                  any of the following are true:
                       ■   Source or destination base address in illegal space
                       ■   Source or destination buffer crosses a page boundary
                       ■   Source or destination base address are NOT in VTCM
                  This instruction is only available on cores with VTCM.
                   Syntax                                Behavior
                  Class: N/A
80-N2040-45 Rev. B                                                                                          256
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Load unsigned byte
                  Load an unsigned byte from memory. The byte at the effective address in memory is
                  placed in the least-significant 8 bits of the destination register. The destination register is
                  then zero-extended from 8 bits to 32.
                   Syntax                                Behavior
                   Rd=memub(Re=#U6)                      apply_extension(#U);
                                                         EA=#U;
                                                         Rd = *EA;
                                                         Re=#U;
                   Rd=memub(Rs+#s11:0)                   apply_extension(#s);
                                                         EA=Rs+#s;
                                                         Rd = *EA;
                   Rd=memub(Rs+Rt<<#u2)                  EA=Rs+(Rt<<#u);
                                                         Rd = *EA;
                   Rd=memub(Rt<<#u2+#U6)                 apply_extension(#U);
                                                         EA=#U+(Rt<<#u);
                                                         Rd = *EA;
                   Rd=memub(Rx++#s4:0)                   EA=Rx;
                                                         Rx=Rx+#s;
                                                         Rd = *EA;
                   Rd=memub(Rx++#s4:0:circ(Mu))          EA=Rx;
                                                         Rx=Rx=circ_add(Rx,#s,MuV);
                                                         Rd = *EA;
                   Rd=memub(Rx++I:circ(Mu))              EA=Rx;
                                                         Rx=Rx=circ_add(Rx,I<<0,MuV);
                                                         Rd = *EA;
                   Rd=memub(Rx++Mu)                      EA=Rx;
                                                         Rx=Rx+MuV;
                                                         Rd = *EA;
                   Rd=memub(Rx++Mu:brev)                 EA=Rx.h[1] | brev(Rx.h[0]);
                                                         Rx=Rx+MuV;
                                                         Rd = *EA;
                   Rd=memub(gp+#u16:0)                   apply_extension(#u);
                                                         EA=(Constant_extended ? (0) : GP)+#u;
                                                         Rd = *EA;
                  Class: LD (slots 0,1)
                  Intrinsics
                   Rd=memub(Rx++#s4:0:circ(Mu))          Word32 Q6_R_memub_IM_circ(void** StartAddress,
                                                         Word32 Is4_0, Word32 Mu, void* BaseAddress)
                   Rd=memub(Rx++I:circ(Mu))              Word32 Q6_R_memub_M_circ(void** StartAddress,
                                                         Word32 Mu, void* BaseAddress)
80-N2040-45 Rev. B                                                                                              257
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2  1 0
   ICLASS                              s5        Parse          t5               d5
 0  0  1  1 1  0   1  0  0   0 1  s  s  s  s  s  P   P  i t   t  t t t i - - d d d  d d Rd=memub(Rs+Rt<<#u2)
   ICLASS                 Type U                 Parse                           d5
                               N
 0  1  0  0 1   i   i 1  0   0 1  i  i   i  i  i P   P  i i   i  i i i i i i d d d  d d Rd=memub(gp+#u16:0)
   ICLASS    Amode      Type   U       s5        Parse                           d5
                               N
 1  0  0  1 0   i   i 1  0   0 1  s  s  s  s  s  P   P  i i   i  i i i i i i d d d  d d Rd=memub(Rs+#s11:0)
                               U
   ICLASS    Amode      Type           x5        Parse u1                        d5
                               N
                                                                                        Rd=memub(Rx++#s4:0:circ
 1  0  0  1 1  0   0  1  0   0 1  x  x  x  x  x  P   P u 0    -  - 0 i i i i d d d  d d
                                                                                        (Mu))
 1  0  0  1 1  0   0  1  0   0 1  x  x  x  x  x  P   P u 0    -  - 1 - 0 - - d d d  d d Rd=memub(Rx++I:circ(Mu)
                                                                                        )
   ICLASS    Amode      Type   U       e5        Parse                           d5
                               N
 1  0  0  1 1  0   1  1  0   0 1  e  e  e  e  e  P   P 0  1   I  I I I - I I d d d  d d Rd=memub(Re=#U6)
                               U
   ICLASS    Amode      Type   N       x5        Parse                           d5
 1  0  0  1 1  0   1  1  0   0 1  x  x  x  x  x  P   P 0  0   -  - - i i i i d d d  d d Rd=memub(Rx++#s4:0)
                               U
   ICLASS    Amode      Type   N        t5       Parse                           d5
 1  0  0  1 1  1   0  1  0   0 1  t  t   t  t  t P   P  i 1   I  I I I i I I d d d  d d Rd=memub(Rt<<#u2+#U6)
                               U
   ICLASS    Amode      Type   N       x5        Parse u1                        d5
 1  0  0  1 1  1   0  1  0   0 1  x  x  x  x  x  P   P u 0    -  - - - 0 - - d d d  d d Rd=memub(Rx++Mu)
 1  0  0  1 1  1   1  1  0   0 1  x  x  x  x  x  P   P u 0    -  - - - 0 - - d d d  d d Rd=memub(Rx++Mu:brev)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                          258
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
          Load unsigned byte conditionally
                  Load an unsigned byte from memory. The byte at the effective address in memory is
                  placed in the least-significant 8 bits of the destination register. The destination register is
                  then zero-extended from 8 bits to 32.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                                   Behavior
                   if ([!]Pt[.new]) Rd=memub(#u6)           apply_extension(#u);
                                                            EA=#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         apply_extension(#u);
                   Rd=memub(Rs+#u6:0)                       EA=Rs+#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         EA=Rx;
                   Rd=memub(Rx++#s4:0)                      if([!]Pt[.new][0]){
                                                                  Rx=Rx+#s;
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pv[.new])                         EA=Rs+(Rt<<#u);
                   Rd=memub(Rs+Rt<<#u2)                     if ([!]Pv[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                  Class: LD (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6 5 4 3  2  1 0
   ICLASS                              s5       Parse            t5                  d5
                                                                                             if (Pv)
 0  0  1  1 0  0   0  0 0   0 1   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d  d  d d Rd=memub(Rs+Rt<<#u2)
                                                                                          d ifRd=memub(Rs+Rt<<#u2)
                                                                                                (!Pv)
 0  0  1  1 0  0   0  1 0   0 1   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d  d  d
                                                                                          d ifRd=memub(Rs+Rt<<#u2)
                                                                                                (Pv.new)
 0  0  1  1 0  0   1  0 0   0 1   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d  d  d
                                                                                             if (!Pv.new)
 0  0  1  1 0  0   1  1 0   0 1   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d  d  d d Rd=memub(Rs+Rt<<#u2)
                   Pr
               Se
                  ed          U
   ICLASS      ns        Type          s5       Parse       t2                       d5
                  Ne          N
                e  w
80-N2040-45 Rev. B                                                                                                  259
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7 6 5 4 3 2  1 0
                                                                                          if (Pt)
 0  1  0  0 0  0   0 1  0   0 1   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memub(Rs+#u6:0)
                                                                                          if (Pt.new)
 0  1  0  0 0  0   1 1  0   0 1   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memub(Rs+#u6:0)
                                                                                          if (!Pt)
 0  1  0  0 0  1   0 1  0   0 1   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memub(Rs+#u6:0)
                                                                                          if (!Pt.new)
 0  1  0  0 0  1   1 1  0   0 1   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d Rd=memub(Rs+#u6:0)
                              U
   ICLASS    Amode     Type            x5        Parse            t2               d5
                              N
                                                                                          if (Pt)
 1  0  0  1 1  0   1 1  0   0 1   x  x  x  x  x  P   P 1 0   0  t    t i i i i d d d  d d
                                                                                          Rd=memub(Rx++#s4:0)
                                                                                          if (!Pt)
 1  0  0  1 1  0   1 1  0   0 1   x  x  x  x  x  P   P 1 0   1  t    t i i i i d d d  d d
                                                                                          Rd=memub(Rx++#s4:0)
                                                                                          if (Pt.new)
 1  0  0  1 1  0   1 1  0   0 1   x  x  x  x  x  P   P 1 1   0  t    t i i i i d d d  d d
                                                                                          Rd=memub(Rx++#s4:0)
                                                                                          if (!Pt.new)
 1  0  0  1 1  0   1 1  0   0 1   x  x  x  x  x  P   P 1 1   1  t    t i i i i d d d  d d Rd=memub(Rx++#s4:0)
                              U
   ICLASS    Amode     Type   N                  Parse            t2               d5
 1  0  0  1 1  1   1 1  0   0 1   i  i  i   i  i P   P 1 0   0  t    t i 1 - - d d d  d d if (Pt) Rd=memub(#u6)
 1  0  0  1 1  1   1 1  0   0 1   i  i  i   i  i P   P 1 0   1  t    t i 1 - - d d d  d d if (!Pt) Rd=memub(#u6)
 1  0  0  1 1  1   1 1  0   0 1   i  i  i   i  i P   P 1 1   0  t    t i 1 - - d d d  d d if (Pt.new) Rd=memub(#u6)
                                                                                          if (!Pt.new)
 1  0  0  1 1  1   1 1  0   0 1   i  i  i   i  i P   P 1 1   1  t    t i 1 - - d d d  d d Rd=memub(#u6)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t2                Field to encode register t
                  t5                Field to encode register t
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               260
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Load unsigned halfword
                  Load an unsigned halfword from memory. The 16-bit halfword at the effective address in
                  memory is placed in the least-significant 16 bits of the destination register. The destination
                  register is zero-extended from 16 bits to 32.
                   Syntax                              Behavior
                   Rd=memuh(Re=#U6)                     apply_extension(#U);
                                                        EA=#U;
                                                        Rd = *EA;
                                                        Re=#U;
                   Rd=memuh(Rs+#s11:1)                  apply_extension(#s);
                                                        EA=Rs+#s;
                                                        Rd = *EA;
                   Rd=memuh(Rs+Rt<<#u2)                 EA=Rs+(Rt<<#u);
                                                        Rd = *EA;
                   Rd=memuh(Rt<<#u2+#U6)                apply_extension(#U);
                                                        EA=#U+(Rt<<#u);
                                                        Rd = *EA;
                   Rd=memuh(Rx++#s4:1)                  EA=Rx;
                                                        Rx=Rx+#s;
                                                        Rd = *EA;
                   Rd=memuh(Rx++#s4:1:circ(Mu))         EA=Rx;
                                                        Rx=Rx=circ_add(Rx,#s,MuV);
                                                        Rd = *EA;
                   Rd=memuh(Rx++I:circ(Mu))             EA=Rx;
                                                        Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                        Rd = *EA;
                   Rd=memuh(Rx++Mu)                     EA=Rx;
                                                        Rx=Rx+MuV;
                                                        Rd = *EA;
                   Rd=memuh(Rx++Mu:brev)                EA=Rx.h[1] | brev(Rx.h[0]);
                                                        Rx=Rx+MuV;
                                                        Rd = *EA;
                   Rd=memuh(gp+#u16:1)                  apply_extension(#u);
                                                        EA=(Constant_extended ? (0) : GP)+#u;
                                                        Rd = *EA;
                  Class: LD (slots 0,1)
                  Intrinsics
                   Rd=memuh(Rx++#s4:1:circ(Mu))        Word32 Q6_R_memuh_IM_circ(void** StartAddress,
                                                       Word32 Is4_1, Word32 Mu, void* BaseAddress)
                   Rd=memuh(Rx++I:circ(Mu))            Word32 Q6_R_memuh_M_circ(void** StartAddress,
                                                       Word32 Mu, void* BaseAddress)
80-N2040-45 Rev. B                                                                                             261
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2  1 0
   ICLASS                              s5        Parse          t5               d5
 0  0  1  1 1  0   1  0  0   1 1  s  s  s  s  s  P   P  i t   t  t t t i - - d d d  d d Rd=memuh(Rs+Rt<<#u2)
   ICLASS                 Type U                 Parse                           d5
                               N
 0  1  0  0 1   i   i 1  0   1 1  i  i   i  i  i P   P  i i   i  i i i i i i d d d  d d Rd=memuh(gp+#u16:1)
   ICLASS    Amode      Type   U       s5        Parse                           d5
                               N
 1  0  0  1 0   i   i 1  0   1 1  s  s  s  s  s  P   P  i i   i  i i i i i i d d d  d d Rd=memuh(Rs+#s11:1)
                               U
   ICLASS    Amode      Type           x5        Parse u1                        d5
                               N
                                                                                        Rd=memuh(Rx++#s4:1:circ
 1  0  0  1 1  0   0  1  0   1 1  x  x  x  x  x  P   P u 0    -  - 0 i i i i d d d  d d
                                                                                        (Mu))
 1  0  0  1 1  0   0  1  0   1 1  x  x  x  x  x  P   P u 0    -  - 1 - 0 - - d d d  d d Rd=memuh(Rx++I:circ(Mu)
                                                                                        )
   ICLASS    Amode      Type   U       e5        Parse                           d5
                               N
 1  0  0  1 1  0   1  1  0   1 1  e  e  e  e  e  P   P 0  1   I  I I I - I I d d d  d d Rd=memuh(Re=#U6)
                               U
   ICLASS    Amode      Type   N       x5        Parse                           d5
 1  0  0  1 1  0   1  1  0   1 1  x  x  x  x  x  P   P 0  0   -  - - i i i i d d d  d d Rd=memuh(Rx++#s4:1)
                               U
   ICLASS    Amode      Type   N        t5       Parse                           d5
 1  0  0  1 1  1   0  1  0   1 1  t  t   t  t  t P   P  i 1   I  I I I i I I d d d  d d Rd=memuh(Rt<<#u2+#U6)
                               U
   ICLASS    Amode      Type   N       x5        Parse u1                        d5
 1  0  0  1 1  1   0  1  0   1 1  x  x  x  x  x  P   P u 0    -  - - - 0 - - d d d  d d Rd=memuh(Rx++Mu)
 1  0  0  1 1  1   1  1  0   1 1  x  x  x  x  x  P   P u 0    -  - - - 0 - - d d d  d d Rd=memuh(Rx++Mu:brev)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                          262
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          Load unsigned halfword conditionally
                  Load an unsigned halfword from memory. The 16-bit halfword at the effective address in
                  memory is placed in the least-significant 16 bits of the destination register. The destination
                  register is zero-extended from 16 bits to 32.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                                   Behavior
                   if ([!]Pt[.new]) Rd=memuh(#u6)           apply_extension(#u);
                                                            EA=#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         apply_extension(#u);
                   Rd=memuh(Rs+#u6:1)                       EA=Rs+#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         EA=Rx;
                   Rd=memuh(Rx++#s4:1)                      if([!]Pt[.new][0]){
                                                                  Rx=Rx+#s;
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pv[.new])                         EA=Rs+(Rt<<#u);
                   Rd=memuh(Rs+Rt<<#u2)                     if ([!]Pv[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                  Class: LD (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6 5 4 3 2  1 0
   ICLASS                              s5       Parse            t5                 d5
                                                                                            if (Pv)
 0  0  1  1 0  0   0  0 0   1  1  s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d d Rd=memuh(Rs+Rt<<#u2)
                                                                                         d ifRd=memuh(Rs+Rt<<#u2)
                                                                                               (!Pv)
 0  0  1  1 0  0   0  1 0   1  1  s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d
                                                                                         d ifRd=memuh(Rs+Rt<<#u2)
                                                                                               (Pv.new)
 0  0  1  1 0  0   1  0 0   1  1  s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d
                                                                                            if (!Pv.new)
 0  0  1  1 0  0   1  1 0   1  1  s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d d Rd=memuh(Rs+Rt<<#u2)
                   Pr
               Se
                  ed           U
   ICLASS      ns        Type          s5       Parse       t2                      d5
                  Ne           N
                e  w
80-N2040-45 Rev. B                                                                                                 263
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7 6 5 4 3 2  1 0
                                                                                          if (Pt)
 0  1  0  0 0  0   0 1  0   1 1   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memuh(Rs+#u6:1)
                                                                                          if (Pt.new)
 0  1  0  0 0  0   1 1  0   1 1   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memuh(Rs+#u6:1)
                                                                                          if (!Pt)
 0  1  0  0 0  1   0 1  0   1 1   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memuh(Rs+#u6:1)
                                                                                          if (!Pt.new)
 0  1  0  0 0  1   1 1  0   1 1   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d Rd=memuh(Rs+#u6:1)
                              U
   ICLASS    Amode     Type            x5        Parse            t2               d5
                              N
                                                                                          if (Pt)
 1  0  0  1 1  0   1 1  0   1 1   x  x  x  x  x  P   P 1 0   0  t    t i i i i d d d  d d
                                                                                          Rd=memuh(Rx++#s4:1)
                                                                                          if (!Pt)
 1  0  0  1 1  0   1 1  0   1 1   x  x  x  x  x  P   P 1 0   1  t    t i i i i d d d  d d
                                                                                          Rd=memuh(Rx++#s4:1)
                                                                                          if (Pt.new)
 1  0  0  1 1  0   1 1  0   1 1   x  x  x  x  x  P   P 1 1   0  t    t i i i i d d d  d d
                                                                                          Rd=memuh(Rx++#s4:1)
                                                                                          if (!Pt.new)
 1  0  0  1 1  0   1 1  0   1 1   x  x  x  x  x  P   P 1 1   1  t    t i i i i d d d  d d Rd=memuh(Rx++#s4:1)
                              U
   ICLASS    Amode     Type   N                  Parse            t2               d5
 1  0  0  1 1  1   1 1  0   1 1   i  i  i   i  i P   P 1 0   0  t    t i 1 - - d d d  d d if (Pt) Rd=memuh(#u6)
 1  0  0  1 1  1   1 1  0   1 1   i  i  i   i  i P   P 1 0   1  t    t i 1 - - d d d  d d if (!Pt) Rd=memuh(#u6)
 1  0  0  1 1  1   1 1  0   1 1   i  i  i   i  i P   P 1 1   0  t    t i 1 - - d d d  d d if (Pt.new) Rd=memuh(#u6)
                                                                                          if (!Pt.new)
 1  0  0  1 1  1   1 1  0   1 1   i  i  i   i  i P   P 1 1   1  t    t i 1 - - d d d  d d Rd=memuh(#u6)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t2                Field to encode register t
                  t5                Field to encode register t
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               264
Hexagon V67 Programmer’s Reference Manual                                               Instruction Set
        Load word
                  Load a 32-bit word from memory and place in a destination register.
                   Syntax                          Behavior
                   Rd=memw(Re=#U6)                 apply_extension(#U);
                                                   EA=#U;
                                                   Rd = *EA;
                                                   Re=#U;
                   Rd=memw(Rs+#s11:2)              apply_extension(#s);
                                                   EA=Rs+#s;
                                                   Rd = *EA;
                   Rd=memw(Rs+Rt<<#u2)             EA=Rs+(Rt<<#u);
                                                   Rd = *EA;
                   Rd=memw(Rt<<#u2+#U6)            apply_extension(#U);
                                                   EA=#U+(Rt<<#u);
                                                   Rd = *EA;
                   Rd=memw(Rx++#s4:2)              EA=Rx;
                                                   Rx=Rx+#s;
                                                   Rd = *EA;
                   Rd=memw(Rx++#s4:2:circ(Mu))     EA=Rx;
                                                   Rx=Rx=circ_add(Rx,#s,MuV);
                                                   Rd = *EA;
                   Rd=memw(Rx++I:circ(Mu))         EA=Rx;
                                                   Rx=Rx=circ_add(Rx,I<<2,MuV);
                                                   Rd = *EA;
                   Rd=memw(Rx++Mu)                 EA=Rx;
                                                   Rx=Rx+MuV;
                                                   Rd = *EA;
                   Rd=memw(Rx++Mu:brev)            EA=Rx.h[1] | brev(Rx.h[0]);
                                                   Rx=Rx+MuV;
                                                   Rd = *EA;
                   Rd=memw(gp+#u16:2)              apply_extension(#u);
                                                   EA=(Constant_extended ? (0) : GP)+#u;
                                                   Rd = *EA;
                  Class: LD (slots 0,1)
                  Intrinsics
                   Rd=memw(Rx++#s4:2:circ(Mu))     Word32 Q6_R_memw_IM_circ(void** StartAddress,
                                                   Word32 Is4_2, Word32 Mu, void* BaseAddress)
                   Rd=memw(Rx++I:circ(Mu))         Word32 Q6_R_memw_M_circ(void** StartAddress,
                                                   Word32 Mu, void* BaseAddress)
80-N2040-45 Rev. B                                                                                  265
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2  1 0
   ICLASS                              s5        Parse          t5               d5
 0  0  1  1 1  0   1  0  1   0 0  s  s  s  s  s  P   P  i t   t  t t t i - - d d d  d d Rd=memw(Rs+Rt<<#u2)
   ICLASS                 Type U                 Parse                           d5
                               N
 0  1  0  0 1   i   i 1  1   0 0  i  i   i  i  i P   P  i i   i  i i i i i i d d d  d d Rd=memw(gp+#u16:2)
   ICLASS    Amode      Type   U       s5        Parse                           d5
                               N
 1  0  0  1 0   i   i 1  1   0 0  s  s  s  s  s  P   P  i i   i  i i i i i i d d d  d d Rd=memw(Rs+#s11:2)
                               U
   ICLASS    Amode      Type           x5        Parse u1                        d5
                               N
                                                                                        Rd=memw(Rx++#s4:2:circ(
 1  0  0  1 1  0   0  1  1   0 0  x  x  x  x  x  P   P u 0    -  - 0 i i i i d d d  d d
                                                                                        Mu))
 1  0  0  1 1  0   0  1  1   0 0  x  x  x  x  x  P   P u 0    -  - 1 - 0 - - d d d  d d Rd=memw(Rx++I:circ(Mu))
                               U
   ICLASS    Amode      Type           e5        Parse                           d5
                               N
 1  0  0  1 1  0   1  1  1   0 0  e  e  e  e  e  P   P 0  1   I  I I I - I I d d d  d d Rd=memw(Re=#U6)
                               U
   ICLASS    Amode      Type           x5        Parse                           d5
                               N
 1  0  0  1 1  0   1  1  1   0 0  x  x  x  x  x  P   P 0  0   -  - - i i i i d d d  d d Rd=memw(Rx++#s4:2)
                               U
   ICLASS    Amode      Type            t5       Parse                           d5
                               N
 1  0  0  1 1  1   0  1  1   0 0  t  t   t  t  t P   P  i 1   I  I I I i I I d d d  d d Rd=memw(Rt<<#u2+#U6)
                               U
   ICLASS    Amode      Type           x5        Parse u1                        d5
                               N
 1  0  0  1 1  1   0  1  1   0 0  x  x  x  x  x  P   P u 0    -  - - - 0 - - d d d  d d Rd=memw(Rx++Mu)
 1  0  0  1 1  1   1  1  1   0 0  x  x  x  x  x  P   P u 0    -  - - - 0 - - d d d  d d Rd=memw(Rx++Mu:brev)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                          266
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Load word conditionally
                  Load a 32-bit word from memory and place in a destination register.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                                   Behavior
                   if ([!]Pt[.new]) Rd=memw(#u6)            apply_extension(#u);
                                                            EA=#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         apply_extension(#u);
                   Rd=memw(Rs+#u6:2)                        EA=Rs+#u;
                                                            if ([!]Pt[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pt[.new])                         EA=Rx;
                   Rd=memw(Rx++#s4:2)                       if([!]Pt[.new][0]){
                                                                  Rx=Rx+#s;
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                   if ([!]Pv[.new])                         EA=Rs+(Rt<<#u);
                   Rd=memw(Rs+Rt<<#u2)                      if ([!]Pv[.new][0]) {
                                                                  Rd = *EA;
                                                            } else {
                                                                  NOP;
                                                            }
                  Class: LD (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6 5 4 3 2  1 0
   ICLASS                              s5       Parse            t5                 d5
                                                                                         d ifRd=memw(Rs+Rt<<#u2)
                                                                                              (Pv)
 0  0  1  1 0  0   0  0 1   0 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d
                                                                                           if (!Pv)
 0  0  1  1 0  0   0  1 1   0 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d d Rd=memw(Rs+Rt<<#u2)
                                                                                         d ifRd=memw(Rs+Rt<<#u2)
                                                                                              (Pv.new)
 0  0  1  1 0  0   1  0 1   0 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d
                                                                                         d ifRd=memw(Rs+Rt<<#u2)
                                                                                              (!Pv.new)
 0  0  1  1 0  0   1  1 1   0 0   s  s  s  s  s P   P  i  t    t  t t  t i  v v d d d  d
                   Pr
               Se ed
   ICLASS      ns Ne     Type U        s5       Parse       t2                      d5
                              N
                e w
                                                                                         d ifRd=memw(Rs+#u6:2)
                                                                                              (Pt)
 0  1  0  0 0  0   0  1 1   0 0   s  s  s  s  s P   P 0   t    t  i i  i i  i i d d d  d
80-N2040-45 Rev. B                                                                                                267
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7 6 5 4 3 2  1 0
                                                                                          if (Pt.new)
 0  1  0  0 0  0   1 1  1   0 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memw(Rs+#u6:2)
                                                                                          if (!Pt)
 0  1  0  0 0  1   0 1  1   0 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memw(Rs+#u6:2)
                                                                                          if (!Pt.new)
 0  1  0  0 0  1   1 1  1   0 0   s  s  s  s  s  P   P 0  t   t i    i i i i i d d d  d d
                                                                                          Rd=memw(Rs+#u6:2)
                              U
   ICLASS    Amode     Type   N        x5        Parse            t2               d5
                                                                                          if (Pt)
 1  0  0  1 1  0   1 1  1   0 0   x  x  x  x  x  P   P 1 0   0  t    t i i i i d d d  d d
                                                                                          Rd=memw(Rx++#s4:2)
 1  0  0  1 1  0   1 1  1   0 0   x  x  x  x  x  P   P 1 0   1  t    t i i i i d d d  d d if (!Pt)
                                                                                          Rd=memw(Rx++#s4:2)
                                                                                          if (Pt.new)
 1  0  0  1 1  0   1 1  1   0 0   x  x  x  x  x  P   P 1 1   0  t    t i i i i d d d  d d
                                                                                          Rd=memw(Rx++#s4:2)
                                                                                          if (!Pt.new)
 1  0  0  1 1  0   1 1  1   0 0   x  x  x  x  x  P   P 1 1   1  t    t i i i i d d d  d d
                                                                                          Rd=memw(Rx++#s4:2)
                              U
   ICLASS    Amode     Type                      Parse            t2               d5
                              N
 1  0  0  1 1  1   1 1  1   0 0   i  i  i   i  i P   P 1 0   0  t    t i 1 - - d d d  d d if (Pt) Rd=memw(#u6)
 1  0  0  1 1  1   1 1  1   0 0   i  i  i   i  i P   P 1 0   1  t    t i 1 - - d d d  d d if (!Pt) Rd=memw(#u6)
 1  0  0  1 1  1   1 1  1   0 0   i  i  i   i  i P   P 1 1   0  t    t i 1 - - d d d  d d if (Pt.new) Rd=memw(#u6)
 1  0  0  1 1  1   1 1  1   0 0   i  i  i   i  i P   P 1 1   1  t    t i 1 - - d d d  d d if (!Pt.new) Rd=memw(#u6)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Type              Type
                  UN                Unsigned
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t2                Field to encode register t
                  t5                Field to encode register t
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               268
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Deallocate stack frame
                  Deallocate a stack frame from the call stack. The instruction first loads the saved FP and
                  saved LR values from the address at FP. It then points SP back to the previous frame.
                  The stack layout is seen in the following figure.
                                                   Stack in Memory
                                                       Saved LR
                                                       Saved FP
                     Higher Address
                                                    Procedure Local
                                                     Data on Stack
                                                                                     Stack frame
                                                       Saved LR
                                                       Saved FP                          FP register
                                                    Procedure Local
                                                     Data on Stack
                                                                                         SP register
                    Lower Address
                                                   Unallocated Stack
                   Syntax                               Behavior
                   Rdd=deallocframe(Rs):raw             EA=Rs;
                                                        tmp = *EA;
                                                        Rdd = frame_unscramble(tmp);
                                                        SP=EA+8;
                   deallocframe                         Assembler mapped to:
                                                        "r31:30=deallocframe(r30):raw"
80-N2040-45 Rev. B                                                                                            269
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
                  Class: LD (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2  1 0
                              U
   ICLASS    Amode     Type            s5        Parse                          d5
                              N
 1  0  0  1 0  0   0 0  0   0 0   s  s  s  s  s  P   P 0  -  -  - - - - - - d d d  d d Rdd=deallocframe(Rs):raw
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                           270
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
        Deallocate frame and return
                  Return from a function with a stack frame. This instruction is equivalent to deallocframe
                  followed by jumpr R31.
                   Syntax                             Behavior
                   Rdd=dealloc_return(Rs):raw          EA=Rs;
                                                       tmp = *EA;
                                                       Rdd = frame_unscramble(tmp);
                                                       SP=EA+8;
                                                       PC=Rdd.w[1];
                   dealloc_return                      Assembler mapped to:
                                                       "r31:30=dealloc_return(r30):raw"
                   if ([!]Pv)                          ;
                   Rdd=dealloc_return(Rs):raw          EA=Rs;
                                                       if ([!]Pv[0]) {
                                                           tmp = *EA;
                                                           Rdd = frame_unscramble(tmp);
                                                           SP=EA+8;
                                                           PC=Rdd.w[1];
                                                       } else {
                                                           NOP;
                                                       }
                   if ([!]Pv) dealloc_return           Assembler mapped to: "if ([!]Pv"")
                                                       r31:30=dealloc_return(r30)"":raw"
                   if ([!]Pv.new)                      ;
                   Rdd=dealloc_return(Rs):nt:raw       EA=Rs;
                                                       if ([!]Pv.new[0]) {
                                                           tmp = *EA;
                                                           Rdd = frame_unscramble(tmp);
                                                           SP=EA+8;
                                                           PC=Rdd.w[1];
                                                       } else {
                                                           NOP;
                                                       }
                   if ([!]Pv.new)                      ;
                   Rdd=dealloc_return(Rs):t:raw        EA=Rs;
                                                       if ([!]Pv.new[0]) {
                                                           tmp = *EA;
                                                           Rdd = frame_unscramble(tmp);
                                                           SP=EA+8;
                                                           PC=Rdd.w[1];
                                                       } else {
                                                           NOP;
                                                       }
                   if ([!]Pv.new)                      Assembler mapped to: "if ([!]Pv"".new"")
                   dealloc_return:nt                   r31:30=dealloc_return(r30)"":nt"":raw"
                   if ([!]Pv.new) dealloc_return:t     Assembler mapped to: "if ([!]Pv"".new"")
                                                       r31:30=dealloc_return(r30)"":t"":raw"
80-N2040-45 Rev. B                                                                                          271
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Class: LD (slots 0)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2  1 0
                              U
   ICLASS    Amode     Type            s5        Parse                          d5
                              N
                                                                                       Rdd=dealloc_return(Rs):ra
 1  0  0  1 0  1   1 0  0   0 0   s  s  s  s  s  P   P 0 0   0 0  - - - - - d d d  d d
                                                                                       w
                                                                                       if (Pv.new)
 1  0  0  1 0  1   1 0  0   0 0   s  s  s  s  s  P   P 0 0   1 0  v v - - - d d d  d d Rdd=dealloc_return(Rs):nt:
                                                                                       raw
                                                                                       if (Pv)
 1  0  0  1 0  1   1 0  0   0 0   s  s  s  s  s  P   P 0 1   0 0  v v - - - d d d  d d Rdd=dealloc_return(Rs):ra
                                                                                       w
                                                                                       if (Pv.new)
 1  0  0  1 0  1   1 0  0   0 0   s  s  s  s  s  P   P 0 1   1 0  v v - - - d d d  d d Rdd=dealloc_return(Rs):t:r
                                                                                       aw
                                                                                       if (!Pv.new)
 1  0  0  1 0  1   1 0  0   0 0   s  s  s  s  s  P   P 1 0   1 0  v v - - - d d d  d d Rdd=dealloc_return(Rs):nt:
                                                                                       raw
                                                                                       if (!Pv)
 1  0  0  1 0  1   1 0  0   0 0   s  s  s  s  s  P   P 1 1   0 0  v v - - - d d d  d d Rdd=dealloc_return(Rs):ra
                                                                                       w
                                                                                       if (!Pv.new)
 1  0  0  1 0  1   1 0  0   0 0   s  s  s  s  s  P   P 1 1   1 0  v v - - - d d d  d d Rdd=dealloc_return(Rs):t:r
                                                                                       aw
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  v2                Field to encode register v
80-N2040-45 Rev. B                                                                                            272
Hexagon V67 Programmer’s Reference Manual                                                Instruction Set
        Load and unpack bytes to halfwords
                  Load contiguous bytes from memory and vector unpack them into halfwords.
                                                             Rdd=memubh(amode)
                                                                                  mem
                      zero           zero          zero            zero           Rdd
                                                              Rd=memubh(amode)
                                                                                  mem
                                                   zero            zero           Rdd
                   Syntax                         Behavior
                   Rd=membh(Re=#U6)                apply_extension(#U);
                                                   EA=#U;
                                                   {
                                                        tmpV = *EA;
                                                        for (i=0;i<2;i++) {
                                                            Rd.h[i]=tmpV.b[i];
                                                        }
                                                   }
                                                   ;
                                                   Re=#U;
                   Rd=membh(Rs)                    Assembler mapped to: "Rd=membh""(Rs+#0)"
                   Rd=membh(Rs+#s11:1)             apply_extension(#s);
                                                   EA=Rs+#s;
                                                   {
                                                        tmpV = *EA;
                                                        for (i=0;i<2;i++) {
                                                            Rd.h[i]=tmpV.b[i];
                                                        }
                                                   }
                                                   ;
                   Rd=membh(Rt<<#u2+#U6)           apply_extension(#U);
                                                   EA=#U+(Rt<<#u);
                                                   {
                                                        tmpV = *EA;
                                                        for (i=0;i<2;i++) {
                                                            Rd.h[i]=tmpV.b[i];
                                                        }
                                                   }
                                                   ;
80-N2040-45 Rev. B                                                                                   273
Hexagon V67 Programmer’s Reference Manual                                    Instruction Set
                   Syntax                       Behavior
                   Rd=membh(Rx++#s4:1)          EA=Rx;
                                                Rx=Rx+#s;
                                                {
                                                    tmpV = *EA;
                                                    for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                    }
                                                }
                                                ;
                   Rd=membh(Rx++#s4:1:circ(Mu)) EA=Rx;
                                                Rx=Rx=circ_add(Rx,#s,MuV);
                                                {
                                                    tmpV = *EA;
                                                    for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                    }
                                                }
                                                ;
                   Rd=membh(Rx++I:circ(Mu))     EA=Rx;
                                                Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                {
                                                    tmpV = *EA;
                                                    for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                    }
                                                }
                                                ;
                   Rd=membh(Rx++Mu)             EA=Rx;
                                                Rx=Rx+MuV;
                                                {
                                                    tmpV = *EA;
                                                    for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                    }
                                                }
                                                ;
                   Rd=membh(Rx++Mu:brev)        EA=Rx.h[1] | brev(Rx.h[0]);
                                                Rx=Rx+MuV;
                                                {
                                                    tmpV = *EA;
                                                    for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.b[i];
                                                    }
                                                }
                                                ;
                   Rd=memubh(Re=#U6)            apply_extension(#U);
                                                EA=#U;
                                                {
                                                    tmpV = *EA;
                                                    for (i=0;i<2;i++) {
                                                         Rd.h[i]=tmpV.ub[i];
                                                    }
                                                }
                                                ;
                                                Re=#U;
80-N2040-45 Rev. B                                                                       274
Hexagon V67 Programmer’s Reference Manual                                     Instruction Set
                   Syntax                        Behavior
                   Rd=memubh(Rs+#s11:1)          apply_extension(#s);
                                                 EA=Rs+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                          Rd.h[i]=tmpV.ub[i];
                                                     }
                                                 }
                                                 ;
                   Rd=memubh(Rt<<#u2+#U6)        apply_extension(#U);
                                                 EA=#U+(Rt<<#u);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                          Rd.h[i]=tmpV.ub[i];
                                                     }
                                                 }
                                                 ;
                   Rd=memubh(Rx++#s4:1)          EA=Rx;
                                                 Rx=Rx+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                          Rd.h[i]=tmpV.ub[i];
                                                     }
                                                 }
                                                 ;
                   Rd=memubh(Rx++#s4:1:circ(Mu)) EA=Rx;
                                                 Rx=Rx=circ_add(Rx,#s,MuV);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                          Rd.h[i]=tmpV.ub[i];
                                                     }
                                                 }
                                                 ;
                   Rd=memubh(Rx++I:circ(Mu))     EA=Rx;
                                                 Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                          Rd.h[i]=tmpV.ub[i];
                                                     }
                                                 }
                                                 ;
                   Rd=memubh(Rx++Mu)             EA=Rx;
                                                 Rx=Rx+MuV;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                          Rd.h[i]=tmpV.ub[i];
                                                     }
                                                 }
                                                 ;
80-N2040-45 Rev. B                                                                        275
Hexagon V67 Programmer’s Reference Manual                                             Instruction Set
                   Syntax                        Behavior
                   Rd=memubh(Rx++Mu:brev)        EA=Rx.h[1] | brev(Rx.h[0]);
                                                 Rx=Rx+MuV;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<2;i++) {
                                                          Rd.h[i]=tmpV.ub[i];
                                                     }
                                                 }
                                                 ;
                   Rdd=membh(Re=#U6)             apply_extension(#U);
                                                 EA=#U;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                          Rdd.h[i]=tmpV.b[i];
                                                     }
                                                 }
                                                 ;
                                                 Re=#U;
                   Rdd=membh(Rs)                 Assembler mapped to: "Rdd=membh""(Rs+#0)"
                   Rdd=membh(Rs+#s11:2)          apply_extension(#s);
                                                 EA=Rs+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                          Rdd.h[i]=tmpV.b[i];
                                                     }
                                                 }
                                                 ;
                   Rdd=membh(Rt<<#u2+#U6)        apply_extension(#U);
                                                 EA=#U+(Rt<<#u);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                          Rdd.h[i]=tmpV.b[i];
                                                     }
                                                 }
                                                 ;
                   Rdd=membh(Rx++#s4:2)          EA=Rx;
                                                 Rx=Rx+#s;
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                          Rdd.h[i]=tmpV.b[i];
                                                     }
                                                 }
                                                 ;
                   Rdd=membh(Rx++#s4:2:circ(Mu)) EA=Rx;
                                                 Rx=Rx=circ_add(Rx,#s,MuV);
                                                 {
                                                     tmpV = *EA;
                                                     for (i=0;i<4;i++) {
                                                          Rdd.h[i]=tmpV.b[i];
                                                     }
                                                 }
                                                 ;
80-N2040-45 Rev. B                                                                                276
Hexagon V67 Programmer’s Reference Manual                                  Instruction Set
                   Syntax                    Behavior
                   Rdd=membh(Rx++I:circ(Mu)) EA=Rx;
                                             Rx=Rx=circ_add(Rx,I<<2,MuV);
                                             {
                                                 tmpV = *EA;
                                                 for (i=0;i<4;i++) {
                                                      Rdd.h[i]=tmpV.b[i];
                                                 }
                                             }
                                             ;
                   Rdd=membh(Rx++Mu)         EA=Rx;
                                             Rx=Rx+MuV;
                                             {
                                                 tmpV = *EA;
                                                 for (i=0;i<4;i++) {
                                                      Rdd.h[i]=tmpV.b[i];
                                                 }
                                             }
                                             ;
                   Rdd=membh(Rx++Mu:brev)    EA=Rx.h[1] | brev(Rx.h[0]);
                                             Rx=Rx+MuV;
                                             {
                                                 tmpV = *EA;
                                                 for (i=0;i<4;i++) {
                                                      Rdd.h[i]=tmpV.b[i];
                                                 }
                                             }
                                             ;
                   Rdd=memubh(Re=#U6)        apply_extension(#U);
                                             EA=#U;
                                             {
                                                 tmpV = *EA;
                                                 for (i=0;i<4;i++) {
                                                      Rdd.h[i]=tmpV.ub[i];
                                                 }
                                             }
                                             ;
                                             Re=#U;
                   Rdd=memubh(Rs+#s11:2)     apply_extension(#s);
                                             EA=Rs+#s;
                                             {
                                                 tmpV = *EA;
                                                 for (i=0;i<4;i++) {
                                                      Rdd.h[i]=tmpV.ub[i];
                                                 }
                                             }
                                             ;
                   Rdd=memubh(Rt<<#u2+#U6)   apply_extension(#U);
                                             EA=#U+(Rt<<#u);
                                             {
                                                 tmpV = *EA;
                                                 for (i=0;i<4;i++) {
                                                      Rdd.h[i]=tmpV.ub[i];
                                                 }
                                             }
                                             ;
80-N2040-45 Rev. B                                                                     277
Hexagon V67 Programmer’s Reference Manual                                       Instruction Set
                   Syntax                         Behavior
                   Rdd=memubh(Rx++#s4:2)          EA=Rx;
                                                  Rx=Rx+#s;
                                                  {
                                                      tmpV = *EA;
                                                      for (i=0;i<4;i++) {
                                                           Rdd.h[i]=tmpV.ub[i];
                                                      }
                                                  }
                                                  ;
                   Rdd=memubh(Rx++#s4:2:circ(Mu)) EA=Rx;
                                                  Rx=Rx=circ_add(Rx,#s,MuV);
                                                  {
                                                      tmpV = *EA;
                                                      for (i=0;i<4;i++) {
                                                           Rdd.h[i]=tmpV.ub[i];
                                                      }
                                                  }
                                                  ;
                   Rdd=memubh(Rx++I:circ(Mu))     EA=Rx;
                                                  Rx=Rx=circ_add(Rx,I<<2,MuV);
                                                  {
                                                      tmpV = *EA;
                                                      for (i=0;i<4;i++) {
                                                           Rdd.h[i]=tmpV.ub[i];
                                                      }
                                                  }
                                                  ;
                   Rdd=memubh(Rx++Mu)             EA=Rx;
                                                  Rx=Rx+MuV;
                                                  {
                                                      tmpV = *EA;
                                                      for (i=0;i<4;i++) {
                                                           Rdd.h[i]=tmpV.ub[i];
                                                      }
                                                  }
                                                  ;
                   Rdd=memubh(Rx++Mu:brev)        EA=Rx.h[1] | brev(Rx.h[0]);
                                                  Rx=Rx+MuV;
                                                  {
                                                      tmpV = *EA;
                                                      for (i=0;i<4;i++) {
                                                           Rdd.h[i]=tmpV.ub[i];
                                                      }
                                                  }
                                                  ;
80-N2040-45 Rev. B                                                                          278
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
                  Class: LD (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2  1 0
                               U
   ICLASS    Amode      Type           s5       Parse                           d5
                               N
 1  0  0  1 0   i   i 0  0   0 1  s  s  s  s  s P   P  i  i  i  i i i i i i d d d  d d Rd=membh(Rs+#s11:1)
 1  0  0  1 0   i   i 0  0   1 1  s  s  s  s  s P   P  i  i  i  i i i i i i d d d  d d Rd=memubh(Rs+#s11:1)
 1  0  0  1 0   i   i 0  1   0 1  s  s  s  s  s P   P  i  i  i  i i i i i i d d d  d d Rdd=memubh(Rs+#s11:2)
 1  0  0  1 0   i   i 0  1   1 1  s  s  s  s  s P   P  i  i  i  i i i i i i d d d  d d Rdd=membh(Rs+#s11:2)
                               U
   ICLASS    Amode      Type           x5       Parse u1                        d5
                               N
                                                                                       Rd=membh(Rx++#s4:1:circ
 1  0  0  1 1  0   0  0  0   0 1  x  x  x  x  x P   P u 0    -  - 0 i i i i d d d  d d
                                                                                       (Mu))
 1  0  0  1 1  0   0  0  0   0 1  x  x  x  x  x P   P u 0    -  - 1 - 0 - - d d d  d d Rd=membh(Rx++I:circ(Mu)
                                                                                       )
                                                                                       Rd=memubh(Rx++#s4:1:cir
 1  0  0  1 1  0   0  0  0   1 1  x  x  x  x  x P   P u 0    -  - 0 i i i i d d d  d d c(Mu))
 1  0  0  1 1  0   0  0  0   1 1  x  x  x  x  x P   P u 0    -  - 1 - 0 - - d d d  d d Rd=memubh(Rx++I:circ(Mu
                                                                                       ))
 1  0  0  1 1  0   0  0  1   0 1  x  x  x  x  x P   P u 0    -  - 0 i i i i d d d  d d Rdd=memubh(Rx++#s4:2:c
                                                                                       irc(Mu))
                                                                                       Rdd=memubh(Rx++I:circ(M
 1  0  0  1 1  0   0  0  1   0 1  x  x  x  x  x P   P u 0    -  - 1 - 0 - - d d d  d d u))
 1  0  0  1 1  0   0  0  1   1 1  x  x  x  x  x P   P u 0    -  - 0 i i i i d d d  d d Rdd=membh(Rx++#s4:2:cir
                                                                                       c(Mu))
 1  0  0  1 1  0   0  0  1   1 1  x  x  x  x  x P   P u 0    -  - 1 - 0 - - d d d  d d Rdd=membh(Rx++I:circ(Mu
                                                                                       ))
                               U
   ICLASS    Amode      Type           e5       Parse                           d5
                               N
 1  0  0  1 1  0   1  0  0   0 1  e  e  e  e  e P   P 0  1   I  I I I - I I d d d  d d Rd=membh(Re=#U6)
                               U
   ICLASS    Amode      Type   N       x5       Parse                           d5
 1  0  0  1 1  0   1  0  0   0 1  x  x  x  x  x P   P 0  0   -  - - i i i i d d d  d d Rd=membh(Rx++#s4:1)
                               U
   ICLASS    Amode      Type           e5       Parse                           d5
                               N
 1  0  0  1 1  0   1  0  0   1 1  e  e  e  e  e P   P 0  1   I  I I I - I I d d d  d d Rd=memubh(Re=#U6)
                               U
   ICLASS    Amode      Type           x5       Parse                           d5
                               N
 1  0  0  1 1  0   1  0  0   1 1  x  x  x  x  x P   P 0  0   -  - - i i i i d d d  d d Rd=memubh(Rx++#s4:1)
                               U
   ICLASS    Amode      Type   N       e5       Parse                           d5
 1  0  0  1 1  0   1  0  1   0 1  e  e  e  e  e P   P 0  1   I  I I I - I I d d d  d d Rdd=memubh(Re=#U6)
                               U
   ICLASS    Amode      Type           x5       Parse                           d5
                               N
 1  0  0  1 1  0   1  0  1   0 1  x  x  x  x  x P   P 0  0   -  - - i i i i d d d  d d Rdd=memubh(Rx++#s4:2)
                               U
   ICLASS    Amode      Type           e5       Parse                           d5
                               N
 1  0  0  1 1  0   1  0  1   1 1  e  e  e  e  e P   P 0  1   I  I I I - I I d d d  d d Rdd=membh(Re=#U6)
                               U
   ICLASS    Amode      Type           x5       Parse                           d5
                               N
 1  0  0  1 1  0   1  0  1   1 1  x  x  x  x  x P   P 0  0   -  - - i i i i d d d  d d Rdd=membh(Rx++#s4:2)
                               U
   ICLASS    Amode      Type           t5       Parse                           d5
                               N
 1  0  0  1 1  1   0  0  0   0 1  t  t  t  t  t P   P  i 1   I  I I I i I I d d d  d d Rd=membh(Rt<<#u2+#U6)
                               U
   ICLASS    Amode      Type           x5       Parse u1                        d5
                               N
80-N2040-45 Rev. B                                                                                          279
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2  1 0
 1  0  0  1 1  1   0 0  0   0 1   x  x  x  x  x  P   P u 0    - - - - 0 - - d d d  d d Rd=membh(Rx++Mu)
                              U
   ICLASS    Amode     Type             t5       Parse                          d5
                              N
                                                                                       Rd=memubh(Rt<<#u2+#U
 1  0  0  1 1  1   0 0  0   1 1   t  t   t  t  t P   P  i 1   I I I I i I I d d d  d d
                                                                                       6)
                              U
   ICLASS    Amode     Type            x5        Parse u1                       d5
                              N
 1  0  0  1 1  1   0 0  0   1 1   x  x  x  x  x  P   P u 0    - - - - 0 - - d d d  d d Rd=memubh(Rx++Mu)
                              U
   ICLASS    Amode     Type             t5       Parse                          d5
                              N
                                                                                       Rdd=memubh(Rt<<#u2+#
 1  0  0  1 1  1   0 0  1   0 1   t  t   t  t  t P   P  i 1   I I I I i I I d d d  d d
                                                                                       U6)
                              U
   ICLASS    Amode     Type            x5        Parse u1                       d5
                              N
 1  0  0  1 1  1   0 0  1   0 1   x  x  x  x  x  P   P u 0    - - - - 0 - - d d d  d d Rdd=memubh(Rx++Mu)
                              U
   ICLASS    Amode     Type   N         t5       Parse                          d5
                                                                                       Rdd=membh(Rt<<#u2+#U
 1  0  0  1 1  1   0 0  1   1 1   t  t   t  t  t P   P  i 1   I I I I i I I d d d  d d 6)
   ICLASS    Amode     Type   U        x5        Parse u1                       d5
                              N
 1  0  0  1 1  1   0 0  1   1 1   x  x  x  x  x  P   P u 0    - - - - 0 - - d d d  d d Rdd=membh(Rx++Mu)
 1  0  0  1 1  1   1 0  0   0 1   x  x  x  x  x  P   P u 0    - - - - 0 - - d d d  d d Rd=membh(Rx++Mu:brev)
                                                                                       Rd=memubh(Rx++Mu:brev
 1  0  0  1 1  1   1 0  0   1 1   x  x  x  x  x  P   P u 0    - - - - 0 - - d d d  d d )
 1  0  0  1 1  1   1 0  1   0 1   x  x  x  x  x  P   P u 0    - - - - 0 - - d d d  d d Rdd=memubh(Rx++Mu:bre
                                                                                       v)
 1  0  0  1 1  1   1 0  1   1 1   x  x  x  x  x  P   P u 0    - - - - 0 - - d d d  d d Rdd=membh(Rx++Mu:brev
                                                                                       )
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                        280
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
      11.6        MEMOP
                  The MEMOP instruction class includes simple operations on values in memory.
                  MEMOP instructions are executable on slot 0.
          Operation on memory byte
                  Perform ALU or bit operation on the memory byte at the effective address.
                   Syntax                                   Behavior
                   memb(Rs+#u6:0)=clrbit(#U5)               apply_extension(#u);
                                                            EA=Rs+#u;
                                                            tmp = *EA;
                                                            tmp &= (~(1<<#U));
                                                            *EA = tmp;
                   memb(Rs+#u6:0)=setbit(#U5)               apply_extension(#u);
                                                            EA=Rs+#u;
                                                            tmp = *EA;
                                                            tmp |= (1<<#U);
                                                            *EA = tmp;
                   memb(Rs+#u6:0)[+-]=#U5                   apply_extension(#u);
                                                            EA=Rs[+-]#u;
                                                            tmp = *EA;
                                                            tmp [+-]= #U;
                                                            *EA = tmp;
                   memb(Rs+#u6:0)[+-|&]=Rt                  apply_extension(#u);
                                                            EA=Rs+#u;
                                                            tmp = *EA;
                                                            tmp [+-|&]= Rt;
                                                            *EA = tmp;
                  Class: MEMOP (slots 0)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS                              s5       Parse                              t5
 0  0  1  1 1  1   1 0   - 0  0   s  s  s  s  s P   P 0   i   i i  i i i  0 0  t t  t t t memb(Rs+#u6:0)+=Rt
 0  0  1  1 1  1   1 0   - 0  0   s  s  s  s  s P   P 0   i   i i  i i i  0 1  t t  t t t memb(Rs+#u6:0)-=Rt
 0  0  1  1 1  1   1 0   - 0  0   s  s  s  s  s P   P 0   i   i i  i i i  1 0  t t  t t t memb(Rs+#u6:0)&=Rt
 0  0  1  1 1  1   1 0   - 0  0   s  s  s  s  s P   P 0   i   i i  i i i  1 1  t t  t t t memb(Rs+#u6:0)|=Rt
   ICLASS                              s5       Parse
 0  0  1  1 1  1   1 1   - 0  0   s  s  s  s  s P   P 0   i   i i  i i i  0 0  I I  I I I memb(Rs+#u6:0)+=#U5
 0  0  1  1 1  1   1 1   - 0  0   s  s  s  s  s P   P 0   i   i i  i i i  0 1  I I  I I I memb(Rs+#u6:0)-=#U5
                                                                                          memb(Rs+#u6:0)=clrbit(#U
 0  0  1  1 1  1   1 1   - 0  0   s  s  s  s  s P   P 0   i   i i  i i i  1 0  I I  I I I
                                                                                          5)
                                                                                          memb(Rs+#u6:0)=setbit(#
 0  0  1  1 1  1   1 1   - 0  0   s  s  s  s  s P   P 0   i   i i  i i i  1 1  I I  I I I
                                                                                          U5)
80-N2040-45 Rev. B                                                                                              281
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  s5           Field to encode register s
                  t5           Field to encode register t
80-N2040-45 Rev. B                                                    282
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
          Operation on memory halfword
                  Perform ALU or bit operation on the memory halfword at the effective address.
                   Syntax                                   Behavior
                   memh(Rs+#u6:1)=clrbit(#U5)               apply_extension(#u);
                                                            EA=Rs+#u;
                                                            tmp = *EA;
                                                            tmp &= (~(1<<#U));
                                                            *EA = tmp;
                   memh(Rs+#u6:1)=setbit(#U5)               apply_extension(#u);
                                                            EA=Rs+#u;
                                                            tmp = *EA;
                                                            tmp |= (1<<#U);
                                                            *EA = tmp;
                   memh(Rs+#u6:1)[+-]=#U5                   apply_extension(#u);
                                                            EA=Rs[+-]#u;
                                                            tmp = *EA;
                                                            tmp [+-]= #U;
                                                            *EA = tmp;
                   memh(Rs+#u6:1)[+-|&]=Rt                  apply_extension(#u);
                                                            EA=Rs+#u;
                                                            tmp = *EA;
                                                            tmp [+-|&]= Rt;
                                                            *EA = tmp;
                  Class: MEMOP (slots 0)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS                              s5        Parse                             t5
 0  0  1  1 1  1   1 0   - 0  1   s  s  s  s  s  P   P 0  i   i i  i i i  0 0  t t  t t t memh(Rs+#u6:1)+=Rt
 0  0  1  1 1  1   1 0   - 0  1   s  s  s  s  s  P   P 0  i   i i  i i i  0 1  t t  t t t memh(Rs+#u6:1)-=Rt
 0  0  1  1 1  1   1 0   - 0  1   s  s  s  s  s  P   P 0  i   i i  i i i  1 0  t t  t t t memh(Rs+#u6:1)&=Rt
 0  0  1  1 1  1   1 0   - 0  1   s  s  s  s  s  P   P 0  i   i i  i i i  1 1  t t  t t t memh(Rs+#u6:1)|=Rt
   ICLASS                              s5        Parse
 0  0  1  1 1  1   1 1   - 0  1   s  s  s  s  s  P   P 0  i   i i  i i i  0 0  I I  I I I memh(Rs+#u6:1)+=#U5
 0  0  1  1 1  1   1 1   - 0  1   s  s  s  s  s  P   P 0  i   i i  i i i  0 1  I I  I I I memh(Rs+#u6:1)-=#U5
                                                                                          memh(Rs+#u6:1)=clrbit(#U
 0  0  1  1 1  1   1 1   - 0  1   s  s  s  s  s  P   P 0  i   i i  i i i  1 0  I I  I I I
                                                                                          5)
                                                                                          memh(Rs+#u6:1)=setbit(#
 0  0  1  1 1  1   1 1   - 0  1   s  s  s  s  s  P   P 0  i   i i  i i i  1 1  I I  I I I
                                                                                          U5)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              283
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
          Operation on memory word
                  Perform ALU or bit operation on the memory word at the effective address.
                   Syntax                                   Behavior
                   memw(Rs+#u6:2)=clrbit(#U5)               apply_extension(#u);
                                                            EA=Rs+#u;
                                                            tmp = *EA;
                                                            tmp &= (~(1<<#U));
                                                            *EA = tmp;
                   memw(Rs+#u6:2)=setbit(#U5)               apply_extension(#u);
                                                            EA=Rs+#u;
                                                            tmp = *EA;
                                                            tmp |= (1<<#U);
                                                            *EA = tmp;
                   memw(Rs+#u6:2)[+-]=#U5                   apply_extension(#u);
                                                            EA=Rs[+-]#u;
                                                            tmp = *EA;
                                                            tmp [+-]= #U;
                                                            *EA = tmp;
                   memw(Rs+#u6:2)[+-|&]=Rt                  apply_extension(#u);
                                                            EA=Rs+#u;
                                                            tmp = *EA;
                                                            tmp [+-|&]= Rt;
                                                            *EA = tmp;
                  Class: MEMOP (slots 0)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS                              s5        Parse                             t5
 0  0  1  1 1  1   1 0   - 1  0   s  s  s  s  s  P   P 0  i   i i  i i i  0 0  t t  t t t memw(Rs+#u6:2)+=Rt
 0  0  1  1 1  1   1 0   - 1  0   s  s  s  s  s  P   P 0  i   i i  i i i  0 1  t t  t t t memw(Rs+#u6:2)-=Rt
 0  0  1  1 1  1   1 0   - 1  0   s  s  s  s  s  P   P 0  i   i i  i i i  1 0  t t  t t t memw(Rs+#u6:2)&=Rt
 0  0  1  1 1  1   1 0   - 1  0   s  s  s  s  s  P   P 0  i   i i  i i i  1 1  t t  t t t memw(Rs+#u6:2)|=Rt
   ICLASS                              s5        Parse
 0  0  1  1 1  1   1 1   - 1  0   s  s  s  s  s  P   P 0  i   i i  i i i  0 0  I I  I I I memw(Rs+#u6:2)+=#U5
 0  0  1  1 1  1   1 1   - 1  0   s  s  s  s  s  P   P 0  i   i i  i i i  0 1  I I  I I I memw(Rs+#u6:2)-=#U5
                                                                                          memw(Rs+#u6:2)=clrbit(#U
 0  0  1  1 1  1   1 1   - 1  0   s  s  s  s  s  P   P 0  i   i i  i i i  1 0  I I  I I I
                                                                                          5)
                                                                                          memw(Rs+#u6:2)=setbit(#
 0  0  1  1 1  1   1 1   - 1  0   s  s  s  s  s  P   P 0  i   i i  i i i  1 1  I I  I I I
                                                                                          U5)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             284
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
     11.7         NV
                  The NV instruction class includes instructions which take the register source operand from
                  another instruction in the same packet.
                  NV instructions are executable on slot 0.
    11.7.1        NV/J
                  The NV/J instruction subclass includes jump instructions which take the register source
                  operand from another instruction in the same packet.
        Jump to address condition on new register value
                  Compare a register or constant against the value produced by a slot 1 instruction. If the
                  comparison is true, the program counter is changed to a target address, relative to the
                  current PC.
                  This instruction is executable only on slot 0.
                   Syntax                              Behavior
                   if ([!]cmp.eq(Ns.new,#-1))          ;
                   jump:<hint> #r9:2                   if ((Ns.new[!]=(-1))) {
                                                            apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            PC=PC+#r;
                                                       }
                   if ([!]cmp.eq(Ns.new,#U5))          ;
                   jump:<hint> #r9:2                   if ((Ns.new[!]=(#U))) {
                                                            apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            PC=PC+#r;
                                                       }
                   if ([!]cmp.eq(Ns.new,Rt))           ;
                   jump:<hint> #r9:2                   if ((Ns.new[!]=Rt)) {
                                                            apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            PC=PC+#r;
                                                       }
                   if ([!]cmp.gt(Ns.new,#-1))          ;
                   jump:<hint> #r9:2                   if ([!](Ns.new>(-1))) {
                                                            apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            PC=PC+#r;
                                                       }
                   if ([!]cmp.gt(Ns.new,#U5))          ;
                   jump:<hint> #r9:2                   if ([!](Ns.new>(#U))) {
                                                            apply_extension(#r);
                                                            #r=#r & ~PCALIGN_MASK;
                                                            PC=PC+#r;
                                                       }
80-N2040-45 Rev. B                                                                                           285
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
                   Syntax                                   Behavior
                   if ([!]cmp.gt(Ns.new,Rt))                ;
                   jump:<hint> #r9:2                        if ([!](Ns.new>Rt)) {
                                                                 apply_extension(#r);
                                                                 #r=#r & ~PCALIGN_MASK;
                                                                 PC=PC+#r;
                                                            }
                   if ([!]cmp.gt(Rt,Ns.new))                ;
                   jump:<hint> #r9:2                        if ([!](Rt>Ns.new)) {
                                                                 apply_extension(#r);
                                                                 #r=#r & ~PCALIGN_MASK;
                                                                 PC=PC+#r;
                                                            }
                   if ([!]cmp.gtu(Ns.new,#U5))              ;
                   jump:<hint> #r9:2                        if ([!](Ns.new.uw[0]>(#U))) {
                                                                 apply_extension(#r);
                                                                 #r=#r & ~PCALIGN_MASK;
                                                                 PC=PC+#r;
                                                            }
                   if ([!]cmp.gtu(Ns.new,Rt))               ;
                   jump:<hint> #r9:2                        if ([!](Ns.new.uw[0]>Rt.uw[0])) {
                                                                 apply_extension(#r);
                                                                 #r=#r & ~PCALIGN_MASK;
                                                                 PC=PC+#r;
                                                            }
                   if ([!]cmp.gtu(Rt,Ns.new))               ;
                   jump:<hint> #r9:2                        if ([!](Rt.uw[0]>Ns.new.uw[0])) {
                                                                 apply_extension(#r);
                                                                 #r=#r & ~PCALIGN_MASK;
                                                                 PC=PC+#r;
                                                            }
                   if ([!]tstbit(Ns.new,#0))                ;
                   jump:<hint> #r9:2                        if ([!]((Ns.new) & 1)) {
                                                                 apply_extension(#r);
                                                                 #r=#r & ~PCALIGN_MASK;
                                                                 PC=PC+#r;
                                                            }
                  Class: NV (slots 0)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1  0
   ICLASS                                 s3    Parse           t5
                                                                                            if (cmp.eq(Ns.new,Rt))
 0  0  1  0 0  0   0 0  0  0   i  i  -  s  s  s P   P 0   t   t  t t  t i  i i  i i  i  i - jump:nt #r9:2
                                                                                            if (cmp.eq(Ns.new,Rt))
 0  0  1  0 0  0   0 0  0  0   i  i  -  s  s  s P   P 1   t   t  t t  t i  i i  i i  i  i -
                                                                                            jump:t #r9:2
                                                                                            if (!cmp.eq(Ns.new,Rt))
 0  0  1  0 0  0   0 0  0  1   i  i  -  s  s  s P   P 0   t   t  t t  t i  i i  i i  i  i -
                                                                                            jump:nt #r9:2
                                                                                            if (!cmp.eq(Ns.new,Rt))
 0  0  1  0 0  0   0 0  0  1   i  i  -  s  s  s P   P 1   t   t  t t  t i  i i  i i  i  i -
                                                                                            jump:t #r9:2
                                                                                            if (cmp.gt(Ns.new,Rt))
 0  0  1  0 0  0   0 0  1  0   i  i  -  s  s  s P   P 0   t   t  t t  t i  i i  i i  i  i -
                                                                                            jump:nt #r9:2
                                                                                            if (cmp.gt(Ns.new,Rt))
 0  0  1  0 0  0   0 0  1  0   i  i  -  s  s  s P   P 1   t   t  t t  t i  i i  i i  i  i -
                                                                                            jump:t #r9:2
80-N2040-45 Rev. B                                                                                                  286
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
                                                                                      if (!cmp.gt(Ns.new,Rt))
 0  0  1  0 0  0   0 0  1  1   i  i  -  s  s  s P   P 0   t  t  t t t i i i i i i i -
                                                                                      jump:nt #r9:2
                                                                                      if (!cmp.gt(Ns.new,Rt))
 0  0  1  0 0  0   0 0  1  1   i  i  -  s  s  s P   P 1   t  t  t t t i i i i i i i -
                                                                                      jump:t #r9:2
                                                                                      if (cmp.gtu(Ns.new,Rt))
 0  0  1  0 0  0   0 1  0  0   i  i  -  s  s  s P   P 0   t  t  t t t i i i i i i i -
                                                                                      jump:nt #r9:2
                                                                                      if (cmp.gtu(Ns.new,Rt))
 0  0  1  0 0  0   0 1  0  0   i  i  -  s  s  s P   P 1   t  t  t t t i i i i i i i - jump:t #r9:2
                                                                                      if (!cmp.gtu(Ns.new,Rt))
 0  0  1  0 0  0   0 1  0  1   i  i  -  s  s  s P   P 0   t  t  t t t i i i i i i i -
                                                                                      jump:nt #r9:2
 0  0  1  0 0  0   0 1  0  1   i  i  -  s  s  s P   P 1   t  t  t t t i i i i i i i - if (!cmp.gtu(Ns.new,Rt))
                                                                                      jump:t #r9:2
                                                                                      if (cmp.gt(Rt,Ns.new))
 0  0  1  0 0  0   0 1  1  0   i  i  -  s  s  s P   P 0   t  t  t t t i i i i i i i -
                                                                                      jump:nt #r9:2
                                                                                      if (cmp.gt(Rt,Ns.new))
 0  0  1  0 0  0   0 1  1  0   i  i  -  s  s  s P   P 1   t  t  t t t i i i i i i i -
                                                                                      jump:t #r9:2
                                                                                      if (!cmp.gt(Rt,Ns.new))
 0  0  1  0 0  0   0 1  1  1   i  i  -  s  s  s P   P 0   t  t  t t t i i i i i i i -
                                                                                      jump:nt #r9:2
                                                                                      if (!cmp.gt(Rt,Ns.new))
 0  0  1  0 0  0   0 1  1  1   i  i  -  s  s  s P   P 1   t  t  t t t i i i i i i i - jump:t #r9:2
                                                                                      if (cmp.gtu(Rt,Ns.new))
 0  0  1  0 0  0   1 0  0  0   i  i  -  s  s  s P   P 0   t  t  t t t i i i i i i i - jump:nt #r9:2
 0  0  1  0 0  0   1 0  0  0   i  i  -  s  s  s P   P 1   t  t  t t t i i i i i i i - if (cmp.gtu(Rt,Ns.new))
                                                                                      jump:t #r9:2
 0  0  1  0 0  0   1 0  0  1   i  i  -  s  s  s P   P 0   t  t  t t t i i i i i i i - if (!cmp.gtu(Rt,Ns.new))
                                                                                      jump:nt #r9:2
                                                                                      if (!cmp.gtu(Rt,Ns.new))
 0  0  1  0 0  0   1 0  0  1   i  i  -  s  s  s P   P 1   t  t  t t t i i i i i i i -
                                                                                      jump:t #r9:2
   ICLASS                                 s3    Parse
                                                                                      if (cmp.eq(Ns.new,#U5))
 0  0  1  0 0  1   0 0  0  0   i  i  -  s  s  s P   P 0   I  I  I I I i i i i i i i -
                                                                                      jump:nt #r9:2
 0  0  1  0 0  1   0 0  0  0   i  i  -  s  s  s P   P 1   I  I  I I I i i i i i i i - if (cmp.eq(Ns.new,#U5))
                                                                                      jump:t #r9:2
                                                                                      if (!cmp.eq(Ns.new,#U5))
 0  0  1  0 0  1   0 0  0  1   i  i  -  s  s  s P   P 0   I  I  I I I i i i i i i i - jump:nt #r9:2
                                                                                      if (!cmp.eq(Ns.new,#U5))
 0  0  1  0 0  1   0 0  0  1   i  i  -  s  s  s P   P 1   I  I  I I I i i i i i i i -
                                                                                      jump:t #r9:2
                                                                                      if (cmp.gt(Ns.new,#U5))
 0  0  1  0 0  1   0 0  1  0   i  i  -  s  s  s P   P 0   I  I  I I I i i i i i i i - jump:nt #r9:2
                                                                                      if (cmp.gt(Ns.new,#U5))
 0  0  1  0 0  1   0 0  1  0   i  i  -  s  s  s P   P 1   I  I  I I I i i i i i i i - jump:t #r9:2
                                                                                      if (!cmp.gt(Ns.new,#U5))
 0  0  1  0 0  1   0 0  1  1   i  i  -  s  s  s P   P 0   I  I  I I I i i i i i i i -
                                                                                      jump:nt #r9:2
                                                                                      if (!cmp.gt(Ns.new,#U5))
 0  0  1  0 0  1   0 0  1  1   i  i  -  s  s  s P   P 1   I  I  I I I i i i i i i i -
                                                                                      jump:t #r9:2
                                                                                      if (cmp.gtu(Ns.new,#U5))
 0  0  1  0 0  1   0 1  0  0   i  i  -  s  s  s P   P 0   I  I  I I I i i i i i i i -
                                                                                      jump:nt #r9:2
                                                                                      if (cmp.gtu(Ns.new,#U5))
 0  0  1  0 0  1   0 1  0  0   i  i  -  s  s  s P   P 1   I  I  I I I i i i i i i i - jump:t #r9:2
                                                                                      if (!cmp.gtu(Ns.new,#U5))
 0  0  1  0 0  1   0 1  0  1   i  i  -  s  s  s P   P 0   I  I  I I I i i i i i i i - jump:nt #r9:2
                                                                                      if (!cmp.gtu(Ns.new,#U5))
 0  0  1  0 0  1   0 1  0  1   i  i  -  s  s  s P   P 1   I  I  I I I i i i i i i i - jump:t #r9:2
                                                                                      if (tstbit(Ns.new,#0))
 0  0  1  0 0  1   0 1  1  0   i  i  -  s  s  s P   P 0   -  -  - - - i i i i i i i -
                                                                                      jump:nt #r9:2
                                                                                      if (tstbit(Ns.new,#0)) jump:t
 0  0  1  0 0  1   0 1  1  0   i  i  -  s  s  s P   P 1   -  -  - - - i i i i i i i -
                                                                                      #r9:2
                                                                                      if (!tstbit(Ns.new,#0))
 0  0  1  0 0  1   0 1  1  1   i  i  -  s  s  s P   P 0   -  -  - - - i i i i i i i -
                                                                                      jump:nt #r9:2
                                                                                      if (!tstbit(Ns.new,#0)) jump:t
 0  0  1  0 0  1   0 1  1  1   i  i  -  s  s  s P   P 1   -  -  - - - i i i i i i i -
                                                                                      #r9:2
                                                                                      if (cmp.eq(Ns.new,#-1))
 0  0  1  0 0  1   1 0  0  0   i  i  -  s  s  s P   P 0   -  -  - - - i i i i i i i -
                                                                                      jump:nt #r9:2
80-N2040-45 Rev. B                                                                                               287
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
                                                                                      if (cmp.eq(Ns.new,#-1))
 0  0 1  0  0  1   1 0  0  0   i  i  -  s  s  s  P  P 1   -   - - - - i i i i i i i -
                                                                                      jump:t #r9:2
                                                                                      if (!cmp.eq(Ns.new,#-1))
 0  0 1  0  0  1   1 0  0  1   i  i  -  s  s  s  P  P 0   -   - - - - i i i i i i i -
                                                                                      jump:nt #r9:2
                                                                                      if (!cmp.eq(Ns.new,#-1))
 0  0 1  0  0  1   1 0  0  1   i  i  -  s  s  s  P  P 1   -   - - - - i i i i i i i -
                                                                                      jump:t #r9:2
                                                                                      if (cmp.gt(Ns.new,#-1))
 0  0 1  0  0  1   1 0  1  0   i  i  -  s  s  s  P  P 0   -   - - - - i i i i i i i - jump:nt #r9:2
                                                                                      if (cmp.gt(Ns.new,#-1))
 0  0 1  0  0  1   1 0  1  0   i  i  -  s  s  s  P  P 1   -   - - - - i i i i i i i -
                                                                                      jump:t #r9:2
 0  0 1  0  0  1   1 0  1  1   i  i  -  s  s  s  P  P 0   -   - - - - i i i i i i i - if (!cmp.gt(Ns.new,#-1))
                                                                                      jump:nt #r9:2
                                                                                      if (!cmp.gt(Ns.new,#-1))
 0  0 1  0  0  1   1 0  1  1   i  i  -  s  s  s  P  P 1   -   - - - - i i i i i i i -
                                                                                      jump:t #r9:2
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s3                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             288
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
    11.7.2        NV/ST
                  The NV/ST instruction subclass includes store instructions which take the register source
                  operand from another instruction in the same packet.
        Store new-value byte
                  Store the least-significant byte in a source register in memory at the effective address.
                   Syntax                                Behavior
                   memb(Re=#U6)=Nt.new                   apply_extension(#U);
                                                         EA=#U;
                                                         *EA = Nt.new&0xff;
                                                         Re=#U;
                   memb(Rs+#s11:0)=Nt.new                apply_extension(#s);
                                                         EA=Rs+#s;
                                                         *EA = Nt.new&0xff;
                   memb(Rs+Ru<<#u2)=Nt.new               EA=Rs+(Ru<<#u);
                                                         *EA = Nt.new&0xff;
                   memb(Ru<<#u2+#U6)=Nt.new              apply_extension(#U);
                                                         EA=#U+(Ru<<#u);
                                                         *EA = Nt.new&0xff;
                   memb(Rx++#s4:0)=Nt.new                EA=Rx;
                                                         Rx=Rx+#s;
                                                         *EA = Nt.new&0xff;
                   memb(Rx++#s4:0:circ(Mu))=Nt.new       EA=Rx;
                                                         Rx=Rx=circ_add(Rx,#s,MuV);
                                                         *EA = Nt.new&0xff;
                   memb(Rx++I:circ(Mu))=Nt.new           EA=Rx;
                                                         Rx=Rx=circ_add(Rx,I<<0,MuV);
                                                         *EA = Nt.new&0xff;
                   memb(Rx++Mu)=Nt.new                   EA=Rx;
                                                         Rx=Rx+MuV;
                                                         *EA = Nt.new&0xff;
                   memb(Rx++Mu:brev)=Nt.new              EA=Rx.h[1] | brev(Rx.h[0]);
                                                         Rx=Rx+MuV;
                                                         *EA = Nt.new&0xff;
                   memb(gp+#u16:0)=Nt.new                apply_extension(#u);
                                                         EA=(Constant_extended ? (0) : GP)+#u;
                                                         *EA = Nt.new&0xff;
                  Class: NV (slots 0)
                  Notes
                       ■  Forms of this instruction which use a new-value operand produced in the packet
                          must execute on slot 0.
                       ■  This instruction can execute only in slot 0, even though it is an ST instruction.
80-N2040-45 Rev. B                                                                                            289
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1  0
   ICLASS                              s5        Parse         u5                  t3
                                                                                        memb(Rs+Ru<<#u2)=Nt.n
 0  0  1  1 1  0   1  1  1   0  1 s  s  s  s  s  P   P  i u  u  u u  u i - - 0 0 t  t t
                                                                                        ew
   ICLASS                  Type                  Parse            t3
 0  1  0  0 1   i   i 0  1   0  1 i  i  i   i  i P   P  i 0  0  t  t t i i i i i i  i i memb(gp+#u16:0)=Nt.new
                                U
   ICLASS    Amode      Type           s5        Parse            t3
                                N
 1  0  1  0 0   i   i 1  1   0  1 s  s  s  s  s  P   P  i 0  0  t  t t i i i i i i  i i memb(Rs+#s11:0)=Nt.new
                                U
   ICLASS    Amode      Type           x5        Parse u1         t3
                                N
                                                                                        memb(Rx++I:circ(Mu))=Nt.
 1  0  1  0 1  0   0  1  1   0  1 x  x  x  x  x  P   P u 0   0  t  t t 0 - - - - - 1  -
                                                                                        new
                                                                                        memb(Rx++#s4:0:circ(Mu))
 1  0  1  0 1  0   0  1  1   0  1 x  x  x  x  x  P   P u 0   0  t  t t 0 i i i i - 0  -
                                                                                        =Nt.new
                                U
   ICLASS    Amode      Type    N      e5        Parse            t3
 1  0  1  0 1  0   1  1  1   0  1 e  e  e  e  e  P   P 0  0  0  t  t t 1 - I I I I  I I memb(Re=#U6)=Nt.new
                                U
   ICLASS    Amode      Type           x5        Parse            t3
                                N
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 0  0  0  t  t t 0 i i i i - 0  - memb(Rx++#s4:0)=Nt.new
                                U
   ICLASS    Amode      Type           u5        Parse            t3
                                N
                                                                                        memb(Ru<<#u2+#U6)=Nt.
 1  0  1  0 1  1   0  1  1   0  1 u  u  u  u  u  P   P  i 0  0  t  t t 1 i I I I I  I I new
                                U
   ICLASS    Amode      Type    N      x5        Parse u1         t3
 1  0  1  0 1  1   0  1  1   0  1 x  x  x  x  x  P   P u 0   0  t  t t 0 - - - - -  - - memb(Rx++Mu)=Nt.new
                                                                                        memb(Rx++Mu:brev)=Nt.n
 1  0  1  0 1  1   1  1  1   0  1 x  x  x  x  x  P   P u 0   0  t  t t 0 - - - - -  - -
                                                                                        ew
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  Parse             Packet/Loop parse bits
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t3                Field to encode register t
                  u1                Field to encode register u
                  u5                Field to encode register u
                  x5                Field to encode register x
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                           290
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Store new-value byte conditionally
                  Store the least-significant byte in a source register in memory at the effective address.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                                Behavior
                   if ([!]Pv[.new])                      apply_extension(#u);
                   memb(#u6)=Nt.new                      EA=#u;
                                                         if ([!]Pv[.new][0]) {
                                                              *EA = Nt[.new]&0xff;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv[.new])                      apply_extension(#u);
                   memb(Rs+#u6:0)=Nt.new                 EA=Rs+#u;
                                                         if ([!]Pv[.new][0]) {
                                                              *EA = Nt[.new]&0xff;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv[.new])                      EA=Rs+(Ru<<#u);
                   memb(Rs+Ru<<#u2)=Nt.new               if ([!]Pv[.new][0]) {
                                                              *EA = Nt[.new]&0xff;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv[.new])                      EA=Rx;
                   memb(Rx++#s4:0)=Nt.new                if ([!]Pv[.new][0]){
                                                              Rx=Rx+#s;
                                                              *EA = Nt[.new]&0xff;
                                                         } else {
                                                              NOP;
                                                         }
                  Class: NV (slots 0)
                  Notes
                       ■   Forms of this instruction which use a new-value operand produced in the packet
                           must execute on slot 0.
                       ■   This instruction can execute only in slot 0, even though it is an ST instruction.
80-N2040-45 Rev. B                                                                                             291
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1  0
   ICLASS                              s5        Parse         u5                  t3
                                                                                        if (Pv)
 0  0  1  1 0  1   0  0  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 0 0 t  t t memb(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                                                                                        if (!Pv)
 0  0  1  1 0  1   0  1  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 0 0 t  t t memb(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                                                                                        if (Pv.new)
 0  0  1  1 0  1   1  0  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 0 0 t  t t memb(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                                                                                        if (!Pv.new)
 0  0  1  1 0  1   1  1  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 0 0 t  t t memb(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                   Pr
               Se
                  ed
   ICLASS      ns Ne       Type        s5        Parse            t3
                e w
 0  1  0  0 0  0   0  0  1   0  1 s  s  s  s  s  P   P i 0   0  t  t t i i i i i 0 v  v ifmemb(Rs+#u6:0)=Nt.new
                                                                                           (Pv)
                                                                                        if (Pv.new)
 0  1  0  0 0  0   1  0  1   0  1 s  s  s  s  s  P   P i 0   0  t  t t i i i i i 0 v  v memb(Rs+#u6:0)=Nt.new
 0  1  0  0 0  1   0  0  1   0  1 s  s  s  s  s  P   P i 0   0  t  t t i i i i i 0 v  v ifmemb(Rs+#u6:0)=Nt.new
                                                                                           (!Pv)
 0  1  0  0 0  1   1  0  1   0  1 s  s  s  s  s  P   P i 0   0  t  t t i i i i i 0 v  v ifmemb(Rs+#u6:0)=Nt.new
                                                                                           (!Pv.new)
                                U
   ICLASS    Amode      Type           x5        Parse            t3
                                N
                                                                                      v ifmemb(Rx++#s4:0)=Nt.new
                                                                                           (Pv)
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 0   0  t  t t 0 i i i i 0 v
                                                                                      v ifmemb(Rx++#s4:0)=Nt.new
                                                                                           (!Pv)
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 0   0  t  t t 0 i i i i 1 v
                                                                                        if (Pv.new)
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 0   0  t  t t 1 i i i i 0 v  v memb(Rx++#s4:0)=Nt.new
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 0   0  t  t t 1 i i i i 1 v  v ifmemb(Rx++#s4:0)=Nt.new
                                                                                           (!Pv.new)
                                U
   ICLASS    Amode      Type    N                Parse            t3
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 0 0   0  t  t t 1 i i i i 0 v  v if (Pv) memb(#u6)=Nt.new
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 0 0   0  t  t t 1 i i i i 1 v  v if (!Pv) memb(#u6)=Nt.new
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 1 0   0  t  t t 1 i i i i 0 v  v ifmemb(#u6)=Nt.new
                                                                                           (Pv.new)
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 1 0   0  t  t t 1 i i i i 1 v  v ifmemb(#u6)=Nt.new
                                                                                           (!Pv.new)
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t3                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                             292
Hexagon V67 Programmer’s Reference Manual  Instruction Set
                  Field name   Description
                  Amode        Amode
                  Type         Type
                  UN           Unsigned
80-N2040-45 Rev. B                                     293
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Store new-value halfword
                  Store the upper or lower 16-bits of a source register in memory at the effective address.
                   Syntax                              Behavior
                   memh(Re=#U6)=Nt.new                  apply_extension(#U);
                                                        EA=#U;
                                                        *EA = Nt.new.h[0];
                                                        Re=#U;
                   memh(Rs+#s11:1)=Nt.new               apply_extension(#s);
                                                        EA=Rs+#s;
                                                        *EA = Nt.new.h[0];
                   memh(Rs+Ru<<#u2)=Nt.new              EA=Rs+(Ru<<#u);
                                                        *EA = Nt.new.h[0];
                   memh(Ru<<#u2+#U6)=Nt.new             apply_extension(#U);
                                                        EA=#U+(Ru<<#u);
                                                        *EA = Nt.new.h[0];
                   memh(Rx++#s4:1)=Nt.new               EA=Rx;
                                                        Rx=Rx+#s;
                                                        *EA = Nt.new.h[0];
                   memh(Rx++#s4:1:circ(Mu))=Nt.new      EA=Rx;
                                                        Rx=Rx=circ_add(Rx,#s,MuV);
                                                        *EA = Nt.new.h[0];
                   memh(Rx++I:circ(Mu))=Nt.new          EA=Rx;
                                                        Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                        *EA = Nt.new.h[0];
                   memh(Rx++Mu)=Nt.new                  EA=Rx;
                                                        Rx=Rx+MuV;
                                                        *EA = Nt.new.h[0];
                   memh(Rx++Mu:brev)=Nt.new             EA=Rx.h[1] | brev(Rx.h[0]);
                                                        Rx=Rx+MuV;
                                                        *EA = Nt.new.h[0];
                   memh(gp+#u16:1)=Nt.new               apply_extension(#u);
                                                        EA=(Constant_extended ? (0) : GP)+#u;
                                                        *EA = Nt.new.h[0];
                  Class: NV (slots 0)
                  Notes
                       ■  Forms of this instruction which use a new-value operand produced in the packet
                          must execute on slot 0.
                       ■  This instruction can execute only in slot 0, even though it is an ST instruction.
80-N2040-45 Rev. B                                                                                           294
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1  0
   ICLASS                              s5        Parse         u5                  t3
                                                                                        memh(Rs+Ru<<#u2)=Nt.n
 0  0  1  1 1  0   1  1  1   0  1 s  s  s  s  s  P   P  i u  u  u u  u i - - 0 1 t  t t
                                                                                        ew
   ICLASS                  Type                  Parse            t3
 0  1  0  0 1   i   i 0  1   0  1 i  i  i   i  i P   P  i 0  1  t  t t i i i i i i  i i memh(gp+#u16:1)=Nt.new
                                U
   ICLASS    Amode      Type           s5        Parse            t3
                                N
 1  0  1  0 0   i   i 1  1   0  1 s  s  s  s  s  P   P  i 0  1  t  t t i i i i i i  i i memh(Rs+#s11:1)=Nt.new
                                U
   ICLASS    Amode      Type           x5        Parse u1         t3
                                N
                                                                                        memh(Rx++I:circ(Mu))=Nt.
 1  0  1  0 1  0   0  1  1   0  1 x  x  x  x  x  P   P u 0   1  t  t t 0 - - - - - 1  -
                                                                                        new
                                                                                        memh(Rx++#s4:1:circ(Mu))
 1  0  1  0 1  0   0  1  1   0  1 x  x  x  x  x  P   P u 0   1  t  t t 0 i i i i - 0  -
                                                                                        =Nt.new
                                U
   ICLASS    Amode      Type    N      e5        Parse            t3
 1  0  1  0 1  0   1  1  1   0  1 e  e  e  e  e  P   P 0  0  1  t  t t 1 - I I I I  I I memh(Re=#U6)=Nt.new
                                U
   ICLASS    Amode      Type           x5        Parse            t3
                                N
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 0  0  1  t  t t 0 i i i i - 0  - memh(Rx++#s4:1)=Nt.new
                                U
   ICLASS    Amode      Type           u5        Parse            t3
                                N
                                                                                        memh(Ru<<#u2+#U6)=Nt.
 1  0  1  0 1  1   0  1  1   0  1 u  u  u  u  u  P   P  i 0  1  t  t t 1 i I I I I  I I new
                                U
   ICLASS    Amode      Type    N      x5        Parse u1         t3
 1  0  1  0 1  1   0  1  1   0  1 x  x  x  x  x  P   P u 0   1  t  t t 0 - - - - -  - - memh(Rx++Mu)=Nt.new
                                                                                        memh(Rx++Mu:brev)=Nt.n
 1  0  1  0 1  1   1  1  1   0  1 x  x  x  x  x  P   P u 0   1  t  t t 0 - - - - -  - -
                                                                                        ew
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  Parse             Packet/Loop parse bits
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t3                Field to encode register t
                  u1                Field to encode register u
                  u5                Field to encode register u
                  x5                Field to encode register x
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                           295
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Store new-value halfword conditionally
                  Store the upper or lower 16-bits of a source register in memory at the effective address.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                              Behavior
                   if ([!]Pv[.new])                     apply_extension(#u);
                   memh(#u6)=Nt.new                     EA=#u;
                                                        if ([!]Pv[.new][0]) {
                                                              *EA = Nt[.new].h[0];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     apply_extension(#u);
                   memh(Rs+#u6:1)=Nt.new                EA=Rs+#u;
                                                        if ([!]Pv[.new][0]) {
                                                              *EA = Nt[.new].h[0];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     EA=Rs+(Ru<<#u);
                   memh(Rs+Ru<<#u2)=Nt.new              if ([!]Pv[.new][0]) {
                                                              *EA = Nt[.new].h[0];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     EA=Rx;
                   memh(Rx++#s4:1)=Nt.new               if ([!]Pv[.new][0]){
                                                              Rx=Rx+#s;
                                                              *EA = Nt[.new].h[0];
                                                        } else {
                                                              NOP;
                                                        }
                  Class: NV (slots 0)
                  Notes
                       ■   Forms of this instruction which use a new-value operand produced in the packet
                           must execute on slot 0.
                       ■   This instruction can execute only in slot 0, even though it is an ST instruction.
80-N2040-45 Rev. B                                                                                             296
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1  0
   ICLASS                              s5        Parse         u5                  t3
                                                                                        if (Pv)
 0  0  1  1 0  1   0  0  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 0 1 t  t t memh(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                                                                                        if (!Pv)
 0  0  1  1 0  1   0  1  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 0 1 t  t t memh(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                                                                                        if (Pv.new)
 0  0  1  1 0  1   1  0  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 0 1 t  t t memh(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                                                                                        if (!Pv.new)
 0  0  1  1 0  1   1  1  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 0 1 t  t t memh(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                   Pr
               Se
                  ed
   ICLASS      ns Ne       Type        s5        Parse            t3
                e w
 0  1  0  0 0  0   0  0  1   0  1 s  s  s  s  s  P   P i 0   1  t  t t i i i i i 0 v  v ifmemh(Rs+#u6:1)=Nt.new
                                                                                           (Pv)
                                                                                        if (Pv.new)
 0  1  0  0 0  0   1  0  1   0  1 s  s  s  s  s  P   P i 0   1  t  t t i i i i i 0 v  v memh(Rs+#u6:1)=Nt.new
 0  1  0  0 0  1   0  0  1   0  1 s  s  s  s  s  P   P i 0   1  t  t t i i i i i 0 v  v ifmemh(Rs+#u6:1)=Nt.new
                                                                                           (!Pv)
 0  1  0  0 0  1   1  0  1   0  1 s  s  s  s  s  P   P i 0   1  t  t t i i i i i 0 v  v ifmemh(Rs+#u6:1)=Nt.new
                                                                                           (!Pv.new)
                                U
   ICLASS    Amode      Type           x5        Parse            t3
                                N
                                                                                      v ifmemh(Rx++#s4:1)=Nt.new
                                                                                           (Pv)
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 0   1  t  t t 0 i i i i 0 v
                                                                                      v ifmemh(Rx++#s4:1)=Nt.new
                                                                                           (!Pv)
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 0   1  t  t t 0 i i i i 1 v
                                                                                        if (Pv.new)
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 0   1  t  t t 1 i i i i 0 v  v memh(Rx++#s4:1)=Nt.new
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 0   1  t  t t 1 i i i i 1 v  v ifmemh(Rx++#s4:1)=Nt.new
                                                                                           (!Pv.new)
                                U
   ICLASS    Amode      Type    N                Parse            t3
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 0 0   1  t  t t 1 i i i i 0 v  v if (Pv) memh(#u6)=Nt.new
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 0 0   1  t  t t 1 i i i i 1 v  v if (!Pv) memh(#u6)=Nt.new
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 1 0   1  t  t t 1 i i i i 0 v  v ifmemh(#u6)=Nt.new
                                                                                           (Pv.new)
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 1 0   1  t  t t 1 i i i i 1 v  v ifmemh(#u6)=Nt.new
                                                                                           (!Pv.new)
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t3                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                             297
Hexagon V67 Programmer’s Reference Manual  Instruction Set
                  Field name   Description
                  Amode        Amode
                  Type         Type
                  UN           Unsigned
80-N2040-45 Rev. B                                     298
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Store new-value word
                  Store a 32-bit register in memory at the effective address.
                   Syntax                              Behavior
                   memw(Re=#U6)=Nt.new                  apply_extension(#U);
                                                        EA=#U;
                                                        *EA = Nt.new;
                                                        Re=#U;
                   memw(Rs+#s11:2)=Nt.new               apply_extension(#s);
                                                        EA=Rs+#s;
                                                        *EA = Nt.new;
                   memw(Rs+Ru<<#u2)=Nt.new              EA=Rs+(Ru<<#u);
                                                        *EA = Nt.new;
                   memw(Ru<<#u2+#U6)=Nt.new             apply_extension(#U);
                                                        EA=#U+(Ru<<#u);
                                                        *EA = Nt.new;
                   memw(Rx++#s4:2)=Nt.new               EA=Rx;
                                                        Rx=Rx+#s;
                                                        *EA = Nt.new;
                   memw(Rx++#s4:2:circ(Mu))=Nt.new      EA=Rx;
                                                        Rx=Rx=circ_add(Rx,#s,MuV);
                                                        *EA = Nt.new;
                   memw(Rx++I:circ(Mu))=Nt.new          EA=Rx;
                                                        Rx=Rx=circ_add(Rx,I<<2,MuV);
                                                        *EA = Nt.new;
                   memw(Rx++Mu)=Nt.new                  EA=Rx;
                                                        Rx=Rx+MuV;
                                                        *EA = Nt.new;
                   memw(Rx++Mu:brev)=Nt.new             EA=Rx.h[1] | brev(Rx.h[0]);
                                                        Rx=Rx+MuV;
                                                        *EA = Nt.new;
                   memw(gp+#u16:2)=Nt.new               apply_extension(#u);
                                                        EA=(Constant_extended ? (0) : GP)+#u;
                                                        *EA = Nt.new;
                  Class: NV (slots 0)
                  Notes
                       ■  Forms of this instruction which use a new-value operand produced in the packet
                          must execute on slot 0.
                       ■  This instruction can execute only in slot 0, even though it is an ST instruction.
80-N2040-45 Rev. B                                                                                           299
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1  0
   ICLASS                              s5        Parse         u5                  t3
                                                                                        memw(Rs+Ru<<#u2)=Nt.n
 0  0  1  1 1  0   1  1  1   0  1 s  s  s  s  s  P   P  i u  u  u u  u i - - 1 0 t  t t
                                                                                        ew
   ICLASS                  Type                  Parse            t3
 0  1  0  0 1   i   i 0  1   0  1 i  i  i   i  i P   P  i 1  0  t  t t i i i i i i  i i memw(gp+#u16:2)=Nt.new
                                U
   ICLASS    Amode      Type           s5        Parse            t3
                                N
 1  0  1  0 0   i   i 1  1   0  1 s  s  s  s  s  P   P  i 1  0  t  t t i i i i i i  i i memw(Rs+#s11:2)=Nt.new
                                U
   ICLASS    Amode      Type           x5        Parse u1         t3
                                N
                                                                                        memw(Rx++I:circ(Mu))=Nt.
 1  0  1  0 1  0   0  1  1   0  1 x  x  x  x  x  P   P u 1   0  t  t t 0 - - - - - 1  -
                                                                                        new
                                                                                        memw(Rx++#s4:2:circ(Mu)
 1  0  1  0 1  0   0  1  1   0  1 x  x  x  x  x  P   P u 1   0  t  t t 0 i i i i - 0  -
                                                                                        )=Nt.new
                                U
   ICLASS    Amode      Type    N      e5        Parse            t3
 1  0  1  0 1  0   1  1  1   0  1 e  e  e  e  e  P   P 0  1  0  t  t t 1 - I I I I  I I memw(Re=#U6)=Nt.new
                                U
   ICLASS    Amode      Type           x5        Parse            t3
                                N
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 0  1  0  t  t t 0 i i i i - 0  - memw(Rx++#s4:2)=Nt.new
                                U
   ICLASS    Amode      Type           u5        Parse            t3
                                N
                                                                                        memw(Ru<<#u2+#U6)=Nt.
 1  0  1  0 1  1   0  1  1   0  1 u  u  u  u  u  P   P  i 1  0  t  t t 1 i I I I I  I I new
                                U
   ICLASS    Amode      Type    N      x5        Parse u1         t3
 1  0  1  0 1  1   0  1  1   0  1 x  x  x  x  x  P   P u 1   0  t  t t 0 - - - - -  - - memw(Rx++Mu)=Nt.new
                                                                                        memw(Rx++Mu:brev)=Nt.n
 1  0  1  0 1  1   1  1  1   0  1 x  x  x  x  x  P   P u 1   0  t  t t 0 - - - - -  - -
                                                                                        ew
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  Parse             Packet/Loop parse bits
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t3                Field to encode register t
                  u1                Field to encode register u
                  u5                Field to encode register u
                  x5                Field to encode register x
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                           300
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Store new-value word conditionally
                  Store a 32-bit register in memory at the effective address.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                              Behavior
                   if ([!]Pv[.new])                     apply_extension(#u);
                   memw(#u6)=Nt.new                     EA=#u;
                                                        if ([!]Pv[.new][0]) {
                                                              *EA = Nt[.new];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     apply_extension(#u);
                   memw(Rs+#u6:2)=Nt.new                EA=Rs+#u;
                                                        if ([!]Pv[.new][0]) {
                                                              *EA = Nt[.new];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     EA=Rs+(Ru<<#u);
                   memw(Rs+Ru<<#u2)=Nt.new              if ([!]Pv[.new][0]) {
                                                              *EA = Nt[.new];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     EA=Rx;
                   memw(Rx++#s4:2)=Nt.new               if ([!]Pv[.new][0]){
                                                              Rx=Rx+#s;
                                                              *EA = Nt[.new];
                                                        } else {
                                                              NOP;
                                                        }
                  Class: NV (slots 0)
                  Notes
                       ■   Forms of this instruction which use a new-value operand produced in the packet
                           must execute on slot 0.
                       ■   This instruction can execute only in slot 0, even though it is an ST instruction.
80-N2040-45 Rev. B                                                                                             301
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1  0
   ICLASS                              s5        Parse         u5                  t3
                                                                                        if (Pv)
 0  0  1  1 0  1   0  0  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 1 0 t  t t memw(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                                                                                        if (!Pv)
 0  0  1  1 0  1   0  1  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 1 0 t  t t memw(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                                                                                        if (Pv.new)
 0  0  1  1 0  1   1  0  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 1 0 t  t t memw(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                                                                                        if (!Pv.new)
 0  0  1  1 0  1   1  1  1   0  1 s  s  s  s  s  P   P i  u  u  u u  u i v v 1 0 t  t t memw(Rs+Ru<<#u2)=Nt.n
                                                                                        ew
                   Pr
               Se
                  ed
   ICLASS      ns Ne       Type        s5        Parse            t3
                e w
 0  1  0  0 0  0   0  0  1   0  1 s  s  s  s  s  P   P i 1   0  t  t t i i i i i 0 v  v ifmemw(Rs+#u6:2)=Nt.new
                                                                                           (Pv)
                                                                                        if (Pv.new)
 0  1  0  0 0  0   1  0  1   0  1 s  s  s  s  s  P   P i 1   0  t  t t i i i i i 0 v  v memw(Rs+#u6:2)=Nt.new
 0  1  0  0 0  1   0  0  1   0  1 s  s  s  s  s  P   P i 1   0  t  t t i i i i i 0 v  v ifmemw(Rs+#u6:2)=Nt.new
                                                                                           (!Pv)
 0  1  0  0 0  1   1  0  1   0  1 s  s  s  s  s  P   P i 1   0  t  t t i i i i i 0 v  v ifmemw(Rs+#u6:2)=Nt.new
                                                                                           (!Pv.new)
                                U
   ICLASS    Amode      Type           x5        Parse            t3
                                N
                                                                                      v ifmemw(Rx++#s4:2)=Nt.new
                                                                                           (Pv)
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 1   0  t  t t 0 i i i i 0 v
                                                                                      v ifmemw(Rx++#s4:2)=Nt.new
                                                                                           (!Pv)
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 1   0  t  t t 0 i i i i 1 v
                                                                                        if (Pv.new)
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 1   0  t  t t 1 i i i i 0 v  v memw(Rx++#s4:2)=Nt.new
 1  0  1  0 1  0   1  1  1   0  1 x  x  x  x  x  P   P 1 1   0  t  t t 1 i i i i 1 v  v ifmemw(Rx++#s4:2)=Nt.new
                                                                                           (!Pv.new)
                                U
   ICLASS    Amode      Type    N                Parse            t3
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 0 1   0  t  t t 1 i i i i 0 v  v if (Pv) memw(#u6)=Nt.new
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 0 1   0  t  t t 1 i i i i 1 v  v if (!Pv) memw(#u6)=Nt.new
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 1 1   0  t  t t 1 i i i i 0 v  v ifmemw(#u6)=Nt.new
                                                                                           (Pv.new)
 1  0  1  0 1  1   1  1  1   0  1 -  -  -   i  i P   P 1 1   0  t  t t 1 i i i i 1 v  v ifmemw(#u6)=Nt.new
                                                                                           (!Pv.new)
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t3                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                             302
Hexagon V67 Programmer’s Reference Manual  Instruction Set
                  Field name   Description
                  Amode        Amode
                  Type         Type
                  UN           Unsigned
80-N2040-45 Rev. B                                     303
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
     11.8         ST
                  The ST instruction class includes store instructions, used to store values in memory.
                  ST instructions are executable on slot 0 and slot 1.
        Store doubleword
                  Store a 64-bit register pair in memory at the effective address.
                   Syntax                              Behavior
                   memd(Re=#U6)=Rtt                    apply_extension(#U);
                                                       EA=#U;
                                                       *EA = Rtt;
                                                       Re=#U;
                   memd(Rs+#s11:3)=Rtt                 apply_extension(#s);
                                                       EA=Rs+#s;
                                                       *EA = Rtt;
                   memd(Rs+Ru<<#u2)=Rtt                EA=Rs+(Ru<<#u);
                                                       *EA = Rtt;
                   memd(Ru<<#u2+#U6)=Rtt               apply_extension(#U);
                                                       EA=#U+(Ru<<#u);
                                                       *EA = Rtt;
                   memd(Rx++#s4:3)=Rtt                 EA=Rx;
                                                       Rx=Rx+#s;
                                                       *EA = Rtt;
                   memd(Rx++#s4:3:circ(Mu))=Rtt        EA=Rx;
                                                       Rx=Rx=circ_add(Rx,#s,MuV);
                                                       *EA = Rtt;
                   memd(Rx++I:circ(Mu))=Rtt            EA=Rx;
                                                       Rx=Rx=circ_add(Rx,I<<3,MuV);
                                                       *EA = Rtt;
                   memd(Rx++Mu)=Rtt                    EA=Rx;
                                                       Rx=Rx+MuV;
                                                       *EA = Rtt;
                   memd(Rx++Mu:brev)=Rtt               EA=Rx.h[1] | brev(Rx.h[0]);
                                                       Rx=Rx+MuV;
                                                       *EA = Rtt;
                   memd(gp+#u16:3)=Rtt                 apply_extension(#u);
                                                       EA=(Constant_extended ? (0) : GP)+#u;
                                                       *EA = Rtt;
80-N2040-45 Rev. B                                                                                           304
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Class: ST (slots 0,1)
                  Intrinsics
                   memd(Rx++#s4:3:circ(Mu))=Rtt             void Q6_memd_IMP_circ(void** StartAddress,
                                                            Word32 Is4_3, Word32 Mu, Word64 Rtt, void*
                                                            BaseAddress)
                   memd(Rx++I:circ(Mu))=Rtt                 void Q6_memd_MP_circ(void** StartAddress, Word32
                                                            Mu, Word64 Rtt, void* BaseAddress)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6 5  4 3  2  1 0
   ICLASS                              s5        Parse          u5                  t5
 0  0  1  1 1  0   1  1  1   1  0 s  s  s  s  s  P   P  i u   u u  u u  i -  - t  t  t t t memd(Rs+Ru<<#u2)=Rtt
   ICLASS                  Type                  Parse          t5
 0  1  0  0 1   i   i 0  1   1  0 i  i  i   i  i P   P  i t   t  t t t  i i  i i  i  i i i memd(gp+#u16:3)=Rtt
                                U
   ICLASS    Amode      Type           s5        Parse          t5
                                N
 1  0  1  0 0   i   i 1  1   1  0 s  s  s  s  s  P   P  i t   t  t t t  i i  i i  i  i i i memd(Rs+#s11:3)=Rtt
                                U
   ICLASS    Amode      Type           x5        Parse u1       t5
                                N
 1  0  1  0 1  0   0  1  1   1  0 x  x  x  x  x  P   P u  t   t  t t t 0  -  - -  -  - 1 - memd(Rx++I:circ(Mu))=Rtt
                                                                                           memd(Rx++#s4:3:circ(Mu))
 1  0  1  0 1  0   0  1  1   1  0 x  x  x  x  x  P   P u  t   t  t t t 0  i  i i  i  - 0 -
                                                                                           =Rtt
                                U
   ICLASS    Amode      Type    N      e5        Parse          t5
 1  0  1  0 1  0   1  1  1   1  0 e  e  e  e  e  P   P 0  t   t  t t t 1  -  I I  I  I I I memd(Re=#U6)=Rtt
                                U
   ICLASS    Amode      Type    N      x5        Parse          t5
 1  0  1  0 1  0   1  1  1   1  0 x  x  x  x  x  P   P 0  t   t  t t t 0  i  i i  i  - 0 - memd(Rx++#s4:3)=Rtt
                                U
   ICLASS    Amode      Type           u5        Parse          t5
                                N
 1  0  1  0 1  1   0  1  1   1  0 u  u  u  u  u  P   P  i t   t  t t t 1  i  I I  I  I I I memd(Ru<<#u2+#U6)=Rtt
                                U
   ICLASS    Amode      Type           x5        Parse u1       t5
                                N
 1  0  1  0 1  1   0  1  1   1  0 x  x  x  x  x  P   P u  t   t  t t t 0  -  - -  -  - - - memd(Rx++Mu)=Rtt
 1  0  1  0 1  1   1  1  1   1  0 x  x  x  x  x  P   P u  t   t  t t t 0  -  - -  -  - - - memd(Rx++Mu:brev)=Rtt
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  Parse             Packet/Loop parse bits
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                              305
Hexagon V67 Programmer’s Reference Manual  Instruction Set
                  Field name   Description
                  Amode        Amode
                  Type         Type
                  UN           Unsigned
80-N2040-45 Rev. B                                     306
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Store doubleword conditionally
                  Store a 64-bit register pair in memory at the effective address.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                                   Behavior
                   if ([!]Pv[.new]) memd(#u6)=Rtt           apply_extension(#u);
                                                            EA=#u;
                                                            if ([!]Pv[.new][0]) {
                                                                 *EA = Rtt;
                                                            } else {
                                                                 NOP;
                                                            }
                   if ([!]Pv[.new])                         apply_extension(#u);
                   memd(Rs+#u6:3)=Rtt                       EA=Rs+#u;
                                                            if ([!]Pv[.new][0]) {
                                                                 *EA = Rtt;
                                                            } else {
                                                                 NOP;
                                                            }
                   if ([!]Pv[.new])                         EA=Rs+(Ru<<#u);
                   memd(Rs+Ru<<#u2)=Rtt                     if ([!]Pv[.new][0]) {
                                                                 *EA = Rtt;
                                                            } else {
                                                                 NOP;
                                                            }
                   if ([!]Pv[.new])                         EA=Rx;
                   memd(Rx++#s4:3)=Rtt                      if ([!]Pv[.new][0]){
                                                                 Rx=Rx+#s;
                                                                 *EA = Rtt;
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: ST (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5 4 3  2  1 0
   ICLASS                              s5       Parse           u5                  t5
                                                                                           if (Pv)
 0  0  1  1 0  1   0  0 1  1   0  s  s  s  s  s P   P  i u    u u  u  u i  v v t  t  t t t memd(Rs+Ru<<#u2)=Rtt
                                                                                           if (!Pv)
 0  0  1  1 0  1   0  1 1  1   0  s  s  s  s  s P   P  i u    u u  u  u i  v v t  t  t t t
                                                                                           memd(Rs+Ru<<#u2)=Rtt
                                                                                           if (Pv.new)
 0  0  1  1 0  1   1  0 1  1   0  s  s  s  s  s P   P  i u    u u  u  u i  v v t  t  t t t
                                                                                           memd(Rs+Ru<<#u2)=Rtt
                                                                                           if (!Pv.new)
 0  0  1  1 0  1   1  1 1  1   0  s  s  s  s  s P   P  i u    u u  u  u i  v v t  t  t t t
                                                                                           memd(Rs+Ru<<#u2)=Rtt
                   Pr
               Se ed
   ICLASS      ns Ne      Type         s5       Parse           t5
                e w
                                                                                         v ifmemd(Rs+#u6:3)=Rtt
                                                                                              (Pv)
 0  1  0  0 0  0   0  0 1  1   0  s  s  s  s  s P   P  i  t   t  t t  t i  i i i  i 0  v
80-N2040-45 Rev. B                                                                                                307
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1 0
                                                                                       if (Pv.new)
 0  1  0  0 0  0   1 0  1   1 0   s  s  s  s  s  P   P i  t   t  t t t i i i i i 0 v v
                                                                                       memd(Rs+#u6:3)=Rtt
                                                                                       if (!Pv)
 0  1  0  0 0  1   0 0  1   1 0   s  s  s  s  s  P   P i  t   t  t t t i i i i i 0 v v
                                                                                       memd(Rs+#u6:3)=Rtt
                                                                                       if (!Pv.new)
 0  1  0  0 0  1   1 0  1   1 0   s  s  s  s  s  P   P i  t   t  t t t i i i i i 0 v v
                                                                                       memd(Rs+#u6:3)=Rtt
                              U
   ICLASS    Amode     Type   N        x5        Parse          t5
                                                                                       if (Pv)
 1  0  1  0 1  0   1 1  1   1 0   x  x  x  x  x  P   P 1  t   t  t t t 0 i i i i 0 v v
                                                                                       memd(Rx++#s4:3)=Rtt
 1  0  1  0 1  0   1 1  1   1 0   x  x  x  x  x  P   P 1  t   t  t t t 0 i i i i 1 v v if (!Pv)
                                                                                       memd(Rx++#s4:3)=Rtt
                                                                                       if (Pv.new)
 1  0  1  0 1  0   1 1  1   1 0   x  x  x  x  x  P   P 1  t   t  t t t 1 i i i i 0 v v
                                                                                       memd(Rx++#s4:3)=Rtt
                                                                                       if (!Pv.new)
 1  0  1  0 1  0   1 1  1   1 0   x  x  x  x  x  P   P 1  t   t  t t t 1 i i i i 1 v v
                                                                                       memd(Rx++#s4:3)=Rtt
                              U
   ICLASS    Amode     Type                      Parse          t5
                              N
 1  0  1  0 1  1   1 1  1   1 0   -  -  -   i  i P   P 0  t   t  t t t 1 i i i i 0 v v if (Pv) memd(#u6)=Rtt
 1  0  1  0 1  1   1 1  1   1 0   -  -  -   i  i P   P 0  t   t  t t t 1 i i i i 1 v v if (!Pv) memd(#u6)=Rtt
 1  0  1  0 1  1   1 1  1   1 0   -  -  -   i  i P   P 1  t   t  t t t 1 i i i i 0 v v if (Pv.new) memd(#u6)=Rtt
 1  0  1  0 1  1   1 1  1   1 0   -  -  -   i  i P   P 1  t   t  t t t 1 i i i i 1 v v if (!Pv.new) memd(#u6)=Rtt
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                            308
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Store byte
                  Store the least-significant byte in a source register at the effective address.
                   Syntax                                Behavior
                   memb(Re=#U6)=Rt                       apply_extension(#U);
                                                         EA=#U;
                                                         *EA = Rt&0xff;
                                                         Re=#U;
                   memb(Rs+#s11:0)=Rt                    apply_extension(#s);
                                                         EA=Rs+#s;
                                                         *EA = Rt&0xff;
                   memb(Rs+#u6:0)=#S8                    EA=Rs+#u;
                                                         apply_extension(#S);
                                                         *EA = #S;
                   memb(Rs+Ru<<#u2)=Rt                   EA=Rs+(Ru<<#u);
                                                         *EA = Rt&0xff;
                   memb(Ru<<#u2+#U6)=Rt                  apply_extension(#U);
                                                         EA=#U+(Ru<<#u);
                                                         *EA = Rt&0xff;
                   memb(Rx++#s4:0)=Rt                    EA=Rx;
                                                         Rx=Rx+#s;
                                                         *EA = Rt&0xff;
                   memb(Rx++#s4:0:circ(Mu))=Rt           EA=Rx;
                                                         Rx=Rx=circ_add(Rx,#s,MuV);
                                                         *EA = Rt&0xff;
                   memb(Rx++I:circ(Mu))=Rt               EA=Rx;
                                                         Rx=Rx=circ_add(Rx,I<<0,MuV);
                                                         *EA = Rt&0xff;
                   memb(Rx++Mu)=Rt                       EA=Rx;
                                                         Rx=Rx+MuV;
                                                         *EA = Rt&0xff;
                   memb(Rx++Mu:brev)=Rt                  EA=Rx.h[1] | brev(Rx.h[0]);
                                                         Rx=Rx+MuV;
                                                         *EA = Rt&0xff;
                   memb(gp+#u16:0)=Rt                    apply_extension(#u);
                                                         EA=(Constant_extended ? (0) : GP)+#u;
                                                         *EA = Rt&0xff;
                  Class: ST (slots 0,1)
                  Intrinsics
                   memb(Rx++#s4:0:circ(Mu))=Rt           void Q6_memb_IMR_circ(void** StartAddress,
                                                         Word32 Is4_0, Word32 Mu, Word32 Rt, void*
                                                         BaseAddress)
                   memb(Rx++I:circ(Mu))=Rt               void Q6_memb_MR_circ(void** StartAddress, Word32
                                                         Mu, Word32 Rt, void* BaseAddress)
80-N2040-45 Rev. B                                                                                            309
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7 6 5 4 3 2  1 0
   ICLASS                               s5        Parse          u5               t5
 0  0  1  1 1  0   1  1  0   0   0 s  s  s  s  s  P   P  i u  u  u  u u i - - t t  t t t memb(Rs+Ru<<#u2)=Rt
   ICLASS                               s5        Parse
 0  0  1  1 1  1   0  -   -  0   0 s  s  s  s  s  P   P  I i   i  i i i i I I I I  I I I memb(Rs+#u6:0)=#S8
   ICLASS                   Type                  Parse          t5
 0  1  0  0 1   i   i 0  0   0   0 i  i  i   i  i P   P  i t   t  t t t i i i i i  i i i memb(gp+#u16:0)=Rt
                                 U
   ICLASS    Amode      Type            s5        Parse          t5
                                 N
 1  0  1  0 0   i   i 1  0   0   0 s  s  s  s  s  P   P  i t   t  t t t i i i i i  i i i memb(Rs+#s11:0)=Rt
                                 U
   ICLASS    Amode      Type            x5        Parse u1       t5
                                 N
 1  0  1  0 1  0   0  1  0   0   0 x  x  x  x  x  P   P u  t   t  t t t 0 - - - -  - 1 - memb(Rx++I:circ(Mu))=Rt
                                                                                         memb(Rx++#s4:0:circ(Mu))
 1  0  1  0 1  0   0  1  0   0   0 x  x  x  x  x  P   P u  t   t  t t t 0 i i i i  - 0 -
                                                                                         =Rt
                                 U
   ICLASS    Amode      Type            e5        Parse          t5
                                 N
 1  0  1  0 1  0   1  1  0   0   0 e  e  e  e  e  P   P 0  t   t  t t t 1 - I I I  I I I memb(Re=#U6)=Rt
                                 U
   ICLASS    Amode      Type            x5        Parse          t5
                                 N
 1  0  1  0 1  0   1  1  0   0   0 x  x  x  x  x  P   P 0  t   t  t t t 0 i i i i  - 0 - memb(Rx++#s4:0)=Rt
                                 U
   ICLASS    Amode      Type            u5        Parse          t5
                                 N
 1  0  1  0 1  1   0  1  0   0   0 u  u  u  u  u  P   P  i t   t  t t t 1 i I I I  I I I memb(Ru<<#u2+#U6)=Rt
   ICLASS    Amode      Type     U      x5        Parse u1       t5
                                 N
 1  0  1  0 1  1   0  1  0   0   0 x  x  x  x  x  P   P u  t   t  t t t 0 - - - -  - - - memb(Rx++Mu)=Rt
 1  0  1  0 1  1   1  1  0   0   0 x  x  x  x  x  P   P u  t   t  t t t 0 - - - -  - - - memb(Rx++Mu:brev)=Rt
                  Field name         Description
                  ICLASS             Instruction Class
                  Type               Type
                  Parse              Packet/Loop parse bits
                  e5                 Field to encode register e
                  s5                 Field to encode register s
                  t5                 Field to encode register t
                  u1                 Field to encode register u
                  u5                 Field to encode register u
                  x5                 Field to encode register x
                  Amode              Amode
                  Type               Type
                  UN                 Unsigned
80-N2040-45 Rev. B                                                                                            310
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Store byte conditionally
                  Store the least-significant byte in a source register at the effective address.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                                Behavior
                   if ([!]Pv[.new]) memb(#u6)=Rt         apply_extension(#u);
                                                         EA=#u;
                                                         if ([!]Pv[.new][0]) {
                                                              *EA = Rt&0xff;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv[.new])                      EA=Rs+#u;
                   memb(Rs+#u6:0)=#S6                    if ([!]Pv[.new][0]){
                                                              apply_extension(#S);
                                                              *EA = #S;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv[.new])                      apply_extension(#u);
                   memb(Rs+#u6:0)=Rt                     EA=Rs+#u;
                                                         if ([!]Pv[.new][0]) {
                                                              *EA = Rt&0xff;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv[.new])                      EA=Rs+(Ru<<#u);
                   memb(Rs+Ru<<#u2)=Rt                   if ([!]Pv[.new][0]) {
                                                              *EA = Rt&0xff;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv[.new])                      EA=Rx;
                   memb(Rx++#s4:0)=Rt                    if ([!]Pv[.new][0]){
                                                              Rx=Rx+#s;
                                                              *EA = Rt&0xff;
                                                         } else {
                                                              NOP;
                                                         }
80-N2040-45 Rev. B                                                                                             311
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Class: ST (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2  1 0
   ICLASS                              s5        Parse         u5               t5
                                                                                       if (Pv)
 0  0  1  1 0  1   0  0  0   0  0 s  s  s  s  s  P   P i u  u   u u u i v v t t  t t t
                                                                                       memb(Rs+Ru<<#u2)=Rt
                                                                                       if (!Pv)
 0  0  1  1 0  1   0  1  0   0  0 s  s  s  s  s  P   P i u  u   u u u i v v t t  t t t
                                                                                       memb(Rs+Ru<<#u2)=Rt
                                                                                       if (Pv.new)
 0  0  1  1 0  1   1  0  0   0  0 s  s  s  s  s  P   P i u  u   u u u i v v t t  t t t
                                                                                       memb(Rs+Ru<<#u2)=Rt
                                                                                       if (!Pv.new)
 0  0  1  1 0  1   1  1  0   0  0 s  s  s  s  s  P   P i u  u   u u u i v v t t  t t t memb(Rs+Ru<<#u2)=Rt
   ICLASS                              s5        Parse
                                                                                       if (Pv)
 0  0  1  1 1  0   0  0  0   0  0 s  s  s  s  s  P   P I  i  i  i i i i v v I I  I I I memb(Rs+#u6:0)=#S6
                                                                                       if (!Pv)
 0  0  1  1 1  0   0  0  1   0  0 s  s  s  s  s  P   P I  i  i  i i i i v v I I  I I I
                                                                                       memb(Rs+#u6:0)=#S6
                                                                                       if (Pv.new)
 0  0  1  1 1  0   0  1  0   0  0 s  s  s  s  s  P   P I  i  i  i i i i v v I I  I I I memb(Rs+#u6:0)=#S6
                                                                                       if (!Pv.new)
 0  0  1  1 1  0   0  1  1   0  0 s  s  s  s  s  P   P I  i  i  i i i i v v I I  I I I
                                                                                       memb(Rs+#u6:0)=#S6
                   Pr
               Se ed
   ICLASS      ns Ne       Type        s5        Parse         t5
                e w
 0  1  0  0 0  0   0  0  0   0  0 s  s  s  s  s  P   P i  t  t  t t t i i i i i 0  v v if (Pv) memb(Rs+#u6:0)=Rt
                                                                                     v ifmemb(Rs+#u6:0)=Rt
                                                                                          (Pv.new)
 0  1  0  0 0  0   1  0  0   0  0 s  s  s  s  s  P   P i  t  t  t t t i i i i i 0  v
                                                                                     v ifmemb(Rs+#u6:0)=Rt
                                                                                          (!Pv)
 0  1  0  0 0  1   0  0  0   0  0 s  s  s  s  s  P   P i  t  t  t t t i i i i i 0  v
                                                                                       if (!Pv.new)
 0  1  0  0 0  1   1  0  0   0  0 s  s  s  s  s  P   P i  t  t  t t t i i i i i 0  v v memb(Rs+#u6:0)=Rt
                                U
   ICLASS    Amode      Type           x5        Parse         t5
                                N
 1  0  1  0 1  0   1  1  0   0  0 x  x  x  x  x  P   P 1  t  t  t t t 0 i i i i 0  v v ifmemb(Rx++#s4:0)=Rt
                                                                                          (Pv)
                                                                                       if (!Pv)
 1  0  1  0 1  0   1  1  0   0  0 x  x  x  x  x  P   P 1  t  t  t t t 0 i i i i 1  v v memb(Rx++#s4:0)=Rt
                                                                                     v ifmemb(Rx++#s4:0)=Rt
                                                                                          (Pv.new)
 1  0  1  0 1  0   1  1  0   0  0 x  x  x  x  x  P   P 1  t  t  t t t 1 i i i i 0  v
                                                                                     v ifmemb(Rx++#s4:0)=Rt
                                                                                          (!Pv.new)
 1  0  1  0 1  0   1  1  0   0  0 x  x  x  x  x  P   P 1  t  t  t t t 1 i i i i 1  v
                                U
   ICLASS    Amode      Type                     Parse         t5
                                N
 1  0  1  0 1  1   1  1  0   0  0 -  -  -  i   i P   P 0  t  t  t t t 1 i i i i 0  v v if (Pv) memb(#u6)=Rt
 1  0  1  0 1  1   1  1  0   0  0 -  -  -  i   i P   P 0  t  t  t t t 1 i i i i 1  v v if (!Pv) memb(#u6)=Rt
 1  0  1  0 1  1   1  1  0   0  0 -  -  -  i   i P   P 1  t  t  t t t 1 i i i i 0  v v if (Pv.new) memb(#u6)=Rt
 1  0  1  0 1  1   1  1  0   0  0 -  -  -  i   i P   P 1  t  t  t t t 1 i i i i 1  v v if (!Pv.new) memb(#u6)=Rt
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                            312
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  s5           Field to encode register s
                  t5           Field to encode register t
                  u5           Field to encode register u
                  v2           Field to encode register v
                  x5           Field to encode register x
                  Amode        Amode
                  Type         Type
                  UN           Unsigned
80-N2040-45 Rev. B                                                    313
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Store halfword
                  Store the upper or lower 16-bits of a source register at the effective address.
                   Syntax                              Behavior
                   memh(Re=#U6)=Rt.H                    apply_extension(#U);
                                                        EA=#U;
                                                        *EA = Rt.h[1];
                                                        Re=#U;
                   memh(Re=#U6)=Rt                      apply_extension(#U);
                                                        EA=#U;
                                                        *EA = Rt.h[0];
                                                        Re=#U;
                   memh(Rs+#s11:1)=Rt.H                 apply_extension(#s);
                                                        EA=Rs+#s;
                                                        *EA = Rt.h[1];
                   memh(Rs+#s11:1)=Rt                   apply_extension(#s);
                                                        EA=Rs+#s;
                                                        *EA = Rt.h[0];
                   memh(Rs+#u6:1)=#S8                   EA=Rs+#u;
                                                        apply_extension(#S);
                                                        *EA = #S;
                   memh(Rs+Ru<<#u2)=Rt.H                EA=Rs+(Ru<<#u);
                                                        *EA = Rt.h[1];
                   memh(Rs+Ru<<#u2)=Rt                  EA=Rs+(Ru<<#u);
                                                        *EA = Rt.h[0];
                   memh(Ru<<#u2+#U6)=Rt.H               apply_extension(#U);
                                                        EA=#U+(Ru<<#u);
                                                        *EA = Rt.h[1];
                   memh(Ru<<#u2+#U6)=Rt                 apply_extension(#U);
                                                        EA=#U+(Ru<<#u);
                                                        *EA = Rt.h[0];
                   memh(Rx++#s4:1)=Rt.H                 EA=Rx;
                                                        Rx=Rx+#s;
                                                        *EA = Rt.h[1];
                   memh(Rx++#s4:1)=Rt                   EA=Rx;
                                                        Rx=Rx+#s;
                                                        *EA = Rt.h[0];
                   memh(Rx++#s4:1:circ(Mu))=Rt.H        EA=Rx;
                                                        Rx=Rx=circ_add(Rx,#s,MuV);
                                                        *EA = Rt.h[1];
                   memh(Rx++#s4:1:circ(Mu))=Rt          EA=Rx;
                                                        Rx=Rx=circ_add(Rx,#s,MuV);
                                                        *EA = Rt.h[0];
                   memh(Rx++I:circ(Mu))=Rt.H            EA=Rx;
                                                        Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                        *EA = Rt.h[1];
                   memh(Rx++I:circ(Mu))=Rt              EA=Rx;
                                                        Rx=Rx=circ_add(Rx,I<<1,MuV);
                                                        *EA = Rt.h[0];
80-N2040-45 Rev. B                                                                                            314
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                   Syntax                                   Behavior
                   memh(Rx++Mu)=Rt.H                        EA=Rx;
                                                            Rx=Rx+MuV;
                                                            *EA = Rt.h[1];
                   memh(Rx++Mu)=Rt                          EA=Rx;
                                                            Rx=Rx+MuV;
                                                            *EA = Rt.h[0];
                   memh(Rx++Mu:brev)=Rt.H                   EA=Rx.h[1] | brev(Rx.h[0]);
                                                            Rx=Rx+MuV;
                                                            *EA = Rt.h[1];
                   memh(Rx++Mu:brev)=Rt                     EA=Rx.h[1] | brev(Rx.h[0]);
                                                            Rx=Rx+MuV;
                                                            *EA = Rt.h[0];
                   memh(gp+#u16:1)=Rt.H                     apply_extension(#u);
                                                            EA=(Constant_extended ? (0) : GP)+#u;
                                                            *EA = Rt.h[1];
                   memh(gp+#u16:1)=Rt                       apply_extension(#u);
                                                            EA=(Constant_extended ? (0) : GP)+#u;
                                                            *EA = Rt.h[0];
                  Class: ST (slots 0,1)
                  Intrinsics
                   memh(Rx++#s4:1:circ(Mu))=Rt.H            void Q6_memh_IMRh_circ(void** StartAddress,
                                                            Word32 Is4_1, Word32 Mu, Word32 Rt, void*
                                                            BaseAddress)
                   memh(Rx++#s4:1:circ(Mu))=Rt              void Q6_memh_IMR_circ(void** StartAddress,
                                                            Word32 Is4_1, Word32 Mu, Word32 Rt, void*
                                                            BaseAddress)
                   memh(Rx++I:circ(Mu))=Rt.H                void Q6_memh_MRh_circ(void** StartAddress,
                                                            Word32 Mu, Word32 Rt, void* BaseAddress)
                   memh(Rx++I:circ(Mu))=Rt                  void Q6_memh_MR_circ(void** StartAddress, Word32
                                                            Mu, Word32 Rt, void* BaseAddress)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6 5  4 3  2  1 0
   ICLASS                              s5       Parse           u5                  t5
 0  0  1  1 1  0   1  1  0   1   0 s s  s  s  s P   P  i u    u u  u u  i -  - t  t  t t t memh(Rs+Ru<<#u2)=Rt
 0  0  1  1 1  0   1  1  0   1   1 s s  s  s  s P   P  i u    u u  u u  i -  - t  t  t t t memh(Rs+Ru<<#u2)=Rt.H
   ICLASS                              s5       Parse
 0  0  1  1 1  1   0  -   -  0   1 s s  s  s  s P   P  I  i   i  i i i  i I  I I  I  I I I memh(Rs+#u6:1)=#S8
   ICLASS                   Type                Parse           t5
 0  1  0  0 1   i   i 0  0   1   0 i i  i  i  i P   P  i  t   t  t t t  i i  i i  i  i i i memh(gp+#u16:1)=Rt
 0  1  0  0 1   i   i 0  0   1   1 i i  i  i  i P   P  i  t   t  t t t  i i  i i  i  i i i memh(gp+#u16:1)=Rt.H
                                 U
   ICLASS    Amode      Type           s5       Parse           t5
                                 N
 1  0  1  0 0   i   i 1  0   1   0 s s  s  s  s P   P  i  t   t  t t t  i i  i i  i  i i i memh(Rs+#s11:1)=Rt
 1  0  1  0 0   i   i 1  0   1   1 s s  s  s  s P   P  i  t   t  t t t  i i  i i  i  i i i memh(Rs+#s11:1)=Rt.H
80-N2040-45 Rev. B                                                                                             315
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1 0
                              U
   ICLASS    Amode     Type            x5        Parse u1       t5
                              N
 1  0  1  0 1  0   0 1  0   1 0   x  x  x  x  x  P   P u  t   t  t t t 0 - - - - - 1 - memh(Rx++I:circ(Mu))=Rt
                                                                                       memh(Rx++#s4:1:circ(Mu))
 1  0  1  0 1  0   0 1  0   1 0   x  x  x  x  x  P   P u  t   t  t t t 0 i i i i - 0 -
                                                                                       =Rt
 1  0  1  0 1  0   0 1  0   1 1   x  x  x  x  x  P   P u  t   t  t t t 0 - - - - - 1 - memh(Rx++I:circ(Mu))=Rt.
                                                                                       H
                                                                                       memh(Rx++#s4:1:circ(Mu))
 1  0  1  0 1  0   0 1  0   1 1   x  x  x  x  x  P   P u  t   t  t t t 0 i i i i - 0 -
                                                                                       =Rt.H
                              U
   ICLASS    Amode     Type   N        e5        Parse          t5
 1  0  1  0 1  0   1 1  0   1 0   e  e  e  e  e  P   P 0  t   t  t t t 1 - I I I I I I memh(Re=#U6)=Rt
                              U
   ICLASS    Amode     Type            x5        Parse          t5
                              N
 1  0  1  0 1  0   1 1  0   1 0   x  x  x  x  x  P   P 0  t   t  t t t 0 i i i i - 0 - memh(Rx++#s4:1)=Rt
                              U
   ICLASS    Amode     Type            e5        Parse          t5
                              N
 1  0  1  0 1  0   1 1  0   1 1   e  e  e  e  e  P   P 0  t   t  t t t 1 - I I I I I I memh(Re=#U6)=Rt.H
                              U
   ICLASS    Amode     Type            x5        Parse          t5
                              N
 1  0  1  0 1  0   1 1  0   1 1   x  x  x  x  x  P   P 0  t   t  t t t 0 i i i i - 0 - memh(Rx++#s4:1)=Rt.H
                              U
   ICLASS    Amode     Type            u5        Parse          t5
                              N
 1  0  1  0 1  1   0 1  0   1 0  u   u  u  u  u  P   P  i t   t  t t t 1 i I I I I I I memh(Ru<<#u2+#U6)=Rt
                              U
   ICLASS    Amode     Type   N        x5        Parse u1       t5
 1  0  1  0 1  1   0 1  0   1 0   x  x  x  x  x  P   P u  t   t  t t t 0 - - - - - - - memh(Rx++Mu)=Rt
                              U
   ICLASS    Amode     Type   N        u5        Parse          t5
                                                                                       memh(Ru<<#u2+#U6)=Rt.
 1  0  1  0 1  1   0 1  0   1 1  u   u  u  u  u  P   P  i t   t  t t t 1 i I I I I I I
                                                                                       H
   ICLASS    Amode     Type   U        x5        Parse u1       t5
                              N
 1  0  1  0 1  1   0 1  0   1 1   x  x  x  x  x  P   P u  t   t  t t t 0 - - - - - - - memh(Rx++Mu)=Rt.H
 1  0  1  0 1  1   1 1  0   1 0   x  x  x  x  x  P   P u  t   t  t t t 0 - - - - - - - memh(Rx++Mu:brev)=Rt
 1  0  1  0 1  1   1 1  0   1 1   x  x  x  x  x  P   P u  t   t  t t t 0 - - - - - - - memh(Rx++Mu:brev)=Rt.H
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  Parse             Packet/Loop parse bits
                  e5                Field to encode register e
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  u5                Field to encode register u
                  x5                Field to encode register x
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                          316
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Store halfword conditionally
                  Store the upper or lower 16-bits of a source register in memory at the effective address.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                              Behavior
                   if ([!]Pv[.new]) memh(#u6)=Rt.H      apply_extension(#u);
                                                        EA=#u;
                                                        if ([!]Pv[.new][0]) {
                                                              *EA = Rt.h[1];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new]) memh(#u6)=Rt        apply_extension(#u);
                                                        EA=#u;
                                                        if ([!]Pv[.new][0]) {
                                                              *EA = Rt.h[0];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     EA=Rs+#u;
                   memh(Rs+#u6:1)=#S6                   if ([!]Pv[.new][0]){
                                                              apply_extension(#S);
                                                              *EA = #S;
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     apply_extension(#u);
                   memh(Rs+#u6:1)=Rt.H                  EA=Rs+#u;
                                                        if ([!]Pv[.new][0]) {
                                                              *EA = Rt.h[1];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     apply_extension(#u);
                   memh(Rs+#u6:1)=Rt                    EA=Rs+#u;
                                                        if ([!]Pv[.new][0]) {
                                                              *EA = Rt.h[0];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     EA=Rs+(Ru<<#u);
                   memh(Rs+Ru<<#u2)=Rt.H                if ([!]Pv[.new][0]) {
                                                              *EA = Rt.h[1];
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     EA=Rs+(Ru<<#u);
                   memh(Rs+Ru<<#u2)=Rt                  if ([!]Pv[.new][0]) {
                                                              *EA = Rt.h[0];
                                                        } else {
                                                              NOP;
                                                        }
80-N2040-45 Rev. B                                                                                             317
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                   Syntax                                   Behavior
                   if ([!]Pv[.new])                         EA=Rx;
                   memh(Rx++#s4:1)=Rt.H                     if ([!]Pv[.new][0]){
                                                                 Rx=Rx+#s;
                                                                 *EA = Rt.h[1];
                                                            } else {
                                                                 NOP;
                                                            }
                   if ([!]Pv[.new])                         EA=Rx;
                   memh(Rx++#s4:1)=Rt                       if ([!]Pv[.new][0]){
                                                                 Rx=Rx+#s;
                                                                 *EA = Rt.h[0];
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: ST (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS                              s5       Parse           u5                  t5
                                                                                           if (Pv)
 0  0  1  1 0  1   0  0 0  1   0  s  s  s  s  s P   P  i u    u u  u  u i  v v  t t  t t t memh(Rs+Ru<<#u2)=Rt
                                                                                           if (Pv)
 0  0  1  1 0  1   0  0 0  1   1  s  s  s  s  s P   P  i u    u u  u  u i  v v  t t  t t t
                                                                                           memh(Rs+Ru<<#u2)=Rt.H
 0  0  1  1 0  1   0  1 0  1   0  s  s  s  s  s P   P  i u    u u  u  u i  v v  t t  t t t if (!Pv)
                                                                                           memh(Rs+Ru<<#u2)=Rt
                                                                                           if (!Pv)
 0  0  1  1 0  1   0  1 0  1   1  s  s  s  s  s P   P  i u    u u  u  u i  v v  t t  t t t
                                                                                           memh(Rs+Ru<<#u2)=Rt.H
 0  0  1  1 0  1   1  0 0  1   0  s  s  s  s  s P   P  i u    u u  u  u i  v v  t t  t t t if (Pv.new)
                                                                                           memh(Rs+Ru<<#u2)=Rt
 0  0  1  1 0  1   1  0 0  1   1  s  s  s  s  s P   P  i u    u u  u  u i  v v  t t  t t t if (Pv.new)
                                                                                           memh(Rs+Ru<<#u2)=Rt.H
                                                                                           if (!Pv.new)
 0  0  1  1 0  1   1  1 0  1   0  s  s  s  s  s P   P  i u    u u  u  u i  v v  t t  t t t
                                                                                           memh(Rs+Ru<<#u2)=Rt
                                                                                           if (!Pv.new)
 0  0  1  1 0  1   1  1 0  1   1  s  s  s  s  s P   P  i u    u u  u  u i  v v  t t  t t t
                                                                                           memh(Rs+Ru<<#u2)=Rt.H
   ICLASS                              s5       Parse
                                                                                           if (Pv)
 0  0  1  1 1  0   0  0 0  0   1  s  s  s  s  s P   P  I  i   i  i i  i i  v v  I I  I I I
                                                                                           memh(Rs+#u6:1)=#S6
                                                                                           if (!Pv)
 0  0  1  1 1  0   0  0 1  0   1  s  s  s  s  s P   P  I  i   i  i i  i i  v v  I I  I I I
                                                                                           memh(Rs+#u6:1)=#S6
                                                                                           if (Pv.new)
 0  0  1  1 1  0   0  1 0  0   1  s  s  s  s  s P   P  I  i   i  i i  i i  v v  I I  I I I
                                                                                           memh(Rs+#u6:1)=#S6
                                                                                           if (!Pv.new)
 0  0  1  1 1  0   0  1 1  0   1  s  s  s  s  s P   P  I  i   i  i i  i i  v v  I I  I I I
                                                                                           memh(Rs+#u6:1)=#S6
                   Pr
               Se
                  ed
   ICLASS      ns         Type         s5       Parse           t5
                  Ne
                e
                   w
 0  1  0  0 0  0   0  0 0  1   0  s  s  s  s  s P   P  i  t   t  t t  t i  i i  i i 0  v v if (Pv) memh(Rs+#u6:1)=Rt
                                                                                           if (Pv)
 0  1  0  0 0  0   0  0 0  1   1  s  s  s  s  s P   P  i  t   t  t t  t i  i i  i i 0  v v memh(Rs+#u6:1)=Rt.H
                                                                                         v ifmemh(Rs+#u6:1)=Rt
                                                                                              (Pv.new)
 0  1  0  0 0  0   1  0 0  1   0  s  s  s  s  s P   P  i  t   t  t t  t i  i i  i i 0  v
                                                                                         v ifmemh(Rs+#u6:1)=Rt.H
                                                                                              (Pv.new)
 0  1  0  0 0  0   1  0 0  1   1  s  s  s  s  s P   P  i  t   t  t t  t i  i i  i i 0  v
                                                                                           if (!Pv)
 0  1  0  0 0  1   0  0 0  1   0  s  s  s  s  s P   P  i  t   t  t t  t i  i i  i i 0  v v memh(Rs+#u6:1)=Rt
80-N2040-45 Rev. B                                                                                                318
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1 0
                                                                                       if (!Pv)
 0  1  0  0 0  1   0 0  0   1 1   s  s  s  s  s  P   P i  t   t  t t t i i i i i 0 v v
                                                                                       memh(Rs+#u6:1)=Rt.H
                                                                                       if (!Pv.new)
 0  1  0  0 0  1   1 0  0   1 0   s  s  s  s  s  P   P i  t   t  t t t i i i i i 0 v v
                                                                                       memh(Rs+#u6:1)=Rt
                                                                                       if (!Pv.new)
 0  1  0  0 0  1   1 0  0   1 1   s  s  s  s  s  P   P i  t   t  t t t i i i i i 0 v v
                                                                                       memh(Rs+#u6:1)=Rt.H
                              U
   ICLASS    Amode     Type   N        x5        Parse          t5
                                                                                       if (Pv)
 1  0  1  0 1  0   1 1  0   1 0   x  x  x  x  x  P   P 1  t   t  t t t 0 i i i i 0 v v
                                                                                       memh(Rx++#s4:1)=Rt
 1  0  1  0 1  0   1 1  0   1 0   x  x  x  x  x  P   P 1  t   t  t t t 0 i i i i 1 v v if (!Pv)
                                                                                       memh(Rx++#s4:1)=Rt
                                                                                       if (Pv.new)
 1  0  1  0 1  0   1 1  0   1 0   x  x  x  x  x  P   P 1  t   t  t t t 1 i i i i 0 v v
                                                                                       memh(Rx++#s4:1)=Rt
                                                                                       if (!Pv.new)
 1  0  1  0 1  0   1 1  0   1 0   x  x  x  x  x  P   P 1  t   t  t t t 1 i i i i 1 v v
                                                                                       memh(Rx++#s4:1)=Rt
                                                                                       if (Pv)
 1  0  1  0 1  0   1 1  0   1 1   x  x  x  x  x  P   P 1  t   t  t t t 0 i i i i 0 v v memh(Rx++#s4:1)=Rt.H
                                                                                     v ifmemh(Rx++#s4:1)=Rt.H
                                                                                          (!Pv)
 1  0  1  0 1  0   1 1  0   1 1   x  x  x  x  x  P   P 1  t   t  t t t 0 i i i i 1 v
                                                                                       if (Pv.new)
 1  0  1  0 1  0   1 1  0   1 1   x  x  x  x  x  P   P 1  t   t  t t t 1 i i i i 0 v v memh(Rx++#s4:1)=Rt.H
                                                                                     v ifmemh(Rx++#s4:1)=Rt.H
                                                                                          (!Pv.new)
 1  0  1  0 1  0   1 1  0   1 1   x  x  x  x  x  P   P 1  t   t  t t t 1 i i i i 1 v
   ICLASS    Amode     Type   U                  Parse          t5
                              N
 1  0  1  0 1  1   1 1  0   1 0   -  -  -   i  i P   P 0  t   t  t t t 1 i i i i 0 v v if (Pv) memh(#u6)=Rt
 1  0  1  0 1  1   1 1  0   1 0   -  -  -   i  i P   P 0  t   t  t t t 1 i i i i 1 v v if (!Pv) memh(#u6)=Rt
 1  0  1  0 1  1   1 1  0   1 0   -  -  -   i  i P   P 1  t   t  t t t 1 i i i i 0 v v if (Pv.new) memh(#u6)=Rt
 1  0  1  0 1  1   1 1  0   1 0   -  -  -   i  i P   P 1  t   t  t t t 1 i i i i 1 v v if (!Pv.new) memh(#u6)=Rt
 1  0  1  0 1  1   1 1  0   1 1   -  -  -   i  i P   P 0  t   t  t t t 1 i i i i 0 v v if (Pv) memh(#u6)=Rt.H
 1  0  1  0 1  1   1 1  0   1 1   -  -  -   i  i P   P 0  t   t  t t t 1 i i i i 1 v v if (!Pv) memh(#u6)=Rt.H
                                                                                       if (Pv.new)
 1  0  1  0 1  1   1 1  0   1 1   -  -  -   i  i P   P 1  t   t  t t t 1 i i i i 0 v v memh(#u6)=Rt.H
 1  0  1  0 1  1   1 1  0   1 1   -  -  -   i  i P   P 1  t   t  t t t 1 i i i i 1 v v ifmemh(#u6)=Rt.H
                                                                                          (!Pv.new)
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                            319
Hexagon V67 Programmer’s Reference Manual                                                    Instruction Set
        Store word
                  Store a 32-bit register in memory at the effective address.
                   Syntax                              Behavior
                   memw(Re=#U6)=Rt                      apply_extension(#U);
                                                        EA=#U;
                                                        *EA = Rt;
                                                        Re=#U;
                   memw(Rs+#s11:2)=Rt                   apply_extension(#s);
                                                        EA=Rs+#s;
                                                        *EA = Rt;
                   memw(Rs+#u6:2)=#S8                   EA=Rs+#u;
                                                        apply_extension(#S);
                                                        *EA = #S;
                   memw(Rs+Ru<<#u2)=Rt                  EA=Rs+(Ru<<#u);
                                                        *EA = Rt;
                   memw(Ru<<#u2+#U6)=Rt                 apply_extension(#U);
                                                        EA=#U+(Ru<<#u);
                                                        *EA = Rt;
                   memw(Rx++#s4:2)=Rt                   EA=Rx;
                                                        Rx=Rx+#s;
                                                        *EA = Rt;
                   memw(Rx++#s4:2:circ(Mu))=Rt          EA=Rx;
                                                        Rx=Rx=circ_add(Rx,#s,MuV);
                                                        *EA = Rt;
                   memw(Rx++I:circ(Mu))=Rt              EA=Rx;
                                                        Rx=Rx=circ_add(Rx,I<<2,MuV);
                                                        *EA = Rt;
                   memw(Rx++Mu)=Rt                      EA=Rx;
                                                        Rx=Rx+MuV;
                                                        *EA = Rt;
                   memw(Rx++Mu:brev)=Rt                 EA=Rx.h[1] | brev(Rx.h[0]);
                                                        Rx=Rx+MuV;
                                                        *EA = Rt;
                   memw(gp+#u16:2)=Rt                   apply_extension(#u);
                                                        EA=(Constant_extended ? (0) : GP)+#u;
                                                        *EA = Rt;
                  Class: ST (slots 0,1)
                  Intrinsics
                   memw(Rx++#s4:2:circ(Mu))=Rt         void Q6_memw_IMR_circ(void** StartAddress,
                                                       Word32 Is4_2, Word32 Mu, Word32 Rt, void*
                                                       BaseAddress)
                   memw(Rx++I:circ(Mu))=Rt             void Q6_memw_MR_circ(void** StartAddress, Word32
                                                       Mu, Word32 Rt, void* BaseAddress)
80-N2040-45 Rev. B                                                                                       320
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7 6 5 4 3 2  1 0
   ICLASS                               s5        Parse          u5               t5
 0  0  1  1 1  0   1  1  1   0   0 s  s  s  s  s  P   P  i u  u  u  u u i - - t t  t t t memw(Rs+Ru<<#u2)=Rt
   ICLASS                               s5        Parse
 0  0  1  1 1  1   0  -   -  1   0 s  s  s  s  s  P   P  I i   i  i i i i I I I I  I I I memw(Rs+#u6:2)=#S8
   ICLASS                   Type                  Parse          t5
 0  1  0  0 1   i   i 0  1   0   0 i  i  i   i  i P   P  i t   t  t t t i i i i i  i i i memw(gp+#u16:2)=Rt
                                 U
   ICLASS    Amode      Type            s5        Parse          t5
                                 N
 1  0  1  0 0   i   i 1  1   0   0 s  s  s  s  s  P   P  i t   t  t t t i i i i i  i i i memw(Rs+#s11:2)=Rt
                                 U
   ICLASS    Amode      Type            x5        Parse u1       t5
                                 N
 1  0  1  0 1  0   0  1  1   0   0 x  x  x  x  x  P   P u  t   t  t t t 0 - - - -  - 1 - memw(Rx++I:circ(Mu))=Rt
                                                                                         memw(Rx++#s4:2:circ(Mu)
 1  0  1  0 1  0   0  1  1   0   0 x  x  x  x  x  P   P u  t   t  t t t 0 i i i i  - 0 -
                                                                                         )=Rt
                                 U
   ICLASS    Amode      Type            e5        Parse          t5
                                 N
 1  0  1  0 1  0   1  1  1   0   0 e  e  e  e  e  P   P 0  t   t  t t t 1 - I I I  I I I memw(Re=#U6)=Rt
                                 U
   ICLASS    Amode      Type            x5        Parse          t5
                                 N
 1  0  1  0 1  0   1  1  1   0   0 x  x  x  x  x  P   P 0  t   t  t t t 0 i i i i  - 0 - memw(Rx++#s4:2)=Rt
                                 U
   ICLASS    Amode      Type            u5        Parse          t5
                                 N
 1  0  1  0 1  1   0  1  1   0   0 u  u  u  u  u  P   P  i t   t  t t t 1 i I I I  I I I memw(Ru<<#u2+#U6)=Rt
   ICLASS    Amode      Type     U      x5        Parse u1       t5
                                 N
 1  0  1  0 1  1   0  1  1   0   0 x  x  x  x  x  P   P u  t   t  t t t 0 - - - -  - - - memw(Rx++Mu)=Rt
 1  0  1  0 1  1   1  1  1   0   0 x  x  x  x  x  P   P u  t   t  t t t 0 - - - -  - - - memw(Rx++Mu:brev)=Rt
                  Field name         Description
                  ICLASS             Instruction Class
                  Type               Type
                  Parse              Packet/Loop parse bits
                  e5                 Field to encode register e
                  s5                 Field to encode register s
                  t5                 Field to encode register t
                  u1                 Field to encode register u
                  u5                 Field to encode register u
                  x5                 Field to encode register x
                  Amode              Amode
                  Type               Type
                  UN                 Unsigned
80-N2040-45 Rev. B                                                                                            321
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Store word conditionally
                  Store a 32-bit register in memory at the effective address.
                  This instruction is conditional based on a predicate value. If the predicate is true, the
                  instruction is performed, otherwise it is treated as a NOP.
                   Syntax                              Behavior
                   if ([!]Pv[.new]) memw(#u6)=Rt        apply_extension(#u);
                                                        EA=#u;
                                                        if ([!]Pv[.new][0]) {
                                                              *EA = Rt;
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     EA=Rs+#u;
                   memw(Rs+#u6:2)=#S6                   if ([!]Pv[.new][0]){
                                                              apply_extension(#S);
                                                              *EA = #S;
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     apply_extension(#u);
                   memw(Rs+#u6:2)=Rt                    EA=Rs+#u;
                                                        if ([!]Pv[.new][0]) {
                                                              *EA = Rt;
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     EA=Rs+(Ru<<#u);
                   memw(Rs+Ru<<#u2)=Rt                  if ([!]Pv[.new][0]) {
                                                              *EA = Rt;
                                                        } else {
                                                              NOP;
                                                        }
                   if ([!]Pv[.new])                     EA=Rx;
                   memw(Rx++#s4:2)=Rt                   if ([!]Pv[.new][0]){
                                                              Rx=Rx+#s;
                                                              *EA = Rt;
                                                        } else {
                                                              NOP;
                                                        }
80-N2040-45 Rev. B                                                                                             322
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Class: ST (slots 0,1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2  1 0
   ICLASS                              s5        Parse         u5               t5
                                                                                       if (Pv)
 0  0  1  1 0  1   0  0  1   0  0 s  s  s  s  s  P   P i u  u   u u u i v v t t  t t t
                                                                                       memw(Rs+Ru<<#u2)=Rt
                                                                                       if (!Pv)
 0  0  1  1 0  1   0  1  1   0  0 s  s  s  s  s  P   P i u  u   u u u i v v t t  t t t
                                                                                       memw(Rs+Ru<<#u2)=Rt
                                                                                       if (Pv.new)
 0  0  1  1 0  1   1  0  1   0  0 s  s  s  s  s  P   P i u  u   u u u i v v t t  t t t
                                                                                       memw(Rs+Ru<<#u2)=Rt
                                                                                       if (!Pv.new)
 0  0  1  1 0  1   1  1  1   0  0 s  s  s  s  s  P   P i u  u   u u u i v v t t  t t t memw(Rs+Ru<<#u2)=Rt
   ICLASS                              s5        Parse
                                                                                       if (Pv)
 0  0  1  1 1  0   0  0  0   1  0 s  s  s  s  s  P   P I  i  i  i i i i v v I I  I I I memw(Rs+#u6:2)=#S6
                                                                                       if (!Pv)
 0  0  1  1 1  0   0  0  1   1  0 s  s  s  s  s  P   P I  i  i  i i i i v v I I  I I I
                                                                                       memw(Rs+#u6:2)=#S6
                                                                                       if (Pv.new)
 0  0  1  1 1  0   0  1  0   1  0 s  s  s  s  s  P   P I  i  i  i i i i v v I I  I I I memw(Rs+#u6:2)=#S6
                                                                                       if (!Pv.new)
 0  0  1  1 1  0   0  1  1   1  0 s  s  s  s  s  P   P I  i  i  i i i i v v I I  I I I
                                                                                       memw(Rs+#u6:2)=#S6
                   Pr
               Se ed
   ICLASS      ns Ne       Type        s5        Parse         t5
                e w
                                                                                     v ifmemw(Rs+#u6:2)=Rt
                                                                                          (Pv)
 0  1  0  0 0  0   0  0  1   0  0 s  s  s  s  s  P   P i  t  t  t t t i i i i i 0  v
                                                                                       if (Pv.new)
 0  1  0  0 0  0   1  0  1   0  0 s  s  s  s  s  P   P i  t  t  t t t i i i i i 0  v v memw(Rs+#u6:2)=Rt
                                                                                     v ifmemw(Rs+#u6:2)=Rt
                                                                                          (!Pv)
 0  1  0  0 0  1   0  0  1   0  0 s  s  s  s  s  P   P i  t  t  t t t i i i i i 0  v
                                                                                     v ifmemw(Rs+#u6:2)=Rt
                                                                                          (!Pv.new)
 0  1  0  0 0  1   1  0  1   0  0 s  s  s  s  s  P   P i  t  t  t t t i i i i i 0  v
                                U
   ICLASS    Amode      Type    N      x5        Parse         t5
                                                                                     v ifmemw(Rx++#s4:2)=Rt
                                                                                          (Pv)
 1  0  1  0 1  0   1  1  1   0  0 x  x  x  x  x  P   P 1  t  t  t t t 0 i i i i 0  v
                                                                                       if (!Pv)
 1  0  1  0 1  0   1  1  1   0  0 x  x  x  x  x  P   P 1  t  t  t t t 0 i i i i 1  v v memw(Rx++#s4:2)=Rt
                                                                                       if (Pv.new)
 1  0  1  0 1  0   1  1  1   0  0 x  x  x  x  x  P   P 1  t  t  t t t 1 i i i i 0  v v memw(Rx++#s4:2)=Rt
                                                                                     v ifmemw(Rx++#s4:2)=Rt
                                                                                          (!Pv.new)
 1  0  1  0 1  0   1  1  1   0  0 x  x  x  x  x  P   P 1  t  t  t t t 1 i i i i 1  v
                                U
   ICLASS    Amode      Type                     Parse         t5
                                N
 1  0  1  0 1  1   1  1  1   0  0 -  -  -  i   i P   P 0  t  t  t t t 1 i i i i 0  v v if (Pv) memw(#u6)=Rt
 1  0  1  0 1  1   1  1  1   0  0 -  -  -  i   i P   P 0  t  t  t t t 1 i i i i 1  v v if (!Pv) memw(#u6)=Rt
 1  0  1  0 1  1   1  1  1   0  0 -  -  -  i   i P   P 1  t  t  t t t 1 i i i i 0  v v if (Pv.new) memw(#u6)=Rt
 1  0  1  0 1  1   1  1  1   0  0 -  -  -  i   i P   P 1  t  t  t t t 1 i i i i 1  v v if (!Pv.new) memw(#u6)=Rt
                  Field name        Description
                  ICLASS            Instruction Class
                  Type              Type
                  PredNew           PredNew
                  Sense             Sense
                  Parse             Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                            323
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  s5           Field to encode register s
                  t5           Field to encode register t
                  u5           Field to encode register u
                  v2           Field to encode register v
                  x5           Field to encode register x
                  Amode        Amode
                  Type         Type
                  UN           Unsigned
80-N2040-45 Rev. B                                                    324
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Allocate stack frame
                  Allocate a stack frame on the call stack. This instruction first pushes LR and FP to the top
                  of stack. It then subtracts an unsigned immediate from SP to allocate room for local
                  variables. FP is set to the address of the old frame pointer on the stack.
                  The following figure shows the stack layout.
                                                    Stack in Memory
                                                       Saved LR
                                                       Saved FP
                     Higher Address
                                                     Procedure Local
                                                      Data on Stack
                                                                                      Stack frame
                                                       Saved LR
                                                       Saved FP                          FP register
                                                     Procedure Local
                                                      Data on Stack
                                                                                         SP register
                    Lower Address
                                                    Unallocated Stack
                   Syntax                                Behavior
                   allocframe(#u11:3)                    Assembler mapped to:
                                                         "allocframe(r29,#u11:3):raw"
                   allocframe(Rx,#u11:3):raw             EA=Rx+-8;
                                                         *EA = frame_scramble((LR << 32) | FP);
                                                         FP=EA;
                                                         frame_check_limit(EA-#u);
                                                         Rx = EA-#u;
80-N2040-45 Rev. B                                                                                           325
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
                  Class: ST (slots 0)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
                              U
   ICLASS    Amode     Type            x5        Parse
                              N
 1  0  1  0 0  0   0 0  1   0 0   x  x  x  x  x  P   P 0 0   0  i i i i i i i i i i i allocframe(Rx,#u11:3):raw
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  x5                Field to encode register x
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                           326
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
     11.9         SYSTEM
                  The SYSTEM instruction class includes instructions for managing system resources.
    11.9.1        SYSTEM/GUEST
                  The SYSTEM/GUEST instruction subclass includes instructions for Guest mode.
        Guest control register transfer
                  These instructions move registers between the guest control and general register files.
                  The following figure shows the guest control registers and their register field encodings.
                  Registers can be moved as singles or as aligned 64-bit pairs.
                    0      G0         16    ISDBMBXIN
                    1      G1         17   ISDBMBXOUT
                    2      G2
                    3      G3
                                            Reserved
                                       24   GPCYCLELO
                                       25   GPCYCLEHI
                         Reserved
                                       26   GPMUCNT0
                                       27   GPMUCNT1
                                       28   GPMUCNT2
                                       29   GPMUCNT3
                                       30    Reserved
                    15                 31    Reserved
                   Syntax                               Behavior
                   Gd=Rs                                Gd=Rs;
                   Gdd=Rss                              Gdd=Rss;
                   Rd=Gs                                Rd=Gs;
                   Rdd=Gss                              Rdd=Gss;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■  This is a guest-level feature. If performed in User mode, a privilege error
                          exception occurs.
80-N2040-45 Rev. B                                                                                           327
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2  1 0
   ICLASS      sm                      s5        Parse                          d5
 0  1  1  0 0  0   1 0  0  0  0   s  s  s  s  s  P   P -  -  -  - - - - - - d d d  d d Gd=Rs
 0  1  1  0 0  0   1 1  0  0  0   s  s  s  s  s  P   P -  -  -  - - - - - - d d d  d d Gdd=Rss
 0  1  1  0 1  0   0 0  0  0  1   s  s  s  s  s  P   P -  -  -  - - - - - - d d d  d d Rdd=Gss
 0  1  1  0 1  0   1 0  0  0  1   s  s  s  s  s  P   P -  -  -  - - - - - - d d d  d d Rd=Gs
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                         328
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
     11.9.2       SYSTEM/MONITOR
                  The SYSTEM/MONITOR instruction subclass includes instructions for Monitor mode.
          Clear interrupt auto disable
                  Register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
                  interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31.
                  For bits set in Rs, the corresponding bit in IAD is cleared. This re-enables the interrupt.
                  For bits cleared in Rs, the corresponding bit in IAD is unaffected.
                   Syntax                                   Behavior
                   ciad(Rs)                                 IAD &= ~Rs;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This instruction may only be grouped with ALU32 or non-floating-point XTYPE
                           instructions.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6 5  4  3  2  1  0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  1   0 0  0  0  0   s  s  s  s  s  P   P -  -   - -  - - 0  1 1  -  -  -  -  - ciad(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                                329
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Swap SGP control register
                  CRSWAP swaps the contents of a general register with one of the Supervisor General
                  Pointer registers, either SGP0 or SGP1.
                  For example, these registers can be used to hold a supervisor or exception stack pointer, or
                  other general pointers for fast exception processing. A pair swap form exists to swap both
                  SGP registers with an align ed pair of general registers.
                   Syntax                                   Behavior
                   crswap(Rx,sgp)                           Assembler mapped to: "crswap(Rx,sgp0)"
                   crswap(Rx,sgp0)                          tmp = Rx;
                                                            Rx = SGP0;
                                                            SGP0 = tmp;
                   crswap(Rx,sgp1)                          tmp = Rx;
                                                            Rx = SGP1;
                                                            SGP1 = tmp;
                   crswap(Rxx,sgp1:0)                       tmp = Rxx;
                                                            Rxx=SGP;
                                                            SGP = tmp;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6 5  4 3 2  1 0
   ICLASS      sm                      x5        Parse
 0  1  1  0 0  1   0 1  0  0  0   x  x  x  x  x  P   P -  -   - -  - -  - - -  - -  - -  - crswap(Rx,sgp0)
 0  1  1  0 0  1   0 1  0  0  1   x  x  x  x  x  P   P -  -   - -  - -  - - -  - -  - -  - crswap(Rx,sgp1)
 0  1  1  0 1  1   0 1  1  0   -  x  x  x  x  x  P   P -  -   - -  - -  - - - 0  0 0  0 0  crswap(Rxx,sgp1:0)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                             330
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Cancel pending interrupts
                  Register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
                  interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31.
                  CSWI cancels any pending interrupts indicated in the mask by clearing the interrupt from
                  the IPEND register.
                   Syntax                                   Behavior
                   cswi(Rs)                                 IPEND &= ~Rs;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This instruction may only be grouped with ALU32 or non-floating-point XTYPE
                           instructions.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4  3  2  1  0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  1   0 0  0  0  0   s  s  s  s  s  P   P -  -   - -  - - 0  0 1  -  -  -  -  - cswi(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                                331
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Data cache kill
                  DCKILL invalidates the entire contents of the data cache. On power-up, the caches are not
                  guaranteed to contain valid data.
                  Use this instruction to establish an initial clean cache state. All dirty data in the data cache
                  that has not yet written back to memory is lost when DCKILL is executed. To save data
                  clean it out using DCLEAN instructions before executing DCKILL.
                  Because the caches are shared between all threads, this instruction must be performed only
                  while ensuring that no other thread is using the caches. The best option is to use this
                  instruction when only one thread is powered on and others are powered off.
                   Syntax                                   Behavior
                   dckill                                   dcache_inv_all();
                  Class: SYSTEM (slots 0)
                  Notes
                       ■    This is a solo instruction. It must not be grouped with other instructions in a
                            packet.
                       ■    This is a monitor-level feature. If performed in User or Guest mode, a privilege
                            error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4  3  2  1  0
                               U
   ICLASS    Amode     Type                      Parse
                               N
 1  0  1  0 0  0   1 0  0   0  0  -  -  -  -   - P   P -  -   - -  - -  - - -  -  -  -  -  -  dckill
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                                332
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Data cache maintenance monitor instructions
                  Perform maintenance operations on the data cache.
                  DCCLEANINVIDX looks at index Rs in the data cache. If this line has dirty data, the data
                  is flushed out to memory. The line is invalidated. The set is provided in Rs[10:5] and the
                  way in Rs[1:0]. This instruction can only be grouped with X-type or A-type instructions.
                  DCCLEANIDX looks at index Rs in the data cache. If this line has dirty data, the data is
                  flushed out to memory. The set is provided in Rs[10:5] and the way in Rs[1:0]. This
                  instruction can only be grouped with X-type or A-type instructions.
                  DCINVIDX invalidates the line at index Rs. The set is provided in Rs[10:5] and the way
                  in Rs[1:0]. This instruction can only be grouped with X-type or A-type instructions.
                  DCTAGR reads the tag at indicated by Rs and returns the data into Rd. The set is provided
                  Rs[10:5], and the way is provided in Rs[1:0]. The tag is returned in Rd[23:0], and the state
                  is returned in Rd[30:29]. This instruction can only be grouped with X-type or A-type
                  instructions.
                  DCTAGW uses register Rs and Rt. Register Rs contains the set in [10:5] and way in [1:0]
                  while the Rt value contains the Tag in [23:0] and the state in [30:29]. For WT D$,
                  state=2'b11 is an invalid value. The DCTAGW instruction is single-thread only. All other
                  threads must be in Stop or Debug mode with no outstanding transactions. This instruction
                  is SOLO and must not appear in a packet with other instructions.
                  The state bits are encoded as follows:
                           00 = Invalid
                           01 = Valid & clean
                           10 = Reserved
                           11 = Not used for WT D$
                  For 32 KB D$, Rs[11:5] provides the set index for the above instructions.
                   Syntax                              Behavior
                   Rd=dctagr(Rs)                        dcache_tag_read(Rs);
                   dccleanidx(Rs)                       dcache_clean_idx(Rs);
                   dccleaninvidx(Rs)                    dcache_cleaninv_idx(Rs);
                   dcinvidx(Rs)                         dcache_inv_idx(Rs);
                   dctagw(Rs,Rt)                        dcache_tag_write(Rs,Rt);
                  Class: SYSTEM (slots 0)
                  Notes
                        ■  Group this instruction only with ALU32 or non-floating-point XTYPE
                           instructions.
80-N2040-45 Rev. B                                                                                           333
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                       ■    This is a solo instruction. It must not be grouped with other instructions in a
                            packet.
                       ■    This is a monitor-level feature. If performed in User or Guest mode, a privilege
                            error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5 4  3  2  1 0
                               U
   ICLASS    Amode     Type             s5       Parse
                               N
 1  0  1  0 0  0   1 0  0   0  1  s  s  s  s  s  P   P -  -   -  - - -  - - -  - -  -  -  - dccleanidx(Rs)
 1  0  1  0 0  0   1 0  0   1  0  s  s  s  s  s  P   P -  -   -  - - -  - - -  - -  -  -  - dcinvidx(Rs)
 1  0  1  0 0  0   1 0  0   1  1  s  s  s  s  s  P   P -  -   -  - - -  - - -  - -  -  -  - dccleaninvidx(Rs)
                               U
   ICLASS    Amode     Type             s5       Parse          t5
                               N
 1  0  1  0 0  1   0 0  0   0  0  s  s  s  s  s  P   P -  t   t  t t t  - - -  - -  -  -  - dctagw(Rs,Rt)
                               U
   ICLASS    Amode     Type    N        s5       Parse                             d5
 1  0  1  0 0  1   0 0  0   0  1  s  s  s  s  s  P   P -  -   -  - - -  - - - d  d  d  d d Rd=dctagr(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                                334
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
          Read the interrupt mask for a thread
                  Each thread contains an IMASK register that holds the interrupt enable/disable for
                  individual interrupts 0-31.
                  GETIMASK reads the IMASK for the thread indicated by the low bits of Rs. The result is
                  returned in Rd. For Rs values outside of [0-NUM_THREADS-1], the results are
                  undefined.
                   Syntax                                   Behavior
                   Rd=getimask(Rs)                          Rd = IMASK[Rs & thread->processor_ptr-
                                                            >thread_system_mask];
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   Group this instruction only with ALU32 or non-floating-point XTYPE
                           instructions.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS      sm                      s5        Parse                             d5
 0  1  1  0 0  1   1 0  0  0  0   s  s  s  s  s  P   P -  -   - -  - - -  - - d  d d  d d Rd=getimask(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                            335
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          Acquire hardware lock
                  If the lock bit is set, sleep until the lock bit is clear. The packet with the lock instruction
                  only completes once the lock is set and acquired by this thread. When multiple threads are
                  waiting for the lock, the hardware guarantees round-robin fairness such that no thread is
                  starved.
                  TLBLOCK is acquired automatically whenever a thread raises a TLB miss-RW or TLB-
                  miss-X exception.
                   Syntax                                    Behavior
                   k0lock                                    if (can_aquire_k0_lock) {
                                                                 SYSCFG.K0LOCK = 1;
                                                             } else {
                                                                 sleep_until_available;
                                                             }
                   tlblock                                   if (can_aquire_tlb_lock) {
                                                                 SYSCFG.TLBLOCK = 1;
                                                             } else {
                                                                 sleep_until_available;
                                                             }
                  Class: SYSTEM (slot 3)
                  Notes
                        ■  This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                        ■  This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7   6 5  4 3 2  1  0
   ICLASS      sm                                Parse
 0  1  1  0 1  1   0  0  0 0  1   -  -   -  -  - P   P  -  -   - -  -  - 0   0 1  - -  - -  -  tlblock
 0  1  1  0 1  1   0  0  0 0  1   -  -   -  -  - P   P  -  -   - -  -  - 0   1 1  - -  - -  -  k0lock
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                                 336
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Release hardware lock
                  This instruction releases a hardware lock.
                   Syntax                                   Behavior
                   k0unlock                                 SYSCFG.K0LOCK = 0;
                   tlbunlock                                SYSCFG.TLBLOCK = 0;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS      sm                                Parse
 0  1  1  0 1  1   0 0  0  0  1   -  -  -  -   - P   P -  -   - -  - - 0 1  0  - - -  -  - tlbunlock
 0  1  1  0 1  1   0 0  0  0  1   -  -  -  -   - P   P -  -   - -  - - 1 0  0  - - -  -  - k0unlock
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                               337
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Interrupt to thread assignment read
                  Each thread contains an IMASK register that holds the interrupt enable/disable for
                  individual interrupts 0-31.
                  For a given interrupt, IASSIGNR reads the corresponding bit in the IMASK register of
                  each thread. The upper halfword of source register Rs contains the interrupt number from
                  0-31 (0 is the highest priority interrupt, 31 the lowest). The low bits of the destination
                  register Rd contain a bit mask where bit 0 contains the corresponding IMASK value for
                  thread 0, bit 1 the value for thread 1, etc.
                  The number of defined bits depends on the number of hardware threads provided in the
                  core. All bits beyond the number of threads provided are cleared. For example, if the
                  interrupt number is set to 0, Rd[0] is the value of IMASK[0] for thread 0, Rd[1] is the
                  value of IMASK[0] for thread 1, etc.
                    31                             16 15                           0
                                              Int#                                      Rs
                                      Interrupt number [0-31]
                                      0=highest priority
                                      interrupt
                                      31=lowest priority
                    31                                                             0
                                                                                        Rd
                                                                                     Thread 0:
                                                                                     Value of IMASK[int#]
                                                                Thread 5 assignment
                   Syntax                                Behavior
                   Rd=iassignr(Rs)                        Rd=IASSIGNR(Rs);
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   Group this instruction only with ALU32 or non-floating-point XTYPE
                           instructions.
80-N2040-45 Rev. B                                                                                             338
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4 3  2  1 0
   ICLASS      sm                      s5        Parse                            d5
 0  1  1  0 0  1   1 0  0  1  1   s  s  s  s  s  P   P -  -  -  - - - - -  - d d  d  d d Rd=iassignr(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                            339
Hexagon V67 Programmer’s Reference Manual                                                                   Instruction Set
           Interrupt to thread assignment write
                   Each thread contains an IMASK register that holds the interrupt enable/disable for
                   individual interrupts 0-31.
                   For a given interrupt, IASSIGNW sets or clears the corresponding bit the IMASK register
                   of each thread. This allows for easy reassignment of interrupts to selected threads.
                   Source register Rs contains two fields. The upper halfword contains the interrupt number
                   from 0-31 (0 is the highest priority interrupt, 31 the lowest). The low bits contain a bit
                   mask where bit 0 contains the corresponding IMASK value for thread 0, bit 1 the value for
                   thread 1, etc. For example, if the interrupt number is set to 0, and the bit mask is set to
                   0x03, the IMASK[0] for threads 0 and 1 are set and the IMASK[0] for all other threads are
                   cleared. This means that threads 0,1 do not accept this interrupt, whereas other threads do
                   accept it.
   31                               16 15                            0
                               Int#                                          Rs
                                                                        Thread 0 assignment:
                                                                        1=Set Thread0:IMASK[Int#]
                      Interrupt number [0-31]                           (interrupt disabled)
                      0=highest priority
                      interrupt                                         0=Clear Thread0:IMASK[Int#]
                      31=lowest priority                                (interrupt enabled for T0)
                                                Thread 5 assignment
                   Syntax                                   Behavior
                    iassignw(Rs)                            IASSIGNW(Rs);
                   Class: SYSTEM (slot 3)
                   Notes
                          ■  Group this instruction only with ALU32 or non-floating-point XTYPE
                             instructions.
                          ■  This is a monitor-level feature. If performed in User or Guest mode, a privilege
                             error exception occurs.
                   Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8   7  6  5  4  3  2  1  0
    ICLASS      sm                       s5      Parse
 0   1  1   0 0 1   0   0  0  0  0  s  s  s s s  P   P -  -   - -  -   -   0  1 0   -  -  -  -  -  iassignw(Rs)
80-N2040-45 Rev. B                                                                                                      340
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  sm           Supervisor mode only
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  s5           Field to encode register s
80-N2040-45 Rev. B                                                    341
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Instruction cache maintenance supervisor operations
                  Perform maintenance operations on the instruction cache.
                  ICTAGR reads the tag at set Rs[12:5] for 32 Kb I$ or Rs[11:5] for 16 Kb I$, and way
                  Rs[0]. The tag value is returned in Rd[31:10] for 32k caches, or Rd[31:9] for 16k caches.
                  The Valid bit in Rs[1], and the Reserved bit in Rd[0].
                  ICDATAR reads the data word at set Rs[13:5], word Rs[4:2], and way Rs[0]. The data
                  value is returned in Rd[31:0].
                  ICINVIDX invalidates the instruction cache index indicated by Rs[13:6] for 32 Kb I$ and
                  Rs[12:6] for 16 Kb I$.
                   Syntax                                   Behavior
                   Rd=icdatar(Rs)                           icache_data_read(Rs);
                   Rd=ictagr(Rs)                            icache_tag_read(Rs);
                   icinvidx(Rs)                             icache_inv_idx(Rs);
                  Class: SYSTEM (slot 2)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2  1 0
   ICLASS                              s5        Parse                              d5
 0  1  0   1 0 1   0 1  1  0  1   s  s  s  s  s  P   P -  -   - -  - - -  - -  d d  d  d d Rd=icdatar(Rs)
 0  1  0   1 0 1   0 1  1  1  1   s  s  s  s  s  P   P -  -   - -  - - -  - -  d d  d  d d Rd=ictagr(Rs)
   ICLASS                              s5        Parse
 0  1  0   1 0 1   1 0  1  1  0   s  s  s  s  s  P   P 0 0   1  -  - - -  - -  -  -  - - - icinvidx(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                               342
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Instruction cache maintenance operations (single-thread)
                  Perform maintenance operations on the instruction cache.
                  ICKILL invalidates the instruction cache.
                  ICTAGW updates specified tag entry with contents of Rt. Rs[13:5] for 32 Kb I$ or
                  Rs[12:5] for 16 Kb I$ selects index and Rs[0] selects cache way. Rt must have the Tag
                  information in bits 20:0 for 32 Kb I$ or 21:0 for 16 Kb I$, the Valid bit in Rt[30] and the
                  reserved bit in Rt[31].
                  These instructions are single-thread only. All other threads must be in Stop or Debug mode
                  with no outstanding transactions.
                   Syntax                                   Behavior
                   icdataw(Rs,Rt)                           icache_data_write(Rs,Rt);
                   ickill                                   icache_inv_all();
                   ictagw(Rs,Rt)                            icache_tag_write(Rs,Rt);
                  Class: SYSTEM (slot 2)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS                              s5        Parse          t5
 0  1  0   1 0 1   0 1  1  1  0   s  s  s  s  s  P   P 0  t   t  t t t -  - -  - -  - -  - ictagw(Rs,Rt)
 0  1  0   1 0 1   0 1  1  1  0   s  s  s  s  s  P   P 1  t   t  t t t -  - -  - -  - -  - icdataw(Rs,Rt)
   ICLASS                                        Parse
 0  1  0   1 0 1   1 0  1  1  0   -  -  -   -  - P   P 0 1   0   - - - -  - -  - -  - -  - ickill
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              343
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          L2 cache operations by index
                  These instructions operate on a specified line in L2 cache.
                  The clean operation pushed dirty data out to the system. The invalidate operation marks
                  the line as invalidate, and the cleaninv operation first cleans the line and then invalidates
                  it.
                  The index is provided in Rs[S:8] and the way is in Rs[2:0], where S is determined by the
                  number of sets in the L2 cache. For segmented L2 caches, the granule bit provided in
                  Rs[3]. This bit is ignored if the cache is not segmented.
                  Different versions of Hexagon may have different L2 cache sizes. For more information,
                  see the section on Core Versions
                   Syntax                                     Behavior
                   l2cleanidx(Rs)                             l2cache_clean_idx(Rs);
                   l2cleaninvidx(Rs)                          l2cache_clean_invalidate_idx(Rs);
                   l2invidx(Rs)                               l2cache_inv_idx(Rs);
                  Class: SYSTEM (slots 0)
                  Notes
                        ■    Group this instruction only with ALU32 or non-floating-point XTYPE
                             instructions.
                        ■    This is a monitor-level feature. If performed in User or Guest mode, a privilege
                             error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6 5  4 3 2  1 0
                                U
   ICLASS    Amode      Type             s5        Parse
                                N
 1  0  1  0 0  1   1  0  0   0  1  s   s  s  s  s  P   P -  -   - -  - - -  - -  - -  - -  - l2cleanidx(Rs)
 1  0  1  0 0  1   1  0  0   1  0  s   s  s  s  s  P   P -  -   - -  - - -  - -  - -  - -  - l2invidx(Rs)
 1  0  1  0 1  0   0  0  0   1  1  s   s  s  s  s  P   P -  -   - -  - - -  - -  - -  - -  - l2cleaninvidx(Rs)
                  Field name          Description
                  ICLASS              Instruction Class
                  Parse               Packet/Loop parse bits
                  s5                  Field to encode register s
                  Amode               Amode
                  Type                Type
                  UN                  Unsigned
80-N2040-45 Rev. B                                                                                                 344
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        L2 cache global operations
                  Perform maintenance operations over the entire L2 cache.
                  The instructions commit and set the SYSCFG:L2GCA bit to indicate that the Global
                  Cache state machine is Active. Once the state machine is started, it processes every L2
                  cache line in the background. After all cache lines have processed, the SYSCFG:L2GCA
                  status bit is cleared.
                  L2KILL invalidates every line. It is required to execute this instruction prior to using L2
                  after a power-on reset, as the cache starts in an unknown state.
                  L2GCLEAN forces a clean (flush) operation for all L2 cache lines that are dirty.
                  L2GCLEANINV forces a clean (flush) for dirty L2 lines and then invalidate them.
                  L2GUNLOCK clears the lock bit for all L2 cache lines.
                  The L2GCLEAN and L2GCLEANINV are available with PA range and mask option. In
                  this form, the Rtt register contains a mask in the lower word and match value in the upper
                  word. If the Physical Page Number of the cache line AND’d with the mask is equal to the
                  match value, the cache operation is performed. Otherwise, the cache line is left
                  unchanged.
                  For every cache line in L2, the semantics are: if (Rtt[23:0] & PA[35:12]) == Rtt[55:32]),
                  do clean/cleaninv on the cache line.
                   Syntax                                 Behavior
                   l2gclean                               l2cache_global_clean();
                   l2gclean(Rtt)                          l2cache_global_clean_range(Rtt);
                   l2gcleaninv                            l2cache_global_clean_inv();
                   l2gcleaninv(Rtt)                       l2cache_global_clean_inv_range(Rtt);
                   l2gunlock                              l2cache_global_unlock();
                   l2kill                                 l2cache_inv_all();
                  Class: SYSTEM (slots 0)
                  Notes
                        ■  This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                        ■  This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
80-N2040-45 Rev. B                                                                                             345
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1 0
                              U
   ICLASS    Amode     Type                      Parse          t5
                              N
 1  0  1  0 0  1   1 0  1   0 1   -  -  -   -  - P   P -  t   t  t t t - - - - - - - - l2gclean(Rtt)
 1  0  1  0 0  1   1 0  1   1 0   -  -  -   -  - P   P -  t   t  t t t - - - - - - - - l2gcleaninv(Rtt)
                              U                  Parse
   ICLASS    Amode     Type
                              N
 1  0  1  0 1  0   0 0  0   0 1   -  -  -   -  - P   P - 0   0  0  - - - - - - - - - - l2kill
 1  0  1  0 1  0   0 0  0   0 1   -  -  -   -  - P   P - 0   1  0  - - - - - - - - - - l2gunlock
 1  0  1  0 1  0   0 0  0   0 1   -  -  -   -  - P   P - 1   0  0  - - - - - - - - - - l2gclean
 1  0  1  0 1  0   0 0  0   0 1   -  -  -   -  - P   P - 1   1  0  - - - - - - - - - - l2gcleaninv
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  t5                Field to encode register t
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                           346
Hexagon V67 Programmer’s Reference Manual                                                                Instruction Set
          L2 cache operations by address
                  L2LOCKA first allocates a line in L2 based on the address provided in Rs. It then sets the
                  lock bit so the line is not replaced in the future, unless explicitly unlocked. A fetch is
                  initiated for the data. Finally, the instruction returns a status result to the destination
                  predicate.
                  The predicate is set to 0xff if the operation was successful, or 0x00 if the operation did not
                  succeed. The failure state can be returned either because all the L2 cache ways are already
                  locked, or because of so me internal transient conditions. The software should resolve
                  transient conditions by re-trying L2LOCKA with a large number of attempts (1000
                  recommended).
                  The L2UNLOCKA instruction clears the lock bit on an L2 cache line which holds the
                  provided address.
                   Syntax                                     Behavior
                   Pd=l2locka(Rs)                             EA=Rs;
                                                              Pd=l2locka(EA);
                   l2unlocka(Rs)                              EA=Rs;
                                                              l2unlocka(EA);
                  Class: SYSTEM (slots 0)
                  Notes
                        ■    Group this instruction only with ALU32 or non-floating-point XTYPE
                             instructions.
                        ■    The predicate generated by this instruction cannot be used as a .new predicate, nor
                             can it be automatically AND’d with another predicate.
                        ■    This is a monitor-level feature. If performed in User or Guest mode, a privilege
                             error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6 5 4  3  2  1   0
                                U
   ICLASS    Amode      Type             s5        Parse                                   d2
                                N
 1  0  1  0 0  0   0  0  1   1  1   s  s  s  s  s  P   P 1  -   - -  - - -  - -  - -  -  d   d Pd=l2locka(Rs)
                                U
   ICLASS    Amode      Type             s5        Parse
                                N
 1  0  1  0 0  1   1  0  0   1  1   s  s  s  s  s  P   P -  -   - -  - - -  - -  - -  -  -    - l2unlocka(Rs)
                  Field name          Description
                  ICLASS              Instruction Class
                  Parse               Packet/Loop parse bits
                  d2                  Field to encode register d
                  s5                  Field to encode register s
80-N2040-45 Rev. B                                                                                                   347
Hexagon V67 Programmer’s Reference Manual  Instruction Set
                  Field name   Description
                  Amode        Amode
                  Type         Type
                  UN           Unsigned
80-N2040-45 Rev. B                                     348
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        L2 tag read/write
                  L2TAGR reads the tag as indicated by Rs and returns the data into Rd. Group this
                  instruction with A-type and X-type instructions. Do not group the L2TAGW instruction in
                  a packet.
                  Register Rs is formatted as follows:
                  Rs[31:8] = Set
                  Rs[7:0] = Way
                  Return register Rd is formatted as follows:
                  Rd[31] = A1
                  Rd[30] = A0
                  Rd[28:8] = Tag address bits 35:15
                  Rd[4] = Lock bit
                  Rd[3] = Reserve bit
                  Rd[2:0] = State[2:0]
                  The state bits are defined as follows:
                  0 = Invalid
                  1,3 = Reserved
                  4 = Valid & Clean
                  6 = Valid & Dirty
                   Syntax                                 Behavior
                   Rd=l2tagr(Rs)                          l2cache_tag_read(Rs);
                   l2tagw(Rs,Rt)                          l2cache_tag_write(Rs,Rt);
                  Class: SYSTEM (slots 0)
                  Notes
                       ■   Group this instruction only with ALU32 or non-floating-point XTYPE
                           instructions.
                       ■   Results are undefined if a tag read or write addresses a non-present set or way.
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
80-N2040-45 Rev. B                                                                                             349
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2  1 0
                              U
   ICLASS    Amode     Type            s5        Parse          t5
                              N
 1  0  1  0 0  1   0 0  0   1 0   s  s  s  s  s  P   P 0  t   t  t t t - - - - -  - - - l2tagw(Rs,Rt)
                              U
   ICLASS    Amode     Type            s5        Parse                           d5
                              N
 1  0  1  0 0  1   0 0  0   1 1   s  s  s  s  s  P   P -  -   -  - - - - - - d d d  d d Rd=l2tagr(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                           350
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Load from physical address
                  MEMW_PHYS performs a word load using the 36-bit physical address held in source
                  registers Rt:Rs. Rs holds PA[10:0] and Rt holds PA[35:11] in the least-significant bits.
                  This instruction first looks in the L1 and L2 caches for the data. If found, the data is
                  returned. If the access misses in cache, it is treated as a non-allocating (uncached) load.
                  The hardware forces the two least-significant bits to zero, to never result in an alignment
                  violation.
                  The monitor software uses this instruction to walk Guest mode page tables, and for easier
                  debugging.
                   Syntax                                   Behavior
                   Rd=memw_phys(Rs,Rt)                      Rd = *((Rs&0x7ff) | (Rt<<11));
                  Class: SYSTEM (slots 0)
                  Notes
                       ■    This is a solo instruction. It must not be grouped with other instructions in a
                            packet.
                       ■    This is a monitor-level feature. If performed in User or Guest mode, a privilege
                            error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3   2 1  0
                               U
   ICLASS    Amode     Type             s5       Parse          t5                  d5
                               N
 1  0  0  1 0  0   1 0  0   0  0  s  s  s  s  s  P   P 1  t   t  t t t  - 0 0  d d   d d  d Rd=memw_phys(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              351
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Raise NMI on threads
                  The low bits of Rs specify a thread mask, where bit 0 corresponds to thread 0. The number
                  of defined bits depends on the how many hardware threads are supported.
                  NMI raises a non-maskable NMI interrupt for all threads specified in the mask. This
                  interrupt causes the thread jump to the NMI vector at the address specified in EVB.
                   Syntax                                   Behavior
                   nmi(Rs)                                  Raise NMI on threads;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1 0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  1   0 0  0  1  1   s  s  s  s  s  P   P -  -   - -  - - 0 1  0  -  - - -  - nmi(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                             352
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Resume from Wait mode
                  The low bits of Rs specify a thread mask, where bit 0 corresponds to thread 0. The number
                  of defined bits depends on the how many hardware threads are supported.
                  RESUME causes all threads specified in the mask which are in Wait mode to exit Wait
                  mode back to either Supervisor or User mode (whichever was active when the thread
                  entered Wait mode). If the thread to be resumed is off (Stop mode) or already running
                  (User or Supervisor mode), the resume instruction has no affect.
                   Syntax                                   Behavior
                   resume(Rs)                               resume(Rs);
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6 5 4 3  2  1 0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  1   0 0  0  1  0   s  s  s  s  s  P   P -  -   - -  - - 0  0 1 - -  -  -  - resume(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                             353
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
          Return from exception
                  RTE returns from an interrupt or exception handler. This instruction clears the EX bit in
                  SSR and jumps to the location specified in the ELR register.
                  This instruction also clears the SYSCFG.TLBLOCK bit, thus releasing the TLB lock and
                  allowing other threads to acquire the lock if needed. Never group RTE with another
                  exception-causing instruction. If RTE is grouped with any other instruction that causes an
                  exception, the behavior is undefined.
                   Syntax                                  Behavior
                   rte                                     SSR.SSR_EX = 0;
                                                           PC=ELR;
                  Class: SYSTEM (slot 2)
                  Notes
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5 4 3  2  1 0
   ICLASS                                        Parse
 0  1  0  1 0  1   1 1  1  1  1   -  -  -  -   - P   P 0 0   -  - - - 0 0  0 - -  -  - -  rte
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                          354
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Set the interrupt mask for a thread
                  Each thread contains an IMASK register that holds the interrupt enable/disable for
                  individual interrupts 0-31.
                  SETIMASK writes the IMASK for the thread indicated by the low bits of predicate Pt.
                  Register Rs contains the 32-bit mask value to be written. For Pt values outside of [0-
                  NUM_THREADS-1], the results are undefined.
                   Syntax                                   Behavior
                   setimask(Pt,Rs)                          PREDUSE_TIMING;
                                                            IMASK[Pt & thread->processor_ptr-
                                                            >thread_system_mask]=Rs;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This instruction may only be grouped with ALU32 or non-floating-point XTYPE
                           instructions.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8 7 6 5 4 3 2 1 0
   ICLASS      sm                      s5        Parse               t2
 0  1  1  0 0  1   0 0  1  0  0   s  s  s  s  s  P   P -  -   - -  t    t 0 0 0 - - - -  - setimask(Pt,Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t2                Field to encode register t
80-N2040-45 Rev. B                                                                                              355
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Set the priority for a thread
                  Each thread contains an STID register that holds the software thread id (STID) and the
                  priority (PRIO). This instruction writes the PRIO field for the thread indicated by the low
                  bits of predicate Pt. The register Rs contains the 32-bit mask value to be written. For Pt
                  values outside of [0-NUM_THREADS-1], the results are undefined.
                   Syntax                                   Behavior
                   setprio(Pt,Rs)                           PREDUSE_TIMING;
                                                            TID[Pt & thread->processor_ptr-
                                                            >thread_system_mask].PRIO=Rs;
                  Class: SYSTEM (slot 3)
                  Notes
                        ■  This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8 7 6 5 4 3 2 1 0
   ICLASS      sm                      s5        Parse               t2
 0  1  1  0 0  1   0 0   1 0  0   s  s  s  s  s  P   P -  -   - -  t    t 0 0 1 - - - -  - setprio(Pt,Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t2                Field to encode register t
80-N2040-45 Rev. B                                                                                               356
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Set interrupt auto disable
                  Register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
                  interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31.
                  For bits set in Rs, the corresponding bit in IAD is set. This disables the interrupt. For bits
                  cleared in Rs, the corresponding bit in IAD is unaffected.
                   Syntax                                   Behavior
                   siad(Rs)                                 IAD |= Rs;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This instruction may only be grouped with ALU32 or non-floating-point XTYPE
                           instructions.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6  5  4  3  2  1  0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  1   0 0  1  0  0   s  s  s  s  s  P   P -  -   - -  - - 0 1  1  -  -  -  -  - siad(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                                357
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Start threads
                  The low bits of Rs specify a thread mask, where bit 0 corresponds to thread 0. The number
                  of defined bits depends on the how many hardware threads are supported.
                  START raises a non-maskable software reset interrupt for all threads specified in the
                  mask. This interrupt causes the thread to clear all writable bits in the Supervisor Status
                  register and then jump to the start vector at the address specified in EVB. Typically,
                  START powers up threads after they have are disabled by the STOP instruction.
                   Syntax                                   Behavior
                   start(Rs)                                start(Rs);
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4  3  2  1  0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  1   0 0  0  1  1   s  s  s  s  s  P   P -  -   - -  - - 0 0 1  - -   -  -  - start(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                                358
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Stop threads
                  STOP causes the calling thread to enter Stop mode.
                  Stop mode is a power-off mode where all register contents for that thread should be
                  assumed lost. The only way out of Stop mode is through a reset interrupt. The reset
                  interrupt can be from another thread executing the START instruction, or from an external
                  hardware reset signal.
                  The source register Rs is not used in the instruction. It exists for backwards compatibility.
                   Syntax                                   Behavior
                   stop(Rs)                                 if (!in_debug_mode) modectl[TNUM] = 0;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2  1  0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  1   0 0  0  1  1   s  s  s  s  s  P   P -  -   - -  - - 0 0  0  -  -  -  - - stop(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                               359
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Software interrupt
                  Register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
                  interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31.
                  SWI causes the interrupts indicated in the mask to raise. This instruction is provided so
                  that threads can very quickly interrupt one another.
                   Syntax                                   Behavior
                   swi(Rs)                                  IPEND |= Rs;
                  Class: SYSTEM (slot 3)
                  Notes
                        ■  This instruction may only be grouped with ALU32 or non-floating-point XTYPE
                           instructions.
                        ■  This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6  5  4  3  2  1  0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  1   0 0   0 0  0   s  s  s  s  s  P   P -  -   - -  - - 0 0  0  -  -  -  -  - swi(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                               360
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
        TLB read/write/probe operations
                  Manage the software programmable Translation Lookaside Buffer.
                  The TLB Read (TLBR) instruction returns the 64-bit TLB entry at the location specified in
                  register Rs. The result is written into the 64-bit destination register pair.
                  The TLB Write (TLBW) operation writes the 64-bit TLB entry specified by register Rt
                  with the contents of register pair Rss.
                  The TLB Probe (TLBP) operation looks up the TLB based on the virtual page number
                  contained in register Rs[19:0] together with the 7-bit ASID provided in Rs[26:20]. If the
                  entry is found and marked valid, its ind ex is placed in Rd, otherwise Rd is set to
                  0x8000_0000.
                  The TLB Invalidate ASID (TLBINVASID) instruction invalidates all TLB entries with the
                  Global bit NOT set and with the ASID matching the Rs[26:20] operand.
                  The Conditional TLB Write (CTLBW) instruction first checks if the new entry would
                  overlap the virtual address range of any other entry in the TLB. The overlap check
                  considers page size and ASID. In the overlap check, the Global bit of the incoming Rss
                  entry is forced to zero and the Valid bit is forced to 1. If there is no overlap, the entry is
                  written and the destination register is set to 0x8000_0000. Otherwise, if an overlap occurs,
                  no TLB entry is written and the index on the overlapping entry is placed in Rd. If multiple
                  entries overlap, the value 0xffff_ffff is returned.
                  The TLB Overlap Check (TLBOC) operation looks up the TLB based on the VPN, page
                  size, and ASID contained in register Rss (in the same format as TLBW). The overlap
                  check considers page size and ASID. In the overlap check, the Global bit of the incoming
                  Rss entry is forced to zero and the Valid bit is forced to 1. If the Rss entry overlaps virtual
                  address range of any another entry in the TLB, the index of the overlapping entry is placed
                  in Rd, otherwise Rd is set to 0x8000_0000. If multiple entries overlap, the value
                  0xffff_ffff is returned.
                  For both TLBOC and CTLBW, when the PPN[5:0] are all zero, the behavior is undefined.
                   Syntax                                Behavior
                   Rd=ctlbw(Rss,Rt)                      if (CHECK_TLB_OVERLAP((1LL<<63) | Rss)) {
                                                               Rd=GET_OVERLAPPING_IDX((1LL<<63) | Rss);
                                                         } else {
                                                               TLB[Rt] = Rss;
                                                               Rd=0x80000000;
                                                         }
                   Rd=tlboc(Rss)                         if (CHECK_TLB_OVERLAP((1LL<<63) | Rss)) {
                                                               Rd=GET_OVERLAPPING_IDX((1LL<<63) | Rss);
                                                         } else {
                                                               Rd=0x80000000;
                                                         }
                   Rd=tlbp(Rs)                           Rd=search_TLB(Rs);
                   Rdd=tlbr(Rs)                          Rdd = TLB[Rs];
80-N2040-45 Rev. B                                                                                               361
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                   Syntax                                   Behavior
                   tlbinvasid(Rs)                           for (i = 0; i < NUM_TLB_ENTRIES; i++) {
                                                                 if ((TLB[i].PTE_G == 0) && (TLB[i].PTE_ASID
                                                            == Rs[26:20])) {
                                                                     TLB[i] = TLB[i] & ~(1ULL << 63);
                                                                 }
                                                            }
                   tlbw(Rss,Rt)                             TLB[Rt] = Rss;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS      sm                      s5        Parse          t5
 0  1  1  0 1  1   0 0  0  0  0   s  s  s  s  s  P   P 0  t   t  t t  t -  - -  - -  - -  - tlbw(Rss,Rt)
   ICLASS      sm                      s5        Parse                              d5
 0  1  1  0 1  1   0 0  0  1  0   s  s  s  s  s  P   P -  -   -  - -  - -  - - d  d d  d d Rdd=tlbr(Rs)
 0  1  1  0 1  1   0 0  1  0  0   s  s  s  s  s  P   P -  -   -  - -  - -  - - d  d d  d d Rd=tlbp(Rs)
   ICLASS      sm                      s5        Parse
 0  1  1  0 1  1   0 0  1  0  1   s  s  s  s  s  P   P -  -   -  - -  - -  - -  - -  - -  - tlbinvasid(Rs)
   ICLASS      sm                      s5        Parse          t5                  d5
 0  1  1  0 1  1   0 0  1  1  0   s  s  s  s  s  P   P 0  t   t  t t  t -  - - d  d d  d d Rd=ctlbw(Rss,Rt)
   ICLASS      sm                      s5        Parse                              d5
 0  1  1  0 1  1   0 0  1  1  1   s  s  s  s  s  P   P -  -   -  - -  - -  - - d  d d  d d Rd=tlboc(Rss)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                362
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
        System control register transfer
                  Move data between supervisor control registers and general registers.
                  Registers can be moved as 32-bit singles or as 64-bit aligned pairs. The figure shows the
                  system control registers and their register field encodings.
                     0       SGP0           16        EVB              32       ISDBST      48    PMUCNT0
                     1       SGP1           17     MODECTL             33     ISDBCFG0      49    PMUCNT1
                     2       STID           18      SYSCFG             34     ISDBCFG1      50    PMUCNT2
                     3        ELR           19           -             35          -        51    PMUCNT3
                     4     BADVA0           20       IPEND             36     BRKPTPC0      52   PMUEVTCFG
                     5     BADVA1           21         VID             37    BRKPTCFG0      53    PMUCFG
                     6       SSR            22         IAD             38     BRKPTPC1      54
                     7       CCR            23           -             39    BRKPTCFG1
                                                                                                   Reserved
                     8       HTID           24         IEL             40    ISDBMBXIN
                     9      BADVA           25           -             41   ISDBMBXOUT
                    10      IMASK           26        IAHL                      ISDBEN
                                                                       42
                    11                      27     CFGBASE             43      ISDBGPR
                                            28        DIAG
                           Reserved         29        REV                      Reserved
                                            30     PCYCLELO
                                             31    PCYCLEHI
                     15                                                 47                  63
                   Syntax                                  Behavior
                   Rd=Ss                                   Rd=Ss;
                   Rdd=Sss                                 Rdd=Sss;
                   Sd=Rs                                   Sd=Rs;
                   Sdd=Rss                                 Sdd=Rss;
                  Class: SYSTEM (slot 3)
                  Notes
                        ■ This is a monitor-level feature. If performed in User or Guest mode, a privilege
                          error exception occurs.
80-N2040-45 Rev. B                                                                                          363
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3  2  1 0
   ICLASS      sm                      s5        Parse                        d7
 0  1  1  0 0  1   1 1  0  0   -  s  s  s  s  s  P   P -  -  -  - - - - d d d d  d  d d Sd=Rs
 0  1  1  0 1  1   0 1  0  0   -  s  s  s  s  s  P   P -  -  -  - - - - d d d d  d  d d Sdd=Rss
   ICLASS      sm                   s7           Parse                           d5
 0  1  1  0 1  1   1 0  1   s  s  s  s  s  s  s  P   P -  -  -  - - - - - - d d  d  d d Rd=Ss
 0  1  1  0 1  1   1 1  0   s  s  s  s  s  s  s  P   P -  -  -  - - - - - - d d  d  d d Rdd=Sss
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  d7                Field to encode register d
                  s5                Field to encode register s
                  s7                Field to encode register s
80-N2040-45 Rev. B                                                                                          364
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Transition threads to Wait mode
                  WAIT causes the calling thread to enter Wait mode.
                  Wait mode is a low-power mode where the thread idles. The thread does not fetch or
                  execute instructions in Wait mode.
                  When a thread executes WAIT, the PC is set to the packet after the WAIT instruction.
                  To exit Wait mode, a waiting thread can either receive an interrupt, or another thread can
                  execute the RESUME instruction for the waiting thread. In the case that a thread is woken
                  up by an interrupt, at the time the interrupt service routine completes and executes a RTE
                  instruction, the thread remains running.
                  The source register Rs is not used in the instruction. It exists for backwards compatibility.
                   Syntax                                   Behavior
                   wait(Rs)                                 if (!in_debug_mode) modectl[(TNUM+16)] = 1;
                                                            ;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                       ■   This is a monitor-level feature. If performed in User or Guest mode, a privilege
                           error exception occurs.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2  1  0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  1   0 0  0  1  0   s  s  s  s  s  P   P -  -   - -  - - 0 0  0  -  -  -  - - wait(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                               365
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
     11.9.3       SYSTEM/USER
                  The SYSTEM/USER instruction subclass includes instructions which allow user access to
                  system resources.
          Load locked
                  This memory lock instruction performs a word or double-word locked load.
                  This instruction returns the contents of the memory at address Rs and also reserves a lock
                  reservation at that address. For more information, see the section on Atomic Operations.
                   Syntax                                   Behavior
                   Rd=memw_locked(Rs)                       EA=Rs;
                                                            Rd = *EA;
                   Rdd=memd_locked(Rs)                      EA=Rs;
                                                            Rdd = *EA;
                  Class: SYSTEM (slots 0)
                  Notes
                       ■    This instruction may only be grouped with ALU32 or non-floating-point XTYPE
                            instructions.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3  2 1  0
                               U
   ICLASS    Amode     Type             s5        Parse                          d5
                               N
 1  0  0  1 0  0   1 0  0   0  0  s   s  s  s  s  P   P 0 0   - -  - - - 0 0 d d  d d  d Rd=memw_locked(Rs)
 1  0  0  1 0  0   1 0  0   0  0  s   s  s  s  s  P   P 0 1   - -  - - - 0 0 d d  d d  d Rdd=memd_locked(Rs)
                  Field name         Description
                  ICLASS             Instruction Class
                  Amode              Amode
                  Type               Type
                  UN                 Unsigned
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  s5                 Field to encode register s
80-N2040-45 Rev. B                                                                                           366
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Store conditional
                  This memory lock instruction performs a word or double-word conditional store
                  operation.
                  If the address reservation is held by this thread and there are no intervening accesses to the
                  memory location, the store is performed and the predicate is set to true. Otherwise, the
                  store is not performed and the predicate returns false. For more information, see the
                  section on Atomic Operations.
                   Syntax                                     Behavior
                   memd_locked(Rs,Pd)=Rtt                     EA=Rs;
                                                              if (lock_valid) {
                                                                   *EA = Rtt;
                                                                   Pd = 0xff;
                                                                   lock_valid = 0;
                                                              } else {
                                                                   Pd = 0;
                                                              }
                   memw_locked(Rs,Pd)=Rt                      EA=Rs;
                                                              if (lock_valid) {
                                                                   *EA = Rt;
                                                                   Pd = 0xff;
                                                                   lock_valid = 0;
                                                              } else {
                                                                   Pd = 0;
                                                              }
                  Class: SYSTEM (slots 0)
                  Notes
                        ■    This instruction may only be grouped with ALU32 or non-floating-point XTYPE
                             instructions.
                        ■    The predicate generated by this instruction cannot be used as a .new predicate, nor
                             can it be automatically AND’d with another predicate.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8  7 6 5  4 3 2 1   0
                                U
   ICLASS    Amode      Type    N        s5        Parse          t5                      d2
 1  0  1  0 0  0   0  0  1   0  1   s  s  s  s  s  P   P -  t   t  t t  t  - - -  - - - d   d memw_locked(Rs,Pd)=Rt
 1  0  1  0 0  0   0  0  1   1  1   s  s  s  s  s  P   P 0  t   t  t t  t  - - -  - - - d   d memd_locked(Rs,Pd)=Rtt
                  Field name          Description
                  ICLASS              Instruction Class
                  Parse               Packet/Loop parse bits
                  d2                  Field to encode register d
                  s5                  Field to encode register s
80-N2040-45 Rev. B                                                                                                367
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  t5           Field to encode register t
                  Amode        Amode
                  Type         Type
                  UN           Unsigned
80-N2040-45 Rev. B                                                    368
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Zero a cache line
                  DCZEROA clears 32 bytes of memory.
                  If the memory is marked write-back cacheable, a cache line is allocated in the data cache
                  and 32 bytes are cleared.
                  If the memory is write-through or write-back, 32 bytes of zeros are sent to memory.
                  This instruction is useful for efficiently handling write-only data by pre-allocating lines in
                  the cache.
                  The address must be 32-byte aligned. If not, an unaligned error exception is raised.
                  If this instruction appears in a packet, slot 1 must be A-type or empty.
                   Syntax                                   Behavior
                   dczeroa(Rs)                              EA=Rs;
                                                            dcache_zero_addr(EA);
                  Class: SYSTEM (slots 0)
                  Notes
                        ■    A packet containing this instruction must have slot 1 either empty or executing an
                             ALU32 instruction.
                  Intrinsics
                   dczeroa(Rs)                              void Q6_dczeroa_A(Address a)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2  1  0
                                U
   ICLASS    Amode      Type    N      s5        Parse
 1  0  1  0 0  0   0  0  1   1 0  s  s  s  s  s  P   P 0  -   - -  - -  - -  - -  - -  -  - dczeroa(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                               369
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Memory barrier
                  BARRIER establishes a memory barrier to ensure proper ordering between accesses
                  before the barrier instruction and accesses after the barrier instruction.
                  All accesses before the barrier are globally observable before any access after the barrier
                  can be observed.
                  The use of this instruction is system-dependent.
                   Syntax                                   Behavior
                   barrier                                  memory_barrier;
                  Class: SYSTEM (slots 0)
                  Notes
                       ■    This is a solo instruction. It must not be grouped with other instructions in a
                            packet.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5 4  3  2  1  0
                               U
   ICLASS    Amode     Type                      Parse
                               N
 1  0  1  0 1  0   0 0  0   0  0  -  -  -  -   - P   P -  -   - -  - - 0  0 0  - -  -  -  -  barrier
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                               370
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Breakpoint
                  BRKPT causes the program to enter Debug mode if enabled by ISDB.
                  Execution control is handed to ISDB and the program does not proceed until directed by
                  the debugger.
                  If ISDB is disabled, this instruction is treated as a NOP.
                   Syntax                                   Behavior
                   brkpt                                    Enter Debug mode;
                  Class: SYSTEM (slot 3)
                  Notes
                        ■  This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5 4 3  2  1 0
   ICLASS      sm                                Parse
 0  1  1  0 1  1   0  0  0 0  1   -  -  -  -   - P   P -  -   - -  - - 0 0  0 - -  -  -  - brkpt
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                             371
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Data cache prefetch
                  DCFETCH prefetches the data at address Rs + unsigned immediate.
                  This instruction is a hint to the memory system, and is handled in an implementation-
                  dependent manner.
                   Syntax                                   Behavior
                   dcfetch(Rs)                              Assembler mapped to: "dcfetch(Rs+#0)"
                   dcfetch(Rs+#u11:3)                       EA=Rs+#u;
                                                            dcache_fetch(EA);
                  Class: SYSTEM (slots 0)
                  Intrinsics
                   dcfetch(Rs)                              void Q6_dcfetch_A(Address a)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
                              U
   ICLASS    Amode     Type            s5        Parse
                              N
 1  0  0  1 0  1   0 0  0   0 0   s  s  s  s  s  P   P 0  -   - i  i i  i i  i i i  i i  i dcfetch(Rs+#u11:3)
                  Field name        Description
                  ICLASS            Instruction Class
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                              372
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Data cache maintenance user operations
                  Perform maintenance operations on the data cache.
                  DCCLEANINVA looks up the data cache at address Rs. If this address is in the cache and
                  has dirty data, the data is flushed out to memory and the line is then invalidated.
                  DCCLEANA looks up the data cache at address Rs. If this address is in the cache and has
                  dirty data, the data is flushed out to memory.
                  DCINVA looks up the data cache at address Rs. If this address is in the cache, the line
                  containing the data is invalidated.
                  If an instruction appears in a packet, slot 1 must be A-type or empty.
                  In implementations that support L2 cache, these instructions operate on both L1 data and
                  L2 caches.
                   Syntax                                   Behavior
                   dccleana(Rs)                             EA=Rs;
                                                            dcache_clean_addr(EA);
                   dccleaninva(Rs)                          EA=Rs;
                                                            dcache_cleaninv_addr(EA);
                   dcinva(Rs)                               EA=Rs;
                                                            dcache_cleaninv_addr(EA);
                  Class: SYSTEM (slots 0)
                  Notes
                        ■    A packet containing this instruction must have slot 1 either empty or executing an
                             ALU32 instruction.
                  Intrinsics
                   dccleana(Rs)                             void Q6_dccleana_A(Address a)
                   dccleaninva(Rs)                          void Q6_dccleaninva_A(Address a)
                   dcinva(Rs)                               void Q6_dcinva_A(Address a)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2  1  0
                                U
   ICLASS    Amode      Type           s5       Parse
                                N
 1  0  1  0 0  0   0  0  0   0 0  s  s  s  s  s P   P  -  -   - -  - -  - -  - - -  -  -  - dccleana(Rs)
 1  0  1  0 0  0   0  0  0   0 1  s  s  s  s  s P   P  -  -   - -  - -  - -  - - -  -  -  - dcinva(Rs)
 1  0  1  0 0  0   0  0  0   1 0  s  s  s  s  s P   P  -  -   - -  - -  - -  - - -  -  -  - dccleaninva(Rs)
80-N2040-45 Rev. B                                                                                               373
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  s5           Field to encode register s
                  Amode        Amode
                  Type         Type
                  UN           Unsigned
80-N2040-45 Rev. B                                                    374
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
          Send value to DIAG trace
                  These instructions send the sources to the external DIAG trace.
                   Syntax                                   Behavior
                   diag(Rs)
                   diag0(Rss,Rtt)
                   diag1(Rss,Rtt)
                  Class: SYSTEM (slot 3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7 6 5 4 3 2 1 0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  0   1 0  0  1  0   s  s  s  s  s  P   P -  -   -  - - - 0 0 1 - - - - - diag(Rs)
   ICLASS      sm                      s5        Parse          t5
 0  1  1  0 0  0   1 0  0  1  0   s  s  s  s  s  P   P -  t   t  t t t 0 1 0 - - - - - diag0(Rss,Rtt)
 0  1  1  0 0  0   1 0  0  1  0   s  s  s  s  s  P   P -  t   t  t t t 0 1 1 - - - - - diag1(Rss,Rtt)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                          375
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Instruction cache maintenance user operations
                  ICINVA looks up the address in Rs in the instruction cache.
                  If the address is found, the instruction invalidates the corresponding cache line. If the user
                  does not have proper permissions to the page which is to be invalidated, the instruction is
                  converted to a NOP.
                   Syntax                                  Behavior
                   icinva(Rs)                              EA=Rs;
                                                           icache_inv_addr(EA);
                  Class: SYSTEM (slot 2)
                  Notes
                        ■  This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6  5  4 3 2  1 0
   ICLASS                              s5        Parse
 0  1  0   1 0 1   1  0  1 1  0   s  s  s  s  s  P   P 0 0   0  - - -  - -  -  - - -  -  - icinva(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                               376
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Instruction synchronization
                  ISYNC ensures that all previous instructions have committed before continuing to the next
                  instruction.
                  This instruction should be executed after the following events (when subsequent
                  instructions must observe the results of the event):
                       ■   After modifying the TLB with a TLBW instruction
                       ■   After modifying the SSR register
                       ■   After modifying the SYSCFG register
                       ■   After any instruction cache maintenance operation
                       ■   After modifying the TID register
                   Syntax                                   Behavior
                   isync                                    instruction_sync;
                  Class: SYSTEM (slot 2)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5 4 3  2  1 0
   ICLASS                                        Parse
 0  1  0   1 0 1   1 1  1  1  0  0   0  0  0  0  P   P 0  -   - - 0  0 0 0  0 0 0  0 1  0  isync
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                             377
Hexagon V67 Programmer’s Reference Manual                                                                    Instruction Set
        L2 cache prefetch
                  L2FETCH initiates background prefetching into the L2 cache.
                  Rs specifies the 32-bit virtual start address. There are two forms of this instruction.
                  In the first form, the dimensions of the area to prefetch are encoded in source register Rt as
                  follows:
                            Rt[15:8] = Width of a fetch block in bytes.
                            Rt[7:0] = Height: the number of width-sized blocks to fetch.
                            Rt[31:16] = Stride: an unsigned byte offset which increments the pointer after
                            each width-sized block is fetched.
                  In the second form, the operands are encoded in register pair Rtt as follows:
                            Rtt[31:16] = Width of a fetch block in bytes.
                            Rtt[15:0] = Height: the number of Width-sized blocks to fetch.
                            Rtt[47:32] = Stride: an unsigned byte offset which increments the pointer after
                            each Width-sized block is fetched.
                            Rtt[48] = Direction. If clear, the prefetches should be performed in row major
                            form, meaning all cache lines in a row should be fetched before proceeding to the
                            next row. If the bit is set, prefetch should be done in column major form, meaning
                            all cache lines in a column are fetched before proceeding to the next column.
                  The following figure shows two examples of using the L2FETCH instruction.
                             L2FETCH for box prefetch                             L2FETCH for large linear prefetch
                        31                                                        31             16 15     8 7       0
                                       16 15      8 7       0
                    Rt        Stride       Width     Height                 Rt            128          128     Lines
                    Rs             Start Address                            Rs               Start Address
                                             Stride
                                         Width
                                       Prefetch
                         Height                                                128* Lines
                                         Area
                  In the box prefetch, a 2-D range of memory is defined within a larger frame. The second
                  example shows prefetch for a large linear area of memory which has size Lines * 128.
80-N2040-45 Rev. B                                                                                                       378
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
                  L2FETCH is non-blocking. After the instruction is initiated, the program continues on to
                  the next instruction while the prefetching is performed in the background. L2fetch can
                  bring in either code or data to the L2 cache. If the lines of interest are already in the L2, no
                  action is performed. If the lines are missing from the L2$, the hardware attempts to fetch
                  them from the system memory.
                  The hardware prefetch engine continues to request all lines in the programmed memory
                  range. The prefetching hardware makes a best-effort to prefetch the requested data, and
                  attempts to perform prefetching at a lower priority than demand fetches. This prevents
                  prefetch from adding traffic while the system is under heavy load.
                  If a program initiates a new L2FETCH while an older L2FETCH operation is still
                  pending, the new request is queued, up to 3 deep. If 3 L2FETCHes are already pending,
                  the oldest request is dropped. During the time a L2 prefetch is active for a thread, the
                  USR:PFA status bit is set to indicate that prefetches are in-progress. The programmer can
                  use this bit to decide whether to start a new L2FETCH before the previous one completes.
                  Executing an L2fetch with any subfield programmed as zero cancels all pending
                  prefetches by the calling thread.
                  The implementation is free to drop prefetches when needed.
                   Syntax                                   Behavior
                   l2fetch(Rs,Rt)                           l2fetch(Rs,INFO);
                   l2fetch(Rs,Rtt)                          l2fetch(Rs,INFO);
                  Class: SYSTEM (slots 0)
                  Notes
                        ■    This instruction may only be grouped with ALU32 or non-floating-point XTYPE
                             instructions.
                  Intrinsics
                   l2fetch(Rs,Rt)                           void Q6_l2fetch_AR(Address a, Word32 Rt)
                   l2fetch(Rs,Rtt)                          void Q6_l2fetch_AP(Address a, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4  3  2  1  0
                                U
   ICLASS    Amode      Type    N       s5      Parse           t5
 1  0  1  0 0  1   1  0  0   0  0  s  s  s s  s P   P  -  t   t  t t t 0  0 0  -   - -   - -  l2fetch(Rs,Rt)
 1  0  1  0 0  1   1  0  1   0  0  s  s  s s  s P   P  -  t   t  t t t  - -  - -   - -   - -  l2fetch(Rs,Rtt)
80-N2040-45 Rev. B                                                                                                  379
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  s5           Field to encode register s
                  t5           Field to encode register t
                  Amode        Amode
                  Type         Type
                  UN           Unsigned
80-N2040-45 Rev. B                                                    380
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Pause
                  The PAUSE instruction pauses execution for a specified period of time.
                  During the pause duration, the program enters a low-power state and doesl not fetch and
                  execute instructions. The instruction provides a short immediate which indicates the pause
                  duration. The program pauses for at most the number of cycles specified in the immediate
                  plus 8. The minimum pause is 0 cycles, and the maximum pause is implementation
                  defined.
                  An interrupt to the program exits the paused state.
                  System events, such as hardware or DMA completion, can trigger exits from Pause mode.
                  An implementation is free to pause for durations shorter than (immediate+8), but not
                  longer.
                  This instruction is useful for implementing user-level low-power synchronization
                  operations, such as spin locks or wait-for-event signaling.
                   Syntax                                   Behavior
                   pause(#u8)                               Pause for #u cycles;
                  Class: SYSTEM (slot 2)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS                                        Parse
 0  1  0  1 0  1   0 0  0  1   -  -  -  -  -   - P   P -  i   i i  i i -  - -  i i i  -  - pause(#u8)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                             381
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Memory thread synchronization
                  The SYNCHT instruction synchronizes memory.
                  All outstanding memory operations, including cached and uncached loads and stores, are
                  completed before the processor continues to the next instruction. This ensures that certain
                  memory operations are performed in the desired order (for example, when accessing I/O
                  devices).
                  After performing a SYNCHT operation, the processor ceases fetching and executing
                  instructions from the program until all outstanding memory operations of that program are
                  completed.
                  In multi-threaded or multi-core environments, SYNCHT is not concerned with other
                  execution contexts.
                  The use of this instruction is system-dependent.
                   Syntax                                   Behavior
                   syncht                                   memory_synch;
                  Class: SYSTEM (slots 0)
                  Notes
                       ■    This is a solo instruction. It must not be grouped with other instructions in a
                            packet.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5 4  3  2  1 0
                               U
   ICLASS    Amode     Type                      Parse
                               N
 1  0  1  0 1  0   0 0  0   1  0  -  -  -  -   - P   P -  -   - -  - -  - - -  - -  -  -  - syncht
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  Amode             Amode
                  Type              Type
                  UN                Unsigned
80-N2040-45 Rev. B                                                                                              382
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Send value to ETM trace
                  TRACE takes the value of register Rs and emits it to the ETM trace.
                  The ETM block must be enabled, and the thread must have permissions to perform
                  tracing. The contents of Rs are user-defined.
                   Syntax                                   Behavior
                   trace(Rs)                                Send value to ETM trace;
                  Class: SYSTEM (slot 3)
                  Notes
                       ■   This instruction may only be grouped with ALU32 or non-floating-point XTYPE
                           instructions.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS      sm                      s5        Parse
 0  1  1  0 0  0   1 0  0  1  0   s  s  s  s  s  P   P -  -   - -  - - 0 0  0  - -  - - - trace(Rs)
                  Field name        Description
                  sm                Supervisor mode only
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                              383
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Trap
                  TRAP causes a precise exception.
                  Executing a TRAP instruction sets the EX bit in SSR to 1, which disables interrupts and
                  enables Supervisor mode. The program then jumps to the vector location (either TRAP0
                  or TRAP1). The instruction specifies a n 8-bit immediate field. This field is copied into the
                  system status register cause field.
                  Upon returning from the service routine with a RTE, execution resumes at the packet after
                  the TRAP instruction.
                  These instructions are generally intended for user code to request services from the
                  operating system. Two TRAP instructions are provided so the OS can optimize for fast
                  service routines and slower service routines.
                   Syntax                                   Behavior
                   trap0(#u8)                               SSR.CAUSE = #u;
                                                            TRAP "0";
                   trap1(#u8)                               Assembler mapped to: "trap1(R0,#u8)"
                   trap1(Rx,#u8)                            if (!can_handle_trap1_virtinsn(#u)) {
                                                                SSR.CAUSE = #u;
                                                                TRAP "1";
                                                            } else if (#u == 1) {
                                                                VMRTE;
                                                            } else if (#u == 3) {
                                                                VMSETIE;
                                                            } else if (#u == 4) {
                                                                VMGETIE;
                                                            } else if (#u == 6) {
                                                                VMSPSWAP;
                  Class: SYSTEM (slot 2)
                  Notes
                       ■   This is a solo instruction. It must not be grouped with other instructions in a
                           packet.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1 0
   ICLASS                                       Parse
 0  1  0  1 0  1   0 0  0  0   -  -  -  -  -  - P   P  -  i   i i  i i -  - -  i  i i -  - trap0(#u8)
   ICLASS                              x5       Parse
 0  1  0  1 0  1   0 0  1  0   -  x  x  x  x  x P   P  -  i   i i  i i -  - -  i  i i -  - trap1(Rx,#u8)
80-N2040-45 Rev. B                                                                                              384
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  x5           Field to encode register x
80-N2040-45 Rev. B                                                    385
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
    11.10         XTYPE
                  The XTYPE instruction class includes instructions which perform most of the data
                  processing done by the Hexagon processor.
                  XTYPE instructions are executable on slot 2 or slot 3.
   11.10.1        XTYPE/ALU
                  The XTYPE/ALU instruction subclass includes instructions which perform arithmetic and
                  logical operations.
          Absolute value doubleword
                  Take the absolute value of the 64-bit source register and place it in the destination register.
                   Syntax                                   Behavior
                   Rdd=abs(Rss)                             Rdd = ABS(Rss);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=abs(Rss)                             Word64 Q6_P_abs_P(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0 1  0  0   s  s  s  s  s  P   P -  -   - -  - - 1   1  0 d d d  d d Rdd=abs(Rss)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                             386
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Absolute value word
                  Take the absolute value of the source register and place it in the destination register.
                  The 32-bit absolute value is available with optional saturation. The single case of
                  saturation is when the source register is equal to 0x8000_0000, the destination saturates to
                  0x7fff_ffff.
                   Syntax                                   Behavior
                   Rd=abs(Rs)[:sat]                         Rd = [sat_32](ABS(sxt32->64(Rs)));
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=abs(Rs)                               Word32 Q6_R_abs_R(Word32 Rs)
                   Rd=abs(Rs):sat                           Word32 Q6_R_abs_R_sat(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1  0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 1  1   0  0  1 0   0  s  s  s  s  s  P   P -  -   - -  - - 1   0  0 d d d  d  d Rd=abs(Rs)
 1  0  0  0 1  1   0  0  1 0   0  s  s  s  s  s  P   P -  -   - -  - - 1   0  1 d d d  d  d Rd=abs(Rs):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              387
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Add and accumulate
                  Add Rs and Rt or a signed immediate, then add or subtract the resulting value. The result
                  is saved in Rx.
                   Syntax                                   Behavior
                   Rd=add(Rs,add(Ru,#s6))                   Rd = Rs + Ru + apply_extension(#s);
                   Rd=add(Rs,sub(#s6,Ru))                   Rd = Rs - Ru + apply_extension(#s);
                   Rx+=add(Rs,#s8)                          apply_extension(#s);
                                                            Rx=Rx + Rs + #s;
                   Rx+=add(Rs,Rt)                           Rx=Rx + Rs + Rt;
                   Rx-=add(Rs,#s8)                          apply_extension(#s);
                                                            Rx=Rx - (Rs + #s);
                   Rx-=add(Rs,Rt)                           Rx=Rx - (Rs + Rt);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=add(Rs,add(Ru,#s6))                   Word32 Q6_R_add_add_RRI(Word32 Rs, Word32 Ru,
                                                            Word32 Is6)
                   Rd=add(Rs,sub(#s6,Ru))                   Word32 Q6_R_add_sub_RIR(Word32 Rs, Word32 Is6,
                                                            Word32 Ru)
                   Rx+=add(Rs,#s8)                          Word32 Q6_R_addacc_RI(Word32 Rx, Word32 Rs,
                                                            Word32 Is8)
                   Rx+=add(Rs,Rt)                           Word32 Q6_R_addacc_RR(Word32 Rx, Word32 Rs,
                                                            Word32 Rt)
                   Rx-=add(Rs,#s8)                          Word32 Q6_R_addnac_RI(Word32 Rx, Word32 Rs,
                                                            Word32 Is8)
                   Rx-=add(Rs,Rt)                           Word32 Q6_R_addnac_RR(Word32 Rx, Word32 Rs,
                                                            Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5  4 3 2  1 0
   ICLASS     RegType                  s5       Parse           d5                    u5
 1  1  0  1 1  0   1  1 0   i   i s  s  s  s  s P   P  i d    d d  d d  i    i  i u u u  u u Rd=add(Rs,add(Ru,#s6))
 1  1  0  1 1  0   1  1 1   i   i s  s  s  s  s P   P  i d    d d  d d  i    i  i u u u  u u Rd=add(Rs,sub(#s6,Ru))
   ICLASS     RegType     MajOp        s5       Parse                     MinOp       x5
 1  1  1  0 0  0   1  0 0   -   - s  s  s  s  s P   P 0   i   i  i i i  i    i  i x x  x x x Rx+=add(Rs,#s8)
 1  1  1  0 0  0   1  0 1   -   - s  s  s  s  s P   P 0   i   i  i i i  i    i  i x x  x x x Rx-=add(Rs,#s8)
   ICLASS     RegType     MajOp        s5       Parse           t5        MinOp       x5
 1  1  1  0 1  1   1  1 0  0   0  s  s  s  s  s P   P 0   t   t  t t t  0   0  1  x x  x x x Rx+=add(Rs,Rt)
 1  1  1  0 1  1   1  1 1  0   0  s  s  s  s  s P   P 0   t   t  t t t  0   0  1  x x  x x x Rx-=add(Rs,Rt)
80-N2040-45 Rev. B                                                                                                388
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  RegType      Register Type
                  ICLASS       Instruction Class
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  u5           Field to encode register u
                  x5           Field to encode register x
80-N2040-45 Rev. B                                                    389
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
        Add doublewords
                  The first form of this instruction adds two 32-bit registers. If the result overflows 32 bits,
                  the result is saturated to 0x7FFF_FFFF for a positive result, or 0x8000_0000 for a
                  negative result. 32-bit non-saturating register add is a ALU32-class instruction and can
                  execute on any slot.
                  The second instruction form sign-extends a 32-bit register Rt to 64-bits and performs a 64-
                  bit add with Rss. The result is stored in Rdd.
                  The third instruction form adds 64-bit registers Rss and Rtt and places the result in Rdd.
                  The final instruction form adds two 64-bit registers Rss and Rtt. If the result overflows 64
                  bits, it is saturated to 0x7fff_ffff_ffff_ffff for a positive result, or
                  0x8000_0000_0000_0000 for a negative result.
                   Syntax                                  Behavior
                   Rd=add(Rs,Rt):sat:deprecated            Rd=sat_32(Rs+Rt);
                   Rdd=add(Rs,Rtt)                         if ("Rs & 1") {
                                                                Assembler mapped to:
                                                           "Rdd=add(Rss,Rtt):raw:hi";
                                                           } else {
                                                                Assembler mapped to:
                                                           "Rdd=add(Rss,Rtt):raw:lo";
                                                           }
                   Rdd=add(Rss,Rtt)                        Rdd=Rss+Rtt;
                   Rdd=add(Rss,Rtt):raw:hi                 Rdd=Rtt+sxt32->64(Rss.w[1]);
                   Rdd=add(Rss,Rtt):raw:lo                 Rdd=Rtt+sxt32->64(Rss.w[0]);
                   Rdd=add(Rss,Rtt):sat                    Rdd=sat64(Rss+Rtt);
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■    If saturation occurs during execution of this instruction (a result is clamped to
                             either maximum or minimum values), the OVF bit in the Status Register is set.
                             OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=add(Rs,Rtt)                         Word64 Q6_P_add_RP(Word32 Rs, Word64 Rtt)
                   Rdd=add(Rss,Rtt)                        Word64 Q6_P_add_PP(Word64 Rss, Word64 Rtt)
                   Rdd=add(Rss,Rtt):sat                    Word64 Q6_P_add_PP_sat(Word64 Rss, Word64 Rtt)
80-N2040-45 Rev. B                                                                                                390
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5       MinOp       d5
 1  1  0  1 0  0   1  1 0  0  0   s  s  s  s  s  P   P -  t   t  t t t 1   1  1  d d d  d d Rdd=add(Rss,Rtt)
 1  1  0  1 0  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 1   0  1  d d d  d d Rdd=add(Rss,Rtt):sat
 1  1  0  1 0  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 1   1  0  d d d  d d Rdd=add(Rss,Rtt):raw:lo
 1  1  0  1 0  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 1   1  1  d d d  d d Rdd=add(Rss,Rtt):raw:hi
 1  1  0  1 0  1   0  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t 0   -   - d d d  d d Rd=add(Rs,Rt):sat:depreca
                                                                                            ted
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                391
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Add halfword
                  Perform a 16-bit add with optional saturation, and place the result in either the upper or
                  lower half of a register. If the result goes in the upper half, the sources can be any high or
                  low halfword of Rs and Rt. The lower 16 bits of the result are zeroed.
                  If the result must be placed in the lower 16 bits of Rd, the Rs source can be either high or
                  low, but the other source must be the low halfword of Rt. In this case, the upper halfword
                  of Rd is the sign-extension of the low halfword.
                                            Rd=add(Rs.[hl],Rt.[hl])[:sat]
                           Rs.H             Rs.L            Rs          Rt.H             Rt.L          Rt
                                     Mux                                        Mux
                                                              16-bit Add
                                                       0x7FFF          0x8000
                                                               Saturate
                                         Sign-extend           Result          Rd
                   Syntax                                 Behavior
                   Rd=add(Rt.L,Rs.[HL])[:sat]              Rd=[sat_16](Rt.h[0]+Rs.h[01]);
                   Rd=add(Rt.[HL],Rs.[HL])[:sat]:<         Rd=([sat_16](Rt.h[01]+Rs.h[01]))<<16;
                   <16
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                              392
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Intrinsics
                   Rd=add(Rt.H,Rs.H):<<16                   Word32 Q6_R_add_RhRh_s16(Word32 Rt, Word32 Rs)
                   Rd=add(Rt.H,Rs.H):sat:<<16               Word32 Q6_R_add_RhRh_sat_s16(Word32 Rt, Word32
                                                            Rs)
                   Rd=add(Rt.H,Rs.L):<<16                   Word32 Q6_R_add_RhRl_s16(Word32 Rt, Word32 Rs)
                   Rd=add(Rt.H,Rs.L):sat:<<16               Word32 Q6_R_add_RhRl_sat_s16(Word32 Rt, Word32
                                                            Rs)
                   Rd=add(Rt.L,Rs.H)                        Word32 Q6_R_add_RlRh(Word32 Rt, Word32 Rs)
                   Rd=add(Rt.L,Rs.H):<<16                   Word32 Q6_R_add_RlRh_s16(Word32 Rt, Word32 Rs)
                   Rd=add(Rt.L,Rs.H):sat                    Word32 Q6_R_add_RlRh_sat(Word32 Rt, Word32 Rs)
                   Rd=add(Rt.L,Rs.H):sat:<<16               Word32 Q6_R_add_RlRh_sat_s16(Word32 Rt, Word32
                                                            Rs)
                   Rd=add(Rt.L,Rs.L)                        Word32 Q6_R_add_RlRl(Word32 Rt, Word32 Rs)
                   Rd=add(Rt.L,Rs.L):<<16                   Word32 Q6_R_add_RlRl_s16(Word32 Rt, Word32 Rs)
                   Rd=add(Rt.L,Rs.L):sat                    Word32 Q6_R_add_RlRl_sat(Word32 Rt, Word32 Rs)
                   Rd=add(Rt.L,Rs.L):sat:<<16               Word32 Q6_R_add_RlRl_sat_s16(Word32 Rt, Word32
                                                            Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5       MinOp       d5
 1  1  0  1 0  1   0  1 0  0  0   s  s  s  s  s  P   P -  t   t  t t t 0   0   - d d d  d d Rd=add(Rt.L,Rs.L)
 1  1  0  1 0  1   0  1 0  0  0   s  s  s  s  s  P   P -  t   t  t t t 0   1   - d d d  d d Rd=add(Rt.L,Rs.H)
 1  1  0  1 0  1   0  1 0  0  0   s  s  s  s  s  P   P -  t   t  t t t 1   0   - d d d  d d Rd=add(Rt.L,Rs.L):sat
 1  1  0  1 0  1   0  1 0  0  0   s  s  s  s  s  P   P -  t   t  t t t 1   1   - d d d  d d Rd=add(Rt.L,Rs.H):sat
 1  1  0  1 0  1   0  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 0   0  0  d d d  d d Rd=add(Rt.L,Rs.L):<<16
 1  1  0  1 0  1   0  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 0   0  1  d d d  d d Rd=add(Rt.L,Rs.H):<<16
 1  1  0  1 0  1   0  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 0   1  0  d d d  d d Rd=add(Rt.H,Rs.L):<<16
 1  1  0  1 0  1   0  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 0   1  1  d d d  d d Rd=add(Rt.H,Rs.H):<<16
                                                                                            Rd=add(Rt.L,Rs.L):sat:<<1
 1  1  0  1 0  1   0  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 1   0  0  d d d  d d 6
 1  1  0  1 0  1   0  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 1   0  1  d d d  d d Rd=add(Rt.L,Rs.H):sat:<<1
                                                                                            6
 1  1  0  1 0  1   0  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 1   1  0  d d d  d d Rd=add(Rt.H,Rs.L):sat:<<1
                                                                                            6
                                                                                            Rd=add(Rt.H,Rs.H):sat:<<1
 1  1  0  1 0  1   0  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 1   1  1  d d d  d d 6
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                 393
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Add or subtract doublewords with carry
                  Add or subtract with carry. Use predicate register Px as an extra input and output.
                  For adds, the LSB of the predicate is added to the sum of the two input pairs.
                  For subtracts, the predicate is considered a not-borrow. The LSB of the predicate is added
                  to the first source register and the logical complement of the second argument.
                  The carry-out from the sum is saved in predicate Px.
                  These instructions allow efficient addition or subtraction of numbers larger than 64 bits.
                   Syntax                                   Behavior
                   Rdd=add(Rss,Rtt,Px):carry                PREDUSE_TIMING;
                                                            Rdd = Rss + Rtt + Px[0];
                                                            Px = carry_from_add(Rss,Rtt,Px[0]) ? 0xff :
                                                            0x00;
                   Rdd=sub(Rss,Rtt,Px):carry                PREDUSE_TIMING;
                                                            Rdd = Rss + ~Rtt + Px[0];
                                                            Px = carry_from_add(Rss,~Rtt,Px[0]) ? 0xff :
                                                            0x00;
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  The predicate generated by this instruction cannot be used as a .new predicate, nor
                           can it be automatically AND’d with another predicate.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6    5 4 3 2  1 0
   ICLASS     RegType     Maj          s5        Parse          t5          x2       d5
 1  1  0  0 0  0   1  0  1  1  0  s  s  s  s  s  P   P -  t   t  t t t -  x    x d d d  d d Rdd=add(Rss,Rtt,Px):carry
 1  1  0  0 0  0   1  0  1  1  1  s  s  s  s  s  P   P -  t   t  t t t -  x    x d d d  d d Rdd=sub(Rss,Rtt,Px):carry
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x2                Field to encode register x
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                                394
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Clip to unsigned
                  Clip input to unsigned int
                   Syntax                                   Behavior
                   Rd=clip(Rs,#u5)                          Rd=MIN((1<<#u)-1,MAX(Rs,-(1<<#u)));
                                                            ;
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  This instruction can only execute on a core with the Hexagon audio extensions
                  Intrinsics
                   Rd=clip(Rs,#u5)                          Word32 Q6_R_clip_RI(Word32 Rs, Word32 Iu5)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 1  0   0  0  1 1  0   s  s  s  s  s  P   P 0  i   i i  i i 1   0  1 d d d  d d Rd=clip(Rs,#u5)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              395
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Logical doublewords
                  Perform bitwise logical AND, OR, XOR, and NOT operations.
                  The source and destination registers are 64-bit.
                  For 32-bit logical operations, see the ALU32 logical instructions.
                   Syntax                                   Behavior
                   Rdd=and(Rss,Rtt)                         Rdd=Rss&Rtt;
                   Rdd=and(Rtt,~Rss)                        Rdd = (Rtt & ~Rss);
                   Rdd=not(Rss)                             Rdd=~Rss;
                   Rdd=or(Rss,Rtt)                          Rdd=Rss|Rtt;
                   Rdd=or(Rtt,~Rss)                         Rdd = (Rtt | ~Rss);
                   Rdd=xor(Rss,Rtt)                         Rdd=Rss^Rtt;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=and(Rss,Rtt)                         Word64 Q6_P_and_PP(Word64 Rss, Word64 Rtt)
                   Rdd=and(Rtt,~Rss)                        Word64 Q6_P_and_PnP(Word64 Rtt, Word64 Rss)
                   Rdd=not(Rss)                             Word64 Q6_P_not_P(Word64 Rss)
                   Rdd=or(Rss,Rtt)                          Word64 Q6_P_or_PP(Word64 Rss, Word64 Rtt)
                   Rdd=or(Rtt,~Rss)                         Word64 Q6_P_or_PnP(Word64 Rtt, Word64 Rss)
                   Rdd=xor(Rss,Rtt)                         Word64 Q6_P_xor_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0 1  0  0   s  s  s  s  s  P   P -  -   -  - - - 1   0  0 d d d  d d Rdd=not(Rss)
   ICLASS     RegType                  s5        Parse          t5       MinOp      d5
 1  1  0  1 0  0   1  1 1  1  1   s  s  s  s  s  P   P -  t   t  t t t 0   0  0 d d d  d d Rdd=and(Rss,Rtt)
 1  1  0  1 0  0   1  1 1  1  1   s  s  s  s  s  P   P -  t   t  t t t 0   0  1 d d d  d d Rdd=and(Rtt,~Rss)
 1  1  0  1 0  0   1  1 1  1  1   s  s  s  s  s  P   P -  t   t  t t t 0   1  0 d d d  d d Rdd=or(Rss,Rtt)
 1  1  0  1 0  0   1  1 1  1  1   s  s  s  s  s  P   P -  t   t  t t t 0   1  1 d d d  d d Rdd=or(Rtt,~Rss)
 1  1  0  1 0  0   1  1 1  1  1   s  s  s  s  s  P   P -  t   t  t t t 1   0  0 d d d  d d Rdd=xor(Rss,Rtt)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
80-N2040-45 Rev. B                                                                                             396
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    397
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Logical-logical doublewords
                  Perform a logical operation of the two source operands, then perform a second logical
                  operation of the result with the destination register Rxx.
                  The source and destination registers are 64-bit.
                   Syntax                                   Behavior
                   Rxx^=xor(Rss,Rtt)                        Rxx^=Rss^Rtt;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rxx^=xor(Rss,Rtt)                        Word64 Q6_P_xorxacc_PP(Word64 Rxx, Word64 Rss,
                                                            Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6 5 4 3  2 1  0
   ICLASS     RegType    Maj           s5        Parse          t5       Min       x5
 1  1  0  0 1  0   1  0 1  0   -  s  s  s  s  s  P   P 0  t   t  t t t  0  0 0 x x  x x  x Rxx^=xor(Rss,Rtt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                             398
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
        Logical-logical words
                  Perform a logical operation of the two source operands, then perform a second logical
                  operation of the result with the destination register Rx.
                  The source and destination registers are 32-bit.
                   Syntax                               Behavior
                   Rx=or(Ru,and(Rx,#s10))                Rx = Ru | (Rx & apply_extension(#s));
                   Rx[&|^]=and(Rs,Rt)                    Rx [|&^]= (Rs [|&^] Rt);
                   Rx[&|^]=and(Rs,~Rt)                   Rx [|&^]= (Rs [|&^] ~Rt);
                   Rx[&|^]=or(Rs,Rt)                     Rx [|&^]= (Rs [|&^] Rt);
                   Rx[&|^]=xor(Rs,Rt)                    Rx[|&^]=Rs[|&^]Rt;
                   Rx|=and(Rs,#s10)                      Rx = Rx | (Rs & apply_extension(#s));
                   Rx|=or(Rs,#s10)                       Rx = Rx | (Rs | apply_extension(#s));
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx&=and(Rs,Rt)                       Word32 Q6_R_andand_RR(Word32 Rx, Word32 Rs,
                                                        Word32 Rt)
                   Rx&=and(Rs,~Rt)                      Word32 Q6_R_andand_RnR(Word32 Rx, Word32 Rs,
                                                        Word32 Rt)
                   Rx&=or(Rs,Rt)                        Word32 Q6_R_orand_RR(Word32 Rx, Word32 Rs,
                                                        Word32 Rt)
                   Rx&=xor(Rs,Rt)                       Word32 Q6_R_xorand_RR(Word32 Rx, Word32 Rs,
                                                        Word32 Rt)
                   Rx=or(Ru,and(Rx,#s10))               Word32 Q6_R_or_and_RRI(Word32 Ru, Word32 Rx,
                                                        Word32 Is10)
                   Rx^=and(Rs,Rt)                       Word32 Q6_R_andxacc_RR(Word32 Rx, Word32 Rs,
                                                        Word32 Rt)
                   Rx^=and(Rs,~Rt)                      Word32 Q6_R_andxacc_RnR(Word32 Rx, Word32 Rs,
                                                        Word32 Rt)
                   Rx^=or(Rs,Rt)                        Word32 Q6_R_orxacc_RR(Word32 Rx, Word32 Rs,
                                                        Word32 Rt)
                   Rx^=xor(Rs,Rt)                       Word32 Q6_R_xorxacc_RR(Word32 Rx, Word32 Rs,
                                                        Word32 Rt)
                   Rx|=and(Rs,#s10)                     Word32 Q6_R_andor_RI(Word32 Rx, Word32 Rs,
                                                        Word32 Is10)
80-N2040-45 Rev. B                                                                                        399
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                   Rx|=and(Rs,Rt)                           Word32 Q6_R_andor_RR(Word32 Rx, Word32 Rs,
                                                            Word32 Rt)
                   Rx|=and(Rs,~Rt)                          Word32 Q6_R_andor_RnR(Word32 Rx, Word32 Rs,
                                                            Word32 Rt)
                   Rx|=or(Rs,#s10)                          Word32 Q6_R_oror_RI(Word32 Rx, Word32 Rs, Word32
                                                            Is10)
                   Rx|=or(Rs,Rt)                            Word32 Q6_R_oror_RR(Word32 Rx, Word32 Rs, Word32
                                                            Rt)
                   Rx|=xor(Rs,Rt)                           Word32 Q6_R_xoror_RR(Word32 Rx, Word32 Rs,
                                                            Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5  4 3 2  1 0
   ICLASS     RegType                  s5        Parse                                x5
 1  1  0  1 1  0   1  0 0  0    i s  s  s  s  s  P   P i  i   i  i i i  i    i  i x x  x x x Rx|=and(Rs,#s10)
   ICLASS     RegType                  x5        Parse                                u5
 1  1  0  1 1  0   1  0 0  1    i x  x  x  x  x  P   P i  i   i  i i i  i    i  i u u u  u u Rx=or(Ru,and(Rx,#s10))
   ICLASS     RegType                  s5        Parse                                x5
 1  1  0  1 1  0   1  0 1  0    i s  s  s  s  s  P   P i  i   i  i i i  i    i  i x x  x x x Rx|=or(Rs,#s10)
   ICLASS     RegType     MajOp        s5        Parse          t5        MinOp       x5
 1  1  1  0 1  1   1  1 0  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0    0  0  x x  x x x Rx|=and(Rs,~Rt)
 1  1  1  0 1  1   1  1 0  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0    0  1  x x  x x x Rx&=and(Rs,~Rt)
 1  1  1  0 1  1   1  1 0  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0    1  0  x x  x x x Rx^=and(Rs,~Rt)
 1  1  1  0 1  1   1  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0    0  0  x x  x x x Rx&=and(Rs,Rt)
 1  1  1  0 1  1   1  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0    0  1  x x  x x x Rx&=or(Rs,Rt)
 1  1  1  0 1  1   1  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0    1  0  x x  x x x Rx&=xor(Rs,Rt)
 1  1  1  0 1  1   1  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0    1  1  x x  x x x Rx|=and(Rs,Rt)
 1  1  1  0 1  1   1  1 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0    1  1  x x  x x x Rx^=xor(Rs,Rt)
 1  1  1  0 1  1   1  1 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0    0  0  x x  x x x Rx|=or(Rs,Rt)
 1  1  1  0 1  1   1  1 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0    0  1  x x  x x x Rx|=xor(Rs,Rt)
 1  1  1  0 1  1   1  1 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0    1  0  x x  x x x Rx^=and(Rs,Rt)
 1  1  1  0 1  1   1  1 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0    1  1  x x  x x x Rx^=or(Rs,Rt)
                  Field name        Description
                  RegType           Register Type
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                                400
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Maximum words
                  Select either the signed or unsigned maximum of two source registers and place in a
                  destination register Rdd.
                   Syntax                                   Behavior
                   Rd=max(Rs,Rt)                            Rd = max(Rs,Rt);
                   Rd=maxu(Rs,Rt)                           Rd = max(Rs.uw[0],Rt.uw[0]);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=max(Rs,Rt)                            Word32 Q6_R_max_RR(Word32 Rs, Word32 Rt)
                   Rd=maxu(Rs,Rt)                           UWord32 Q6_R_maxu_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5       MinOp       d5
 1  1  0  1 0  1   0  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t t 0   -   - d d d  d d Rd=max(Rs,Rt)
 1  1  0  1 0  1   0  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t t 1   -   - d d d  d d Rd=maxu(Rs,Rt)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             401
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
          Maximum doublewords
                  Select either the signed or unsigned maximum of two 64-bit source registers and place in a
                  destination register.
                   Syntax                                   Behavior
                   Rdd=max(Rss,Rtt)                         Rdd = max(Rss,Rtt);
                   Rdd=maxu(Rss,Rtt)                        Rdd = max(Rss.u64,Rtt.u64);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=max(Rss,Rtt)                         Word64 Q6_P_max_PP(Word64 Rss, Word64 Rtt)
                   Rdd=maxu(Rss,Rtt)                        UWord64 Q6_P_maxu_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5       MinOp      d5
 1  1  0  1 0  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t t 1   0  0 d d d  d d Rdd=max(Rss,Rtt)
 1  1  0  1 0  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t t 1   0  1 d d d  d d Rdd=maxu(Rss,Rtt)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                            402
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Minimum words
                  Select either the signed or unsigned minimum of two source registers and place in
                  destination register Rd.
                   Syntax                                   Behavior
                   Rd=min(Rt,Rs)                            Rd = min(Rt,Rs);
                   Rd=minu(Rt,Rs)                           Rd = min(Rt.uw[0],Rs.uw[0]);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=min(Rt,Rs)                            Word32 Q6_R_min_RR(Word32 Rt, Word32 Rs)
                   Rd=minu(Rt,Rs)                           UWord32 Q6_R_minu_RR(Word32 Rt, Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5       MinOp       d5
 1  1  0  1 0  1   0  1 1  0  1   s  s  s  s  s  P   P -  t   t  t t t 0   -   - d d d  d d Rd=min(Rt,Rs)
 1  1  0  1 0  1   0  1 1  0  1   s  s  s  s  s  P   P -  t   t  t t t 1   -   - d d d  d d Rd=minu(Rt,Rs)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              403
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Minimum doublewords
                  Select either the signed or unsigned minimum of two 64-bit source registers and place in
                  the destination register Rdd.
                   Syntax                                   Behavior
                   Rdd=min(Rtt,Rss)                         Rdd = min(Rtt,Rss);
                   Rdd=minu(Rtt,Rss)                        Rdd = min(Rtt.u64,Rss.u64);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=min(Rtt,Rss)                         Word64 Q6_P_min_PP(Word64 Rtt, Word64 Rss)
                   Rdd=minu(Rtt,Rss)                        UWord64 Q6_P_minu_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5       MinOp      d5
 1  1  0  1 0  0   1  1 1  0  1   s  s  s  s  s  P   P -  t   t  t t t 1   1  0 d d d  d d Rdd=min(Rtt,Rss)
 1  1  0  1 0  0   1  1 1  0  1   s  s  s  s  s  P   P -  t   t  t t t 1   1  1 d d d  d d Rdd=minu(Rtt,Rss)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             404
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Modulo wrap
                  Wrap the Rs value into the modulo range from 0 to Rt.
                  If Rs is greater than or equal to Rt, wrap it to the bottom of the range by subtracting Rt.
                  If Rs is less than zero, wrap it to the top of the range by adding Rt.
                  Otherwise, when Rs fits within the range, no adjustment is necessary. The result is
                  returned in register Rd.
                   Syntax                                   Behavior
                   Rd=modwrap(Rs,Rt)                        if (Rs    < 0) {
                                                                 Rd   = Rs + Rt.uw[0];
                                                            } else    if (Rs.uw[0] >= Rt.uw[0]) {
                                                                 Rd   = Rs - Rt.uw[0];
                                                            } else    {
                                                                 Rd   = Rs;
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=modwrap(Rs,Rt)                        Word32 Q6_R_modwrap_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5          MinOp      d5
 1  1  0  1 0  0   1  1 1   1  1  s  s  s  s  s  P   P -  t   t  t  t   t 1   1  1 d d d  d d Rd=modwrap(Rs,Rt)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                               405
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Negate
                  The first form of this instruction performs a negate on a 32-bit register with saturation. If
                  the input is 0x80000000, the result is saturated to 0x7fffffff. The non-saturating 32-bit
                  register negate is a ALU32-class instruction and can execute on any slot.
                  The second form of this instruction negates a 64-bit source register and place the result in
                  destination Rdd.
                   Syntax                                   Behavior
                   Rd=neg(Rs):sat                           Rd = sat_32(-Rs.s64);
                   Rdd=neg(Rss)                             Rdd = -Rss;
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=neg(Rs):sat                           Word32 Q6_R_neg_R_sat(Word32 Rs)
                   Rdd=neg(Rss)                             Word64 Q6_P_neg_P(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0  1 0   0  s  s  s  s  s  P   P -  -   - -  - - 1   0  1 d d d  d d Rdd=neg(Rss)
 1  0  0  0 1  1   0  0  1 0   0  s  s  s  s  s  P   P -  -   - -  - - 1   1  0 d d d  d d Rd=neg(Rs):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              406
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Round
                  Perform either arithmetic (.5 is rounded up) or convergent (.5 is rounded towards even)
                  rounding to any bit location.
                  Arithmetic rounding has optional saturation. In this version, the result is saturated to a 32-
                  bit number after adding the rounding constant. After performing the rounding and
                  saturation, a sign-extending shift right shifts the final result.
                   Syntax                               Behavior
                   Rd=cround(Rs,#u5)                    Rd = (#u==0)?Rs:convround(Rs,2**(#u-1))>>#u;
                   Rd=cround(Rs,Rt)                     Rd = (zxt5->32(Rt)==0)?Rs:convround(Rs,2**(zxt5-
                                                        >32(Rt)-1))>>zxt5->32(Rt);
                   Rd=round(Rs,#u5)[:sat]               Rd = ([sat_32]((#u==0)?(Rs):round(Rs,2**(#u-
                                                        1))))>>#u;
                   Rd=round(Rs,Rt)[:sat]                Rd = ([sat_32]((zxt5-
                                                        >32(Rt)==0)?(Rs):round(Rs,2**(zxt5->32(Rt)-
                                                        1))))>>zxt5->32(Rt);
                   Rd=round(Rss):sat                    tmp=sat64(Rss+0x080000000ULL);
                                                        Rd = tmp.w[1];
                   Rdd=cround(Rss,#u6)                  if (#u == 0) {
                                                             Rdd = Rss;
                                                        } else if ((Rss & (size8s_t)((1LL << (#u - 1)) -
                                                        1LL)) == 0) {
                                                             src_128 = sxt64->128(Rss);
                                                             rndbit_128 = sxt64->128(1LL);
                                                             rndbit_128 = (rndbit_128 << #u);
                                                             rndbit_128 = (rndbit_128 & src_128);
                                                             rndbit_128 = (size8s_t) (rndbit_128 >> 1);
                                                             tmp128 = src_128+rndbit_128;
                                                             tmp128 = (size8s_t) (tmp128 >> #u);
                                                             Rdd = sxt128->64(tmp128);
                                                        } else {
                                                             size16s_t rndbit_128 = sxt64->128((1LL << (#u
                                                        - 1)));
                                                             size16s_t src_128 = sxt64->128(Rss);
                                                             size16s_t tmp128 = src_128+rndbit_128;
                                                             tmp128 = (size8s_t) (tmp128 >> #u);
                                                             Rdd = sxt128->64(tmp128);
                                                        }
                                                        ;
                                                        ;
80-N2040-45 Rev. B                                                                                            407
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Syntax                              Behavior
                   Rdd=cround(Rss,Rt)                  if (zxt6->32(Rt) == 0) {
                                                            Rdd = Rss;
                                                       } else if ((Rss & (size8s_t)((1LL << (zxt6-
                                                       >32(Rt) - 1)) - 1LL)) == 0) {
                                                            src_128 = sxt64->128(Rss);
                                                            rndbit_128 = sxt64->128(1LL);
                                                            rndbit_128 = (rndbit_128 << zxt6->32(Rt));
                                                            rndbit_128 = (rndbit_128 & src_128);
                                                            rndbit_128 = (size8s_t) (rndbit_128 >> 1);
                                                            tmp128 = src_128+rndbit_128;
                                                            tmp128 = (size8s_t) (tmp128 >> zxt6->32(Rt));
                                                            Rdd = sxt128->64(tmp128);
                                                       } else {
                                                            size16s_t rndbit_128 = sxt64->128((1LL <<
                                                       (zxt6->32(Rt) - 1)));
                                                            size16s_t src_128 = sxt64->128(Rss);
                                                            size16s_t tmp128 = src_128+rndbit_128;
                                                            tmp128 = (size8s_t) (tmp128 >> zxt6->32(Rt));
                                                            Rdd = sxt128->64(tmp128);
                                                       }
                                                       ;
                                                       ;
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■  This instruction can only execute on a core with the Hexagon audio extensions
                       ■  If saturation occurs during execution of this instruction (a result is clamped to
                          either maximum or minimum values), the OVF bit in the Status Register is set.
                          OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=cround(Rs,#u5)                   Word32 Q6_R_cround_RI(Word32 Rs, Word32 Iu5)
                   Rd=cround(Rs,Rt)                    Word32 Q6_R_cround_RR(Word32 Rs, Word32 Rt)
                   Rd=round(Rs,#u5)                    Word32 Q6_R_round_RI(Word32 Rs, Word32 Iu5)
                   Rd=round(Rs,#u5):sat                Word32 Q6_R_round_RI_sat(Word32 Rs, Word32 Iu5)
                   Rd=round(Rs,Rt)                     Word32 Q6_R_round_RR(Word32 Rs, Word32 Rt)
                   Rd=round(Rs,Rt):sat                 Word32 Q6_R_round_RR_sat(Word32 Rs, Word32 Rt)
                   Rd=round(Rss):sat                   Word32 Q6_R_round_P_sat(Word64 Rss)
                   Rdd=cround(Rss,#u6)                 Word64 Q6_P_cround_PI(Word64 Rss, Word32 Iu6)
                   Rdd=cround(Rss,Rt)                  Word64 Q6_P_cround_PR(Word64 Rss, Word32 Rt)
80-N2040-45 Rev. B                                                                                             408
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp       d5
 1  0  0  0 1  0   0  0 1  1  0   s  s  s  s  s  P   P -  -   -  - - - 0   0  1  d d d  d d Rd=round(Rss):sat
 1  0  0  0 1  1   0  0 1  1  1   s  s  s  s  s  P   P 0  i   i  i i i 0   0   - d d d  d d Rd=cround(Rs,#u5)
 1  0  0  0 1  1   0  0 1  1  1   s  s  s  s  s  P   P 0  i   i  i i i 1   0   - d d d  d d Rd=round(Rs,#u5)
 1  0  0  0 1  1   0  0 1  1  1   s  s  s  s  s  P   P 0  i   i  i i i 1   1   - d d d  d d Rd=round(Rs,#u5):sat
 1  0  0  0 1  1   0  0 1  1  1   s  s  s  s  s  P   P i  i   i  i i i 0   1   - d d d  d d Rdd=cround(Rss,#u6)
   ICLASS     RegType    Maj           s5        Parse          t5      Min          d5
 1  1  0  0 0  1   1  0 1  1   -  s  s  s  s  s  P   P -  t   t  t t t 0   0   - d d d  d d Rd=cround(Rs,Rt)
 1  1  0  0 0  1   1  0 1  1   -  s  s  s  s  s  P   P -  t   t  t t t 0   1   - d d d  d d Rdd=cround(Rss,Rt)
 1  1  0  0 0  1   1  0 1  1   -  s  s  s  s  s  P   P -  t   t  t t t 1   0   - d d d  d d Rd=round(Rs,Rt)
 1  1  0  0 0  1   1  0 1  1   -  s  s  s  s  s  P   P -  t   t  t t t 1   1   - d d d  d d Rd=round(Rs,Rt):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                               409
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Subtract doublewords
                  Subtract the 64-bit register Rss from register Rtt.
                   Syntax                                   Behavior
                   Rd=sub(Rt,Rs):sat:deprecated             Rd=sat_32(Rt - Rs);
                   Rdd=sub(Rtt,Rss)                         Rdd=Rtt-Rss;
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=sub(Rtt,Rss)                         Word64 Q6_P_sub_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5       MinOp       d5
 1  1  0  1 0  0   1  1  0 0   1  s  s  s  s  s  P   P -  t   t  t t t 1   1  1  d d d  d d Rdd=sub(Rtt,Rss)
 1  1  0  1 0  1   0  1  1 0   0  s  s  s  s  s  P   P -  t   t  t t t 1   -   - d d d  d d Rd=sub(Rt,Rs):sat:depreca
                                                                                            ted
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                410
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Subtract and accumulate words
                  Subtract Rs from Rt, then add the resulting value with Rx. The result is saved in Rx.
                   Syntax                                   Behavior
                   Rx+=sub(Rt,Rs)                           Rx=Rx + Rt - Rs;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx+=sub(Rt,Rs)                           Word32 Q6_R_subacc_RR(Word32 Rx, Word32 Rt,
                                                            Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  1   1  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  1 x x x  x x Rx+=sub(Rt,Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                             411
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
         Subtract halfword
                  Perform a 16-bit subtract with optional saturation and place the result in either the upper or
                  lower half of a register. If the result goes in the upper half, the sources can be any high or
                  low halfword of Rs and Rt. The lower 16 bits of the result are zeroed.
                  If the result must be placed in the lower 16 bits of Rd, the Rs source can be either high or
                  low, but the other source must be the low halfword of Rt. In this case, the upper halfword
                  of Rd is the sign-extension of the low halfword.
              Rd=sub(Rt.[hl],Rs.l)[:sat]                                Rd=sub(Rt.[hl],Rs.[hl])[:sat]:<<16
        Rt.H              Rt.L          Rt                           Rt.H            Rt.L          Rt
                  Mux                               Rs                        Mux                                Rs
                                 Rs.H           Rs.L                                       Rs.H             Rs.L
                                                                                                    Mux
                      16-bit Sub                                                 16-bit Sub
               0x7FFF           0x8000                                      0x7FFF        0x8000
                       Saturate                                                   Saturate
    Sign-extend         Result           Rd                                        Result          0x0000         Rd
                   Syntax                                 Behavior
                   Rd=sub(Rt.L,Rs.[HL])[:sat]              Rd=[sat_16](Rt.h[0]-Rs.h[01]);
                   Rd=sub(Rt.[HL],Rs.[HL])[:sat]:<         Rd=([sat_16](Rt.h[01]-Rs.h[01]))<<16;
                   <16
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■    If saturation occurs during execution of this instruction (a result is clamped to
                             either maximum or minimum values), the OVF bit in the Status Register is set.
                             OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                                412
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Intrinsics
                   Rd=sub(Rt.H,Rs.H):<<16                   Word32 Q6_R_sub_RhRh_s16(Word32 Rt, Word32 Rs)
                   Rd=sub(Rt.H,Rs.H):sat:<<16               Word32 Q6_R_sub_RhRh_sat_s16(Word32 Rt, Word32
                                                            Rs)
                   Rd=sub(Rt.H,Rs.L):<<16                   Word32 Q6_R_sub_RhRl_s16(Word32 Rt, Word32 Rs)
                   Rd=sub(Rt.H,Rs.L):sat:<<16               Word32 Q6_R_sub_RhRl_sat_s16(Word32 Rt, Word32
                                                            Rs)
                   Rd=sub(Rt.L,Rs.H)                        Word32 Q6_R_sub_RlRh(Word32 Rt, Word32 Rs)
                   Rd=sub(Rt.L,Rs.H):<<16                   Word32 Q6_R_sub_RlRh_s16(Word32 Rt, Word32 Rs)
                   Rd=sub(Rt.L,Rs.H):sat                    Word32 Q6_R_sub_RlRh_sat(Word32 Rt, Word32 Rs)
                   Rd=sub(Rt.L,Rs.H):sat:<<16               Word32 Q6_R_sub_RlRh_sat_s16(Word32 Rt, Word32
                                                            Rs)
                   Rd=sub(Rt.L,Rs.L)                        Word32 Q6_R_sub_RlRl(Word32 Rt, Word32 Rs)
                   Rd=sub(Rt.L,Rs.L):<<16                   Word32 Q6_R_sub_RlRl_s16(Word32 Rt, Word32 Rs)
                   Rd=sub(Rt.L,Rs.L):sat                    Word32 Q6_R_sub_RlRl_sat(Word32 Rt, Word32 Rs)
                   Rd=sub(Rt.L,Rs.L):sat:<<16               Word32 Q6_R_sub_RlRl_sat_s16(Word32 Rt, Word32
                                                            Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5       MinOp       d5
 1  1  0  1 0  1   0  1 0  0  1   s  s  s  s  s  P   P -  t   t  t t t 0   0   - d d d  d d Rd=sub(Rt.L,Rs.L)
 1  1  0  1 0  1   0  1 0  0  1   s  s  s  s  s  P   P -  t   t  t t t 0   1   - d d d  d d Rd=sub(Rt.L,Rs.H)
 1  1  0  1 0  1   0  1 0  0  1   s  s  s  s  s  P   P -  t   t  t t t 1   0   - d d d  d d Rd=sub(Rt.L,Rs.L):sat
 1  1  0  1 0  1   0  1 0  0  1   s  s  s  s  s  P   P -  t   t  t t t 1   1   - d d d  d d Rd=sub(Rt.L,Rs.H):sat
 1  1  0  1 0  1   0  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 0   0  0  d d d  d d Rd=sub(Rt.L,Rs.L):<<16
 1  1  0  1 0  1   0  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 0   0  1  d d d  d d Rd=sub(Rt.L,Rs.H):<<16
 1  1  0  1 0  1   0  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 0   1  0  d d d  d d Rd=sub(Rt.H,Rs.L):<<16
 1  1  0  1 0  1   0  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 0   1  1  d d d  d d Rd=sub(Rt.H,Rs.H):<<16
                                                                                            Rd=sub(Rt.L,Rs.L):sat:<<1
 1  1  0  1 0  1   0  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 1   0  0  d d d  d d 6
 1  1  0  1 0  1   0  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 1   0  1  d d d  d d Rd=sub(Rt.L,Rs.H):sat:<<1
                                                                                            6
 1  1  0  1 0  1   0  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 1   1  0  d d d  d d Rd=sub(Rt.H,Rs.L):sat:<<1
                                                                                            6
                                                                                            Rd=sub(Rt.H,Rs.H):sat:<<1
 1  1  0  1 0  1   0  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 1   1  1  d d d  d d 6
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                 413
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Sign extend word to doubleword
                  Sign-extend a 32-bit word to a 64-bit doubleword.
                   Syntax                                   Behavior
                   Rdd=sxtw(Rs)                             Rdd = sxt32->64(Rs);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=sxtw(Rs)                             Word64 Q6_P_sxtw_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5  4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp       d5
 1  0  0  0 0  1   0  0 0  1   -  s  s  s  s  s  P   P -  -   - -  - - 0   0   - d d d  d d Rdd=sxtw(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              414
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector absolute value halfwords
                  Take the absolute value of each of the four halfwords in the 64-bit source vector Rss. Place
                  the result in Rdd.
                  Saturation is optionally available.
                   Syntax                                   Behavior
                   Rdd=vabsh(Rss)                           for (i=0;i<4;i++) {
                                                                Rdd.h[i]=ABS(Rss.h[i]);
                                                            }
                   Rdd=vabsh(Rss):sat                       for (i=0;i<4;i++) {
                                                                Rdd.h[i]=sat_16(ABS(Rss.h[i]));
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vabsh(Rss)                           Word64 Q6_P_vabsh_P(Word64 Rss)
                   Rdd=vabsh(Rss):sat                       Word64 Q6_P_vabsh_P_sat(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0  0 1   0  s  s  s  s  s  P   P -  -   - -  - - 1   0  0 d d d  d d Rdd=vabsh(Rss)
 1  0  0  0 0  0   0  0  0 1   0  s  s  s  s  s  P   P -  -   - -  - - 1   0  1 d d d  d d Rdd=vabsh(Rss):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              415
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector absolute value words
                  Take the absolute value of each of the two words in the 64-bit source vector Rss. Place the
                  result in Rdd.
                  Saturation is optionally available.
                   Syntax                                   Behavior
                   Rdd=vabsw(Rss)                           for (i=0;i<2;i++) {
                                                                Rdd.w[i]=ABS(Rss.w[i]);
                                                            }
                   Rdd=vabsw(Rss):sat                       for (i=0;i<2;i++) {
                                                                Rdd.w[i]=sat_32(ABS(Rss.w[i]));
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vabsw(Rss)                           Word64 Q6_P_vabsw_P(Word64 Rss)
                   Rdd=vabsw(Rss):sat                       Word64 Q6_P_vabsw_P_sat(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0  0  1  0  s  s  s  s  s  P   P -  -   - -  - - 1   1  0 d d d  d d Rdd=vabsw(Rss)
 1  0  0  0 0  0   0  0  0  1  0  s  s  s  s  s  P   P -  -   - -  - - 1   1  1 d d d  d d Rdd=vabsw(Rss):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              416
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector absolute difference bytes
                  For each element in the source vector Rss, subtract the corresponding element in source
                  vector Rtt. Take the absolute value of the results, and store into Rdd.
                   Syntax                                   Behavior
                   Rdd=vabsdiffb(Rtt,Rss)                   for (i=0;i<8;i++) {
                                                                 Rdd.b[i]=ABS(Rtt.b[i] - Rss.b[i]);
                                                            }
                   Rdd=vabsdiffub(Rtt,Rss)                  for (i=0;i<8;i++) {
                                                                 Rdd.b[i]=ABS(Rtt.ub[i] - Rss.ub[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vabsdiffb(Rtt,Rss)                   Word64 Q6_P_vabsdiffb_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vabsdiffub(Rtt,Rss)                  Word64 Q6_P_vabsdiffub_PP(Word64 Rtt, Word64
                                                            Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5        MinOp      d5
 1  1  1  0 1  0   0  0 1  0   1  s  s  s  s  s  P   P 0  t   t  t t  t 0   0  0 d d d  d d Rdd=vabsdiffub(Rtt,Rss)
 1  1  1  0 1  0   0  0 1  1   1  s  s  s  s  s  P   P 0  t   t  t t  t 0   0  0 d d d  d d Rdd=vabsdiffb(Rtt,Rss)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                 417
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector absolute difference halfwords
                  For each element in the source vector Rss, subtract the corresponding element in source
                  vector Rtt. Take the absolute value of the results, and store into Rdd.
                   Syntax                                   Behavior
                   Rdd=vabsdiffh(Rtt,Rss)                   for (i=0;i<4;i++) {
                                                                 Rdd.h[i]=ABS(Rtt.h[i] - Rss.h[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vabsdiffh(Rtt,Rss)                   Word64 Q6_P_vabsdiffh_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5        MinOp      d5
 1  1  1  0 1  0   0  0 0  1   1  s  s  s  s  s  P   P 0  t   t  t t  t 0   0  0 d d d  d d Rdd=vabsdiffh(Rtt,Rss)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                 418
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector absolute difference words
                  For each element in the source vector Rss, subtract the corresponding element in source
                  vector Rtt. Take the absolute value of the results, and store into Rdd.
                   Syntax                                   Behavior
                   Rdd=vabsdiffw(Rtt,Rss)                   for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=ABS(Rtt.w[i] - Rss.w[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vabsdiffw(Rtt,Rss)                   Word64 Q6_P_vabsdiffw_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5        MinOp      d5
 1  1  1  0 1  0   0  0 0  0   1  s  s  s  s  s  P   P 0  t   t  t t  t 0   0  0 d d d  d d Rdd=vabsdiffw(Rtt,Rss)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                 419
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
         Vector add compare and select maximum bytes
                   Add each byte element in Rxx and Rtt, and compare the resulting sums with the
                   corresponding differences between Rss and Rtt. Store the maximum value of each
                   compare in Rxx, and set the corresponding bits in a predicate destination to '1' if the
                   compare result is greater, '0' if not. Each sum and difference is saturated to 8 bits before
                   the compare, and the compare operation is a signed byte compare.
       Rxx.H3             Rxx.H2            Rxx.H1             Rxx.H0              Rxx
                   Rss.H3            Rss.H2             Rss.H1            Rss.H0    Rss
            Rtt.H3            Rtt.H2            Rtt.H1             Rtt.H0            Rtt
             +       -         +       -         +       -          +       -
                                                                                  Rxx,Pd=vacsh(Rss,Rtt)
           sat16   sat16     sat16   sat16     sat16   sat16      sat16   sat16
                                                                        >
                                                     >
                                   >
                                                                      1     0
                 >                                                                    1bit
       16bits                                      1     0
                                 1     0
               1     0
              Rxx.H3            Rxx.H2            Rxx.H1             Rxx.H0                   Pd
                   Syntax                                    Behavior
                   Class: N/A
80-N2040-45 Rev. B                                                                                              420
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
         Vector add compare and select maximum halfwords
                   Add each halfword element in Rxx and Rtt, and compare the resulting sums with the
                   corresponding differences between Rss and Rtt. Store the maximum value of each
                   compare in Rxx, and set the corresponding bits in a predicate destination to '11' if the
                   compare result is greater, '00' if not. Each sum and difference is saturated to 16 bits before
                   the compare, and the compare operation is a signed halfword compare.
       Rxx.H3             Rxx.H2            Rxx.H1             Rxx.H0               Rxx
                   Rss.H3            Rss.H2             Rss.H1            Rss.H0     Rss
            Rtt.H3            Rtt.H2            Rtt.H1             Rtt.H0            Rtt
             +       -         +       -         +       -          +       -
                                                                                   Rxx,Pd=vacsh(Rss,Rtt)
           sat16   sat16     sat16   sat16     sat16   sat16      sat16   sat16
                                                                        >
                                                     >
                                   >
                                                                      1     0
                 >                                                                    1bit
       16bits                                      1     0
                                 1     0
               1     0
              Rxx.H3            Rxx.H2            Rxx.H1             Rxx.H0                   Pd
                   Syntax                                    Behavior
                    Rxx,Pe=vacsh(Rss,Rtt)                    for (i = 0; i < 4; i++) {
                                                                 xv = (int) Rxx.h[i];
                                                                 sv = (int) Rss.h[i];
                                                                 tv = (int) Rtt.h[i];
                                                                 xv = xv + tv;
                                                                 sv = sv - tv;
                                                                 Pe.i*2 = (xv > sv);
                                                                 Pe.i*2+1 = (xv > sv);
                                                                 Rxx.h[i]=sat_16(max(xv,sv));
                                                             }
80-N2040-45 Rev. B                                                                                              421
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■   The predicate generated by this instruction cannot be used as a .new predicate, nor
                            can it be automatically AND’d with another predicate.
                        ■   If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7 6   5  4 3 2  1 0
   ICLASS     RegType      MajOp        s5        Parse          t5         e2       x5
 1  1  1  0 1  0   1  0  1  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0 e    e x x x  x x Rxx,Pe=vacsh(Rss,Rtt)
                  Field name         Description
                  ICLASS             Instruction Class
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  RegType            Register Type
                  Parse              Packet/Loop parse bits
                  e2                 Field to encode register e
                  s5                 Field to encode register s
                  t5                 Field to encode register t
                  x5                 Field to encode register x
80-N2040-45 Rev. B                                                                                                422
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector add halfwords
                  Add each of the four halfwords in 64-bit vector Rss to the corresponding halfword in
                  vector Rtt.
                  Optionally saturate each 16-bit addition to either a signed or unsigned 16-bit value.
                  Applying saturation to the vaddh instruction clamps the result to the signed range 0x8000
                  to 0x7fff, whereas applying saturation to the vadduh instruction ensures that the unsigned
                  result falls within the range 0 to 0xffff. When saturation is not needed, use the vaddh form.
                  For the 32-bit version of this vector operation, see the ALU32 instructions.
                   Syntax                                   Behavior
                   Rdd=vaddh(Rss,Rtt)[:sat]                 for (i=0;i<4;i++) {
                                                                 Rdd.h[i]=[sat_16](Rss.h[i]+Rtt.h[i]);
                                                            }
                   Rdd=vadduh(Rss,Rtt):sat                  for (i=0;i<4;i++) {
                                                                 Rdd.h[i]=usat_16(Rss.uh[i]+Rtt.uh[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vaddh(Rss,Rtt)                       Word64 Q6_P_vaddh_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vaddh(Rss,Rtt):sat                   Word64 Q6_P_vaddh_PP_sat(Word64 Rss, Word64 Rtt)
                   Rdd=vadduh(Rss,Rtt):sat                  Word64 Q6_P_vadduh_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1  0  0  0  s  s  s  s  s  P   P -  t   t  t t  t 0   1  0 d d d  d d Rdd=vaddh(Rss,Rtt)
 1  1  0  1 0  0   1  1  0  0  0  s  s  s  s  s  P   P -  t   t  t t  t 0   1  1 d d d  d d Rdd=vaddh(Rss,Rtt):sat
 1  1  0  1 0  0   1  1  0  0  0  s  s  s  s  s  P   P -  t   t  t t  t 1   0  0 d d d  d d Rdd=vadduh(Rss,Rtt):sat
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
80-N2040-45 Rev. B                                                                                                423
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
80-N2040-45 Rev. B                                                    424
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector add halfwords with saturate and pack to unsigned bytes
                  Add the four 16-bit halfwords of Rss to the four 16-bit halfwords of Rtt. The results are
                  saturated to unsigned 8-bits and packed in destination register Rd.
                   Syntax                                   Behavior
                   Rd=vaddhub(Rss,Rtt):sat                  for (i=0;i<4;i++) {
                                                                 Rd.b[i]=usat_8(Rss.h[i]+Rtt.h[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=vaddhub(Rss,Rtt):sat                  Word32 Q6_R_vaddhub_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS     RegType     Maj          s5        Parse          t5       Min        d5
 1  1  0  0 0  0   0  1  0  1  -  s  s  s  s  s  P   P -  t   t  t t  t 0  0 1 d  d d  d d Rd=vaddhub(Rss,Rtt):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              425
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Vector reduce add unsigned bytes
                  For each byte in the source vector Rss, add the corresponding byte in the source vector Rtt.
                  Add the four upper intermediate results and optionally the upper word of the destination.
                  Add the four lower results and optionally the lower word of the destination.
                                                                                             Rss
                                                                                             Rtt
                         +       +          +     +        +       +         +    +
                                     32bit Add                        32bit Add
                                                                                             Rdd
                   Syntax                              Behavior
                   Rdd=vraddub(Rss,Rtt)                Rdd = 0;
                                                       for (i=0;i<4;i++) {
                                                             Rdd.w[0]=(Rdd.w[0] + (Rss.ub[i]+Rtt.ub[i]));
                                                       }
                                                       for (i=4;i<8;i++) {
                                                             Rdd.w[1]=(Rdd.w[1] + (Rss.ub[i]+Rtt.ub[i]));
                                                       }
                   Rxx+=vraddub(Rss,Rtt)               for (i = 0; i < 4; i++) {
                                                             Rxx.w[0]=(Rxx.w[0] + (Rss.ub[i]+Rtt.ub[i]));
                                                       }
                                                       for (i = 4; i < 8; i++) {
                                                             Rxx.w[1]=(Rxx.w[1] + (Rss.ub[i]+Rtt.ub[i]));
                                                       }
                                                       ;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vraddub(Rss,Rtt)                Word64 Q6_P_vraddub_PP(Word64 Rss, Word64 Rtt)
                   Rxx+=vraddub(Rss,Rtt)               Word64 Q6_P_vraddubacc_PP(Word64 Rxx, Word64
                                                       Rss, Word64 Rtt)
80-N2040-45 Rev. B                                                                                           426
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  0 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rdd=vraddub(Rss,Rtt)
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  0   1  0 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x  x x x Rxx+=vraddub(Rss,Rtt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               427
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector reduce add halfwords
                  For each halfword in the source vector Rss, add the corresponding halfword in the source
                  vector Rtt. Add these intermediate results together, and place the result in Rd.
                                                                                              Rss
                                                                                              Rtt
                              +                 +                  +               +
                                                      +
                                                                          Rd
                   Syntax                                   Behavior
                   Rd=vraddh(Rss,Rtt)                       Rd = 0;
                                                            for (i=0;i<4;i++) {
                                                                 Rd += (Rss.h[i]+Rtt.h[i]);
                                                            }
                   Rd=vradduh(Rss,Rtt)                      Rd = 0;
                                                            for (i=0;i<4;i++) {
                                                                 Rd += (Rss.uh[i]+Rtt.uh[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=vraddh(Rss,Rtt)                       Word32 Q6_R_vraddh_PP(Word64 Rss, Word64 Rtt)
                   Rd=vradduh(Rss,Rtt)                      Word32 Q6_R_vradduh_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5       Parse           t5        MinOp      d5
 1  1  1  0 1  0   0  1 0   -   - s  s  s  s  s P   P 0   t   t  t t  t -   0  1 d d d  d d Rd=vradduh(Rss,Rtt)
 1  1  1  0 1  0   0  1 0   -  1  s  s  s  s  s P   P 0   t   t  t t  t 1   1  1 d d d  d d Rd=vraddh(Rss,Rtt)
80-N2040-45 Rev. B                                                                                              428
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
80-N2040-45 Rev. B                                                    429
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector add bytes
                  Add each of the eight bytes in 64-bit vector Rss to the corresponding byte in vector Rtt.
                  Optionally, saturate each 8-bit addition to an unsigned value between 0 and 255. The eight
                  results are stored in destination register Rdd.
                   Syntax                                   Behavior
                   Rdd=vaddb(Rss,Rtt)                       Assembler mapped to: "Rdd=vaddub(Rss,Rtt)"
                   Rdd=vaddub(Rss,Rtt)[:sat]                for (i = 0; i < 8; i++) {
                                                                 Rdd.b[i]=[usat_8](Rss.ub[i]+Rtt.ub[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vaddb(Rss,Rtt)                       Word64 Q6_P_vaddb_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vaddub(Rss,Rtt)                      Word64 Q6_P_vaddub_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vaddub(Rss,Rtt):sat                  Word64 Q6_P_vaddub_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1  0 0   0  s  s  s  s  s  P   P -  t   t  t t  t 0   0  0 d d d  d d Rdd=vaddub(Rss,Rtt)
 1  1  0  1 0  0   1  1  0 0   0  s  s  s  s  s  P   P -  t   t  t t  t 0   0  1 d d d  d d Rdd=vaddub(Rss,Rtt):sat
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                               430
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector add words
                  Add each of the two words in 64-bit vector Rss to the corresponding word in vector Rtt.
                  Optionally, saturate each 32-bit addition to a signed value between 0x80000000 and
                  0x7fffffff. The two word results are stored in destination register Rdd.
                   Syntax                                   Behavior
                   Rdd=vaddw(Rss,Rtt)[:sat]                 for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=[sat_32](Rss.w[i]+Rtt.w[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vaddw(Rss,Rtt)                       Word64 Q6_P_vaddw_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vaddw(Rss,Rtt):sat                   Word64 Q6_P_vaddw_PP_sat(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1  0 0   0  s  s  s  s  s  P   P -  t   t  t t  t 1   0  1 d d d  d d Rdd=vaddw(Rss,Rtt)
 1  1  0  1 0  0   1  1  0 0   0  s  s  s  s  s  P   P -  t   t  t t  t 1   1  0 d d d  d d Rdd=vaddw(Rss,Rtt):sat
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                               431
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
        Vector average halfwords
                  Average each of the four halfwords in the 64-bit source vector Rss with the corresponding
                  halfword in Rtt. The average operation performed on each halfword adds the two
                  halfwords and shifts the result right by 1 bit. Unsigned average uses a logical right shift
                  (shift in 0), whereas signed average uses an arithmetic right shift (shift in the sign bit). If
                  using the round option, a 0x0001 is also added to each result before shifting. This
                  operation does not overflow. In the case that a summation (before right shift by 1) causes
                  an overflow of 32 bits, the value shifted in is the most-significant carry out.
                  The signed average and negative average halfwords is available with optional convergent
                  rounding. In convergent rounding, if the two LSBs after the addition/subtraction are 11, a
                  rounding constant of 1 is added, otherwise a 0 is added. This result is then shifted right by
                  one bit. Convergent rounding accumulates less error than arithmetic rounding.
                   Syntax                                Behavior
                   Rdd=vavgh(Rss,Rtt)                    for (i=0;i<4;i++) {
                                                             Rdd.h[i]=(Rss.h[i]+Rtt.h[i])>>1;
                                                         }
                   Rdd=vavgh(Rss,Rtt):crnd               for (i=0;i<4;i++) {
                                                             Rdd.h[i]=convround(Rss.h[i]+Rtt.h[i])>>1;
                                                         }
                   Rdd=vavgh(Rss,Rtt):rnd                for (i=0;i<4;i++) {
                                                             Rdd.h[i]=(Rss.h[i]+Rtt.h[i]+1)>>1;
                                                         }
                   Rdd=vavguh(Rss,Rtt)                   for (i=0;i<4;i++) {
                                                             Rdd.h[i]=(Rss.uh[i]+Rtt.uh[i])>>1;
                                                         }
                   Rdd=vavguh(Rss,Rtt):rnd               for (i=0;i<4;i++) {
                                                             Rdd.h[i]=(Rss.uh[i]+Rtt.uh[i]+1)>>1;
                                                         }
                   Rdd=vnavgh(Rtt,Rss)                   for (i=0;i<4;i++) {
                                                             Rdd.h[i]=(Rtt.h[i]-Rss.h[i])>>1;
                                                         }
                   Rdd=vnavgh(Rtt,Rss):crnd:sat          for (i=0;i<4;i++) {
                                                             Rdd.h[i]=sat_16(convround(Rtt.h[i]-
                                                         Rss.h[i])>>1);
                                                         }
                   Rdd=vnavgh(Rtt,Rss):rnd:sat           for (i=0;i<4;i++) {
                                                             Rdd.h[i]=sat_16((Rtt.h[i]-Rss.h[i]+1)>>1);
                                                         }
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■    If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                               432
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                  Intrinsics
                   Rdd=vavgh(Rss,Rtt)                       Word64 Q6_P_vavgh_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vavgh(Rss,Rtt):crnd                  Word64 Q6_P_vavgh_PP_crnd(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vavgh(Rss,Rtt):rnd                   Word64 Q6_P_vavgh_PP_rnd(Word64 Rss, Word64 Rtt)
                   Rdd=vavguh(Rss,Rtt)                      Word64 Q6_P_vavguh_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vavguh(Rss,Rtt):rnd                  Word64 Q6_P_vavguh_PP_rnd(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vnavgh(Rtt,Rss)                      Word64 Q6_P_vnavgh_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vnavgh(Rtt,Rss):crnd:sat             Word64 Q6_P_vnavgh_PP_crnd_sat(Word64 Rtt,
                                                            Word64 Rss)
                   Rdd=vnavgh(Rtt,Rss):rnd:sat              Word64 Q6_P_vnavgh_PP_rnd_sat(Word64 Rtt, Word64
                                                            Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5  4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp       d5
 1  1  0  1 0  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t  0   1  0  d d d  d d Rdd=vavgh(Rss,Rtt)
 1  1  0  1 0  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t  0   1  1  d d d  d d Rdd=vavgh(Rss,Rtt):rnd
 1  1  0  1 0  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t  1   0  0  d d d  d d Rdd=vavgh(Rss,Rtt):crnd
 1  1  0  1 0  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t  1   0  1  d d d  d d Rdd=vavguh(Rss,Rtt)
 1  1  0  1 0  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t  1   1   - d d d  d d Rdd=vavguh(Rss,Rtt):rnd
 1  1  0  1 0  0   1  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t  0   0  0  d d d  d d Rdd=vnavgh(Rtt,Rss)
                                                                                             Rdd=vnavgh(Rtt,Rss):rnd:s
 1  1  0  1 0  0   1  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t  0   0  1  d d d  d d at
 1  1  0  1 0  0   1  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t  0   1  0  d d d  d d Rdd=vnavgh(Rtt,Rss):crnd:
                                                                                             sat
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                 433
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector average unsigned bytes
                  Average each of the eight unsigned bytes in the 64-bit source vector Rss with the
                  corresponding byte in Rtt. The average operation performed on each byte is the sum of the
                  two bytes shifted right by 1 bit. If using the round option, a 0x01 is also added to each
                  result before shifting. This operation does not overflow. In the case that a summation
                  (before right shift by 1) causes an overflow of 8 bits, the value shifted in is the most-
                  significant carry out.
                   Syntax                                   Behavior
                   Rdd=vavgub(Rss,Rtt)                      for (i = 0; i < 8; i++) {
                                                                 Rdd.b[i]=((Rss.ub[i] + Rtt.ub[i])>>1);
                                                            }
                   Rdd=vavgub(Rss,Rtt):rnd                  for (i = 0; i < 8; i++) {
                                                                 Rdd.b[i]=((Rss.ub[i]+Rtt.ub[i]+1)>>1);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vavgub(Rss,Rtt)                      Word64 Q6_P_vavgub_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vavgub(Rss,Rtt):rnd                  Word64 Q6_P_vavgub_PP_rnd(Word64 Rss, Word64
                                                            Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t  t 0   0  0 d d d  d d Rdd=vavgub(Rss,Rtt)
 1  1  0  1 0  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t  t 0   0  1 d d d  d d Rdd=vavgub(Rss,Rtt):rnd
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                434
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Vector average words
                  Average each of the two words in the 64-bit source vector Rss with the corresponding
                  word in Rtt. The average operation performed on each halfword adds the two words and
                  shifts the result right by 1 bit. Unsigned average uses a logical right shift (shift in 0),
                  whereas signed average uses an arithmetic right shift (shift in the sign bit). If using the
                  round option, a 0x1 is also added to each result before shifting. This operation does not
                  overflow. In the case that a summation (before right shift by 1) causes an overflow of 32
                  bits, the value shifted in is the most-significant carry out.
                  The signed average and negative average words is available with optional convergent
                  rounding. In convergent rounding, if the two LSBs after the addition/subtraction are 11, a
                  rounding constant of 1 is added, otherwise a 0 is added. This result is then shifted right by
                  one bit. Convergent rounding accumulates less error than arithmetic rounding.
                   Syntax                                Behavior
                   Rdd=vavguw(Rss,Rtt)[:rnd]             for (i=0;i<2;i++) {
                                                               Rdd.w[i]=(zxt32->33(Rss.uw[i])+zxt32-
                                                         >33 (Rtt.uw[i])+1)>>1;
                                                         }
                   Rdd=vavgw(Rss,Rtt):crnd               for (i=0;i<2;i++) {
                                                               Rdd.w[i]=(convround(sxt32->33(Rss.w[i])+sxt32-
                                                         >33(Rtt.w[i]))>>1);
                                                         }
                   Rdd=vavgw(Rss,Rtt)[:rnd]              for (i=0;i<2;i++) {
                                                               Rdd.w[i]=(sxt32->33(Rss.w[i])+sxt32-
                                                         >33(Rtt.w[i])+1)>>1;
                                                         }
                   Rdd=vnavgw(Rtt,Rss)                   for (i=0;i<2;i++) {
                                                               Rdd.w[i]=(sxt32->33(Rtt.w[i])-sxt32-
                                                         >33(Rss.w[i]))>>1;
                                                         }
                   Rdd=vnavgw(Rtt,Rss):crnd:sat          for (i=0;i<2;i++) {
                                                               Rdd.w[i]=sat_32(convround(sxt32-
                                                         >33 (Rtt.w[i])-sxt 32->33(Rss.w[i]))>>1);
                                                         }
                   Rdd=vnavgw(Rtt,Rss):rnd:sat           for (i=0;i<2;i++) {
                                                               Rdd.w[i]=sat_32((sxt32->33(Rtt.w[i])-sxt32-
                                                         >33(Rss.w[i])+1)>>1);
                                                         }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                              435
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                  Intrinsics
                   Rdd=vavguw(Rss,Rtt)                      Word64 Q6_P_vavguw_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vavguw(Rss,Rtt):rnd                  Word64 Q6_P_vavguw_PP_rnd(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vavgw(Rss,Rtt)                       Word64 Q6_P_vavgw_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vavgw(Rss,Rtt):crnd                  Word64 Q6_P_vavgw_PP_crnd(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vavgw(Rss,Rtt):rnd                   Word64 Q6_P_vavgw_PP_rnd(Word64 Rss, Word64 Rtt)
                   Rdd=vnavgw(Rtt,Rss)                      Word64 Q6_P_vnavgw_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vnavgw(Rtt,Rss):crnd:sat             Word64 Q6_P_vnavgw_PP_crnd_sat(Word64 Rtt,
                                                            Word64 Rss)
                   Rdd=vnavgw(Rtt,Rss):rnd:sat              Word64 Q6_P_vnavgw_PP_rnd_sat(Word64 Rtt, Word64
                                                            Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5  4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp       d5
 1  1  0  1 0  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t  0   0  0  d d d  d d Rdd=vavgw(Rss,Rtt)
 1  1  0  1 0  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t  0   0  1  d d d  d d Rdd=vavgw(Rss,Rtt):rnd
 1  1  0  1 0  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t  0   1  0  d d d  d d Rdd=vavgw(Rss,Rtt):crnd
 1  1  0  1 0  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t  0   1  1  d d d  d d Rdd=vavguw(Rss,Rtt)
 1  1  0  1 0  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t  1   0  0  d d d  d d Rdd=vavguw(Rss,Rtt):rnd
 1  1  0  1 0  0   1  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t  0   1  1  d d d  d d Rdd=vnavgw(Rtt,Rss)
                                                                                             Rdd=vnavgw(Rtt,Rss):rnd:s
 1  1  0  1 0  0   1  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t  1   0   - d d d  d d at
 1  1  0  1 0  0   1  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t  1   1   - d d d  d d Rdd=vnavgw(Rtt,Rss):crnd:
                                                                                             sat
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                 436
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector clip to unsigned
                  Clip input to unsigned int
                   Syntax                                   Behavior
                   Rdd=vclip(Rss,#u5)                       tmp=MIN((1<<#u)-1,MAX(Rss.w[0],-(1<<#u)));
                                                            Rdd.w[0]=tmp;
                                                            tmp=MIN((1<<#u)-1,MAX(Rss.w[1],-(1<<#u)));
                                                            Rdd.w[1]=tmp;
                                                            ;
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  This instruction can only execute on a core with the Hexagon audio extensions
                  Intrinsics
                   Rdd=vclip(Rss,#u5)                       Word64 Q6_P_vclip_PI(Word64 Rss, Word32 Iu5)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 1  0   0  0  1 1  0   s  s  s  s  s  P   P 0  i   i i  i i 1   1  0 d d d  d d Rdd=vclip(Rss,#u5)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              437
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Vector compare and compute minimum bytes
                  Compare each of the eight unsigned bytes in the 64-bit source vector Rss to the
                  corresponding byte in Rtt. For each comparison, select the minimum of the two bytes and
                  place that byte in the corresponding location in Rdd.
                   Syntax                                    Behavior
                   Rdd,Pe=vminub(Rtt,Rss)                    for (i = 0; i < 8; i++) {
                                                                  Pe.i = (Rtt.ub[i] > Rss.ub[i]);
                                                                  Rdd.b[i]=min(Rtt.ub[i],Rss.ub[i]);
                                                             }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■   The predicate generated by this instruction cannot be used as a .new predicate, nor
                            can it be automatically AND’d with another predicate.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6   5  4 3 2  1 0
   ICLASS     RegType      MajOp        s5        Parse          t5           e2       d5
 1  1  1  0 1  0   1  0  1  1   1  s  s  s  s  s  P   P 0  t   t  t t  t 0  e    e d d d  d d Rdd,Pe=vminub(Rtt,Rss)
                  Field name         Description
                  ICLASS             Instruction Class
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  RegType            Register Type
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  e2                 Field to encode register e
                  s5                 Field to encode register s
                  t5                 Field to encode register t
80-N2040-45 Rev. B                                                                                                 438
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector conditional negate
                  Based on bits in Rt, conditionally negate halves in Rss.
                   Syntax                                   Behavior
                   Rdd=vcnegh(Rss,Rt)                       for (i = 0; i < 4; i++) {
                                                                 if (Rt.i) {
                                                                     Rdd.h[i]=sat_16(-Rss.h[i]);
                                                                 } else {
                                                                     Rdd.h[i]=Rss.h[i];
                                                                 }
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vcnegh(Rss,Rt)                       Word64 Q6_P_vcnegh_PR(Word64 Rss, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS     RegType     Maj          s5        Parse          t5       Min        d5
 1  1  0  0 0  0   1  1  1  1  -  s  s  s  s  s  P   P -  t   t  t t  t 0  1 - d  d d  d d Rdd=vcnegh(Rss,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              439
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Vector maximum bytes
                  Compare each of the eight unsigned bytes in the 64-bit source vector Rss to the
                  corresponding byte in Rtt. For each comparison, select the maximum of the two bytes and
                  place that byte in the corresponding location in Rdd.
                   Syntax                                   Behavior
                   Rdd=vmaxb(Rtt,Rss)                       for (i = 0; i < 8; i++) {
                                                                 Rdd.b[i]=max(Rtt.b[i],Rss.b[i]);
                                                            }
                   Rdd=vmaxub(Rtt,Rss)                      for (i = 0; i < 8; i++) {
                                                                 Rdd.b[i]=max(Rtt.ub[i],Rss.ub[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vmaxb(Rtt,Rss)                       Word64 Q6_P_vmaxb_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vmaxub(Rtt,Rss)                      Word64 Q6_P_vmaxub_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t  t 0   0  0 d d d  d d Rdd=vmaxub(Rtt,Rss)
 1  1  0  1 0  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t  t 1   1  0 d d d  d d Rdd=vmaxb(Rtt,Rss)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              440
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Vector maximum halfwords
                  Compare each of the four halfwords in the 64-bit source vector Rss to the corresponding
                  halfword in Rtt. For each comparison, select the maximum of the two halfwords and place
                  that halfword in the corresponding location in Rdd. Comparisons are available in both
                  signed and unsigned form.
                   Syntax                                   Behavior
                   Rdd=vmaxh(Rtt,Rss)                       for (i = 0; i < 4; i++) {
                                                                 Rdd.h[i]=max(Rtt.h[i],Rss.h[i]);
                                                            }
                   Rdd=vmaxuh(Rtt,Rss)                      for (i = 0; i < 4; i++) {
                                                                 Rdd.h[i]=max(Rtt.uh[i],Rss.uh[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vmaxh(Rtt,Rss)                       Word64 Q6_P_vmaxh_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vmaxuh(Rtt,Rss)                      Word64 Q6_P_vmaxuh_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t  t 0   0  1 d d d  d d Rdd=vmaxh(Rtt,Rss)
 1  1  0  1 0  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t  t 0   1  0 d d d  d d Rdd=vmaxuh(Rtt,Rss)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              441
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector reduce maximum halfwords
                  Register Rxx contains a maximum value in the low word and the address of that maximum
                  value in the high word. Register Rss contains a vector of four halfword values, and register
                  Ru contains the address of this data. The instruction finds the maximum halfword between
                  the previous maximum in Rxx[0] and the four values in Rss. The address of the new
                  maximum is stored in Rxx[1].
                   Syntax                                  Behavior
                   Rxx=vrmaxh(Rss,Ru)                       max = Rxx.h[0];
                                                            addr = Rxx.w[1];
                                                            for (i = 0; i < 4; i++) {
                                                                 if (max < Rss.h[i]) {
                                                                     max = Rss.h[i];
                                                                     addr = Ru | i<<1;
                                                                 }
                                                            }
                                                            Rxx.w[0]=max;
                                                            Rxx.w[1]=addr;
                   Rxx=vrmaxuh(Rss,Ru)                      max = Rxx.uh[0];
                                                            addr = Rxx.w[1];
                                                            for (i = 0; i < 4; i++) {
                                                                 if (max < Rss.uh[i]) {
                                                                     max = Rss.uh[i];
                                                                     addr = Ru | i<<1;
                                                                 }
                                                            }
                                                            Rxx.w[0]=max;
                                                            Rxx.w[1]=addr;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rxx=vrmaxh(Rss,Ru)                       Word64 Q6_P_vrmaxh_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Ru)
                   Rxx=vrmaxuh(Rss,Ru)                      Word64 Q6_P_vrmaxuh_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Ru)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3  2  1 0
   ICLASS     RegType    Maj           s5        Parse          x5       Min         u5
 1  1  0  0 1  0   1  1 0  0  1   s  s  s  s  s  P   P 0  x   x x  x  x 0  0 1  u u  u  u u Rxx=vrmaxh(Rss,Ru)
 1  1  0  0 1  0   1  1 0  0  1   s  s  s  s  s  P   P 1  x   x x  x  x 0  0 1  u u  u  u u Rxx=vrmaxuh(Rss,Ru)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                              442
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  u5           Field to encode register u
                  x5           Field to encode register x
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    443
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector reduce maximum words
                  Find the maximum word between the previous maximum in Rxx[0] and the two values in
                  Rss. The address of the new maximum is stored in Rxx[1].
                  Register Rxx contains a maximum value in the low word and the address of that maximum
                  value in the high word. Register Rss contains a vector of two word values, and register Ru
                  contains the address of this data.
                   Syntax                                  Behavior
                   Rxx=vrmaxuw(Rss,Ru)                      max = Rxx.uw[0];
                                                            addr = Rxx.w[1];
                                                            for (i = 0; i < 2; i++) {
                                                                 if (max < Rss.uw[i]) {
                                                                     max = Rss.uw[i];
                                                                     addr = Ru | i<<2;
                                                                 }
                                                            }
                                                            Rxx.w[0]=max;
                                                            Rxx.w[1]=addr;
                   Rxx=vrmaxw(Rss,Ru)                       max = Rxx.w[0];
                                                            addr = Rxx.w[1];
                                                            for (i = 0; i < 2; i++) {
                                                                 if (max < Rss.w[i]) {
                                                                     max = Rss.w[i];
                                                                     addr = Ru | i<<2;
                                                                 }
                                                            }
                                                            Rxx.w[0]=max;
                                                            Rxx.w[1]=addr;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rxx=vrmaxuw(Rss,Ru)                      Word64 Q6_P_vrmaxuw_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Ru)
                   Rxx=vrmaxw(Rss,Ru)                       Word64 Q6_P_vrmaxw_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Ru)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3  2  1 0
   ICLASS     RegType    Maj           s5        Parse          x5       Min         u5
 1  1  0  0 1  0   1  1 0  0  1   s  s  s  s  s  P   P 0  x   x x  x  x 0  1 0  u u  u  u u Rxx=vrmaxw(Rss,Ru)
 1  1  0  0 1  0   1  1 0  0  1   s  s  s  s  s  P   P 1  x   x x  x  x 0  1 0  u u  u  u u Rxx=vrmaxuw(Rss,Ru)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                              444
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  u5           Field to encode register u
                  x5           Field to encode register x
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    445
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Vector maximum words
                  Compare each of the two words in the 64-bit source vector Rss to the corresponding word
                  in Rtt. For each comparison, select the maximum of the two words and place that word in
                  the corresponding location in Rdd.
                  Comparisons are available in both signed and unsigned form.
                   Syntax                                   Behavior
                   Rdd=vmaxuw(Rtt,Rss)                      for (i = 0; i < 2; i++) {
                                                                 Rdd.w[i]=max(Rtt.uw[i],Rss.uw[i]);
                                                            }
                   Rdd=vmaxw(Rtt,Rss)                       for (i = 0; i < 2; i++) {
                                                                 Rdd.w[i]=max(Rtt.w[i],Rss.w[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vmaxuw(Rtt,Rss)                      Word64 Q6_P_vmaxuw_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vmaxw(Rtt,Rss)                       Word64 Q6_P_vmaxw_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1 1  0  1   s  s  s  s  s  P   P -  t   t  t t  t 1   0  1 d d d  d d Rdd=vmaxuw(Rtt,Rss)
 1  1  0  1 0  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t  t 0   1  1 d d d  d d Rdd=vmaxw(Rtt,Rss)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              446
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector minimum bytes
                  Compare each of the eight bytes in the 64-bit source vector Rss to the corresponding byte
                  in Rtt. For each comparison, select the minimum of the two bytes and place that byte in the
                  corresponding location in Rdd.
                  Comparisons are available in both signed and unsigned form.
                   Syntax                                   Behavior
                   Rdd=vminb(Rtt,Rss)                       for (i = 0; i < 8; i++) {
                                                                 Rdd.b[i]=min(Rtt.b[i],Rss.b[i]);
                                                            }
                   Rdd=vminub(Rtt,Rss)                      for (i = 0; i < 8; i++) {
                                                                 Rdd.b[i]=min(Rtt.ub[i],Rss.ub[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vminb(Rtt,Rss)                       Word64 Q6_P_vminb_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vminub(Rtt,Rss)                      Word64 Q6_P_vminub_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1 1  0  1   s  s  s  s  s  P   P -  t   t  t t  t 0   0  0 d d d  d d Rdd=vminub(Rtt,Rss)
 1  1  0  1 0  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t  t 1   1  1 d d d  d d Rdd=vminb(Rtt,Rss)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              447
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector minimum halfwords
                  Compare each of the four halfwords in the 64-bit source vector Rss to the corresponding
                  halfword in Rtt. For each comparison, select the minimum of the two halfwords and place
                  that halfword in the corresponding location in Rdd.
                  Comparisons are available in both signed and unsigned form.
                   Syntax                                   Behavior
                   Rdd=vminh(Rtt,Rss)                       for (i = 0; i < 4; i++) {
                                                                 Rdd.h[i]=min(Rtt.h[i],Rss.h[i]);
                                                            }
                   Rdd=vminuh(Rtt,Rss)                      for (i = 0; i < 4; i++) {
                                                                 Rdd.h[i]=min(Rtt.uh[i],Rss.uh[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vminh(Rtt,Rss)                       Word64 Q6_P_vminh_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vminuh(Rtt,Rss)                      Word64 Q6_P_vminuh_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1 1  0  1   s  s  s  s  s  P   P -  t   t  t t  t 0   0  1 d d d  d d Rdd=vminh(Rtt,Rss)
 1  1  0  1 0  0   1  1 1  0  1   s  s  s  s  s  P   P -  t   t  t t  t 0   1  0 d d d  d d Rdd=vminuh(Rtt,Rss)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              448
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector reduce minimum halfwords
                  Find the minimum halfword between the previous minimum in Rxx[0] and the four values
                  in Rss. The address of the new minimum is stored in Rxx[1].
                  Register Rxx contains a minimum value in the low word and the address of that minimum
                  value in the high word. Register Rss contains a vector of four halfword values, and register
                  Ru contains the address of this data.
                   Syntax                                  Behavior
                   Rxx=vrminh(Rss,Ru)                       min = Rxx.h[0];
                                                            addr = Rxx.w[1];
                                                            for (i = 0; i < 4; i++) {
                                                                 if (min > Rss.h[i]) {
                                                                     min = Rss.h[i];
                                                                     addr = Ru | i<<1;
                                                                 }
                                                            }
                                                            Rxx.w[0]=min;
                                                            Rxx.w[1]=addr;
                   Rxx=vrminuh(Rss,Ru)                      min = Rxx.uh[0];
                                                            addr = Rxx.w[1];
                                                            for (i = 0; i < 4; i++) {
                                                                 if (min > Rss.uh[i]) {
                                                                     min = Rss.uh[i];
                                                                     addr = Ru | i<<1;
                                                                 }
                                                            }
                                                            Rxx.w[0]=min;
                                                            Rxx.w[1]=addr;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rxx=vrminh(Rss,Ru)                       Word64 Q6_P_vrminh_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Ru)
                   Rxx=vrminuh(Rss,Ru)                      Word64 Q6_P_vrminuh_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Ru)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3  2  1 0
   ICLASS     RegType    Maj           s5        Parse          x5       Min         u5
 1  1  0  0 1  0   1  1 0  0  1   s  s  s  s  s  P   P 0  x   x x  x  x 1  0 1  u u  u  u u Rxx=vrminh(Rss,Ru)
 1  1  0  0 1  0   1  1 0  0  1   s  s  s  s  s  P   P 1  x   x x  x  x 1  0 1  u u  u  u u Rxx=vrminuh(Rss,Ru)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                              449
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  u5           Field to encode register u
                  x5           Field to encode register x
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    450
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector reduce minimum words
                  Find the minimum word between the previous minimum in Rxx[0] and the two values in
                  Rss. The address of the new minimum is stored in Rxx[1].
                  Register Rxx contains a minimum value in the low word and the address of that minimum
                  value in the high word. Register Rss contains a vector of two word values, and register Ru
                  contains the address of this data.
                   Syntax                                  Behavior
                   Rxx=vrminuw(Rss,Ru)                      min = Rxx.uw[0];
                                                            addr = Rxx.w[1];
                                                            for (i = 0; i < 2; i++) {
                                                                 if (min > Rss.uw[i]) {
                                                                     min = Rss.uw[i];
                                                                     addr = Ru | i<<2;
                                                                 }
                                                            }
                                                            Rxx.w[0]=min;
                                                            Rxx.w[1]=addr;
                   Rxx=vrminw(Rss,Ru)                       min = Rxx.w[0];
                                                            addr = Rxx.w[1];
                                                            for (i = 0; i < 2; i++) {
                                                                 if (min > Rss.w[i]) {
                                                                     min = Rss.w[i];
                                                                     addr = Ru | i<<2;
                                                                 }
                                                            }
                                                            Rxx.w[0]=min;
                                                            Rxx.w[1]=addr;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rxx=vrminuw(Rss,Ru)                      Word64 Q6_P_vrminuw_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Ru)
                   Rxx=vrminw(Rss,Ru)                       Word64 Q6_P_vrminw_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Ru)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3  2  1 0
   ICLASS     RegType    Maj           s5        Parse          x5       Min         u5
 1  1  0  0 1  0   1  1 0  0  1   s  s  s  s  s  P   P 0  x   x x  x  x 1  1 0  u u  u  u u Rxx=vrminw(Rss,Ru)
 1  1  0  0 1  0   1  1 0  0  1   s  s  s  s  s  P   P 1  x   x x  x  x 1  1 0  u u  u  u u Rxx=vrminuw(Rss,Ru)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                              451
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  u5           Field to encode register u
                  x5           Field to encode register x
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    452
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector minimum words
                  Compare each of the two words in the 64-bit source vector Rss to the corresponding word
                  in Rtt. For each comparison, select the minimum of the two words and place that word in
                  the corresponding location in Rdd.
                  Comparisons are available in both signed and unsigned form.
                   Syntax                                   Behavior
                   Rdd=vminuw(Rtt,Rss)                      for (i = 0; i < 2; i++) {
                                                                 Rdd.w[i]=min(Rtt.uw[i],Rss.uw[i]);
                                                            }
                   Rdd=vminw(Rtt,Rss)                       for (i = 0; i < 2; i++) {
                                                                 Rdd.w[i]=min(Rtt.w[i],Rss.w[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vminuw(Rtt,Rss)                      Word64 Q6_P_vminuw_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vminw(Rtt,Rss)                       Word64 Q6_P_vminw_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1 1  0  1   s  s  s  s  s  P   P -  t   t  t t  t 0   1  1 d d d  d d Rdd=vminw(Rtt,Rss)
 1  1  0  1 0  0   1  1 1  0  1   s  s  s  s  s  P   P -  t   t  t t  t 1   0  0 d d d  d d Rdd=vminuw(Rtt,Rss)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              453
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Vector reduce conditional negate
                  Based on bits in Rt, conditionally negate halves in Rss and accumulate.
                   Syntax                                   Behavior
                   Rxx+=vrcnegh(Rss,Rt)                     for (i = 0; i < 4; i++) {
                                                                 if (Rt.i) {
                                                                     Rxx += -Rss.h[i];
                                                                 } else {
                                                                     Rxx += Rss.h[i];
                                                                 }
                                                            }
                                                            ;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rxx+=vrcnegh(Rss,Rt)                     Word64 Q6_P_vrcneghacc_PR(Word64 Rxx, Word64
                                                            Rss, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS     RegType    Maj           s5        Parse          t5       Min        x5
 1  1  0  0 1  0   1  1 0  0  1   s  s  s  s  s  P   P 1  t   t  t t  t 1  1 1  x x x  x x Rxx+=vrcnegh(Rss,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              454
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Vector sum of absolute differences unsigned bytes
                  For each byte in the source vector Rss, subtract the corresponding byte in source vector
                  Rtt. Take the absolute value of the intermediate results, and the upper four together and
                  add the lower four together. Optionally, add the destination upper and lower words to these
                  results.
                  This instruction is useful in determining distance between two vectors, in applications
                  such as motion estimation.
                                                                                             Rss
                                                                                             Rtt
                        sad     sad       sad     sad     sad     sad      sad     sad
                                     32bit Add                        32bit Add
                                                                                             Rdd
                   Syntax                               Behavior
                   Rdd=vrsadub(Rss,Rtt)                 Rdd = 0;
                                                        for (i = 0; i < 4; i++) {
                                                            Rdd.w[0]=(Rdd.w[0] + ABS((Rss.ub[i] -
                                                        Rtt.ub[i])));
                                                        }
                                                        for (i = 4; i < 8; i++) {
                                                            Rdd.w[1]=(Rdd.w[1] + ABS((Rss.ub[i] -
                                                        Rtt.ub[i])));
                                                        }
                   Rxx+=vrsadub(Rss,Rtt)                for (i = 0; i < 4; i++) {
                                                            Rxx.w[0]=(Rxx.w[0] + ABS((Rss.ub[i] -
                                                        Rtt.ub[i])));
                                                        }
                                                        for (i = 4; i < 8; i++) {
                                                            Rxx.w[1]=(Rxx.w[1] + ABS((Rss.ub[i] -
                                                        Rtt.ub[i])));
                                                        }
                                                        ;
80-N2040-45 Rev. B                                                                                           455
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vrsadub(Rss,Rtt)                     Word64 Q6_P_vrsadub_PP(Word64 Rss, Word64 Rtt)
                   Rxx+=vrsadub(Rss,Rtt)                    Word64 Q6_P_vrsadubacc_PP(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  0 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  0 d d d  d d Rdd=vrsadub(Rss,Rtt)
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  0   1  0 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  0 x x  x x x Rxx+=vrsadub(Rss,Rtt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               456
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector subtract halfwords
                  Subtract each of the four halfwords in 64-bit vector Rss from the corresponding halfword
                  in vector Rtt.
                  Optionally, saturate each 16-bit addition to either a signed or unsigned 16-bit value.
                  Applying saturation to the vsubh instruction clamps the result to the signed range 0x8000
                  to 0x7fff, whereas applying saturation to the vsubuh instruction ensures that the unsigned
                  result falls within the range 0 to 0xffff.
                  When saturation is not needed, use vsubh.
                   Syntax                                   Behavior
                   Rdd=vsubh(Rtt,Rss)[:sat]                 for (i=0;i<4;i++) {
                                                                 Rdd.h[i]=[sat_16](Rtt.h[i]-Rss.h[i]);
                                                            }
                   Rdd=vsubuh(Rtt,Rss):sat                  for (i=0;i<4;i++) {
                                                                 Rdd.h[i]=usat_16(Rtt.uh[i]-Rss.uh[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vsubh(Rtt,Rss)                       Word64 Q6_P_vsubh_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vsubh(Rtt,Rss):sat                   Word64 Q6_P_vsubh_PP_sat(Word64 Rtt, Word64 Rss)
                   Rdd=vsubuh(Rtt,Rss):sat                  Word64 Q6_P_vsubuh_PP_sat(Word64 Rtt, Word64
                                                            Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1  0 0   1  s  s  s  s  s  P   P -  t   t  t t  t 0   1  0 d d d  d d Rdd=vsubh(Rtt,Rss)
 1  1  0  1 0  0   1  1  0 0   1  s  s  s  s  s  P   P -  t   t  t t  t 0   1  1 d d d  d d Rdd=vsubh(Rtt,Rss):sat
 1  1  0  1 0  0   1  1  0 0   1  s  s  s  s  s  P   P -  t   t  t t  t 1   0  0 d d d  d d Rdd=vsubuh(Rtt,Rss):sat
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
80-N2040-45 Rev. B                                                                                                457
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
80-N2040-45 Rev. B                                                    458
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector subtract bytes
                  Subtract each of the eight bytes in 64-bit vector Rss from the corresponding byte in vector
                  Rtt.
                  Optionally, saturate each 8-bit subtraction to an unsigned value between 0 and 255. The
                  eight results are stored in destination register Rdd.
                   Syntax                                   Behavior
                   Rdd=vsubb(Rss,Rtt)                       Assembler mapped to: "Rdd=vsubub(Rss,Rtt)"
                   Rdd=vsubub(Rtt,Rss)[:sat]                for (i = 0; i < 8; i++) {
                                                                 Rdd.b[i]=[usat_8](Rtt.ub[i]-Rss.ub[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vsubb(Rss,Rtt)                       Word64 Q6_P_vsubb_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vsubub(Rtt,Rss)                      Word64 Q6_P_vsubub_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vsubub(Rtt,Rss):sat                  Word64 Q6_P_vsubub_PP_sat(Word64 Rtt, Word64
                                                            Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1  0 0   1  s  s  s  s  s  P   P -  t   t  t t  t 0   0  0 d d d  d d Rdd=vsubub(Rtt,Rss)
 1  1  0  1 0  0   1  1  0 0   1  s  s  s  s  s  P   P -  t   t  t t  t 0   0  1 d d d  d d Rdd=vsubub(Rtt,Rss):sat
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                459
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector subtract words
                  Subtract each of the two words in 64-bit vector Rss from the corresponding word in vector
                  Rtt.
                  Optionally, saturate each 32-bit subtraction to a signed value between 0x8000_0000 and
                  0x7fff_ffff. The two word results are stored in destination register Rdd.
                   Syntax                                   Behavior
                   Rdd=vsubw(Rtt,Rss)[:sat]                 for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=[sat_32](Rtt.w[i]-Rss.w[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vsubw(Rtt,Rss)                       Word64 Q6_P_vsubw_PP(Word64 Rtt, Word64 Rss)
                   Rdd=vsubw(Rtt,Rss):sat                   Word64 Q6_P_vsubw_PP_sat(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType                  s5        Parse          t5        MinOp      d5
 1  1  0  1 0  0   1  1  0 0   1  s  s  s  s  s  P   P -  t   t  t t  t 1   0  1 d d d  d d Rdd=vsubw(Rtt,Rss)
 1  1  0  1 0  0   1  1  0 0   1  s  s  s  s  s  P   P -  t   t  t t  t 1   1  0 d d d  d d Rdd=vsubw(Rtt,Rss):sat
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                               460
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
  11.10.2         XTYPE/BIT
                  The XTYPE/BIT instruction subclass includes instructions for bit manipulation.
        Count leading
                  Count leading zeros (cl0) counts the number of consecutive zeros starting with the most
                  significant bit.
                  Count leading ones (cl1) counts the number of consecutive ones starting with the most
                  significant bit.
                  Count leading bits (clb) counts both leading ones and leading zeros and then selects the
                  maximum.
                  The NORMAMT instruction returns the number of leading bits minus one.
                  For a two's-complement number, the number of leading zeros is zero for negative
                  numbers. The number of leading ones is zero for positive numbers.
                  Use the number of leading bits to judge the magnitude of the value.
                   Syntax                              Behavior
                   Rd=add(clb(Rs),#s6)                 Rd =
                                                       (max(count_leading_ones(Rs),count_leading_ones(~
                                                       Rs)))+#s;
                   Rd=add(clb(Rss),#s6)                Rd =
                                                       (max(count_leading_ones(Rss),count_leading_ones(
                                                       ~Rss)))+#s;
                   Rd=cl0(Rs)                          Rd = count_leading_ones(~Rs);
                   Rd=cl0(Rss)                         Rd = count_leading_ones(~Rss);
                   Rd=cl1(Rs)                          Rd = count_leading_ones(Rs);
80-N2040-45 Rev. B                                                                                         461
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                   Syntax                                   Behavior
                   Rd=cl1(Rss)                              Rd = count_leading_ones(Rss);
                   Rd=clb(Rs)                               Rd =
                                                            max(count_leading_ones(Rs),count_leading_ones(~R
                                                            s));
                   Rd=clb(Rss)                              Rd =
                                                            max(count_leading_ones(Rss),count_leading_ones(~
                                                            Rss));
                   Rd=normamt(Rs)                           if (Rs == 0) {
                                                                 Rd = 0;
                                                            } else {
                                                                 Rd =
                                                            (max(count_leading_ones(Rs),count_leading_ones(~
                                                            Rs)))-1;
                                                            }
                   Rd=normamt(Rss)                          if (Rss == 0) {
                                                                 Rd = 0;
                                                            } else {
                                                                 Rd =
                                                            (max(count_leading_ones(Rss),count_leading_ones(
                                                            ~Rss)))-1;
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=add(clb(Rs),#s6)                      Word32 Q6_R_add_clb_RI(Word32 Rs, Word32 Is6)
                   Rd=add(clb(Rss),#s6)                     Word32 Q6_R_add_clb_PI(Word64 Rss, Word32 Is6)
                   Rd=cl0(Rs)                               Word32 Q6_R_cl0_R(Word32 Rs)
                   Rd=cl0(Rss)                              Word32 Q6_R_cl0_P(Word64 Rss)
                   Rd=cl1(Rs)                               Word32 Q6_R_cl1_R(Word32 Rs)
                   Rd=cl1(Rss)                              Word32 Q6_R_cl1_P(Word64 Rss)
                   Rd=clb(Rs)                               Word32 Q6_R_clb_R(Word32 Rs)
                   Rd=clb(Rss)                              Word32 Q6_R_clb_P(Word64 Rss)
                   Rd=normamt(Rs)                           Word32 Q6_R_normamt_R(Word32 Rs)
                   Rd=normamt(Rss)                          Word32 Q6_R_normamt_P(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7  6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5       Parse                     MinOp      d5
 1  0  0  0 1  0   0  0 0  1  0   s  s  s  s  s P   P  -  -   - -  -  - 0   0  0 d d d  d d Rd=clb(Rss)
 1  0  0  0 1  0   0  0 0  1  0   s  s  s  s  s P   P  -  -   - -  -  - 0   1  0 d d d  d d Rd=cl0(Rss)
 1  0  0  0 1  0   0  0 0  1  0   s  s  s  s  s P   P  -  -   - -  -  - 1   0  0 d d d  d d Rd=cl1(Rss)
 1  0  0  0 1  0   0  0 0  1  1   s  s  s  s  s P   P  -  -   - -  -  - 0   0  0 d d d  d d Rd=normamt(Rss)
 1  0  0  0 1  0   0  0 0  1  1   s  s  s  s  s P   P  i  i   i i  i  i 0   1  0 d d d  d d Rd=add(clb(Rss),#s6)
80-N2040-45 Rev. B                                                                                               462
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
 1  0 0  0  1  1   0 0  0  0  1   s  s  s  s  s  P  P  i  i  i  i i i 0 0 0 d d d d d Rd=add(clb(Rs),#s6)
 1  0 0  0  1  1   0 0  0  0  0   s  s  s  s  s  P  P  -  -  -  - - - 1 0 0 d d d d d Rd=clb(Rs)
 1  0 0  0  1  1   0 0  0  0  0   s  s  s  s  s  P  P  -  -  -  - - - 1 0 1 d d d d d Rd=cl0(Rs)
 1  0 0  0  1  1   0 0  0  0  0   s  s  s  s  s  P  P  -  -  -  - - - 1 1 0 d d d d d Rd=cl1(Rs)
 1  0 0  0  1  1   0 0  0  0  0   s  s  s  s  s  P  P  -  -  -  - - - 1 1 1 d d d d d Rd=normamt(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                        463
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Count population
                  Population Count (popcount) counts the number of bits in Rss that are set.
                   Syntax                                   Behavior
                   Rd=popcount(Rss)                         Rd = count_ones(Rss);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=popcount(Rss)                         Word32 Q6_R_popcount_P(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 1  0   0  0 0  1  1   s  s  s  s  s  P   P -  -   - -  - - 0   1  1 d d d  d d Rd=popcount(Rss)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                             464
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Count trailing
                  Count trailing zeros (ct0) counts the number of consecutive zeros starting with the least
                  significant bit.
                  Count trailing ones (ct1) counts the number of consecutive ones starting with the least
                  significant bit.
                   Syntax                                   Behavior
                   Rd=ct0(Rs)                               Rd = count_leading_ones(~reverse_bits(Rs));
                   Rd=ct0(Rss)                              Rd = count_leading_ones(~reverse_bits(Rss));
                   Rd=ct1(Rs)                               Rd = count_leading_ones(reverse_bits(Rs));
                   Rd=ct1(Rss)                              Rd = count_leading_ones(reverse_bits(Rss));
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=ct0(Rs)                               Word32 Q6_R_ct0_R(Word32 Rs)
                   Rd=ct0(Rss)                              Word32 Q6_R_ct0_P(Word64 Rss)
                   Rd=ct1(Rs)                               Word32 Q6_R_ct1_R(Word32 Rs)
                   Rd=ct1(Rss)                              Word32 Q6_R_ct1_P(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 1  0   0  0 1  1  1   s  s  s  s  s  P   P -  -   - -  - - 0   1  0 d d d  d d Rd=ct0(Rss)
 1  0  0  0 1  0   0  0 1  1  1   s  s  s  s  s  P   P -  -   - -  - - 1   0  0 d d d  d d Rd=ct1(Rss)
 1  0  0  0 1  1   0  0 0  1  0   s  s  s  s  s  P   P -  -   - -  - - 1   0  0 d d d  d d Rd=ct0(Rs)
 1  0  0  0 1  1   0  0 0  1  0   s  s  s  s  s  P   P -  -   - -  - - 1   0  1 d d d  d d Rd=ct1(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                             465
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
        Extract bitfield
                  Extract a bitfield from the source register (or register pair) and deposit into the least
                  significant bits of the destination register (or register pair). The other, more significant bits
                  in the destination are either cleared or sign-extended, depending on the instruction.
                  The width of the extracted field is obtained from the first immediate or from the most-
                  significant word of Rtt. The field offset is obtained from either the second immediate or
                  from the least-significant word of Rtt.
                  For register-based extract, where Rtt supplies the offset and width, the offset value is
                  treated as a signed 7-bit number. If this value is negative, the source register Rss is shifted
                  left (the reverse direction). Width number of bits are then taken from the least-significant
                  portion of this result.
                  If the shift amount and/or offset captures data beyond the most significant end of the input,
                  these bits are taken as zero.
                                                           Width                   Offset
                                                                                                    Rs
                                                                                                   Rd
                                       Zero Extension
                   Syntax                                Behavior
                   Rd=extract(Rs,#u5,#U5)                 width=#u;
                                                          offset=#U;
                                                          Rd = sxtwidth->32((Rs >> offset));
                   Rd=extract(Rs,Rtt)                     width=zxt6->32((Rtt.w[1]));
                                                          offset=sxt7->32((Rtt.w[0]));
                                                          Rd = sxtwidth->64((offset>0)?(zxt32->64(zxt32-
                                                          >64(Rs))>>>offset):(zxt32->64(zxt32-
                                                          >64(Rs))<<offset));
                   Rd=extractu(Rs,#u5,#U5)                width=#u;
                                                          offset=#U;
                                                          Rd = zxtwidth->32((Rs >> offset));
80-N2040-45 Rev. B                                                                                               466
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                   Syntax                                   Behavior
                   Rd=extractu(Rs,Rtt)                      width=zxt6->32((Rtt.w[1]));
                                                            offset=sxt7->32((Rtt.w[0]));
                                                            Rd = zxtwidth->64((offset>0)?(zxt32->64(zxt32-
                                                            >64(Rs))>>>offset):(zxt32->64(zxt32-
                                                            >64(Rs))<<offset));
                   Rdd=extract(Rss,#u6,#U6)                 width=#u;
                                                            offset=#U;
                                                            Rdd = sxtwidth->64((Rss >> offset));
                   Rdd=extract(Rss,Rtt)                     width=zxt6->32((Rtt.w[1]));
                                                            offset=sxt7->32((Rtt.w[0]));
                                                            Rdd = sxtwidth-
                                                            >64((offset>0)?(Rss>>>offset):(Rss<<offset));
                   Rdd=extractu(Rss,#u6,#U6)                width=#u;
                                                            offset=#U;
                                                            Rdd = zxtwidth->64((Rss >> offset));
                   Rdd=extractu(Rss,Rtt)                    width=zxt6->32((Rtt.w[1]));
                                                            offset=sxt7->32((Rtt.w[0]));
                                                            Rdd = zxtwidth-
                                                            >64((offset>0)?(Rss>>>offset):(Rss<<offset));
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=extract(Rs,#u5,#U5)                   Word32 Q6_R_extract_RII(Word32 Rs, Word32 Iu5,
                                                            Word32 IU5)
                   Rd=extract(Rs,Rtt)                       Word32 Q6_R_extract_RP(Word32 Rs, Word64 Rtt)
                   Rd=extractu(Rs,#u5,#U5)                  Word32 Q6_R_extractu_RII(Word32 Rs, Word32 Iu5,
                                                            Word32 IU5)
                   Rd=extractu(Rs,Rtt)                      Word32 Q6_R_extractu_RP(Word32 Rs, Word64 Rtt)
                   Rdd=extract(Rss,#u6,#U6)                 Word64 Q6_P_extract_PII(Word64 Rss, Word32 Iu6,
                                                            Word32 IU6)
                   Rdd=extract(Rss,Rtt)                     Word64 Q6_P_extract_PP(Word64 Rss, Word64 Rtt)
                   Rdd=extractu(Rss,#u6,#U6)                Word64 Q6_P_extractu_PII(Word64 Rss, Word32 Iu6,
                                                            Word32 IU6)
                   Rdd=extractu(Rss,Rtt)                    Word64 Q6_P_extractu_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5  4 3 2  1 0
   ICLASS     RegType   MajOp          s5       Parse                     MinOp       d5
                                                                                             Rdd=extractu(Rss,#u6,#U6
 1  0  0  0 0  0   0  1  I  I  I  s  s  s  s  s P   P  i  i   i  i i  i I    I  I d d d  d d )
 1  0  0  0 1  0   1  0  I  I  I  s  s  s  s  s P   P  i  i   i  i i  i I    I  I d d d  d d Rdd=extract(Rss,#u6,#U6)
 1  0  0  0 1  1   0  1 0   I  I  s  s  s  s  s P   P 0   i   i  i i  i I    I  I d d d  d d Rd=extractu(Rs,#u5,#U5)
 1  0  0  0 1  1   0  1 1   I  I  s  s  s  s  s P   P 0   i   i  i i  i I    I  I d d d  d d Rd=extract(Rs,#u5,#U5)
80-N2040-45 Rev. B                                                                                                 467
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5 4 3 2  1 0
   ICLASS     RegType    Maj           s5        Parse          t5      Min       d5
 1  1  0  0 0  0   0  1 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  0 - d d d  d d Rdd=extractu(Rss,Rtt)
 1  1  0  0 0  0   0  1 1  1   -  s  s  s  s  s  P   P -  t   t  t t t 1  0 - d d d  d d Rdd=extract(Rss,Rtt)
 1  1  0  0 1  0   0  1 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  0 - d d d  d d Rd=extractu(Rs,Rtt)
 1  1  0  0 1  0   0  1 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  1 - d d d  d d Rd=extract(Rs,Rtt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                             468
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
        Insert bitfield
                  Replace a bitfield in the destination register (or register pair) with bits from the least
                  significant portion of Rs/Rss. The number of bits is obtained from the first immediate or
                  the most-significant word of Rtt. The bits are shifted by the second immediate or the least
                  significant word of Rtt.
                  If register Rtt specifies the offset, the low 7-bits of Rtt are treated as a signed 7-bit value. If
                  this value is negative, the result is zero.
                  Shift amounts and offsets that are too large can push bits beyond the end of the destination
                  register, in this case the bits do not appear in the destination register.
                                                                                   Width
                                                                                                    Rs
                                                                                        Offset
                                                                                                    Rd
                                    Unchanged                                       Unchanged
                   Syntax                                  Behavior
                   Rx=insert(Rs,#u5,#U5)                   width=#u;
                                                           offset=#U;
                                                           Rx &= ~(((1<<width)-1)<<offset);
                                                           Rx |= ((Rs & ((1<<width)-1)) << offset);
                   Rx=insert(Rs,Rtt)                       width=zxt6->32((Rtt.w[1]));
                                                           offset=sxt7->32((Rtt.w[0]));
                                                           mask = ((1<<width)-1);
                                                           if (offset < 0) {
                                                               Rx = 0;
                                                           } else {
                                                               Rx &= ~(mask<<offset);
                                                               Rx |= ((Rs & mask) << offset);
                                                           }
                   Rxx=insert(Rss,#u6,#U6)                 width=#u;
                                                           offset=#U;
                                                           Rxx &= ~(((1<<width)-1)<<offset);
                                                           Rxx |= ((Rss & ((1<<width)-1)) << offset);
80-N2040-45 Rev. B                                                                                                 469
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                   Syntax                                   Behavior
                   Rxx=insert(Rss,Rtt)                      width=zxt6->32((Rtt.w[1]));
                                                            offset=sxt7->32((Rtt.w[0]));
                                                            mask = ((1<<width)-1);
                                                            if (offset < 0) {
                                                                 Rxx = 0;
                                                            } else {
                                                                 Rxx &= ~(mask<<offset);
                                                                 Rxx |= ((Rss & mask) << offset);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx=insert(Rs,#u5,#U5)                    Word32 Q6_R_insert_RII(Word32 Rx, Word32 Rs,
                                                            Word32 Iu5, Word32 IU5)
                   Rx=insert(Rs,Rtt)                        Word32 Q6_R_insert_RP(Word32 Rx, Word32 Rs,
                                                            Word64 Rtt)
                   Rxx=insert(Rss,#u6,#U6)                  Word64 Q6_P_insert_PII(Word64 Rxx, Word64 Rss,
                                                            Word32 Iu6, Word32 IU6)
                   Rxx=insert(Rss,Rtt)                      Word64 Q6_P_insert_PP(Word64 Rxx, Word64 Rss,
                                                            Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5  4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                    MinOp       x5
 1  0  0  0 0  0   1  1  I   I I  s  s  s  s  s  P   P i  i   i  i i  i I    I  I x x x  x x Rxx=insert(Rss,#u6,#U6)
 1  0  0  0 1  1   1  1 0    I I  s  s  s  s  s  P   P 0  i   i  i i  i I    I  I x x x  x x Rx=insert(Rs,#u5,#U5)
   ICLASS     RegType                  s5        Parse          t5                    x5
 1  1  0  0 1  0   0  0  -  -  -  s  s  s  s  s  P   P -  t   t  t t  t -   -   - x x x  x x Rx=insert(Rs,Rtt)
   ICLASS     RegType     Maj          s5        Parse          t5                    x5
 1  1  0  0 1  0   1  0 0   -  -  s  s  s  s  s  P   P 0  t   t  t t  t -   -   - x x x  x x Rxx=insert(Rss,Rtt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Maj               Major Opcode
                  RegType           Register Type
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                                 470
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          Interleave/deinterleave
                   For interleave, bits I+32 of Rss (which are the bits from the upper source word) get placed
                   in the odd bits (I*2)+1 of Rdd, while bits I of Rss (which are the bits from the lower source
                   word) get placed in the even bits (I*2) of Rdd.
                   For deinterleave, the even bits of the source register are placed in the even register of the
                   result pair, and the odd bits of the source register are placed in the odd register of the result
                   pair.
                   "r1:0 = deinterleave(r1:0)" is the inverse of "r1:0 = interleave(r1:0)".
                   Syntax                                    Behavior
                    Rdd=deinterleave(Rss)                    Rdd = deinterleave(ODD,EVEN);
                    Rdd=interleave(Rss)                      Rdd = interleave(Rss.w[1],Rss.w[0]);
                   Class: XTYPE (slots 2,3)
                   Intrinsics
                    Rdd=deinterleave(Rss)                    Word64 Q6_P_deinterleave_P(Word64 Rss)
                    Rdd=interleave(Rss)                      Word64 Q6_P_interleave_P(Word64 Rss)
                   Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3   2 1  0
   ICLASS      RegType   MajOp          s5        Parse                   MinOp       d5
 1  0  0   0 0  0   0  0 1  1   0 s   s  s  s  s  P   P -  -   - -  - - 1   0  0 d d   d d  d Rdd=deinterleave(Rss)
 1  0  0   0 0  0   0  0 1  1   0 s   s  s  s  s  P   P -  -   - -  - - 1   0  1 d d   d d  d Rdd=interleave(Rss)
                   Field name        Description
                   ICLASS            Instruction Class
                   Parse             Packet/Loop parse bits
                   d5                Field to encode register d
                   s5                Field to encode register s
                   MajOp             Major Opcode
                   MinOp             Minor Opcode
                   RegType           Register Type
80-N2040-45 Rev. B                                                                                                  471
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Linear feedback-shift iteration
                  Count the number of ones of the logical AND of the two source input values, and take the
                  least significant value of that sum. The first source value is shifted right by one bit, and the
                  parity is placed in the MSB.
                   Syntax                                   Behavior
                   Rdd=lfs(Rss,Rtt)                         Rdd = (Rss.u64 >> 1) | ((1&count_ones(Rss &
                                                            Rtt)).u64<<63) ;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=lfs(Rss,Rtt)                         Word64 Q6_P_lfs_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4  3  2  1  0
   ICLASS     RegType     Maj          s5        Parse          t5      Min         d5
 1  1  0  0 0  0   0  1  1  0  -  s  s  s  s  s  P   P -  t   t  t t t 1  1 0  d  d  d  d  d Rdd=lfs(Rss,Rtt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                                472
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Masked parity
                  Count the number of ones of the logical AND of the two source input values, and take the
                  least significant bit of that sum.
                   Syntax                                   Behavior
                   Rd=parity(Rs,Rt)                         Rd = 1&count_ones(Rs & Rt);
                   Rd=parity(Rss,Rtt)                       Rd = 1&count_ones(Rss & Rtt);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=parity(Rs,Rt)                         Word32 Q6_R_parity_RR(Word32 Rs, Word32 Rt)
                   Rd=parity(Rss,Rtt)                       Word32 Q6_R_parity_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS     RegType                  s5        Parse          t5                 d5
 1  1  0  1 0  0   0  0  -  -  -  s  s  s  s  s  P   P -  t   t  t t t  - -  - d d  d d  d Rd=parity(Rss,Rtt)
 1  1  0  1 0  1   0  1  1 1  1   s  s  s  s  s  P   P -  t   t  t t t  - -  - d d  d d  d Rd=parity(Rs,Rt)
                  Field name        Description
                  RegType           Register Type
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              473
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Bit reverse
                  Reverse the order of bits. The most significant gets swapped with the least significant, bit
                  30 gets swapped with bit 1, and so on.
                   Syntax                                   Behavior
                   Rd=brev(Rs)                              Rd = reverse_bits(Rs);
                   Rdd=brev(Rss)                            Rdd = reverse_bits(Rss);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=brev(Rs)                              Word32 Q6_R_brev_R(Word32 Rs)
                   Rdd=brev(Rss)                            Word64 Q6_P_brev_P(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0 1  1  0   s  s  s  s  s  P   P -  -   - -  - - 1   1  0 d d d  d d Rdd=brev(Rss)
 1  0  0  0 1  1   0  0 0  1  0   s  s  s  s  s  P   P -  -   - -  - - 1   1  0 d d d  d d Rd=brev(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                             474
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          Set/clear/toggle bit
                  Set (to 1), clear (to 0), or toggle a single bit in the source, and place the resulting value in
                  the destination. Indicate the bit to manipulate using an immediate or register value.
                  If a register indicates the bit position, and the value of the least-significant 7 bits of Rt is
                  out of range, the destination register is unchanged.
                   Syntax                                   Behavior
                   Rd=clrbit(Rs,#u5)                        Rd = (Rs & (~(1<<#u)));
                   Rd=clrbit(Rs,Rt)                         Rd = (Rs & (~((sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7-
                                                            >32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt)))));
                   Rd=setbit(Rs,#u5)                        Rd = (Rs | (1<<#u));
                   Rd=setbit(Rs,Rt)                         Rd = (Rs | (sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7-
                                                            >32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt)));
                   Rd=togglebit(Rs,#u5)                     Rd = (Rs ^ (1<<#u));
                   Rd=togglebit(Rs,Rt)                      Rd = (Rs ^ (sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7-
                                                            >32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt)));
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=clrbit(Rs,#u5)                        Word32 Q6_R_clrbit_RI(Word32 Rs, Word32 Iu5)
                   Rd=clrbit(Rs,Rt)                         Word32 Q6_R_clrbit_RR(Word32 Rs, Word32 Rt)
                   Rd=setbit(Rs,#u5)                        Word32 Q6_R_setbit_RI(Word32 Rs, Word32 Iu5)
                   Rd=setbit(Rs,Rt)                         Word32 Q6_R_setbit_RR(Word32 Rs, Word32 Rt)
                   Rd=togglebit(Rs,#u5)                     Word32 Q6_R_togglebit_RI(Word32 Rs, Word32 Iu5)
                   Rd=togglebit(Rs,Rt)                      Word32 Q6_R_togglebit_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5  4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                    MinOp       d5
 1  0  0  0 1  1   0  0  1  1  0  s  s  s  s  s  P   P 0  i   i  i i  i 0   0  0  d d d  d d Rd=setbit(Rs,#u5)
 1  0  0  0 1  1   0  0  1  1  0  s  s  s  s  s  P   P 0  i   i  i i  i 0   0  1  d d d  d d Rd=clrbit(Rs,#u5)
 1  0  0  0 1  1   0  0  1  1  0  s  s  s  s  s  P   P 0  i   i  i i  i 0   1  0  d d d  d d Rd=togglebit(Rs,#u5)
   ICLASS     RegType     Maj          s5        Parse          t5       Min          d5
 1  1  0  0 0  1   1  0  1  0  -  s  s  s  s  s  P   P -  t   t  t t  t 0   0   - d d d  d d Rd=setbit(Rs,Rt)
 1  1  0  0 0  1   1  0  1  0  -  s  s  s  s  s  P   P -  t   t  t t  t 0   1   - d d d  d d Rd=clrbit(Rs,Rt)
 1  1  0  0 0  1   1  0  1  0  -  s  s  s  s  s  P   P -  t   t  t t  t 1   0   - d d d  d d Rd=togglebit(Rs,Rt)
80-N2040-45 Rev. B                                                                                                 475
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
                  RegType      Register Type
80-N2040-45 Rev. B                                                    476
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Split bitfield
                  Split the bitfield in a register into upper and lower parts of variable size. The lower part is
                  placed in the lower word of a destination register pair, and the upper part is placed in the
                  upper word of the destination. An immediate value or register Rt determines the bit
                  position of the split.
                                                                    Bits
                                                                                     Rs
                                                                                                        Rdd[0]
                                                          Zero
                                                                                   Rdd[1]
                    Zero
                   Syntax                                 Behavior
                   Rdd=bitsplit(Rs,#u5)                    Rdd.w[1]=(Rs>>#u);
                                                           Rdd.w[0]=zxt#u->32(Rs);
                   Rdd=bitsplit(Rs,Rt)                     shamt = zxt5->32(Rt);
                                                           Rdd.w[1]=(Rs>>shamt);
                                                           Rdd.w[0]=zxtshamt->32(Rs);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=bitsplit(Rs,#u5)                   Word64 Q6_P_bitsplit_RI(Word32 Rs, Word32 Iu5)
                   Rdd=bitsplit(Rs,Rt)                    Word64 Q6_P_bitsplit_RR(Word32 Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                                              477
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp       d5
 1  0  0  0 1  0   0  0 1  1  0   s  s  s  s  s  P   P 0  i   i  i i i 1   0  0  d d d  d d Rdd=bitsplit(Rs,#u5)
   ICLASS     RegType                  s5        Parse          t5                   d5
 1  1  0  1 0  1   0  0  -  - 1   s  s  s  s  s  P   P -  t   t  t t t -   -   - d d d  d d Rdd=bitsplit(Rs,Rt)
                  Field name        Description
                  RegType           Register Type
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                               478
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
        Table index
                  The table index instruction supports fast lookup tables where the index into the table is
                  stored in a bit-field. The instruction forms the address of a table element by extracting the
                  bit-field and inserting it into the appropriate bits of a pointer to the table element.
                  Tables are defined to contain entries of bytes, halfwords, words, or doublewords. The table
                  must be aligned to a power-of-2 size greater than or equal to the table size. For example, a
                  4Kbyte table should be aligned to a 4Kbyte boundary. This instruction supports tables
                  with a maximum of 32K table entries.
                  Register Rx contains a pointer to within the table. Register Rs contains a field to extract
                  and use as a table index. This instruction first extracts the field from register Rs and then
                  inserts it into register Rx. The insertion point is bit 0 for tables of bytes, bit 1 for tables of
                  halfwords, bit 2 for tables of words, and bit 3 for tables of doublewords.
                  In the assembly syntax, the width and offset values represent the field in Rs to extract. Use
                  unsigned constants to specify the width and offsets in assembly. In the encoded
                  instruction, however, these values are adjusted by the assembler as follows.
                            For tableidxb, no adjustment is necessary.
                            For tableidxh, the assembler encodes offset-1 in the signed immediate field.
                            For tableidxw, the assembler encodes offset-2 in the signed immediate field.
                            For tableidxd, the assembler encodes offset-3 in the signed immediate field.
                                 Rx=TABLEIDXD(Rs,#width,#offset)
                                                           Width                  Offset
                                                                                                    Rs
                                           Unchanged                                                Rx
                                                                                         Unchanged
                   Syntax                                Behavior
                   Rx=tableidxb(Rs,#u4,#S6):raw           width=#u;
                                                          offset=#S;
                                                          field = Rs[(width+offset-1):offset];
                                                          Rx[(width-1+0):0]=field;
                   Rx=tableidxb(Rs,#u4,#U5)               Assembler mapped to:
                                                          "Rx=tableidxb(Rs,#u4,#U5):raw"
80-N2040-45 Rev. B                                                                                                479
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                   Syntax                                   Behavior
                   Rx=tableidxd(Rs,#u4,#S6):raw             width=#u;
                                                            offset=#S+3;
                                                            field = Rs[(width+offset-1):offset];
                                                            Rx[(width-1+3):3]=field;
                   Rx=tableidxd(Rs,#u4,#U5)                 Assembler mapped to: "Rx=tableidxd(Rs,#u4,#U5-
                                                            3):raw"
                   Rx=tableidxh(Rs,#u4,#S6):raw             width=#u;
                                                            offset=#S+1;
                                                            field = Rs[(width+offset-1):offset];
                                                            Rx[(width-1+1):1]=field;
                   Rx=tableidxh(Rs,#u4,#U5)                 Assembler mapped to: "Rx=tableidxh(Rs,#u4,#U5-
                                                            1):raw"
                   Rx=tableidxw(Rs,#u4,#S6):raw             width=#u;
                                                            offset=#S+2;
                                                            field = Rs[(width+offset-1):offset];
                                                            Rx[(width-1+2):2]=field;
                   Rx=tableidxw(Rs,#u4,#U5)                 Assembler mapped to: "Rx=tableidxw(Rs,#u4,#U5-
                                                            2):raw"
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx=tableidxb(Rs,#u4,#U5)                 Word32 Q6_R_tableidxb_RII(Word32 Rx, Word32 Rs,
                                                            Word32 Iu4, Word32 IU5)
                   Rx=tableidxd(Rs,#u4,#U5)                 Word32 Q6_R_tableidxd_RII(Word32 Rx, Word32 Rs,
                                                            Word32 Iu4, Word32 IU5)
                   Rx=tableidxh(Rs,#u4,#U5)                 Word32 Q6_R_tableidxh_RII(Word32 Rx, Word32 Rs,
                                                            Word32 Iu4, Word32 IU5)
                   Rx=tableidxw(Rs,#u4,#U5)                 Word32 Q6_R_tableidxw_RII(Word32 Rx, Word32 Rs,
                                                            Word32 Iu4, Word32 IU5)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7    6  5  4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                    MinOp       x5
                                                                                             Rx=tableidxb(Rs,#u4,#S6):r
 1  0  0  0 0  1   1  1 0  0   i  s  s  s  s  s  P   P I  I   I I  I I  i    i  i x x x  x x aw
 1  0  0  0 0  1   1  1 0  1   i  s  s  s  s  s  P   P I  I   I I  I I  i    i  i x x x  x x Rx=tableidxh(Rs,#u4,#S6):r
                                                                                             aw
 1  0  0  0 0  1   1  1 1  0   i  s  s  s  s  s  P   P I  I   I I  I I  i    i  i x x x  x x Rx=tableidxw(Rs,#u4,#S6):
                                                                                             raw
                                                                                             Rx=tableidxd(Rs,#u4,#S6):r
 1  0  0  0 0  1   1  1 1  1   i  s  s  s  s  s  P   P I  I   I I  I I  i    i  i x x x  x x aw
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-45 Rev. B                                                                                                 480
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  x5           Field to encode register x
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    481
Hexagon V67 Programmer’s Reference Manual                                                 Instruction Set
  11.10.3         XTYPE/COMPLEX
                  The XTYPE/COMPLEX instruction subclass includes instructions which are for complex
                  math, using imaginary values.
        Complex add/sub halfwords
                  Cross vector add-sub or sub-add used to perform X+jY and X-jY complex operations.
                  Each 16-bit result is saturated to 16-bits.
                                 Rdd=vxaddsubh(Rss,Rtt):sat
              I                       R                        I               R            Rss
              I                       R                        I               R             Rtt
                  -                                              -
             +                       +                        +               +
          Sat_16                  Sat_16                   Sat_16           Sat_16
              I                       R                        I               R           Rdd
                            Rdd=vxsubaddh(Rss,Rt):rnd:>>1:sat
             I                        R                       I               R             Rss
             I                        R                       I               R             Rtt
                               -                                         -
    1        +              1        +              1        +         1      +
            >>1                    >>1                      >>1              >>1
                                                                                         Rdd
          Sat_16                  Sat_16                   Sat_16           Sat_16
              I                       R                        I              R
80-N2040-45 Rev. B                                                                                    482
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                   Syntax                                   Behavior
                   Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:          Rdd.h[0]=sat_16((Rss.h[0]+Rtt.h[1]+1)>>1);
                   sat                                      Rdd.h[1]=sat_16((Rss.h[1]-Rtt.h[0]+1)>>1);
                                                            Rdd.h[2]=sat_16((Rss.h[2]+Rtt.h[3]+1)>>1);
                                                            Rdd.h[3]=sat_16((Rss.h[3]-Rtt.h[2]+1)>>1);
                   Rdd=vxaddsubh(Rss,Rtt):sat               Rdd.h[0]=sat_16(Rss.h[0]+Rtt.h[1]);
                                                            Rdd.h[1]=sat_16(Rss.h[1]-Rtt.h[0]);
                                                            Rdd.h[2]=sat_16(Rss.h[2]+Rtt.h[3]);
                                                            Rdd.h[3]=sat_16(Rss.h[3]-Rtt.h[2]);
                   Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:          Rdd.h[0]=sat_16((Rss.h[0]-Rtt.h[1]+1)>>1);
                   sat                                      Rdd.h[1]=sat_16((Rss.h[1]+Rtt.h[0]+1)>>1);
                                                            Rdd.h[2]=sat_16((Rss.h[2]-Rtt.h[3]+1)>>1);
                                                            Rdd.h[3]=sat_16((Rss.h[3]+Rtt.h[2]+1)>>1);
                   Rdd=vxsubaddh(Rss,Rtt):sat               Rdd.h[0]=sat_16(Rss.h[0]-Rtt.h[1]);
                                                            Rdd.h[1]=sat_16(Rss.h[1]+Rtt.h[0]);
                                                            Rdd.h[2]=sat_16(Rss.h[2]-Rtt.h[3]);
                                                            Rdd.h[3]=sat_16(Rss.h[3]+Rtt.h[2]);
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:          Word64 Q6_P_vxaddsubh_PP_rnd_rs1_sat(Word64 Rss,
                   sat                                      Word64 Rtt)
                   Rdd=vxaddsubh(Rss,Rtt):sat               Word64 Q6_P_vxaddsubh_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:          Word64 Q6_P_vxsubaddh_PP_rnd_rs1_sat(Word64 Rss,
                   sat                                      Word64 Rtt)
                   Rdd=vxsubaddh(Rss,Rtt):sat               Word64 Q6_P_vxsubaddh_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6 5 4 3  2  1 0
   ICLASS     RegType     Maj          s5       Parse           t5       Min        d5
 1  1  0  0 0  0   0  1  0  1  -  s  s  s  s  s P   P  -  t   t  t t t  1  0 0 d d  d  d d Rdd=vxaddsubh(Rss,Rtt):s
                                                                                            at
                                                                                            Rdd=vxsubaddh(Rss,Rtt):s
 1  1  0  0 0  0   0  1  0  1  -  s  s  s  s  s P   P  -  t   t  t t t  1  1 0 d d  d  d d at
 1  1  0  0 0  0   0  1  1  1  -  s  s  s  s  s P   P  -  t   t  t t t  0  0 - d d  d  d d Rdd=vxaddsubh(Rss,Rtt):r
                                                                                            nd:>>1:sat
 1  1  0  0 0  0   0  1  1  1  -  s  s  s  s  s P   P  -  t   t  t t t  0  1 - d d  d  d d Rdd=vxsubaddh(Rss,Rtt):r
                                                                                            nd:>>1:sat
80-N2040-45 Rev. B                                                                                               483
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    484
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Complex add/sub words
                  Cross vector add-sub or sub-add used to perform X+jY and X-jY complex operations.
                  Each 32-bit result is saturated to 32-bits.
      Rdd=vxaddsubw(Rss,Rt):sat                                   Rdd=vxsubaddw(Rss,Rt):sat
              I                       R               Rss                I                       R                 Rss
              I                       R               Rtt                I                        R                Rtt
             -                       +                                 +                         -
          Sat_32                   Sat_32                            Sat_32                   Sat_32
              I                       R              Rdd                 I                       R               Rdd
                   Syntax                               Behavior
                   Rdd=vxaddsubw(Rss,Rtt):sat            Rdd.w[0]=sat_32(Rss.w[0]+Rtt.w[1]);
                                                         Rdd.w[1]=sat_32(Rss.w[1]-Rtt.w[0]);
                   Rdd=vxsubaddw(Rss,Rtt):sat            Rdd.w[0]=sat_32(Rss.w[0]-Rtt.w[1]);
                                                         Rdd.w[1]=sat_32(Rss.w[1]+Rtt.w[0]);
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■  If saturation occurs during execution of this instruction (a result is clamped to
                          either maximum or minimum values), the OVF bit in the Status Register is set.
                          OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vxaddsubw(Rss,Rtt):sat           Word64 Q6_P_vxaddsubw_PP_sat(Word64 Rss, Word64
                                                        Rtt)
                   Rdd=vxsubaddw(Rss,Rtt):sat           Word64 Q6_P_vxsubaddw_PP_sat(Word64 Rss, Word64
                                                        Rtt)
80-N2040-45 Rev. B                                                                                             485
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5 4 3 2  1 0
   ICLASS     RegType    Maj           s5        Parse          t5      Min       d5
                                                                                         Rdd=vxaddsubw(Rss,Rtt):s
 1  1  0  0 0  0   0  1 0  1   -  s  s  s  s  s  P   P -  t   t  t t t 0  0 0 d d d  d d
                                                                                         at
 1  1  0  0 0  0   0  1 0  1   -  s  s  s  s  s  P   P -  t   t  t t t 0  1 0 d d d  d d Rdd=vxsubaddw(Rss,Rtt):s
                                                                                         at
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                           486
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Complex multiply
                  Multiply complex values Rs and Rt. The inputs have a real 16-bit value in the low
                  halfword and an imaginary 16-bit value in the high halfword. Optionally, scale the result
                  by 0-1 bits. Optionally, add a complex accumulator. Saturate the real and imaginary
                  portions to 32-bits. The output has a real 32-bit value in the low word and an imaginary
                  32-bit value in the high word. The Rt input can be optionally conjugated. Another option
                  is that the result can be subtracted from the destination rather than accumulated.
                                                   Rxx+=cmpy(Rs,Rt):sat
                    Rs              I               R                    I                R          Rs
                    Rt              I               R                    I                R           Rt
                                      *               *                     *               *
                                        32              32                   32              32
                                    <<0-1            <<0-1               <<0-1            <<0-1
                                                                           -
                                            Add                                   Add
                                           Sat_32                               Sat_32                      32
                           32
                                      Imaginary Accumulation             Real Accumulation
                                                                 Rxx
                   Syntax                                Behavior
                   Rdd=cmpy(Rs,Rt)[:<<1]:sat              Rdd.w[1]=sat_32((Rs.h[1] * Rt.h[0])[<<1] +
                                                          (Rs.h[0] * Rt.h[1])[<<1]);
                                                          Rdd.w[0]=sat_32((Rs.h[0] * Rt.h[0])[<<1] -
                                                          (Rs.h[1] * Rt.h[1])[<<1]);
                   Rdd=cmpy(Rs,Rt*)[:<<1]:sat             Rdd.w[1]=sat_32((Rs.h[1] * Rt.h[0])[<<1] -
                                                          (Rs.h[0] * Rt.h[1])[<<1]);
                                                          Rdd.w[0]=sat_32((Rs.h[0] * Rt.h[0])[<<1] +
                                                          (Rs.h[1] * Rt.h[1])[<<1]);
80-N2040-45 Rev. B                                                                                           487
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Syntax                              Behavior
                   Rxx+=cmpy(Rs,Rt)[:<<1]:sat          Rxx.w[1]=sat_32(Rxx.w[1]     +  (Rs.h[1] *
                                                       Rt.h[0])[<<1] + (Rs.h[0]     *  Rt.h[1])[<<1]);
                                                       Rxx.w[0]=sat_32(Rxx.w[0]     +  (Rs.h[0] *
                                                       Rt.h[0])[<<1] - (Rs.h[1]     *  Rt.h[1])[<<1]);
                                                       ;
                   Rxx+=cmpy(Rs,Rt*)[:<<1]:sat         Rxx.w[1]=sat_32(Rxx.w[1]     +  (Rs.h[1] *
                                                       Rt.h[0])[<<1] - (Rs.h[0]     *  Rt.h[1])[<<1]);
                                                       Rxx.w[0]=sat_32(Rxx.w[0]     +  (Rs.h[0] *
                                                       Rt.h[0])[<<1] + (Rs.h[1]     *  Rt.h[1])[<<1]);
                                                       ;
                   Rxx-=cmpy(Rs,Rt)[:<<1]:sat          Rxx.w[1]=sat_32(Rxx.w[1]     -  ((Rs.h[1] *
                                                       Rt.h[0])[<<1] + (Rs.h[0]     *  Rt.h[1])[<<1]));
                                                       Rxx.w[0]=sat_32(Rxx.w[0]     -  ((Rs.h[0] *
                                                       Rt.h[0])[<<1] - (Rs.h[1]     *  Rt.h[1])[<<1]));
                                                       ;
                   Rxx-=cmpy(Rs,Rt*)[:<<1]:sat         Rxx.w[1]=sat_32(Rxx.w[1]     -  ((Rs.h[1] *
                                                       Rt.h[0])[<<1] - (Rs.h[0]     *  Rt.h[1])[<<1]));
                                                       Rxx.w[0]=sat_32(Rxx.w[0]     -  ((Rs.h[0] *
                                                       Rt.h[0])[<<1] + (Rs.h[1]     *  Rt.h[1])[<<1]));
                                                       ;
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■  If saturation occurs during execution of this instruction (a result is clamped to
                          either maximum or minimum values), the OVF bit in the Status Register is set.
                          OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=cmpy(Rs,Rt):<<1:sat             Word64 Q6_P_cmpy_RR_s1_sat(Word32 Rs, Word32 Rt)
                   Rdd=cmpy(Rs,Rt):sat                 Word64 Q6_P_cmpy_RR_sat(Word32 Rs, Word32 Rt)
                   Rdd=cmpy(Rs,Rt*):<<1:sat            Word64 Q6_P_cmpy_RR_conj_s1_sat(Word32 Rs,
                                                       Word32 Rt)
                   Rdd=cmpy(Rs,Rt*):sat                Word64 Q6_P_cmpy_RR_conj_sat(Word32 Rs, Word32
                                                       Rt)
                   Rxx+=cmpy(Rs,Rt):<<1:sat            Word64 Q6_P_cmpyacc_RR_s1_sat(Word64 Rxx, Word32
                                                       Rs, Word32 Rt)
                   Rxx+=cmpy(Rs,Rt):sat                Word64 Q6_P_cmpyacc_RR_sat(Word64 Rxx, Word32
                                                       Rs, Word32 Rt)
                   Rxx+=cmpy(Rs,Rt*):<<1:sat           Word64 Q6_P_cmpyacc_RR_conj_s1_sat(Word64 Rxx,
                                                       Word32 Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                                             488
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Rxx+=cmpy(Rs,Rt*):sat                    Word64 Q6_P_cmpyacc_RR_conj_sat(Word64 Rxx,
                                                            Word32 Rs, Word32 Rt)
                   Rxx-=cmpy(Rs,Rt):<<1:sat                 Word64 Q6_P_cmpynac_RR_s1_sat(Word64 Rxx, Word32
                                                            Rs, Word32 Rt)
                   Rxx-=cmpy(Rs,Rt):sat                     Word64 Q6_P_cmpynac_RR_sat(Word64 Rxx, Word32
                                                            Rs, Word32 Rt)
                   Rxx-=cmpy(Rs,Rt*):<<1:sat                Word64 Q6_P_cmpynac_RR_conj_s1_sat(Word64 Rxx,
                                                            Word32 Rs, Word32 Rt)
                   Rxx-=cmpy(Rs,Rt*):sat                    Word64 Q6_P_cmpynac_RR_conj_sat(Word64 Rxx,
                                                            Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5 4 3 2  1 0
   ICLASS     RegType    MajOp         s5        Parse          t5       MinOp      d5
 1  1  1  0 0  1   0  1 N 0   0   s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 d d d  d d Rdd=cmpy(Rs,Rt)[:<<N]:sat
 1  1  1  0 0  1   0  1 N 1   0   s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 d d d  d d Rdd=cmpy(Rs,Rt*)[:<<N]:s
                                                                                           at
   ICLASS     RegType    MajOp         s5        Parse          t5       MinOp      x5
 1  1  1  0 0  1   1  1 N 0   0   s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 x x  x x x Rxx+=cmpy(Rs,Rt)[:<<N]:s
                                                                                           at
 1  1  1  0 0  1   1  1 N 0   0   s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 x x  x x x Rxx-
                                                                                           =cmpy(Rs,Rt)[:<<N]:sat
                                                                                           Rxx+=cmpy(Rs,Rt*)[:<<N]:
 1  1  1  0 0  1   1  1 N 1   0   s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 x x  x x x sat
 1  1  1  0 0  1   1  1 N 1   0   s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 x x  x x x Rxx-
                                                                                           =cmpy(Rs,Rt*)[:<<N]:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                                489
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
        Complex multiply real or imaginary
                  Multiply complex values Rs and Rt. The inputs have a real 16-bit value in the low
                  halfword and an imaginary 16-bit value in the high halfword. Take either the real or
                  imaginary result and optionally accumulate with a 64-bit destination.
                                     Rxx+=cmpyi(Rs,Rt)
                                          I              R             Rs
                                          I              R             Rt
                                            *              *
                                              32
                                                            32
                                                  Add
                                                                                              64
                                                                                        Rxx
                                        Imaginary Accumulation
                   Syntax                             Behavior
                   Rdd=cmpyi(Rs,Rt)                   Rdd = (Rs.h[1] * Rt.h[0]) + (Rs.h[0] * Rt.h[1]);
                   Rdd=cmpyr(Rs,Rt)                   Rdd = (Rs.h[0] * Rt.h[0]) - (Rs.h[1] * Rt.h[1]);
                   Rxx+=cmpyi(Rs,Rt)                  Rxx = Rxx + (Rs.h[1] * Rt.h[0]) + (Rs.h[0] *
                                                      Rt.h[1]);
                                                      ;
                   Rxx+=cmpyr(Rs,Rt)                  Rxx = Rxx + (Rs.h[0] * Rt.h[0]) - (Rs.h[1] *
                                                      Rt.h[1]);
                                                      ;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=cmpyi(Rs,Rt)                   Word64 Q6_P_cmpyi_RR(Word32 Rs, Word32 Rt)
                   Rdd=cmpyr(Rs,Rt)                   Word64 Q6_P_cmpyr_RR(Word32 Rs, Word32 Rt)
                   Rxx+=cmpyi(Rs,Rt)                  Word64 Q6_P_cmpyiacc_RR(Word64 Rxx, Word32 Rs,
                                                      Word32 Rt)
                   Rxx+=cmpyr(Rs,Rt)                  Word64 Q6_P_cmpyracc_RR(Word64 Rxx, Word32 Rs,
                                                      Word32 Rt)
80-N2040-45 Rev. B                                                                                         490
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 0  1   0  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rdd=cmpyi(Rs,Rt)
 1  1  1  0 0  1   0  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  0 d d d  d d Rdd=cmpyr(Rs,Rt)
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 0  1   1  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x  x x x Rxx+=cmpyi(Rs,Rt)
 1  1  1  0 0  1   1  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  0 x x  x x x Rxx+=cmpyr(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                            491
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Complex multiply with round and pack
                  Multiply complex values Rs and Rt. The inputs have a real 16-bit value in the low
                  halfword and an imaginary 16-bit value in the high halfword. The Rt input is optionally
                  conjugated. The multiplier results are optionally scaled by 0-1 bits. A rounding constant is
                  added to each real and imaginary sum. The real and imaginary parts are individually
                  saturated to 32bits. The upper 16-bits of each 32-bit results are packed in a 32-bit
                  destination register.
                                                  Rd=cmpy(Rs,Rt):rnd:sat
                    Rs            I                R                    I                R            Rs
                    Rt            I                R                    I                R            Rt
                                    *                *                    *                *
                                       32              32                   32               32
                     0x8000       <<0-1             <<0-1               <<0-1             <<0-1      0x8000
                                                                          -
                                            Add                                  Add
                                          Sat_32                               Sat_32
                                                 High 16bits                High 16bits
                                                        I               R            Rd
                   Syntax                               Behavior
                   Rd=cmpy(Rs,Rt)[:<<1]:rnd:sat          Rd.h[1]=(sat_32((Rs.h[1]    * Rt.h[0])[<<1] +
                                                         (Rs.h[0] * Rt.h[1])[<<1]    + 0x8000)).h[1];
                                                         Rd.h[0]=(sat_32((Rs.h[0]    * Rt.h[0])[<<1] -
                                                         (Rs.h[1] * Rt.h[1])[<<1]    + 0x8000)).h[1];
                   Rd=cmpy(Rs,Rt*)[:<<1]:rnd:sat         Rd.h[1]=(sat_32((Rs.h[1]    * Rt.h[0])[<<1] -
                                                         (Rs.h[0] * Rt.h[1])[<<1]    + 0x8000)).h[1];
                                                         Rd.h[0]=(sat_32((Rs.h[0]    * Rt.h[0])[<<1] +
                                                         (Rs.h[1] * Rt.h[1])[<<1]    + 0x8000)).h[1];
80-N2040-45 Rev. B                                                                                           492
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=cmpy(Rs,Rt):<<1:rnd:sat               Word32 Q6_R_cmpy_RR_s1_rnd_sat(Word32 Rs, Word32
                                                            Rt)
                   Rd=cmpy(Rs,Rt):rnd:sat                   Word32 Q6_R_cmpy_RR_rnd_sat(Word32 Rs, Word32
                                                            Rt)
                   Rd=cmpy(Rs,Rt*):<<1:rnd:sat              Word32 Q6_R_cmpy_RR_conj_s1_rnd_sat(Word32 Rs,
                                                            Word32 Rt)
                   Rd=cmpy(Rs,Rt*):rnd:sat                  Word32 Q6_R_cmpy_RR_conj_rnd_sat(Word32 Rs,
                                                            Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  1   0  1  N 0   1  s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 d d d  d d Rd=cmpy(Rs,Rt)[:<<N]:rnd:
                                                                                            sat
                                                                                            Rd=cmpy(Rs,Rt*)[:<<N]:rnd
 1  1  1  0 1  1   0  1  N 1   1  s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 d d d  d d :sat
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                               493
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Complex multiply 32x16
                  Multiply 32 by 16 bit complex values Rss and Rt. The inputs have a real value in the low
                  part of a register and the imaginary value in the upper part. The multiplier results are
                  scaled by 1 bit and accumulated with a rounding constant. The result is saturated to 32bits.
   Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat                                    Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat
             I                         R              Rss                       I                         R              Rss
                                 I           R        Rt                                      I            R        Rt
                     *                        *                                        *   48
                                                                                                                  *
                         48
                                             48                                                                  48
                                                     0x8000                                                            0x8000
                            <<1       <<1                                                   <<1        <<1
                           -
                                  Add                                                              Add
                                 Sat_32                                                           Sat_32
                               Real result       Rd                                             Imag result         Rd
                   Syntax                               Behavior
                   Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat        Rd = sat_32(( (Rss.w[0] * Rt.h[1]) + (Rss.w[1] *
                                                         Rt.h[0]) + 0x4000)>>15);
                   Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat       Rd = sat_32(( (Rss.w[1] * Rt.h[0]) - (Rss.w[0] *
                                                         Rt.h[1]) + 0x4000)>>15);
                   Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat        Rd = sat_32(( (Rss.w[0] * Rt.h[0]) - (Rss.w[1] *
                                                         Rt.h[1]) + 0x4000)>>15);
                   Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat       Rd = sat_32(( (Rss.w[0] * Rt.h[0]) + (Rss.w[1] *
                                                         Rt.h[1]) + 0x4000)>>15);
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■   If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                              494
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Intrinsics
                   Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat           Word32 Q6_R_cmpyiwh_PR_s1_rnd_sat(Word64 Rss,
                                                            Word32 Rt)
                   Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat          Word32 Q6_R_cmpyiwh_PR_conj_s1_rnd_sat(Word64
                                                            Rss, Word32 Rt)
                   Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat           Word32 Q6_R_cmpyrwh_PR_s1_rnd_sat(Word64 Rss,
                                                            Word32 Rt)
                   Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat          Word32 Q6_R_cmpyrwh_PR_conj_s1_rnd_sat(Word64
                                                            Rss, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS     RegType                  s5        Parse          t5      Min        d5
 1  1  0  0 0  1   0  1  -  -  -  s  s  s  s  s  P   P -  t   t  t t t 1  0 0  d d  d d  d Rd=cmpyiwh(Rss,Rt):<<1:r
                                                                                           nd:sat
 1  1  0  0 0  1   0  1  -  -  -  s  s  s  s  s  P   P -  t   t  t t t 1  0 1  d d  d d  d Rd=cmpyiwh(Rss,Rt*):<<1:
                                                                                           rnd:sat
                                                                                           Rd=cmpyrwh(Rss,Rt):<<1:r
 1  1  0  0 0  1   0  1  -  -  -  s  s  s  s  s  P   P -  t   t  t t t 1  1 0  d d  d d  d nd:sat
 1  1  0  0 0  1   0  1  -  -  -  s  s  s  s  s  P   P -  t   t  t t t 1  1 1  d d  d d  d Rd=cmpyrwh(Rss,Rt*):<<1:
                                                                                           rnd:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              495
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
        Complex multiply real or imaginary 32-bit
                  Multiply complex values Rss and Rtt. The inputs have a real 32-bit value in the low word
                  and an imaginary 32-bit value in the high word. Take either the real or imaginary result
                  and optionally accumulate with a 64-bit destination.
                   Syntax                             Behavior
                   Rd=cmpyiw(Rss,Rtt):<<1:rnd:sat      tmp128 = sxt64->128((Rss.w[0] * Rtt.w[1]));
                                                       acc128 = sxt64->128((Rss.w[1] * Rtt.w[0]));
                                                       const128 = sxt64->128(0x40000000);
                                                       acc128 = tmp128+acc128;
                                                       acc128 = acc128+const128;
                                                       acc128 = (size8s_t) (acc128 >> 31);
                                                       acc64 = sxt128->64(acc128);
                                                       Rd = sat_32(acc64);
                                                       ;
                   Rd=cmpyiw(Rss,Rtt):<<1:sat          tmp128 = sxt64->128((Rss.w[0] * Rtt.w[1]));
                                                       acc128 = sxt64->128((Rss.w[1] * Rtt.w[0]));
                                                       acc128 = tmp128+acc128;
                                                       acc128 = (size8s_t) (acc128 >> 31);
                                                       acc64 = sxt128->64(acc128);
                                                       Rd = sat_32(acc64);
                                                       ;
                   Rd=cmpyiw(Rss,Rtt*):<<1:rnd:sat     tmp128 = sxt64->128((Rss.w[1] * Rtt.w[0]));
                                                       acc128 = sxt64->128((Rss.w[0] * Rtt.w[1]));
                                                       const128 = sxt64->128(0x40000000);
                                                       acc128 = tmp128-acc128;
                                                       acc128 = acc128+const128;
                                                       acc128 = (size8s_t) (acc128 >> 31);
                                                       acc64 = sxt128->64(acc128);
                                                       Rd = sat_32(acc64);
                                                       ;
                   Rd=cmpyiw(Rss,Rtt*):<<1:sat         tmp128 = sxt64->128((Rss.w[1] * Rtt.w[0]));
                                                       acc128 = sxt64->128((Rss.w[0] * Rtt.w[1]));
                                                       acc128 = tmp128-acc128;
                                                       acc128 = (size8s_t) (acc128 >> 31);
                                                       acc64 = sxt128->64(acc128);
                                                       Rd = sat_32(acc64);
                                                       ;
                   Rd=cmpyrw(Rss,Rtt):<<1:rnd:sat      tmp128 = sxt64->128((Rss.w[0] * Rtt.w[0]));
                                                       acc128 = sxt64->128((Rss.w[1] * Rtt.w[1]));
                                                       const128 = sxt64->128(0x40000000);
                                                       acc128 = tmp128-acc128;
                                                       acc128 = acc128+const128;
                                                       acc128 = (size8s_t) (acc128 >> 31);
                                                       acc64 = sxt128->64(acc128);
                                                       Rd = sat_32(acc64);
                                                       ;
                   Rd=cmpyrw(Rss,Rtt):<<1:sat          tmp128 = sxt64->128((Rss.w[0] * Rtt.w[0]));
                                                       acc128 = sxt64->128((Rss.w[1] * Rtt.w[1]));
                                                       acc128 = tmp128-acc128;
                                                       acc128 = (size8s_t) (acc128 >> 31);
                                                       acc64 = sxt128->64(acc128);
                                                       Rd = sat_32(acc64);
                                                       ;
80-N2040-45 Rev. B                                                                                         496
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
                   Syntax                              Behavior
                   Rd=cmpyrw(Rss,Rtt*):<<1:rnd:sat     tmp128 = sxt64->128((Rss.w[0] * Rtt.w[0]));
                                                       acc128 = sxt64->128((Rss.w[1] * Rtt.w[1]));
                                                       const128 = sxt64->128(0x40000000);
                                                       acc128 = tmp128+acc128;
                                                       acc128 = acc128+const128;
                                                       acc128 = (size8s_t) (acc128 >> 31);
                                                       acc64 = sxt128->64(acc128);
                                                       Rd = sat_32(acc64);
                                                       ;
                   Rd=cmpyrw(Rss,Rtt*):<<1:sat         tmp128 = sxt64->128((Rss.w[0] * Rtt.w[0]));
                                                       acc128 = sxt64->128((Rss.w[1] * Rtt.w[1]));
                                                       acc128 = tmp128+acc128;
                                                       acc128 = (size8s_t) (acc128 >> 31);
                                                       acc64 = sxt128->64(acc128);
                                                       Rd = sat_32(acc64);
                                                       ;
                   Rdd=cmpyiw(Rss,Rtt)                 Rdd = ((Rss.w[0] * Rtt.w[1]) + (Rss.w[1] *
                                                       Rtt.w[0]));
                                                       ;
                   Rdd=cmpyiw(Rss,Rtt*)                Rdd = ((Rss.w[1] * Rtt.w[0]) - (Rss.w[0] *
                                                       Rtt.w[1]));
                                                       ;
                   Rdd=cmpyrw(Rss,Rtt)                 Rdd = ((Rss.w[0] * Rtt.w[0]) - (Rss.w[1] *
                                                       Rtt.w[1]));
                                                       ;
                   Rdd=cmpyrw(Rss,Rtt*)                Rdd = ((Rss.w[0] * Rtt.w[0]) + (Rss.w[1] *
                                                       Rtt.w[1]));
                                                       ;
                   Rxx+=cmpyiw(Rss,Rtt)                Rxx += ((Rss.w[0] * Rtt.w[1]) + (Rss.w[1] *
                                                       Rtt.w[0]));
                                                       ;
                                                       ;
                   Rxx+=cmpyiw(Rss,Rtt*)               Rxx += ((Rss.w[1] * Rtt.w[0]) - (Rss.w[0] *
                                                       Rtt.w[1]));
                                                       ;
                                                       ;
                   Rxx+=cmpyrw(Rss,Rtt)                Rxx += ((Rss.w[0] * Rtt.w[0]) - (Rss.w[1] *
                                                       Rtt.w[1]));
                                                       ;
                                                       ;
                   Rxx+=cmpyrw(Rss,Rtt*)               Rxx += ((Rss.w[0] * Rtt.w[0]) + (Rss.w[1] *
                                                       Rtt.w[1]));
                                                       ;
                                                       ;
                  Class: XTYPE (slots 3)
                  Notes
                       ■  This instruction can only execute on a core with the Hexagon audio extensions
                       ■  A packet with this instruction cannot have a slot 2 multiply instruction.
80-N2040-45 Rev. B                                                                                           497
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                        ■   If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=cmpyiw(Rss,Rtt):<<1:rnd:sat           Word32 Q6_R_cmpyiw_PP_s1_rnd_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rd=cmpyiw(Rss,Rtt):<<1:sat               Word32 Q6_R_cmpyiw_PP_s1_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rd=cmpyiw(Rss,Rtt*):<<1:rnd:sat          Word32 Q6_R_cmpyiw_PP_conj_s1_rnd_sat(Word64
                                                            Rss, Word64 Rtt)
                   Rd=cmpyiw(Rss,Rtt*):<<1:sat              Word32 Q6_R_cmpyiw_PP_conj_s1_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rd=cmpyrw(Rss,Rtt):<<1:rnd:sat           Word32 Q6_R_cmpyrw_PP_s1_rnd_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rd=cmpyrw(Rss,Rtt):<<1:sat               Word32 Q6_R_cmpyrw_PP_s1_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rd=cmpyrw(Rss,Rtt*):<<1:rnd:sat          Word32 Q6_R_cmpyrw_PP_conj_s1_rnd_sat(Word64
                                                            Rss, Word64 Rtt)
                   Rd=cmpyrw(Rss,Rtt*):<<1:sat              Word32 Q6_R_cmpyrw_PP_conj_s1_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rdd=cmpyiw(Rss,Rtt)                      Word64 Q6_P_cmpyiw_PP(Word64 Rss, Word64 Rtt)
                   Rdd=cmpyiw(Rss,Rtt*)                     Word64 Q6_P_cmpyiw_PP_conj(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=cmpyrw(Rss,Rtt)                      Word64 Q6_P_cmpyrw_PP(Word64 Rss, Word64 Rtt)
                   Rdd=cmpyrw(Rss,Rtt*)                     Word64 Q6_P_cmpyrw_PP_conj(Word64 Rss, Word64
                                                            Rtt)
                   Rxx+=cmpyiw(Rss,Rtt)                     Word64 Q6_P_cmpyiwacc_PP(Word64 Rxx, Word64 Rss,
                                                            Word64 Rtt)
                   Rxx+=cmpyiw(Rss,Rtt*)                    Word64 Q6_P_cmpyiwacc_PP_conj(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                   Rxx+=cmpyrw(Rss,Rtt)                     Word64 Q6_P_cmpyrwacc_PP(Word64 Rxx, Word64 Rss,
                                                            Word64 Rtt)
                   Rxx+=cmpyrw(Rss,Rtt*)                    Word64 Q6_P_cmpyrwacc_PP_conj(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5 4 3 2  1 0
   ICLASS     RegType      MajOp        s5      Parse           t5        MinOp      d5
 1  1  1  0 1  0   0  0  0  1   1  s s  s  s  s P   P 0   t   t  t t t  0   1  0 d d d  d d Rdd=cmpyiw(Rss,Rtt)
 1  1  1  0 1  0   0  0  1  0   0  s s  s  s  s P   P 0   t   t  t t t  0   1  0 d d d  d d Rdd=cmpyrw(Rss,Rtt)
 1  1  1  0 1  0   0  0  1  1   0  s s  s  s  s P   P 0   t   t  t t t  0   1  0 d d d  d d Rdd=cmpyrw(Rss,Rtt*)
 1  1  1  0 1  0   0  0  1  1   1  s s  s  s  s P   P 0   t   t  t t t  0   1  0 d d d  d d Rdd=cmpyiw(Rss,Rtt*)
 1  1  1  0 1  0   0  1  0  0   0  s s  s  s  s P   P 0   t   t  t t t  1   0  0 d d d  d d Rd=cmpyiw(Rss,Rtt*):<<1:s
                                                                                             at
                                                                                             Rd=cmpyiw(Rss,Rtt):<<1:s
 1  1  1  0 1  0   0  1  0  0   1  s s  s  s  s P   P 0   t   t  t t t  0   0  0 d d d  d d at
80-N2040-45 Rev. B                                                                                                498
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
                                                                                           Rd=cmpyrw(Rss,Rtt):<<1:s
 1  1  1  0 1  0   0  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d
                                                                                           at
                                                                                           Rd=cmpyrw(Rss,Rtt*):<<1:
 1  1  1  0 1  0   0  1 0  1   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d
                                                                                           sat
                                                                                           Rd=cmpyiw(Rss,Rtt*):<<1:r
 1  1  1  0 1  0   0  1 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t 1   0  0 d d d  d d
                                                                                           nd:sat
                                                                                           Rd=cmpyiw(Rss,Rtt):<<1:rn
 1  1  1  0 1  0   0  1 1  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d d:sat
                                                                                           Rd=cmpyrw(Rss,Rtt):<<1:r
 1  1  1  0 1  0   0  1 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d
                                                                                           nd:sat
 1  1  1  0 1  0   0  1 1  1   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d Rd=cmpyrw(Rss,Rtt*):<<1:r
                                                                                           nd:sat
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  0   1  0 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 x x x  x x Rxx+=cmpyiw(Rss,Rtt*)
 1  1  1  0 1  0   1  0 0  1   1  s  s  s  s  s  P   P 0  t   t  t t t 0   1  0 x x x  x x Rxx+=cmpyiw(Rss,Rtt)
 1  1  1  0 1  0   1  0 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  0 x x x  x x Rxx+=cmpyrw(Rss,Rtt)
 1  1  1  0 1  0   1  0 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  0 x x x  x x Rxx+=cmpyrw(Rss,Rtt*)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               499
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Vector complex multiply real or imaginary
                  The inputs Rss and Rtt are a vector of two complex values. Each complex value is
                  composed of a 16-bit imaginary portion in the upper halfword and a 16-bit real portion in
                  the lower halfword. Generate two complex results, either the real result or the imaginary
                  result. These results are optionally shifted left by 0-1 bits, and optionally accumulated
                  with the destination register.
                                          Rxx+=vcmpyi(Rss,Rtt):sat
                                  I                R                  I               R           Rss
                                  I                R                  I               R            Rtt
                                    *                *                  *                *
                                      32                32               32               32
                                  <<0-1             <<0-1             <<0-1            <<0-1
                                           Add                                Add
                                         Sat_32                             Sat_32                       32
                      32
                                   Imag Accumulation                 Imag Accumulation
                                                            Rxx
                   Syntax                                Behavior
                   Rdd=vcmpyi(Rss,Rtt)[:<<1]:sat         Rdd.w[0]=sat_32((Rss.h[1] * Rtt.h[0]) +
                                                         (Rss.h[0] * Rtt.h[1])[<<1]);
                                                         Rdd.w[1]=sat_32((Rss.h[3] * Rtt.h[2]) +
                                                         (Rss.h[2] * Rtt.h[3])[<<1]);
                                                         ;
                                                         ;
                   Rdd=vcmpyr(Rss,Rtt)[:<<1]:sat         Rdd.w[0]=sat_32((Rss.h[0] * Rtt.h[0]) -
                                                         (Rss.h[1] * Rtt.h[1])[<<1]);
                                                         Rdd.w[1]=sat_32((Rss.h[2] * Rtt.h[2]) -
                                                         (Rss.h[3] * Rtt.h[3])[<<1]);
                                                         ;
                                                         ;
80-N2040-45 Rev. B                                                                                             500
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                   Syntax                                   Behavior
                   Rxx+=vcmpyi(Rss,Rtt):sat                 Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[1] * Rtt.h[0])
                                                            + (Rss.h[0] * Rtt.h[1])<<0);
                                                            Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[3] * Rtt.h[2])
                                                            + (Rss.h[2] * Rtt.h[3])<<0);
                                                            ;
                                                            ;
                   Rxx+=vcmpyr(Rss,Rtt):sat                 Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] * Rtt.h[0])
                                                            - (Rss.h[1] * Rtt.h[1])<<0);
                                                            Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[2] * Rtt.h[2])
                                                            - (Rss.h[3] * Rtt.h[3])<<0);
                                                            ;
                                                            ;
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■   If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vcmpyi(Rss,Rtt):<<1:sat              Word64 Q6_P_vcmpyi_PP_s1_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vcmpyi(Rss,Rtt):sat                  Word64 Q6_P_vcmpyi_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vcmpyr(Rss,Rtt):<<1:sat              Word64 Q6_P_vcmpyr_PP_s1_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vcmpyr(Rss,Rtt):sat                  Word64 Q6_P_vcmpyr_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rxx+=vcmpyi(Rss,Rtt):sat                 Word64 Q6_P_vcmpyiacc_PP_sat(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                   Rxx+=vcmpyr(Rss,Rtt):sat                 Word64 Q6_P_vcmpyracc_PP_sat(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1  0
   ICLASS     RegType      MajOp        s5      Parse           t5       MinOp      d5
 1  1  1  0 1  0   0  0  N 0    1  s s  s  s  s P   P 0   t   t  t t t 1   1  0 d d d  d  d Rdd=vcmpyr(Rss,Rtt)[:<<N]
                                                                                             :sat
 1  1  1  0 1  0   0  0  N 1    0  s s  s  s  s P   P 0   t   t  t t t 1   1  0 d d d  d  d Rdd=vcmpyi(Rss,Rtt)[:<<N]
                                                                                             :sat
   ICLASS     RegType      MajOp        s5      Parse           t5       MinOp      x5
 1  1  1  0 1  0   1  0  0  0   1  s s  s  s  s P   P 0   t   t  t t t 1   0  0 x x  x x  x Rxx+=vcmpyr(Rss,Rtt):sat
 1  1  1  0 1  0   1  0  0  1   0  s s  s  s  s P   P 0   t   t  t t t 1   0  0 x x  x x  x Rxx+=vcmpyi(Rss,Rtt):sat
80-N2040-45 Rev. B                                                                                                501
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  x5           Field to encode register x
80-N2040-45 Rev. B                                                    502
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector complex conjugate
                  Perform a vector complex conjugate of both complex values in vector Rss. This is done by
                  negating the imaginary halfwords, and placing the result in destination Rdd.
                   Syntax                                   Behavior
                   Rdd=vconj(Rss):sat                       Rdd.h[1]=sat_16(-Rss.h[1]);
                                                            Rdd.h[0]=Rss.h[0];
                                                            Rdd.h[3]=sat_16(-Rss.h[3]);
                                                            Rdd.h[2]=Rss.h[2];
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vconj(Rss):sat                       Word64 Q6_P_vconj_P_sat(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0  1 0   0  s  s  s  s  s  P   P -  -   - -  - - 1   1  1 d d d  d d Rdd=vconj(Rss):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              503
Hexagon V67 Programmer’s Reference Manual                                                                Instruction Set
        Vector complex rotate
                  Take the least significant bits of Rt, and use these bits to rotate each of the two complex
                  values in the source vector a multiple of 90 degrees. Bits 0 and 1 control the rotation factor
                  for word 0, and bits 2 and 3 control the rotation factor for word 1.
                  If the rotation control bits are 0, the rotation is 0: the real and imaginary halves of the
                  source appear unchanged and unmoved in the destination.
                  If the rotation control bits are 1, the rotation is -pi/2: the real half of the destination gets the
                  imaginary half of the source, and the imaginary half of the destination gets the negative
                  real half of the source.
                  If the rotation control bits are 2, the rotation is pi/2: the real half of the destination gets the
                  negative imaginary half of the source, and the imaginary half of the destination gets the
                  real half of the source.
                  If the rotation control bits are 3, the rotation is pi: the real half of the destination gets the
                  negative real half of the source, and the imaginary half of the destination gets the negative
                  imaginary half of the source.
                   Syntax                                  Behavior
                   Rdd=vcrotate(Rss,Rt)                    tmp = Rt[1:0];
                                                           if (tmp == 0) {
                                                                Rdd.h[0]=Rss.h[0];
                                                                Rdd.h[1]=Rss.h[1];
                                                           } else if (tmp == 1) {
                                                                Rdd.h[0]=Rss.h[1];
                                                                Rdd.h[1]=sat_16(-Rss.h[0]);
                                                           } else if (tmp == 2) {
                                                                Rdd.h[0]=sat_16(-Rss.h[1]);
                                                                Rdd.h[1]=Rss.h[0];
                                                           } else {
                                                                Rdd.h[0]=sat_16(-Rss.h[0]);
                                                                Rdd.h[1]=sat_16(-Rss.h[1]);
                                                           }
                                                           tmp = Rt[3:2];
                                                           if (tmp == 0) {
                                                                Rdd.h[2]=Rss.h[2];
                                                                Rdd.h[3]=Rss.h[3];
                                                           } else if (tmp == 1) {
                                                                Rdd.h[2]=Rss.h[3];
                                                                Rdd.h[3]=sat_16(-Rss.h[2]);
                                                           } else if (tmp == 2) {
                                                                Rdd.h[2]=sat_16(-Rss.h[3]);
                                                                Rdd.h[3]=Rss.h[2];
                                                           } else {
                                                                Rdd.h[2]=sat_16(-Rss.h[2]);
                                                                Rdd.h[3]=sat_16(-Rss.h[3]);
                                                           }
80-N2040-45 Rev. B                                                                                                   504
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vcrotate(Rss,Rt)                     Word64 Q6_P_vcrotate_PR(Word64 Rss, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS     RegType     Maj          s5        Parse          t5      Min        d5
 1  1  0  0 0  0   1  1  1  1  -  s  s  s  s  s  P   P -  t   t  t t t 0  0  - d d  d d  d Rdd=vcrotate(Rss,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              505
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
        Vector reduce complex multiply real or imaginary
                  The input vectors are two packed complex values, each with a real low halfword and
                  imaginary high halfword. Compute either the real or imaginary products, add the
                  intermediate results together and optionally accumulate with the destination. The Rtt input
                  is optionally conjugated (negate the imaginary portion) before multiplication.
                  Using vrcmpyr and vrcmpyi, it is possible to sustain an average of one full complex
                  multiply per cycle in a complex FIR, while also keeping both the real and imaginary
                  accumulators in full precision 64-bit values.
                                          Rxx+=vrcmpyi(Rss,Rtt)
                            I               R                I              R              Rss
                            I               R                I              R              Rtt
                              *     32
                                              *                 *             *
                                                  32           32
                                                                     32
                                                   Add
                                                                                                64
                                                                                        Rxx
                                         Imaginary Accumulation
                   Syntax                              Behavior
                   Rdd=vrcmpyi(Rss,Rtt)                 Rdd = (Rss.h[1] * Rtt.h[0]) + (Rss.h[0] *
                                                        Rtt.h[1]) + (Rss.h[3] * Rtt.h[2]) + (Rss.h[2] *
                                                        Rtt.h[3]);
                   Rdd=vrcmpyi(Rss,Rtt*)                Rdd = (Rss.h[1] * Rtt.h[0]) - (Rss.h[0] *
                                                        Rtt.h[1]) + (Rss.h[3] * Rtt.h[2]) - (Rss.h[2] *
                                                        Rtt.h[3]);
                   Rdd=vrcmpyr(Rss,Rtt)                 Rdd = (Rss.h[0] * Rtt.h[0]) - (Rss.h[1] *
                                                        Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) - (Rss.h[3] *
                                                        Rtt.h[3]);
80-N2040-45 Rev. B                                                                                          506
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Syntax                                   Behavior
                   Rdd=vrcmpyr(Rss,Rtt*)                    Rdd = (Rss.h[0] * Rtt.h[0]) + (Rss.h[1] *
                                                            Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) + (Rss.h[3] *
                                                            Rtt.h[3]);
                   Rxx+=vrcmpyi(Rss,Rtt)                    Rxx = Rxx + (Rss.h[1] * Rtt.h[0]) + (Rss.h[0] *
                                                            Rtt.h[1]) + (Rss.h[3] * Rtt.h[2]) + (Rss.h[2] *
                                                            Rtt.h[3]);
                                                            ;
                   Rxx+=vrcmpyi(Rss,Rtt*)                   Rxx = Rxx + (Rss.h[1] * Rtt.h[0]) - (Rss.h[0] *
                                                            Rtt.h[1]) + (Rss.h[3] * Rtt.h[2]) - (Rss.h[2] *
                                                            Rtt.h[3]);
                                                            ;
                   Rxx+=vrcmpyr(Rss,Rtt)                    Rxx = Rxx + (Rss.h[0] * Rtt.h[0]) - (Rss.h[1] *
                                                            Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) - (Rss.h[3] *
                                                            Rtt.h[3]);
                                                            ;
                   Rxx+=vrcmpyr(Rss,Rtt*)                   Rxx = Rxx + (Rss.h[0] * Rtt.h[0]) + (Rss.h[1] *
                                                            Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) + (Rss.h[3] *
                                                            Rtt.h[3]);
                                                            ;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vrcmpyi(Rss,Rtt)                     Word64 Q6_P_vrcmpyi_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vrcmpyi(Rss,Rtt*)                    Word64 Q6_P_vrcmpyi_PP_conj(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vrcmpyr(Rss,Rtt)                     Word64 Q6_P_vrcmpyr_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vrcmpyr(Rss,Rtt*)                    Word64 Q6_P_vrcmpyr_PP_conj(Word64 Rss, Word64
                                                            Rtt)
                   Rxx+=vrcmpyi(Rss,Rtt)                    Word64 Q6_P_vrcmpyiacc_PP(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                   Rxx+=vrcmpyi(Rss,Rtt*)                   Word64 Q6_P_vrcmpyiacc_PP_conj(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vrcmpyr(Rss,Rtt)                    Word64 Q6_P_vrcmpyracc_PP(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                   Rxx+=vrcmpyr(Rss,Rtt*)                   Word64 Q6_P_vrcmpyracc_PP_conj(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5       Parse           t5       MinOp      d5
 1  1  1  0 1  0   0  0 0  0   0  s  s  s  s  s P   P 0   t   t  t t t 0   0  0 d d d  d d Rdd=vrcmpyi(Rss,Rtt)
 1  1  1  0 1  0   0  0 0  0   0  s  s  s  s  s P   P 0   t   t  t t t 0   0  1 d d d  d d Rdd=vrcmpyr(Rss,Rtt)
 1  1  1  0 1  0   0  0 0  1   0  s  s  s  s  s P   P 0   t   t  t t t 0   0  0 d d d  d d Rdd=vrcmpyi(Rss,Rtt*)
 1  1  1  0 1  0   0  0 0  1   1  s  s  s  s  s P   P 0   t   t  t t t 0   0  1 d d d  d d Rdd=vrcmpyr(Rss,Rtt*)
80-N2040-45 Rev. B                                                                                               507
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  0   1  0 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 x x x  x x Rxx+=vrcmpyi(Rss,Rtt)
 1  1  1  0 1  0   1  0 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x x  x x Rxx+=vrcmpyr(Rss,Rtt)
 1  1  1  0 1  0   1  0 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 x x x  x x Rxx+=vrcmpyi(Rss,Rtt*)
 1  1  1  0 1  0   1  0 0  1   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x x  x x Rxx+=vrcmpyr(Rss,Rtt*)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               508
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Vector reduce complex multiply by scalar
                  Multiply a complex number by a scalar. Rss contains two complex numbers. The real
                  portions are each multiplied by two scalars contained in register Rt, scaled, summed,
                  optionally accumulated, saturated, and stored in the lower word of Rdd. A similar
                  operation is done on the two imaginary portions of Rss.
                                              Rdd=vrcmpys(Rss,Rt):<<1:sat
                                    I               R                I                R              Rss
                    Rt            b               a                     b                a            Rt
                                    *               *                     *                *
                                      32              32                   32                32
                                   <<1             <<1                   <<1              <<1
                                           Add                                 Add
                                         Sat_32                               Sat_32
                                        I                                                                Rdd
                   Syntax                              Behavior
                   Rdd=vrcmpys(Rss,Rt):<<1:sat         if ("Rt & 1") {
                                                           Assembler mapped to:
                                                       "Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi";
                                                       } else {
                                                           Assembler mapped to:
                                                       "Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo";
                                                       }
                   Rdd=vrcmpys(Rss,Rtt):<<1:sat:ra     Rdd.w[1]=sat_32((Rss.h[1] * Rtt.w[1].h[0])<<1 +
                   w:hi                                (Rss.h[3] * Rtt.w[1].h[1])<<1);
                                                       Rdd.w[0]=sat_32((Rss.h[0] * Rtt.w[1].h[0])<<1 +
                                                       (Rss.h[2] * Rtt.w[1].h[1])<<1);
80-N2040-45 Rev. B                                                                                           509
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                   Syntax                                 Behavior
                   Rdd=vrcmpys(Rss,Rtt):<<1:sat:ra         Rdd.w[1]=sat_32((Rss.h[1] * Rtt.w[0].h[0])<<1 +
                   w:lo                                    (Rss.h[3] * Rtt.w[0].h[1])<<1);
                                                           Rdd.w[0]=sat_32((Rss.h[0] * Rtt.w[0].h[0])<<1 +
                                                           (Rss.h[2] * Rtt.w[0].h[1])<<1);
                   Rxx+=vrcmpys(Rss,Rt):<<1:sat            if ("Rt & 1") {
                                                                Assembler mapped to:
                                                           "Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi";
                                                           } else {
                                                                Assembler mapped to:
                                                           "Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo";
                                                           }
                   Rxx+=vrcmpys(Rss,Rtt):<<1:sat:r         Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[1] *
                   aw:hi                                   Rtt.w[1].h[0])<<1 + (Rss.h[3] *
                                                           Rtt.w[1].h[1])<<1);
                                                           Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] *
                                                           Rtt.w[1].h[0])<<1 + (Rss.h[2] *
                                                           Rtt.w[1].h[1])<<1);
                                                           ;
                   Rxx+=vrcmpys(Rss,Rtt):<<1:sat:r         Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[1] *
                   aw:lo                                   Rtt.w[0].h[0])<<1 + (Rss.h[3] *
                                                           Rtt.w[0].h[1])<<1);
                                                           Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] *
                                                           Rtt.w[0].h[0])<<1 + (Rss.h[2] *
                                                           Rtt.w[0].h[1])<<1);
                                                           ;
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■   If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vrcmpys(Rss,Rt):<<1:sat             Word64 Q6_P_vrcmpys_PR_s1_sat(Word64 Rss, Word32
                                                           Rt)
                   Rxx+=vrcmpys(Rss,Rt):<<1:sat            Word64 Q6_P_vrcmpysacc_PR_s1_sat(Word64 Rxx,
                                                           Word64 Rss, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4 3 2  1  0
   ICLASS     RegType    MajOp         s5       Parse          t5       MinOp      d5
80-N2040-45 Rev. B                                                                                              510
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
                                                                                           Rdd=vrcmpys(Rss,Rtt):<<1
 1  1  1  0 1  0   0  0 1  0   1  s  s  s  s  s  P   P 0  t   t  t t t 1   0  0 d d d  d d
                                                                                           :sat:raw:hi
                                                                                           Rdd=vrcmpys(Rss,Rtt):<<1
 1  1  1  0 1  0   0  0 1  1   1  s  s  s  s  s  P   P 0  t   t  t t t 1   0  0 d d d  d d
                                                                                           :sat:raw:lo
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  0   1  0 1  0   1  s  s  s  s  s  P   P 0  t   t  t t t 1   0  0 x x x  x x Rxx+=vrcmpys(Rss,Rtt):<<
                                                                                           1:sat:raw:hi
                                                                                           Rxx+=vrcmpys(Rss,Rtt):<<
 1  1  1  0 1  0   1  0 1  1   1  s  s  s  s  s  P   P 0  t   t  t t t 1   0  0 x x x  x x
                                                                                           1:sat:raw:lo
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                                511
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Vector reduce complex multiply by scalar with round and pack
                  Multiply a complex number by scalar. Rss contains two complex numbers. The real
                  portions are each multiplied by two scalars contained in register Rt, scaled, summed,
                  rounded, and saturated. The upper 16bits of this result are packed in the lower halfword of
                  Rd. A similar operation is done on the two imaginary portions of Rss.
                                             Rd=vrcmpys(Rss,Rt):<<1:rnd:sat
                                    I               R                 I                R             Rss
                    Rt            b               a                     b                a            Rt
                                    *               *                     *                *
                                      32              32                    32               32
                     0x8000       <<0-1            <<0-1                <<0-1            <<0-1       0x8000
                                           Add                                  Add
                                         Sat_32                                Sat_32
                                                High 16bits                 High 16bits
                                                       I                R           Rd
                   Syntax                              Behavior
                   Rd=vrcmpys(Rss,Rt):<<1:rnd:sat       if ("Rt & 1") {
                                                            Assembler mapped to:
                                                        "Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi";
                                                        } else {
                                                            Assembler mapped to:
                                                        "Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo";
                                                        }
                   Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat      Rd.h[1]=sat_32((Rss.h[1] * Rtt.w[1].h[0])<<1 +
                   :raw:hi                              (Rss.h[3] * Rtt.w[1].h[1])<<1 + 0x8000).h[1];
                                                        Rd.h[0]=sat_32((Rss.h[0] * Rtt.w[1].h[0])<<1 +
                                                        (Rss.h[2] * Rtt.w[1].h[1])<<1 + 0x8000).h[1];
80-N2040-45 Rev. B                                                                                           512
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
                   Syntax                                    Behavior
                   Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat           Rd.h[1]=sat_32((Rss.h[1] * Rtt.w[0].h[0])<<1 +
                   :raw:lo                                   (Rss.h[3] * Rtt.w[0].h[1])<<1 + 0x8000).h[1];
                                                             Rd.h[0]=sat_32((Rss.h[0] * Rtt.w[0].h[0])<<1 +
                                                             (Rss.h[2] * Rtt.w[0].h[1])<<1 + 0x8000).h[1];
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■   If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=vrcmpys(Rss,Rt):<<1:rnd:sat            Word32 Q6_R_vrcmpys_PR_s1_rnd_sat(Word64 Rss,
                                                             Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType      MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  1  1   -  1  s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 d d d  d d Rd=vrcmpys(Rss,Rtt):<<1:r
                                                                                             nd:sat:raw:hi
 1  1  1  0 1  0   0  1  1   -  1  s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 d d d  d d Rd=vrcmpys(Rss,Rtt):<<1:r
                                                                                             nd:sat:raw:lo
                  Field name         Description
                  ICLASS             Instruction Class
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  RegType            Register Type
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  s5                 Field to encode register s
                  t5                 Field to encode register t
80-N2040-45 Rev. B                                                                                                 513
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Vector reduce complex rotate
                  This instruction is useful for CDMA despreading. An unsigned 2-bit immediate specifies a
                  byte to use in Rt. Each of four 2-bit fields in the specified byte selects a rotation amount
                  for one of the four complex numbers in Rss. The real and imaginary products are
                  accumulated and stored as a 32-bit complex number in Rd. Optionally, the destination
                  register can also be accumulated.
                    Rxx += vrcrotate(Rss,Rt,#0)
                                                                              Rt
                              1 j -1 -j      1 j -1 -j     1 j -1 -j        1 j -1 -j
                                 mux            mux          mux              mux
                              Im3     Re3     Im2      Re2  Im1      Re1   Im0      Re0     Rss
                                  *              *            *                *
                                         +                               +
                                          I                            R                Rxx
80-N2040-45 Rev. B                                                                                              514
Hexagon V67 Programmer’s Reference Manual                                           Instruction Set
                   Syntax                     Behavior
                   Rdd=vrcrotate(Rss,Rt,#u2)  sumr = 0;
                                              sumi = 0;
                                              control = Rt.ub[#u];
                                              for (i = 0; i < 8; i += 2) {
                                                  tmpr = Rss.b[i];
                                                  tmpi = Rss.b[i+1];
                                                  switch (control & 3) {
                                                       case 0: sumr += tmpr;
                                                       sumi += tmpi;
                                                       break;
                                                       case 1: sumr += tmpi;
                                                       sumi -= tmpr;
                                                       break;
                                                       case 2: sumr -= tmpi;
                                                       sumi += tmpr;
                                                       break;
                                                       case 3: sumr -= tmpr;
                                                       sumi -= tmpi;
                                                       break;
                                                  }
                                                  control = control >> 2;
                                              }
                                              Rdd.w[0]=sumr;
                                              Rdd.w[1]=sumi;
                   Rxx+=vrcrotate(Rss,Rt,#u2) sumr = 0;
                                              sumi = 0;
                                              control = Rt.ub[#u];
                                              for (i = 0; i < 8; i += 2) {
                                                  tmpr = Rss.b[i];
                                                  tmpi = Rss.b[i+1];
                                                  switch (control & 3) {
                                                       case 0: sumr += tmpr;
                                                       sumi += tmpi;
                                                       break;
                                                       case 1: sumr += tmpi;
                                                       sumi -= tmpr;
                                                       break;
                                                       case 2: sumr -= tmpi;
                                                       sumi += tmpr;
                                                       break;
                                                       case 3: sumr -= tmpr;
                                                       sumi -= tmpi;
                                                       break;
                                                  }
                                                  control = control >> 2;
                                              }
                                              Rxx.w[0]=Rxx.w[0] + sumr;
                                              Rxx.w[1]=Rxx.w[1] + sumi;
                                              ;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vrcrotate(Rss,Rt,#u2)  Word64 Q6_P_vrcrotate_PRI(Word64 Rss, Word32 Rt,
                                              Word32 Iu2)
                   Rxx+=vrcrotate(Rss,Rt,#u2) Word64 Q6_P_vrcrotateacc_PRI(Word64 Rxx, Word64
                                              Rss, Word32 Rt, Word32 Iu2)
80-N2040-45 Rev. B                                                                              515
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4 3 2  1 0
   ICLASS     RegType    Maj           s5        Parse          t5      Min        d5
 1  1  0  0 0  0   1  1 1  1   -  s  s  s  s  s  P   P i  t   t  t t t 1  1  i d d d  d d Rdd=vrcrotate(Rss,Rt,#u2)
   ICLASS     RegType    Maj           s5        Parse          t5                 x5
                                                                                          Rxx+=vrcrotate(Rss,Rt,#u2
 1  1  0  0 1  0   1  1 1  0  1   s  s  s  s  s  P   P i  t   t  t t t -   - i x x  x x x
                                                                                          )
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              516
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
   11.10.4        XTYPE/FP
                  The XTYPE/FP instruction subclass includes instructions that are for floating point math.
          Floating point addition
                  Add two floating point values
                   Syntax                                   Behavior
                   Rd=sfadd(Rs,Rt)                          Rd=Rs+Rt;
                   Rdd=dfadd(Rss,Rtt)                       Rdd=Rss+Rtt;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=sfadd(Rs,Rt)                          Word32 Q6_R_sfadd_RR(Word32 Rs, Word32 Rt)
                   Rdd=dfadd(Rss,Rtt)                       Word64 Q6_P_dfadd_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  0 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  1 d d d  d d Rdd=dfadd(Rss,Rtt)
 1  1  1  0 1  0   1  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d Rd=sfadd(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             517
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Classify floating-point value
                  Classify floating point values. Classes are Normal, Subnormal, Zero, NaN, or Infinity. If
                  the number is one of the specified classes, return true.
                   Syntax                                   Behavior
                   Pd=dfclass(Rss,#u5)                      Pd = 0;
                                                            class = fpclassify(Rss);
                                                            if (#u.0 && (class == FP_ZERO)) Pd = 0xff;
                                                            if (#u.1 && (class == FP_NORMAL)) Pd = 0xff;
                                                            if (#u.2 && (class == FP_SUBNORMAL)) Pd = 0xff;
                                                            if (#u.3 && (class == FP_INFINITE)) Pd = 0xff;
                                                            if (#u.4 && (class == FP_NAN)) Pd = 0xff;
                                                            cancel_flags();
                   Pd=sfclass(Rs,#u5)                       Pd = 0;
                                                            class = fpclassify(Rs);
                                                            if (#u.0 && (class == FP_ZERO)) Pd = 0xff;
                                                            if (#u.1 && (class == FP_NORMAL)) Pd = 0xff;
                                                            if (#u.2 && (class == FP_SUBNORMAL)) Pd = 0xff;
                                                            if (#u.3 && (class == FP_INFINITE)) Pd = 0xff;
                                                            if (#u.4 && (class == FP_NAN)) Pd = 0xff;
                                                            cancel_flags();
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=dfclass(Rss,#u5)                      Byte Q6_p_dfclass_PI(Word64 Rss, Word32 Iu5)
                   Pd=sfclass(Rs,#u5)                       Byte Q6_p_sfclass_RI(Word32 Rs, Word32 Iu5)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1   0
   ICLASS     RegType   MajOp          s5        Parse                                  d2
 1  0  0  0 0  1   0  1 1  1  1   s  s  s  s  s  P   P 0  i   i i  i i  - -  - - -  - d   d Pd=sfclass(Rs,#u5)
   ICLASS     RegType                  s5        Parse                                  d2
 1  1  0  1 1  1   0  0 1  0  0   s  s  s  s  s  P   P - 0   0  0  i i  i i  i 1 0  - d   d Pd=dfclass(Rss,#u5)
                  Field name        Description
                  RegType           Register Type
                  MajOp             Major Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                               518
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Compare floating-point value
                  Compare floating point values. p0 returns true if at least one value is a NaN, zero
                  otherwise.
                   Syntax                                   Behavior
                   Pd=dfcmp.eq(Rss,Rtt)                     Pd=Rss==Rtt ? 0xff : 0x00;
                   Pd=dfcmp.ge(Rss,Rtt)                     Pd=Rss>=Rtt ? 0xff : 0x00;
                   Pd=dfcmp.gt(Rss,Rtt)                     Pd=Rss>Rtt ? 0xff : 0x00;
                   Pd=dfcmp.uo(Rss,Rtt)                     Pd=isunordered(Rss,Rtt) ? 0xff : 0x00;
                   Pd=sfcmp.eq(Rs,Rt)                       Pd=Rs==Rt ? 0xff : 0x00;
                   Pd=sfcmp.ge(Rs,Rt)                       Pd=Rs>=Rt ? 0xff : 0x00;
                   Pd=sfcmp.gt(Rs,Rt)                       Pd=Rs>Rt ? 0xff : 0x00;
                   Pd=sfcmp.uo(Rs,Rt)                       Pd=isunordered(Rs,Rt) ? 0xff : 0x00;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=dfcmp.eq(Rss,Rtt)                     Byte Q6_p_dfcmp_eq_PP(Word64 Rss, Word64 Rtt)
                   Pd=dfcmp.ge(Rss,Rtt)                     Byte Q6_p_dfcmp_ge_PP(Word64 Rss, Word64 Rtt)
                   Pd=dfcmp.gt(Rss,Rtt)                     Byte Q6_p_dfcmp_gt_PP(Word64 Rss, Word64 Rtt)
                   Pd=dfcmp.uo(Rss,Rtt)                     Byte Q6_p_dfcmp_uo_PP(Word64 Rss, Word64 Rtt)
                   Pd=sfcmp.eq(Rs,Rt)                       Byte Q6_p_sfcmp_eq_RR(Word32 Rs, Word32 Rt)
                   Pd=sfcmp.ge(Rs,Rt)                       Byte Q6_p_sfcmp_ge_RR(Word32 Rs, Word32 Rt)
                   Pd=sfcmp.gt(Rs,Rt)                       Byte Q6_p_sfcmp_gt_RR(Word32 Rs, Word32 Rt)
                   Pd=sfcmp.uo(Rs,Rt)                       Byte Q6_p_sfcmp_uo_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2 1   0
   ICLASS     RegType    Maj           s5       Parse           t5      Min             d2
 1  1  0  0 0  1   1  1 1  1  1   s  s  s  s  s P   P  -  t   t  t t t 0   0  0 - - - d   d Pd=sfcmp.ge(Rs,Rt)
 1  1  0  0 0  1   1  1 1  1  1   s  s  s  s  s P   P  -  t   t  t t t 0   0  1 - - - d   d Pd=sfcmp.uo(Rs,Rt)
 1  1  0  0 0  1   1  1 1  1  1   s  s  s  s  s P   P  -  t   t  t t t 0   1  1 - - - d   d Pd=sfcmp.eq(Rs,Rt)
 1  1  0  0 0  1   1  1 1  1  1   s  s  s  s  s P   P  -  t   t  t t t 1   0  0 - - - d   d Pd=sfcmp.gt(Rs,Rt)
   ICLASS     RegType                  s5       Parse           t5       MinOp          d2
 1  1  0  1 0  0   1  0 1  1  1   s  s  s  s  s P   P  -  t   t  t t t 0   0  0 - - - d   d Pd=dfcmp.eq(Rss,Rtt)
 1  1  0  1 0  0   1  0 1  1  1   s  s  s  s  s P   P  -  t   t  t t t 0   0  1 - - - d   d Pd=dfcmp.gt(Rss,Rtt)
 1  1  0  1 0  0   1  0 1  1  1   s  s  s  s  s P   P  -  t   t  t t t 0   1  0 - - - d   d Pd=dfcmp.ge(Rss,Rtt)
 1  1  0  1 0  0   1  0 1  1  1   s  s  s  s  s P   P  -  t   t  t t t 0   1  1 - - - d   d Pd=dfcmp.uo(Rss,Rtt)
80-N2040-45 Rev. B                                                                                               519
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  RegType      Register Type
                  MinOp        Minor Opcode
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d2           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    520
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Convert floating-point value to other format
                  Convert floating point values. If rounding is required, it happens according to the rounding
                  mode.
                   Syntax                                   Behavior
                   Rd=convert_df2sf(Rss)                    Rd = conv_df_to_sf(Rss);
                   Rdd=convert_sf2df(Rs)                    Rdd = conv_sf_to_df(Rs);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=convert_df2sf(Rss)                    Word32 Q6_R_convert_df2sf_P(Word64 Rss)
                   Rdd=convert_sf2df(Rs)                    Word64 Q6_P_convert_sf2df_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  1   0  0 1   -  -  s  s  s  s  s  P   P -  -   - -  - - 0   0  0 d d d  d d Rdd=convert_sf2df(Rs)
 1  0  0  0 1  0   0  0 0  0  0   s  s  s  s  s  P   P -  -   - -  - - 0   0  1 d d d  d d Rd=convert_df2sf(Rss)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                               521
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Convert integer to floating-point value
                  Convert floating point values. If rounding is required, it happens according to the rounding
                  mode unless the :chop option is specified.
                   Syntax                                   Behavior
                   Rd=convert_d2sf(Rss)                     Rd = conv_8s_to_sf(Rss.s64);
                   Rd=convert_ud2sf(Rss)                    Rd = conv_8u_to_sf(Rss.u64);
                   Rd=convert_uw2sf(Rs)                     Rd = conv_4u_to_sf(Rs.uw[0]);
                   Rd=convert_w2sf(Rs)                      Rd = conv_4s_to_sf(Rs.s32);
                   Rdd=convert_d2df(Rss)                    Rdd = conv_8s_to_df(Rss.s64);
                   Rdd=convert_ud2df(Rss)                   Rdd = conv_8u_to_df(Rss.u64);
                   Rdd=convert_uw2df(Rs)                    Rdd = conv_4u_to_df(Rs.uw[0]);
                   Rdd=convert_w2df(Rs)                     Rdd = conv_4s_to_df(Rs.s32);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=convert_d2sf(Rss)                     Word32 Q6_R_convert_d2sf_P(Word64 Rss)
                   Rd=convert_ud2sf(Rss)                    Word32 Q6_R_convert_ud2sf_P(Word64 Rss)
                   Rd=convert_uw2sf(Rs)                     Word32 Q6_R_convert_uw2sf_R(Word32 Rs)
                   Rd=convert_w2sf(Rs)                      Word32 Q6_R_convert_w2sf_R(Word32 Rs)
                   Rdd=convert_d2df(Rss)                    Word64 Q6_P_convert_d2df_P(Word64 Rss)
                   Rdd=convert_ud2df(Rss)                   Word64 Q6_P_convert_ud2df_P(Word64 Rss)
                   Rdd=convert_uw2df(Rs)                    Word64 Q6_P_convert_uw2df_R(Word32 Rs)
                   Rdd=convert_w2df(Rs)                     Word64 Q6_P_convert_w2df_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5       Parse                    MinOp      d5
 1  0  0  0 0  0   0  0 1  1  1   s  s  s  s  s P   P 0   -   - -  - - 0   1  0 d d d  d d Rdd=convert_ud2df(Rss)
 1  0  0  0 0  0   0  0 1  1  1   s  s  s  s  s P   P 0   -   - -  - - 0   1  1 d d d  d d Rdd=convert_d2df(Rss)
 1  0  0  0 0  1   0  0 1   -  -  s  s  s  s  s P   P  -  -   - -  - - 0   0  1 d d d  d d Rdd=convert_uw2df(Rs)
 1  0  0  0 0  1   0  0 1   -  -  s  s  s  s  s P   P  -  -   - -  - - 0   1  0 d d d  d d Rdd=convert_w2df(Rs)
 1  0  0  0 1  0   0  0 0  0  1   s  s  s  s  s P   P  -  -   - -  - - 0   0  1 d d d  d d Rd=convert_ud2sf(Rss)
 1  0  0  0 1  0   0  0 0  1  0   s  s  s  s  s P   P  -  -   - -  - - 0   0  1 d d d  d d Rd=convert_d2sf(Rss)
 1  0  0  0 1  0   1  1 0  0  1   s  s  s  s  s P   P  -  -   - -  - - 0   0  0 d d d  d d Rd=convert_uw2sf(Rs)
 1  0  0  0 1  0   1  1 0  1  0   s  s  s  s  s P   P  -  -   - -  - - 0   0  0 d d d  d d Rd=convert_w2sf(Rs)
80-N2040-45 Rev. B                                                                                               522
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    523
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Convert floating-point value to integer
                  Convert floating point values. If rounding is required, it happens according to the rounding
                  mode unless the :chop option is specified. If the value is out of range of the destination
                  integer type, the INVALID flag is raised and closest integer is chosen, including for
                  infinite inputs. For NaN inputs, the INVALID flag is also raised, and the output value is
                  IMPLEMENTATION DEFINED.
                   Syntax                               Behavior
                   Rd=convert_df2uw(Rss)                Rd = conv_df_to_4u(Rss).uw[0];
                   Rd=convert_df2uw(Rss):chop           round_to_zero();
                                                        Rd = conv_df_to_4u(Rss).uw[0];
                   Rd=convert_df2w(Rss)                 Rd = conv_df_to_4s(Rss).s32;
                   Rd=convert_df2w(Rss):chop            round_to_zero();
                                                        Rd = conv_df_to_4s(Rss).s32;
                   Rd=convert_sf2uw(Rs)                 Rd = conv_sf_to_4u(Rs).uw[0];
                   Rd=convert_sf2uw(Rs):chop            round_to_zero();
                                                        Rd = conv_sf_to_4u(Rs).uw[0];
                   Rd=convert_sf2w(Rs)                  Rd = conv_sf_to_4s(Rs).s32;
                   Rd=convert_sf2w(Rs):chop             round_to_zero();
                                                        Rd = conv_sf_to_4s(Rs).s32;
                   Rdd=convert_df2d(Rss)                Rdd = conv_df_to_8s(Rss).s64;
                   Rdd=convert_df2d(Rss):chop           round_to_zero();
                                                        Rdd = conv_df_to_8s(Rss).s64;
                   Rdd=convert_df2ud(Rss)               Rdd = conv_df_to_8u(Rss).u64;
                   Rdd=convert_df2ud(Rss):chop          round_to_zero();
                                                        Rdd = conv_df_to_8u(Rss).u64;
                   Rdd=convert_sf2d(Rs)                 Rdd = conv_sf_to_8s(Rs).s64;
                   Rdd=convert_sf2d(Rs):chop            round_to_zero();
                                                        Rdd = conv_sf_to_8s(Rs).s64;
                   Rdd=convert_sf2ud(Rs)                Rdd = conv_sf_to_8u(Rs).u64;
                   Rdd=convert_sf2ud(Rs):chop           round_to_zero();
                                                        Rdd = conv_sf_to_8u(Rs).u64;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=convert_df2uw(Rss)                Word32 Q6_R_convert_df2uw_P(Word64 Rss)
                   Rd=convert_df2uw(Rss):chop           Word32 Q6_R_convert_df2uw_P_chop(Word64 Rss)
                   Rd=convert_df2w(Rss)                 Word32 Q6_R_convert_df2w_P(Word64 Rss)
                   Rd=convert_df2w(Rss):chop            Word32 Q6_R_convert_df2w_P_chop(Word64 Rss)
                   Rd=convert_sf2uw(Rs)                 Word32 Q6_R_convert_sf2uw_R(Word32 Rs)
                   Rd=convert_sf2uw(Rs):chop            Word32 Q6_R_convert_sf2uw_R_chop(Word32 Rs)
80-N2040-45 Rev. B                                                                                            524
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Rd=convert_sf2w(Rs)                      Word32 Q6_R_convert_sf2w_R(Word32 Rs)
                   Rd=convert_sf2w(Rs):chop                 Word32 Q6_R_convert_sf2w_R_chop(Word32 Rs)
                   Rdd=convert_df2d(Rss)                    Word64 Q6_P_convert_df2d_P(Word64 Rss)
                   Rdd=convert_df2d(Rss):chop               Word64 Q6_P_convert_df2d_P_chop(Word64 Rss)
                   Rdd=convert_df2ud(Rss)                   Word64 Q6_P_convert_df2ud_P(Word64 Rss)
                   Rdd=convert_df2ud(Rss):chop              Word64 Q6_P_convert_df2ud_P_chop(Word64 Rss)
                   Rdd=convert_sf2d(Rs)                     Word64 Q6_P_convert_sf2d_R(Word32 Rs)
                   Rdd=convert_sf2d(Rs):chop                Word64 Q6_P_convert_sf2d_R_chop(Word32 Rs)
                   Rdd=convert_sf2ud(Rs)                    Word64 Q6_P_convert_sf2ud_R(Word32 Rs)
                   Rdd=convert_sf2ud(Rs):chop               Word64 Q6_P_convert_sf2ud_R_chop(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0 1  1  1   s  s  s  s  s  P   P 0  -   - -  - - 0   0  0 d d d  d d Rdd=convert_df2d(Rss)
 1  0  0  0 0  0   0  0 1  1  1   s  s  s  s  s  P   P 0  -   - -  - - 0   0  1 d d d  d d Rdd=convert_df2ud(Rss)
                                                                                           Rdd=convert_df2d(Rss):ch
 1  0  0  0 0  0   0  0 1  1  1   s  s  s  s  s  P   P 0  -   - -  - - 1   1  0 d d d  d d op
 1  0  0  0 0  0   0  0 1  1  1   s  s  s  s  s  P   P 0  -   - -  - - 1   1  1 d d d  d d Rdd=convert_df2ud(Rss):c
                                                                                           hop
 1  0  0  0 0  1   0  0 1   -  -  s  s  s  s  s  P   P -  -   - -  - - 0   1  1 d d d  d d Rdd=convert_sf2ud(Rs)
 1  0  0  0 0  1   0  0 1   -  -  s  s  s  s  s  P   P -  -   - -  - - 1   0  0 d d d  d d Rdd=convert_sf2d(Rs)
                                                                                           Rdd=convert_sf2ud(Rs):ch
 1  0  0  0 0  1   0  0 1   -  -  s  s  s  s  s  P   P -  -   - -  - - 1   0  1 d d d  d d op
 1  0  0  0 0  1   0  0 1   -  -  s  s  s  s  s  P   P -  -   - -  - - 1   1  0 d d d  d d Rdd=convert_sf2d(Rs):cho
                                                                                           p
 1  0  0  0 1  0   0  0 0  1  1   s  s  s  s  s  P   P -  -   - -  - - 0   0  1 d d d  d d Rd=convert_df2uw(Rss)
 1  0  0  0 1  0   0  0 1  0  0   s  s  s  s  s  P   P -  -   - -  - - 0   0  1 d d d  d d Rd=convert_df2w(Rss)
                                                                                           Rd=convert_df2uw(Rss):ch
 1  0  0  0 1  0   0  0 1  0  1   s  s  s  s  s  P   P -  -   - -  - - 0   0  1 d d d  d d op
 1  0  0  0 1  0   0  0 1  1  1   s  s  s  s  s  P   P -  -   - -  - - 0   0  1 d d d  d d Rd=convert_df2w(Rss):cho
                                                                                           p
 1  0  0  0 1  0   1  1 0  1  1   s  s  s  s  s  P   P -  -   - -  - - 0   0  0 d d d  d d Rd=convert_sf2uw(Rs)
 1  0  0  0 1  0   1  1 0  1  1   s  s  s  s  s  P   P -  -   - -  - - 0   0  1 d d d  d d Rd=convert_sf2uw(Rs):cho
                                                                                           p
 1  0  0  0 1  0   1  1 1  0  0   s  s  s  s  s  P   P -  -   - -  - - 0   0  0 d d d  d d Rd=convert_sf2w(Rs)
 1  0  0  0 1  0   1  1 1  0  0   s  s  s  s  s  P   P -  -   - -  - - 0   0  1 d d d  d d Rd=convert_sf2w(Rs):chop
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                               525
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Floating point extreme value assistance
                  For divide and square root routines, certain values are problematic for the default routine.
                  These instructions appropriately fix up the numerator (fixupn), denominator (fixupd), or
                  radicand (fixupr) for proper calculations when combined with the divide or square root
                  approximation instructions.
                   Syntax                                   Behavior
                   Rd=sffixupd(Rs,Rt)                       (Rs,Rt,Rd,adjust)=recip_common(Rs,Rt);
                                                            Rd = Rt;
                   Rd=sffixupn(Rs,Rt)                       (Rs,Rt,Rd,adjust)=recip_common(Rs,Rt);
                                                            Rd = Rs;
                   Rd=sffixupr(Rs)                          (Rs,Rd,adjust)=invsqrt_common(Rs);
                                                            Rd = Rs;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=sffixupd(Rs,Rt)                       Word32 Q6_R_sffixupd_RR(Word32 Rs, Word32 Rt)
                   Rd=sffixupn(Rs,Rt)                       Word32 Q6_R_sffixupn_RR(Word32 Rs, Word32 Rt)
                   Rd=sffixupr(Rs)                          Word32 Q6_R_sffixupr_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 1  0   1  1 1  0   1  s  s  s  s  s  P   P -  -   -  - - - 0   0  0 d d d  d d Rd=sffixupr(Rs)
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   1  1 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d Rd=sffixupn(Rs,Rt)
 1  1  1  0 1  0   1  1 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rd=sffixupd(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              526
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Floating point fused multiply-add
                  Multiply two values, and add to (or subtract from) the accumulator. Full intermediate
                  precision is kept.
                   Syntax                                   Behavior
                   Rx+=sfmpy(Rs,Rt)                         Rx=fmaf(Rs,Rt,Rx);
                   Rx-=sfmpy(Rs,Rt)                         Rx=fmaf(-Rs,Rt,Rx);
                   Rxx+=dfmpyhh(Rss,Rtt)                    Rxx = Rss*Rtt with partial product Rxx;
                   Rxx+=dfmpylh(Rss,Rtt)                    Rxx += (Rss.uw[0] * (0x00100000 | zxt20-
                                                            >64(Rtt.uw[1]))) << 1;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx+=sfmpy(Rs,Rt)                         Word32 Q6_R_sfmpyacc_RR(Word32 Rx, Word32 Rs,
                                                            Word32 Rt)
                   Rx-=sfmpy(Rs,Rt)                         Word32 Q6_R_sfmpynac_RR(Word32 Rx, Word32 Rs,
                                                            Word32 Rt)
                   Rxx+=dfmpyhh(Rss,Rtt)                    Word64 Q6_P_dfmpyhhacc_PP(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                   Rxx+=dfmpylh(Rss,Rtt)                    Word64 Q6_P_dfmpylhacc_PP(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5        MinOp      x5
 1  1  1  0 1  0   1  0 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t  0   1  1 x x x  x x Rxx+=dfmpylh(Rss,Rtt)
 1  1  1  0 1  0   1  0 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t  0   1  1 x x x  x x Rxx+=dfmpyhh(Rss,Rtt)
 1  1  1  0 1  1   1  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t  1   0  0 x x x  x x Rx+=sfmpy(Rs,Rt)
 1  1  1  0 1  1   1  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t  1   0  1 x x x  x x Rx-=sfmpy(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                                527
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Floating point fused multiply-add with scaling
                  Multiply two values, and add to (or subtract from) the accumulator. Full intermediate
                  precision is kept. Additionally, scale the output. This instruction has special handling of
                  corner cases. If a multiplicand source is zero and a NaN is not produced, the accumulator
                  is left unchanged; this means the sign of a zero accumulator does not change if the product
                  is a true zero. The scaling factor is the predicate taken as a two's compliment number for
                  single precision. The scaling factor is twice the predicate taken as a two's compliment
                  number for double precision. The implementation may change denormal accumulator
                  values to zero for positive scale factors.
                   Syntax                                   Behavior
                   Rx+=sfmpy(Rs,Rt,Pu):scale                PREDUSE_TIMING;
                                                            if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx =
                                                            NaN;
                                                            ;
                                                            tmp=fmaf(Rs,Rt,Rx) * 2**(Pu);
                                                            if (!((Rx == 0.0) && is_true_zero(Rs*Rt))) Rx =
                                                            tmp;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx+=sfmpy(Rs,Rt,Pu):scale                Word32 Q6_R_sfmpyacc_RRp_scale(Word32 Rx, Word32
                                                            Rs, Word32 Rt, Byte Pu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6  5 4  3 2  1 0
   ICLASS     RegType      MajOp       s5        Parse          t5         u2       x5
                                                                                           Rx+=sfmpy(Rs,Rt,Pu):scal
 1  1  1  0 1  1   1  1  0  1   1 s  s  s  s  s  P   P 0  t   t  t t t 1  u  u x  x x  x x e
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u2                Field to encode register u
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                              528
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Floating point reciprocal square root approximation
                  Provides an approximation of the reciprocal square root of the radicand (Rs), if combined
                  with the appropriate fixup instruction. Certain values (such as infinities or zeros) in the
                  numerator or denominator may yield values that are not reciprocal approximations, but
                  yield the correct answer when combined with fixup instructions and the appropriate
                  routines.
                  For compatibility, exact results of these instructions cannot be relied on. The precision of
                  the approximation for this architecture and later is at least 6.6 bits.
                   Syntax                                   Behavior
                   Rd,Pe=sfinvsqrta(Rs)                     if ((Rs,Rd,adjust)=invsqrt_common(Rs)) {
                                                                Pe = adjust;
                                                                idx = (Rs >> 17) & 0x7f;
                                                                mant = (invsqrt_lut[idx] << 15);
                                                                exp = 127 - ((exponent(Rs) - 127) >> 1) - 1;
                                                                Rd = -1**Rs.31 * 1.MANT * 2**(exp-BIAS);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  This instruction provides a certain amount of accuracy. In future versions the
                           accuracy may increase. For future compatibility, avoid dependence on exact
                           values.
                        ■  The predicate generated by this instruction cannot be used as a .new predicate, nor
                           can it be automatically AND’d with another predicate.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6   5  4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                      e2       d5
 1  0  0  0 1  0   1  1  1 1  1   s  s  s  s  s  P   P -  -   - -  - - 0  e    e d d d  d d Rd,Pe=sfinvsqrta(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  e2                Field to encode register e
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                               529
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
        Floating point fused multiply-add for library routines
                  Multiply two values, and add to (or subtract from) the accumulator. Full intermediate
                  precision is kept. This instruction has special handling of corner cases. Addition of
                  infinities with opposite signs, or subtraction of infinities with like signs, is defined as
                  (positive) zero. Rounding is always Nearest-Even, except that overflows to infinity round
                  to maximal finite values. If a multiplicand source is zero and a NaN is not produced, the
                  accumulator is left unchanged; this means the sign of a zero accumulator does not change
                  if the product is a true zero. Flags and Exceptions are not generated.
                   Syntax                                Behavior
                   Rx+=sfmpy(Rs,Rt):lib                  round_to_nearest();
                                                         infminusinf = ((isinf(Rx)) && (isinf(Rs*Rt)) &&
                                                         (Rs ^ Rx ^ Rt.31 != 0));
                                                         infinp = (isinf(Rx)) || (isinf(Rt)) ||
                                                         (isinf(Rs));
                                                         if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx =
                                                         NaN;
                                                         ;
                                                         tmp=fmaf(Rs,Rt,Rx);
                                                         if (!((Rx == 0.0) && is_true_zero(Rs*Rt))) Rx =
                                                         tmp;
                                                         cancel_flags();
                                                         if (isinf(Rx) && !infinp) Rx = Rx - 1;
                                                         if (infminusinf) Rx = 0;
                   Rx-=sfmpy(Rs,Rt):lib                  round_to_nearest();
                                                         infminusinf = ((isinf(Rx)) && (isinf(Rs*Rt)) &&
                                                         (Rs ^ Rx ^ Rt.31 == 0));
                                                         infinp = (isinf(Rx)) || (isinf(Rt)) ||
                                                         (isinf(Rs));
                                                         if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx =
                                                         NaN;
                                                         ;
                                                         tmp=fmaf(-Rs,Rt,Rx);
                                                         if (!((Rx == 0.0) && is_true_zero(Rs*Rt))) Rx =
                                                         tmp;
                                                         cancel_flags();
                                                         if (isinf(Rx) && !infinp) Rx = Rx - 1;
                                                         if (infminusinf) Rx = 0;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx+=sfmpy(Rs,Rt):lib                  Word32 Q6_R_sfmpyacc_RR_lib(Word32 Rx, Word32
                                                         Rs, Word32 Rt)
                   Rx-=sfmpy(Rs,Rt):lib                  Word32 Q6_R_sfmpynac_RR_lib(Word32 Rx, Word32
                                                         Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                                               530
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  1   1  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 x x x  x x Rx+=sfmpy(Rs,Rt):lib
 1  1  1  0 1  1   1  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 x x x  x x Rx-=sfmpy(Rs,Rt):lib
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                              531
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Create floating-point constant
                  Using ten bits of immediate, form a floating-point constant.
                   Syntax                                   Behavior
                   Rd=sfmake(#u10):neg                      Rd = (127 - 6) << 23;
                                                            Rd += (#u << 17);
                                                            Rd |= (1 << 31);
                   Rd=sfmake(#u10):pos                      Rd = (127 - 6) << 23;
                                                            Rd += #u << 17;
                   Rdd=dfmake(#u10):neg                     Rdd = (1023ULL - 6) << 52;
                                                            Rdd += (#u) << 46;
                                                            Rdd |= ((1ULL) << 63);
                   Rdd=dfmake(#u10):pos                     Rdd = (1023ULL - 6) << 52;
                                                            Rdd += (#u) << 46;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=sfmake(#u10):neg                      Word32 Q6_R_sfmake_I_neg(Word32 Iu10)
                   Rd=sfmake(#u10):pos                      Word32 Q6_R_sfmake_I_pos(Word32 Iu10)
                   Rdd=dfmake(#u10):neg                     Word64 Q6_P_dfmake_I_neg(Word32 Iu10)
                   Rdd=dfmake(#u10):pos                     Word64 Q6_P_dfmake_I_pos(Word32 Iu10)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7    6  5  4 3 2  1 0
   ICLASS     RegType                            Parse                    MinOp       d5
 1  1  0  1 0  1   1  0 0  0   i  -  -  -   -  - P   P i  i   i i  i i  i    i  i d d d  d d Rd=sfmake(#u10):pos
 1  1  0  1 0  1   1  0 0  1   i  -  -  -   -  - P   P i  i   i i  i i  i    i  i d d d  d d Rd=sfmake(#u10):neg
   ICLASS     RegType                            Parse                                d5
 1  1  0  1 1  0   0  1 0  0   i  -  -  -   -  - P   P i  i   i i  i i  i    i  i d d d  d d Rdd=dfmake(#u10):pos
 1  1  0  1 1  0   0  1 0  1   i  -  -  -   -  - P   P i  i   i i  i i  i    i  i d d d  d d Rdd=dfmake(#u10):neg
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
80-N2040-45 Rev. B                                                                                                532
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Floating point maximum
                  Maximum of two floating point values. If one value is a NaN, the other is chosen.
                   Syntax                                   Behavior
                   Rd=sfmax(Rs,Rt)                          Rd = fmaxf(Rs,Rt);
                   Rdd=dfmax(Rss,Rtt)                       Rdd = fmax(Rss,Rtt);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=sfmax(Rs,Rt)                          Word32 Q6_R_sfmax_RR(Word32 Rs, Word32 Rt)
                   Rdd=dfmax(Rss,Rtt)                       Word64 Q6_P_dfmax_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  0 0  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0   1  1 d d d  d d Rdd=dfmax(Rss,Rtt)
 1  1  1  0 1  0   1  1 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d Rd=sfmax(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             533
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Floating point minimum
                  Minimum of two floating point values. If one value is a NaN, the other is chosen.
                   Syntax                                   Behavior
                   Rd=sfmin(Rs,Rt)                          Rd = fmin(Rs,Rt);
                   Rdd=dfmin(Rss,Rtt)                       Rdd = fmin(Rss,Rtt);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=sfmin(Rs,Rt)                          Word32 Q6_R_sfmin_RR(Word32 Rs, Word32 Rt)
                   Rdd=dfmin(Rss,Rtt)                       Word64 Q6_P_dfmin_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  0 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  1 d d d  d d Rdd=dfmin(Rss,Rtt)
 1  1  1  0 1  0   1  1 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rd=sfmin(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             534
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Floating point multiply
                  Multiply two floating point values
                   Syntax                                   Behavior
                   Rd=sfmpy(Rs,Rt)                          Rd=Rs*Rt;
                   Rdd=dfmpyfix(Rss,Rtt)                    if (is_denormal(Rss) && (df_exponent(Rtt) >=
                                                            512) && is_normal(Rtt)) Rdd = Rss * 0x1.0p52;
                                                            else if (is_denormal(Rtt) && (df_exponent(Rss)
                                                            >= 512) && is_normal(Rss)) Rdd = Rss * 0x1.0p-52;
                                                            else Rdd = Rss;
                   Rdd=dfmpyll(Rss,Rtt)                     prod = (Rss.uw[0] * Rtt.uw[0]);
                                                            Rdd = (prod >> 32) << 1;
                                                            if (prod.uw[0] != 0) Rdd.0 = 1;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=sfmpy(Rs,Rt)                          Word32 Q6_R_sfmpy_RR(Word32 Rs, Word32 Rt)
                   Rdd=dfmpyfix(Rss,Rtt)                    Word64 Q6_P_dfmpyfix_PP(Word64 Rss, Word64 Rtt)
                   Rdd=dfmpyll(Rss,Rtt)                     Word64 Q6_P_dfmpyll_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  0 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  1 d d d  d d Rdd=dfmpyfix(Rss,Rtt)
 1  1  1  0 1  0   0  0 1  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0   1  1 d d d  d d Rdd=dfmpyll(Rss,Rtt)
 1  1  1  0 1  0   1  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d Rd=sfmpy(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                               535
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          Floating point reciprocal approximation
                  Provides an approximation of the reciprocal of the denominator (Rt), if combined with the
                  appropriate fixup instructions. Certain values (such as infinities or zeros) in the numerator
                  or denominator may yield values that are not reciprocal approximations, but yield the
                  correct answer when combined with fixup instructions and the appropriate routines.
                  For compatibility, do not rely on exact results of these instructions. The precision of the
                  approximation for this architecture and later is at least 6.6 bits.
                   Syntax                                    Behavior
                   Rd,Pe=sfrecipa(Rs,Rt)                     if ((Rs,Rt,Rd,adjust)=recip_common(Rs,Rt)) {
                                                                  Pe = adjust;
                                                                  idx = (Rt >> 16) & 0x7f;
                                                                  mant = (recip_lut[idx] << 15) | 1;
                                                                  exp = 127 - (exponent(Rt) - 127) - 1;
                                                                  Rd = -1**Rt.31 * 1.MANT * 2**(exp-BIAS);
                                                             }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■   This instruction provides a certain amount of accuracy. In future versions the
                            accuracy may increase. For future compatibility, avoid dependence on exact
                            values.
                        ■   The predicate generated by this instruction cannot be used as a .new predicate, nor
                            can it be automatically AND’d with another predicate.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6   5  4 3 2  1 0
   ICLASS     RegType      MajOp        s5        Parse          t5           e2       d5
 1  1  1  0 1  0   1  1  1  1   1  s  s  s  s  s  P   P 0  t   t  t t  t 1  e    e d d d  d d Rd,Pe=sfrecipa(Rs,Rt)
                  Field name         Description
                  ICLASS             Instruction Class
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  RegType            Register Type
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  e2                 Field to encode register e
                  s5                 Field to encode register s
                  t5                 Field to encode register t
80-N2040-45 Rev. B                                                                                                  536
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Floating point subtraction
                  Subtract two floating point values
                   Syntax                                   Behavior
                   Rd=sfsub(Rs,Rt)                          Rd=Rs-Rt;
                   Rdd=dfsub(Rss,Rtt)                       Rdd=Rss-Rtt;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=sfsub(Rs,Rt)                          Word32 Q6_R_sfsub_RR(Word32 Rs, Word32 Rt)
                   Rdd=dfsub(Rss,Rtt)                       Word64 Q6_P_dfsub_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  0 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  1 d d d  d d Rdd=dfsub(Rss,Rtt)
 1  1  1  0 1  0   1  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rd=sfsub(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                             537
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
  11.10.5         XTYPE/MPY
                  The XTYPE/MPY instruction subclass includes instructions which perform
                  multiplication.
        Multiply and use lower result
                  Multiply the signed 32-bit integer in Rs by either the signed 32-bit integer in Rt or an
                  unsigned immediate value. The 64-bit result is optionally accumulated with the 32-bit
                  destination, or added to an immediate. The least-significant 32-bits of the result are written
                  to the single destination register.
                  This multiply produces the correct results for the ANSI C multiplication of two signed or
                  unsigned integers with an integer result.
                                            Rs
                                          Rt /#u8
                                 *
                                   64
                                Add
                          Low 32-bits                     32
                        Rx
                   Syntax                              Behavior
                   Rd=+mpyi(Rs,#u8)                     apply_extension(#u);
                                                        Rd=Rs*#u;
                   Rd=-mpyi(Rs,#u8)                     Rd=Rs*-#u;
                   Rd=add(#u6,mpyi(Rs,#U6))             apply_extension(#u);
                                                        Rd = #u + Rs*#U;
                   Rd=add(#u6,mpyi(Rs,Rt))              apply_extension(#u);
                                                        Rd = #u + Rs*Rt;
                   Rd=add(Ru,mpyi(#u6:2,Rs))            Rd = Ru + Rs*#u;
                                                        ;
                   Rd=add(Ru,mpyi(Rs,#u6))              apply_extension(#u);
                                                        Rd = Ru + Rs*#u;
                                                        ;
80-N2040-45 Rev. B                                                                                            538
Hexagon V67 Programmer’s Reference Manual                                         Instruction Set
                   Syntax                    Behavior
                   Rd=mpyi(Rs,#m9)           if ("((#m9<0) && (#m9>-256))") {
                                                 Assembler mapped to: "Rd=-mpyi(Rs,#m9*(-
                                             1))";
                                             } else {
                                                 Assembler mapped to: "Rd=+mpyi(Rs,#m9)";
                                             }
                   Rd=mpyi(Rs,Rt)            Rd=Rs*Rt;
                   Rd=mpyui(Rs,Rt)           Assembler mapped to: "Rd=mpyi(Rs,Rt)"
                   Rx+=mpyi(Rs,#u8)          apply_extension(#u);
                                             Rx=Rx + (Rs*#u);
                                             ;
                   Rx+=mpyi(Rs,Rt)           Rx=Rx + Rs*Rt;
                                             ;
                   Rx-=mpyi(Rs,#u8)          apply_extension(#u);
                                             Rx=Rx - (Rs*#u);
                                             ;
                   Rx-=mpyi(Rs,Rt)           Rx=Rx - Rs*Rt;
                                             ;
                   Ry=add(Ru,mpyi(Ry,Rs))    Ry = Ru + Rs*Ry;
                                             ;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=add(#u6,mpyi(Rs,#U6))  Word32 Q6_R_add_mpyi_IRI(Word32 Iu6, Word32 Rs,
                                             Word32 IU6)
                   Rd=add(#u6,mpyi(Rs,Rt))   Word32 Q6_R_add_mpyi_IRR(Word32 Iu6, Word32 Rs,
                                             Word32 Rt)
                   Rd=add(Ru,mpyi(#u6:2,Rs)) Word32 Q6_R_add_mpyi_RIR(Word32 Ru, Word32
                                             Iu6_2, Word32 Rs)
                   Rd=add(Ru,mpyi(Rs,#u6))   Word32 Q6_R_add_mpyi_RRI(Word32 Ru, Word32 Rs,
                                             Word32 Iu6)
                   Rd=mpyi(Rs,#m9)           Word32 Q6_R_mpyi_RI(Word32 Rs, Word32 Im9)
                   Rd=mpyi(Rs,Rt)            Word32 Q6_R_mpyi_RR(Word32 Rs, Word32 Rt)
                   Rd=mpyui(Rs,Rt)           Word32 Q6_R_mpyui_RR(Word32 Rs, Word32 Rt)
                   Rx+=mpyi(Rs,#u8)          Word32 Q6_R_mpyiacc_RI(Word32 Rx, Word32 Rs,
                                             Word32 Iu8)
                   Rx+=mpyi(Rs,Rt)           Word32 Q6_R_mpyiacc_RR(Word32 Rx, Word32 Rs,
                                             Word32 Rt)
                   Rx-=mpyi(Rs,#u8)          Word32 Q6_R_mpyinac_RI(Word32 Rx, Word32 Rs,
                                             Word32 Iu8)
                   Rx-=mpyi(Rs,Rt)           Word32 Q6_R_mpyinac_RR(Word32 Rx, Word32 Rs,
                                             Word32 Rt)
                   Ry=add(Ru,mpyi(Ry,Rs))    Word32 Q6_R_add_mpyi_RRR(Word32 Ru, Word32 Ry,
                                             Word32 Rs)
80-N2040-45 Rev. B                                                                            539
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5  4 3 2  1 0
   ICLASS     RegType                   s5        Parse          t5       MinOp       d5
 1  1  0  1 0  1   1  1 0    i   i s  s  s  s  s  P   P i  t   t  t t t i    i  i d d d  d d Rd=add(#u6,mpyi(Rs,Rt))
   ICLASS     RegType                   s5        Parse          d5
 1  1  0  1 1  0   0  0  I   i   i s  s  s  s  s  P   P i  d  d  d  d d i    i  i I I  I I I Rd=add(#u6,mpyi(Rs,#U6))
   ICLASS     RegType                   s5        Parse          d5                   u5
 1  1  0  1 1  1   1  1 0    i   i s  s  s  s  s  P   P i  d  d  d  d d i    i  i u u u  u u Rd=add(Ru,mpyi(#u6:2,Rs)
                                                                                             )
 1  1  0  1 1  1   1  1 1    i   i s  s  s  s  s  P   P i  d  d  d  d d i    i  i u u u  u u Rd=add(Ru,mpyi(Rs,#u6))
   ICLASS     RegType      MajOp        s5        Parse          y5                   u5
 1  1  1  0 0  0   1  1 0   0   0  s  s  s  s  s  P   P -  y  y   y y y -   -   - u u u  u u Ry=add(Ru,mpyi(Ry,Rs))
   ICLASS     RegType      MajOp        s5        Parse                   MinOp       d5
 1  1  1  0 0  0   0  0 0    -   - s  s  s  s  s  P   P 0  i   i  i i i i    i  i d d d  d d Rd=+mpyi(Rs,#u8)
 1  1  1  0 0  0   0  0 1    -   - s  s  s  s  s  P   P 0  i   i  i i i i    i  i d d d  d d Rd=-mpyi(Rs,#u8)
   ICLASS     RegType      MajOp        s5        Parse                   MinOp       x5
 1  1  1  0 0  0   0  1 0    -   - s  s  s  s  s  P   P 0  i   i  i i i i    i  i x x  x x x Rx+=mpyi(Rs,#u8)
 1  1  1  0 0  0   0  1 1    -   - s  s  s  s  s  P   P 0  i   i  i i i i    i  i x x  x x x Rx-=mpyi(Rs,#u8)
   ICLASS     RegType      MajOp        s5        Parse          t5       MinOp       d5
 1  1  1  0 1  1   0  1 0   0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0  d d d  d d Rd=mpyi(Rs,Rt)
   ICLASS     RegType      MajOp        s5        Parse          t5       MinOp       x5
 1  1  1  0 1  1   1  1 0   0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0  x x  x x x Rx+=mpyi(Rs,Rt)
 1  1  1  0 1  1   1  1 1   0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0  x x  x x x Rx-=mpyi(Rs,Rt)
                  Field name         Description
                  RegType            Register Type
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  ICLASS             Instruction Class
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  RegType            Register Type
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  s5                 Field to encode register s
                  t5                 Field to encode register t
                  u5                 Field to encode register u
                  x5                 Field to encode register x
                  y5                 Field to encode register y
80-N2040-45 Rev. B                                                                                                540
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
        Vector multiply word by signed half (32x16)
                  Perform mixed precision vector multiply operations. A 32-bit word from vector Rss is
                  multiplied by a 16-bit halfword (either even or odd) from vector Rtt. The multiplication is
                  performed as a signed 32x16, which produces a 48-bit result. This result is optionally
                  scaled left by one bit. This result is then shifted right by 16 bits, optionally accumulated
                  and then saturated to 32-bits. This operation is available in vector form
                  (vmpyweh/vmpywoh) and non-vector form (multiply and use upper result).
                            s16                s16                 s16              s16           Rtt
                                                mux                                 mux
                                     s32                                    s32                   Rss
                                      *                                      *
                                        48    0x0    0x8000                   48     0x0   0x8000
                                    <<0-1                                  <<0-1
                                                  mux                                    mux
                                         Add                                   Add
                                        >>16                                   >>16
                                        Add                                      Add
                                      Sat_32                                   Sat_32                        32
                       32
                                                               Rxx
                   Syntax                                 Behavior
                   Rdd=vmpyweh(Rss,Rtt)[:<<1]:rnd:        Rdd.w[1]=sat_32(((Rss.w[1] *
                   sat                                    Rtt.h[2])[<<1]+0x8000)>>16);
                                                          Rdd.w[0]=sat_32(((Rss.w[0] *
                                                          Rtt.h[0])[<<1]+0x8000)>>16);
80-N2040-45 Rev. B                                                                                                541
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Syntax                              Behavior
                   Rdd=vmpyweh(Rss,Rtt)[:<<1]:sat      Rdd.w[1]=sat_32(((Rss.w[1] *
                                                       Rtt.h[2])[<<1])>>16);
                                                       Rdd.w[0]=sat_32(((Rss.w[0] *
                                                       Rtt.h[0])[<<1])>>16);
                   Rdd=vmpywoh(Rss,Rtt)[:<<1]:rnd:     Rdd.w[1]=sat_32(((Rss.w[1] *
                   sat                                 Rtt.h[3])[<<1]+0x8000)>>16);
                                                       Rdd.w[0]=sat_32(((Rss.w[0] *
                                                       Rtt.h[1])[<<1]+0x8000)>>16);
                   Rdd=vmpywoh(Rss,Rtt)[:<<1]:sat      Rdd.w[1]=sat_32(((Rss.w[1] *
                                                       Rtt.h[3])[<<1])>>16);
                                                       Rdd.w[0]=sat_32(((Rss.w[0] *
                                                       Rtt.h[1])[<<1])>>16);
                   Rxx+=vmpyweh(Rss,Rtt)[:<<1]:rnd     Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
                   :sat                                Rtt.h[2])[<<1]+0x8000)>>16));
                                                       Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
                                                       Rtt.h[0])[<<1]+0x8000)>>16));
                                                       ;
                   Rxx+=vmpyweh(Rss,Rtt)[:<<1]:sat     Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
                                                       Rtt.h[2])[<<1])>>16));
                                                       Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
                                                       Rtt.h[0])[<<1])>>16));
                                                       ;
                   Rxx+=vmpywoh(Rss,Rtt)[:<<1]:rnd     Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
                   :sat                                Rtt.h[3])[<<1]+0x8000)>>16));
                                                       Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
                                                       Rtt.h[1])[<<1]+0x8000)>>16 ));
                                                       ;
                   Rxx+=vmpywoh(Rss,Rtt)[:<<1]:sat     Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
                                                       Rtt.h[3])[<<1])>>16));
                                                       Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
                                                       Rtt.h[1])[<<1])>>16 ));
                                                       ;
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■  If saturation occurs during execution of this instruction (a result is clamped to
                          either maximum or minimum values), the OVF bit in the Status Register is set.
                          OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                             542
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                  Intrinsics
                   Rdd=vmpyweh(Rss,Rtt):<<1:rnd:sa          Word64 Q6_P_vmpyweh_PP_s1_rnd_sat(Word64 Rss,
                   t                                        Word64 Rtt)
                   Rdd=vmpyweh(Rss,Rtt):<<1:sat             Word64 Q6_P_vmpyweh_PP_s1_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vmpyweh(Rss,Rtt):rnd:sat             Word64 Q6_P_vmpyweh_PP_rnd_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rdd=vmpyweh(Rss,Rtt):sat                 Word64 Q6_P_vmpyweh_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vmpywoh(Rss,Rtt):<<1:rnd:sa          Word64 Q6_P_vmpywoh_PP_s1_rnd_sat(Word64 Rss,
                   t                                        Word64 Rtt)
                   Rdd=vmpywoh(Rss,Rtt):<<1:sat             Word64 Q6_P_vmpywoh_PP_s1_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vmpywoh(Rss,Rtt):rnd:sat             Word64 Q6_P_vmpywoh_PP_rnd_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rdd=vmpywoh(Rss,Rtt):sat                 Word64 Q6_P_vmpywoh_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rxx+=vmpyweh(Rss,Rtt):<<1:rnd:s          Word64 Q6_P_vmpywehacc_PP_s1_rnd_sat(Word64 Rxx,
                   at                                       Word64 Rss, Word64 Rtt)
                   Rxx+=vmpyweh(Rss,Rtt):<<1:sat            Word64 Q6_P_vmpywehacc_PP_s1_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vmpyweh(Rss,Rtt):rnd:sat            Word64 Q6_P_vmpywehacc_PP_rnd_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vmpyweh(Rss,Rtt):sat                Word64 Q6_P_vmpywehacc_PP_sat(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                   Rxx+=vmpywoh(Rss,Rtt):<<1:rnd:s          Word64 Q6_P_vmpywohacc_PP_s1_rnd_sat(Word64 Rxx,
                   at                                       Word64 Rss, Word64 Rtt)
                   Rxx+=vmpywoh(Rss,Rtt):<<1:sat            Word64 Q6_P_vmpywohacc_PP_s1_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vmpywoh(Rss,Rtt):rnd:sat            Word64 Q6_P_vmpywohacc_PP_rnd_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vmpywoh(Rss,Rtt):sat                Word64 Q6_P_vmpywohacc_PP_sat(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5 4 3 2  1 0
   ICLASS     RegType    MajOp         s5       Parse           t5        MinOp      d5
 1  1  1  0 1  0   0  0 N 0   0   s  s  s  s  s P   P 0   t   t  t t t  1   0  1 d d d  d d Rdd=vmpyweh(Rss,Rtt)[:<<
                                                                                            N]:sat
 1  1  1  0 1  0   0  0 N 0   0   s  s  s  s  s P   P 0   t   t  t t t  1   1  1 d d d  d d Rdd=vmpywoh(Rss,Rtt)[:<<
                                                                                            N]:sat
                                                                                            Rdd=vmpyweh(Rss,Rtt)[:<<
 1  1  1  0 1  0   0  0 N 0   1   s  s  s  s  s P   P 0   t   t  t t t  1   0  1 d d d  d d N]:rnd:sat
 1  1  1  0 1  0   0  0 N 0   1   s  s  s  s  s P   P 0   t   t  t t t  1   1  1 d d d  d d Rdd=vmpywoh(Rss,Rtt)[:<<
                                                                                            N]:rnd:sat
80-N2040-45 Rev. B                                                                                                543
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType    MajOp         s5        Parse          t5       MinOp      x5
                                                                                           Rxx+=vmpyweh(Rss,Rtt)[:<
 1  1  1  0 1  0   1  0 N 0   0   s  s  s  s  s  P   P 0  t   t  t t t 1   0  1 x x x  x x
                                                                                           <N]:sat
                                                                                           Rxx+=vmpywoh(Rss,Rtt)[:<
 1  1  1  0 1  0   1  0 N 0   0   s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 x x x  x x
                                                                                           <N]:sat
                                                                                           Rxx+=vmpyweh(Rss,Rtt)[:<
 1  1  1  0 1  0   1  0 N 0   1   s  s  s  s  s  P   P 0  t   t  t t t 1   0  1 x x x  x x
                                                                                           <N]:rnd:sat
                                                                                           Rxx+=vmpywoh(Rss,Rtt)[:<
 1  1  1  0 1  0   1  0 N 0   1   s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 x x x  x x
                                                                                           <N]:rnd:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                              544
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
        Vector multiply word by unsigned half (32x16)
                  Perform mixed precision vector multiply operations. A 32-bit signed word from vector
                  Rss is multiplied by a 16-bit unsigned halfword (either odd or even) from vector Rtt. This
                  multiplication produces a 48-bit result. This result is optionally scaled left by one bit, and
                  then a rounding constant is optionally added to the lower 16-bits. This result is then shifted
                  right by 16 bits, optionally accumulated and then saturated to 32-bits. This is a dual vector
                  operation and is performed for both high and low word of Rss.
                            u16                u16              u16               u16            Rtt
                                                mux                                mux
                                      s32                                 s32                    Rss
                                       *                                   *
                                        48    0x0   0x8000                   48     0x0   0x8000
                                     <<0-1                                <<0-1
                                                  mux                                   mux
                                         Add                                  Add
                                        >>16                                  >>16
                                         Add                                    Add
                                       Sat_32                                Sat_32                         32
                       32
                                                            Rxx
                   Syntax                               Behavior
                   Rdd=vmpyweuh(Rss,Rtt)[:<<1]:rnd      Rdd.w[1]=sat_32(((Rss.w[1] *
                   :sat                                 Rtt.uh[2])[<<1]+0x8000)>>16);
                                                        Rdd.w[0]=sat_32(((Rss.w[0] *
                                                        Rtt.uh[0])[<<1]+0x8000)>>16);
80-N2040-45 Rev. B                                                                                               545
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Syntax                              Behavior
                   Rdd=vmpyweuh(Rss,Rtt)[:<<1]:sat     Rdd.w[1]=sat_32(((Rss.w[1] *
                                                       Rtt.uh[2])[<<1])>>16);
                                                       Rdd.w[0]=sat_32(((Rss.w[0] *
                                                       Rtt.uh[0])[<<1])>>16);
                   Rdd=vmpywouh(Rss,Rtt)[:<<1]:rnd     Rdd.w[1]=sat_32(((Rss.w[1] *
                   :sat                                Rtt.uh[3])[<<1]+0x8000)>>16);
                                                       Rdd.w[0]=sat_32(((Rss.w[0] *
                                                       Rtt.uh[1])[<<1]+0x8000)>>16);
                   Rdd=vmpywouh(Rss,Rtt)[:<<1]:sat     Rdd.w[1]=sat_32(((Rss.w[1] *
                                                       Rtt.uh[3])[<<1])>>16);
                                                       Rdd.w[0]=sat_32(((Rss.w[0] *
                                                       Rtt.uh[1])[<<1])>>16);
                   Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:rn     Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
                   d:sat                               Rtt.uh[2])[<<1]+0x8000)>>16));
                                                       Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
                                                       Rtt.uh[0])[<<1]+0x8000)>>16));
                                                       ;
                   Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:sa     Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
                   t                                   Rtt.uh[2])[<<1])>>16));
                                                       Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
                                                       Rtt.uh[0])[<<1])>>16));
                                                       ;
                   Rxx+=vmpywouh(Rss,Rtt)[:<<1]:rn     Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
                   d:sat                               Rtt.uh[3])[<<1]+0x8000)>>16));
                                                       Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
                                                       Rtt.uh[1])[<<1]+0x8000)>>16 ));
                                                       ;
                   Rxx+=vmpywouh(Rss,Rtt)[:<<1]:sa     Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
                   t                                   Rtt.uh[3])[<<1])>>16));
                                                       Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
                                                       Rtt.uh[1])[<<1])>>16 ));
                                                       ;
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■  If saturation occurs during execution of this instruction (a result is clamped to
                          either maximum or minimum values), the OVF bit in the Status Register is set.
                          OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                             546
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                  Intrinsics
                   Rdd=vmpyweuh(Rss,Rtt):<<1:rnd:s          Word64 Q6_P_vmpyweuh_PP_s1_rnd_sat(Word64 Rss,
                   at                                       Word64 Rtt)
                   Rdd=vmpyweuh(Rss,Rtt):<<1:sat            Word64 Q6_P_vmpyweuh_PP_s1_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rdd=vmpyweuh(Rss,Rtt):rnd:sat            Word64 Q6_P_vmpyweuh_PP_rnd_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rdd=vmpyweuh(Rss,Rtt):sat                Word64 Q6_P_vmpyweuh_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vmpywouh(Rss,Rtt):<<1:rnd:s          Word64 Q6_P_vmpywouh_PP_s1_rnd_sat(Word64 Rss,
                   at                                       Word64 Rtt)
                   Rdd=vmpywouh(Rss,Rtt):<<1:sat            Word64 Q6_P_vmpywouh_PP_s1_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rdd=vmpywouh(Rss,Rtt):rnd:sat            Word64 Q6_P_vmpywouh_PP_rnd_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rdd=vmpywouh(Rss,Rtt):sat                Word64 Q6_P_vmpywouh_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rxx+=vmpyweuh(Rss,Rtt):<<1:rnd:          Word64 Q6_P_vmpyweuhacc_PP_s1_rnd_sat(Word64
                   sat                                      Rxx, Word64 Rss, Word64 Rtt)
                   Rxx+=vmpyweuh(Rss,Rtt):<<1:sat           Word64 Q6_P_vmpyweuhacc_PP_s1_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vmpyweuh(Rss,Rtt):rnd:sat           Word64 Q6_P_vmpyweuhacc_PP_rnd_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vmpyweuh(Rss,Rtt):sat               Word64 Q6_P_vmpyweuhacc_PP_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vmpywouh(Rss,Rtt):<<1:rnd:          Word64 Q6_P_vmpywouhacc_PP_s1_rnd_sat(Word64
                   sat                                      Rxx, Word64 Rss, Word64 Rtt)
                   Rxx+=vmpywouh(Rss,Rtt):<<1:sat           Word64 Q6_P_vmpywouhacc_PP_s1_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vmpywouh(Rss,Rtt):rnd:sat           Word64 Q6_P_vmpywouhacc_PP_rnd_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vmpywouh(Rss,Rtt):sat               Word64 Q6_P_vmpywouhacc_PP_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5 4 3 2  1 0
   ICLASS     RegType    MajOp         s5       Parse           t5        MinOp      d5
 1  1  1  0 1  0   0  0 N 1   0   s  s  s  s  s P   P 0   t   t  t t t  1   0  1 d d d  d d Rdd=vmpyweuh(Rss,Rtt)[:<
                                                                                            <N]:sat
 1  1  1  0 1  0   0  0 N 1   0   s  s  s  s  s P   P 0   t   t  t t t  1   1  1 d d d  d d Rdd=vmpywouh(Rss,Rtt)[:<
                                                                                            <N]:sat
                                                                                            Rdd=vmpyweuh(Rss,Rtt)[:<
 1  1  1  0 1  0   0  0 N 1   1   s  s  s  s  s P   P 0   t   t  t t t  1   0  1 d d d  d d <N]:rnd:sat
 1  1  1  0 1  0   0  0 N 1   1   s  s  s  s  s P   P 0   t   t  t t t  1   1  1 d d d  d d Rdd=vmpywouh(Rss,Rtt)[:<
                                                                                            <N]:rnd:sat
80-N2040-45 Rev. B                                                                                               547
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType    MajOp         s5        Parse          t5       MinOp      x5
                                                                                           Rxx+=vmpyweuh(Rss,Rtt)[:
 1  1  1  0 1  0   1  0 N 1   0   s  s  s  s  s  P   P 0  t   t  t t t 1   0  1 x x x  x x
                                                                                           <<N]:sat
                                                                                           Rxx+=vmpywouh(Rss,Rtt)[:
 1  1  1  0 1  0   1  0 N 1   0   s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 x x x  x x
                                                                                           <<N]:sat
                                                                                           Rxx+=vmpyweuh(Rss,Rtt)[:
 1  1  1  0 1  0   1  0 N 1   1   s  s  s  s  s  P   P 0  t   t  t t t 1   0  1 x x x  x x
                                                                                           <<N]:rnd:sat
                                                                                           Rxx+=vmpywouh(Rss,Rtt)[:
 1  1  1  0 1  0   1  0 N 1   1   s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 x x x  x x
                                                                                           <<N]:rnd:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                              548
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Multiply signed halfwords
                  Multiply two signed halfwords. Optionally shift the multiplier result by 1 bit. This result
                  can be accumulated or rounded. The destination/accumulator is either 32 or 64-bits. For
                  32-bit results, saturation is optional.
  Rx+=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat]                          Rxx+=mpy(Rs.[HL],Rt.[HL])[:<<1]
  Rd = mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd][:sat]                   Rdd = mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd]
            Rs                     Rt                               Rs                 Rt
           mux                     mux                             mux                 mux
                      16x16                                                 16x16
                                                                                       0x0 0x8000
                                    0x0 0x8000
                           32                                                   32
                      <<0-1                                                 <<0-1
                                                                                          mux
                                       mux
                             32-bit                                           64-bit Add/
                           Add/Sub                                               Sub
                        Optional Sat
                          to 32-bits
                                                                                                                  Rxx
                                                       Rx
                   Syntax                                 Behavior
                   Rd=mpy(Rs.[HL],Rt.[HL])[:<<1][:        Rd=[sat_32]([round]((Rs.h[01] *
                   rnd][:sat]                             Rt.h[01])[<<1]));
                                                          ;
80-N2040-45 Rev. B                                                                                            549
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Syntax                              Behavior
                   Rdd=mpy(Rs.[HL],Rt.[HL])[:<<1][     Rdd=[round]((Rs.h[01] * Rt.h[01])[<<1]);
                   :rnd]                               ;
                   Rx+=mpy(Rs.[HL],Rt.[HL])[:<<1][     Rx=[sat_32](Rx+ (Rs.h[01] * Rt.h[01])[<<1]);
                   :sat]                               ;
                   Rx-                                 Rx=[sat_32](Rx- (Rs.h[01] * Rt.h[01])[<<1]);
                   =mpy(Rs.[HL],Rt.[HL])[:<<1][:sa     ;
                   t]
                   Rxx+=mpy(Rs.[HL],Rt.[HL])[:<<1]     Rxx=Rxx+ (Rs.h[01] * Rt.h[01])[<<1];
                                                       ;
                   Rxx-=mpy(Rs.[HL],Rt.[HL])[:<<1]     Rxx=Rxx- (Rs.h[01] * Rt.h[01])[<<1];
                                                       ;
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■  If saturation occurs during execution of this instruction (a result is clamped to
                          either maximum or minimum values), the OVF bit in the Status Register is set.
                          OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=mpy(Rs.H,Rt.H)                   Word32 Q6_R_mpy_RhRh(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.H,Rt.H):<<1               Word32 Q6_R_mpy_RhRh_s1(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.H,Rt.H):<<1:rnd           Word32 Q6_R_mpy_RhRh_s1_rnd(Word32 Rs, Word32
                                                       Rt)
                   Rd=mpy(Rs.H,Rt.H):<<1:rnd:sat       Word32 Q6_R_mpy_RhRh_s1_rnd_sat(Word32 Rs,
                                                       Word32 Rt)
                   Rd=mpy(Rs.H,Rt.H):<<1:sat           Word32 Q6_R_mpy_RhRh_s1_sat(Word32 Rs, Word32
                                                       Rt)
                   Rd=mpy(Rs.H,Rt.H):rnd               Word32 Q6_R_mpy_RhRh_rnd(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.H,Rt.H):rnd:sat           Word32 Q6_R_mpy_RhRh_rnd_sat(Word32 Rs, Word32
                                                       Rt)
                   Rd=mpy(Rs.H,Rt.H):sat               Word32 Q6_R_mpy_RhRh_sat(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.H,Rt.L)                   Word32 Q6_R_mpy_RhRl(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.H,Rt.L):<<1               Word32 Q6_R_mpy_RhRl_s1(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.H,Rt.L):<<1:rnd           Word32 Q6_R_mpy_RhRl_s1_rnd(Word32 Rs, Word32
                                                       Rt)
                   Rd=mpy(Rs.H,Rt.L):<<1:rnd:sat       Word32 Q6_R_mpy_RhRl_s1_rnd_sat(Word32 Rs,
                                                       Word32 Rt)
                   Rd=mpy(Rs.H,Rt.L):<<1:sat           Word32 Q6_R_mpy_RhRl_s1_sat(Word32 Rs, Word32
                                                       Rt)
                   Rd=mpy(Rs.H,Rt.L):rnd               Word32 Q6_R_mpy_RhRl_rnd(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.H,Rt.L):rnd:sat           Word32 Q6_R_mpy_RhRl_rnd_sat(Word32 Rs, Word32
                                                       Rt)
                   Rd=mpy(Rs.H,Rt.L):sat               Word32 Q6_R_mpy_RhRl_sat(Word32 Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                                             550
Hexagon V67 Programmer’s Reference Manual                                             Instruction Set
                   Rd=mpy(Rs.L,Rt.H)             Word32 Q6_R_mpy_RlRh(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.L,Rt.H):<<1         Word32 Q6_R_mpy_RlRh_s1(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.L,Rt.H):<<1:rnd     Word32 Q6_R_mpy_RlRh_s1_rnd(Word32 Rs, Word32
                                                 Rt)
                   Rd=mpy(Rs.L,Rt.H):<<1:rnd:sat Word32 Q6_R_mpy_RlRh_s1_rnd_sat(Word32 Rs,
                                                 Word32 Rt)
                   Rd=mpy(Rs.L,Rt.H):<<1:sat     Word32 Q6_R_mpy_RlRh_s1_sat(Word32 Rs, Word32
                                                 Rt)
                   Rd=mpy(Rs.L,Rt.H):rnd         Word32 Q6_R_mpy_RlRh_rnd(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.L,Rt.H):rnd:sat     Word32 Q6_R_mpy_RlRh_rnd_sat(Word32 Rs, Word32
                                                 Rt)
                   Rd=mpy(Rs.L,Rt.H):sat         Word32 Q6_R_mpy_RlRh_sat(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.L,Rt.L)             Word32 Q6_R_mpy_RlRl(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.L,Rt.L):<<1         Word32 Q6_R_mpy_RlRl_s1(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.L,Rt.L):<<1:rnd     Word32 Q6_R_mpy_RlRl_s1_rnd(Word32 Rs, Word32
                                                 Rt)
                   Rd=mpy(Rs.L,Rt.L):<<1:rnd:sat Word32 Q6_R_mpy_RlRl_s1_rnd_sat(Word32 Rs,
                                                 Word32 Rt)
                   Rd=mpy(Rs.L,Rt.L):<<1:sat     Word32 Q6_R_mpy_RlRl_s1_sat(Word32 Rs, Word32
                                                 Rt)
                   Rd=mpy(Rs.L,Rt.L):rnd         Word32 Q6_R_mpy_RlRl_rnd(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs.L,Rt.L):rnd:sat     Word32 Q6_R_mpy_RlRl_rnd_sat(Word32 Rs, Word32
                                                 Rt)
                   Rd=mpy(Rs.L,Rt.L):sat         Word32 Q6_R_mpy_RlRl_sat(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.H,Rt.H)            Word64 Q6_P_mpy_RhRh(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.H,Rt.H):<<1        Word64 Q6_P_mpy_RhRh_s1(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.H,Rt.H):<<1:rnd    Word64 Q6_P_mpy_RhRh_s1_rnd(Word32 Rs, Word32
                                                 Rt)
                   Rdd=mpy(Rs.H,Rt.H):rnd        Word64 Q6_P_mpy_RhRh_rnd(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.H,Rt.L)            Word64 Q6_P_mpy_RhRl(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.H,Rt.L):<<1        Word64 Q6_P_mpy_RhRl_s1(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.H,Rt.L):<<1:rnd    Word64 Q6_P_mpy_RhRl_s1_rnd(Word32 Rs, Word32
                                                 Rt)
                   Rdd=mpy(Rs.H,Rt.L):rnd        Word64 Q6_P_mpy_RhRl_rnd(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.L,Rt.H)            Word64 Q6_P_mpy_RlRh(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.L,Rt.H):<<1        Word64 Q6_P_mpy_RlRh_s1(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.L,Rt.H):<<1:rnd    Word64 Q6_P_mpy_RlRh_s1_rnd(Word32 Rs, Word32
                                                 Rt)
                   Rdd=mpy(Rs.L,Rt.H):rnd        Word64 Q6_P_mpy_RlRh_rnd(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.L,Rt.L)            Word64 Q6_P_mpy_RlRl(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.L,Rt.L):<<1        Word64 Q6_P_mpy_RlRl_s1(Word32 Rs, Word32 Rt)
                   Rdd=mpy(Rs.L,Rt.L):<<1:rnd    Word64 Q6_P_mpy_RlRl_s1_rnd(Word32 Rs, Word32
                                                 Rt)
                   Rdd=mpy(Rs.L,Rt.L):rnd        Word64 Q6_P_mpy_RlRl_rnd(Word32 Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                                551
Hexagon V67 Programmer’s Reference Manual                                           Instruction Set
                   Rx+=mpy(Rs.H,Rt.H)         Word32 Q6_R_mpyacc_RhRh(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx+=mpy(Rs.H,Rt.H):<<1     Word32 Q6_R_mpyacc_RhRh_s1(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx+=mpy(Rs.H,Rt.H):<<1:sat Word32 Q6_R_mpyacc_RhRh_s1_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx+=mpy(Rs.H,Rt.H):sat     Word32 Q6_R_mpyacc_RhRh_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx+=mpy(Rs.H,Rt.L)         Word32 Q6_R_mpyacc_RhRl(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx+=mpy(Rs.H,Rt.L):<<1     Word32 Q6_R_mpyacc_RhRl_s1(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx+=mpy(Rs.H,Rt.L):<<1:sat Word32 Q6_R_mpyacc_RhRl_s1_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx+=mpy(Rs.H,Rt.L):sat     Word32 Q6_R_mpyacc_RhRl_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx+=mpy(Rs.L,Rt.H)         Word32 Q6_R_mpyacc_RlRh(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx+=mpy(Rs.L,Rt.H):<<1     Word32 Q6_R_mpyacc_RlRh_s1(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx+=mpy(Rs.L,Rt.H):<<1:sat Word32 Q6_R_mpyacc_RlRh_s1_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx+=mpy(Rs.L,Rt.H):sat     Word32 Q6_R_mpyacc_RlRh_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx+=mpy(Rs.L,Rt.L)         Word32 Q6_R_mpyacc_RlRl(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx+=mpy(Rs.L,Rt.L):<<1     Word32 Q6_R_mpyacc_RlRl_s1(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx+=mpy(Rs.L,Rt.L):<<1:sat Word32 Q6_R_mpyacc_RlRl_s1_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx+=mpy(Rs.L,Rt.L):sat     Word32 Q6_R_mpyacc_RlRl_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx-=mpy(Rs.H,Rt.H)         Word32 Q6_R_mpynac_RhRh(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx-=mpy(Rs.H,Rt.H):<<1     Word32 Q6_R_mpynac_RhRh_s1(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx-=mpy(Rs.H,Rt.H):<<1:sat Word32 Q6_R_mpynac_RhRh_s1_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx-=mpy(Rs.H,Rt.H):sat     Word32 Q6_R_mpynac_RhRh_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx-=mpy(Rs.H,Rt.L)         Word32 Q6_R_mpynac_RhRl(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx-=mpy(Rs.H,Rt.L):<<1     Word32 Q6_R_mpynac_RhRl_s1(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx-=mpy(Rs.H,Rt.L):<<1:sat Word32 Q6_R_mpynac_RhRl_s1_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx-=mpy(Rs.H,Rt.L):sat     Word32 Q6_R_mpynac_RhRl_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                              552
Hexagon V67 Programmer’s Reference Manual                                           Instruction Set
                   Rx-=mpy(Rs.L,Rt.H)         Word32 Q6_R_mpynac_RlRh(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx-=mpy(Rs.L,Rt.H):<<1     Word32 Q6_R_mpynac_RlRh_s1(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx-=mpy(Rs.L,Rt.H):<<1:sat Word32 Q6_R_mpynac_RlRh_s1_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx-=mpy(Rs.L,Rt.H):sat     Word32 Q6_R_mpynac_RlRh_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx-=mpy(Rs.L,Rt.L)         Word32 Q6_R_mpynac_RlRl(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx-=mpy(Rs.L,Rt.L):<<1     Word32 Q6_R_mpynac_RlRl_s1(Word32 Rx, Word32 Rs,
                                              Word32 Rt)
                   Rx-=mpy(Rs.L,Rt.L):<<1:sat Word32 Q6_R_mpynac_RlRl_s1_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rx-=mpy(Rs.L,Rt.L):sat     Word32 Q6_R_mpynac_RlRl_sat(Word32 Rx, Word32
                                              Rs, Word32 Rt)
                   Rxx+=mpy(Rs.H,Rt.H)        Word64 Q6_P_mpyacc_RhRh(Word64 Rxx, Word32 Rs,
                                              Word32 Rt)
                   Rxx+=mpy(Rs.H,Rt.H):<<1    Word64 Q6_P_mpyacc_RhRh_s1(Word64 Rxx, Word32
                                              Rs, Word32 Rt)
                   Rxx+=mpy(Rs.H,Rt.L)        Word64 Q6_P_mpyacc_RhRl(Word64 Rxx, Word32 Rs,
                                              Word32 Rt)
                   Rxx+=mpy(Rs.H,Rt.L):<<1    Word64 Q6_P_mpyacc_RhRl_s1(Word64 Rxx, Word32
                                              Rs, Word32 Rt)
                   Rxx+=mpy(Rs.L,Rt.H)        Word64 Q6_P_mpyacc_RlRh(Word64 Rxx, Word32 Rs,
                                              Word32 Rt)
                   Rxx+=mpy(Rs.L,Rt.H):<<1    Word64 Q6_P_mpyacc_RlRh_s1(Word64 Rxx, Word32
                                              Rs, Word32 Rt)
                   Rxx+=mpy(Rs.L,Rt.L)        Word64 Q6_P_mpyacc_RlRl(Word64 Rxx, Word32 Rs,
                                              Word32 Rt)
                   Rxx+=mpy(Rs.L,Rt.L):<<1    Word64 Q6_P_mpyacc_RlRl_s1(Word64 Rxx, Word32
                                              Rs, Word32 Rt)
                   Rxx-=mpy(Rs.H,Rt.H)        Word64 Q6_P_mpynac_RhRh(Word64 Rxx, Word32 Rs,
                                              Word32 Rt)
                   Rxx-=mpy(Rs.H,Rt.H):<<1    Word64 Q6_P_mpynac_RhRh_s1(Word64 Rxx, Word32
                                              Rs, Word32 Rt)
                   Rxx-=mpy(Rs.H,Rt.L)        Word64 Q6_P_mpynac_RhRl(Word64 Rxx, Word32 Rs,
                                              Word32 Rt)
                   Rxx-=mpy(Rs.H,Rt.L):<<1    Word64 Q6_P_mpynac_RhRl_s1(Word64 Rxx, Word32
                                              Rs, Word32 Rt)
                   Rxx-=mpy(Rs.L,Rt.H)        Word64 Q6_P_mpynac_RlRh(Word64 Rxx, Word32 Rs,
                                              Word32 Rt)
                   Rxx-=mpy(Rs.L,Rt.H):<<1    Word64 Q6_P_mpynac_RlRh_s1(Word64 Rxx, Word32
                                              Rs, Word32 Rt)
                   Rxx-=mpy(Rs.L,Rt.L)        Word64 Q6_P_mpynac_RlRl(Word64 Rxx, Word32 Rs,
                                              Word32 Rt)
                   Rxx-=mpy(Rs.L,Rt.L):<<1    Word64 Q6_P_mpynac_RlRl_s1(Word64 Rxx, Word32
                                              Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                              553
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6  5 4 3 2  1 0
   ICLASS     RegType    MajOp         s5       Parse          t5       sH tH     d5
 1  1  1  0 0  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t - 0  0  d d d  d d Rdd=mpy(Rs.L,Rt.L)[:<<N]
 1  1  1  0 0  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t - 0  1  d d d  d d Rdd=mpy(Rs.L,Rt.H)[:<<N]
 1  1  1  0 0  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t - 1  0  d d d  d d Rdd=mpy(Rs.H,Rt.L)[:<<N]
 1  1  1  0 0  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t - 1  1  d d d  d d Rdd=mpy(Rs.H,Rt.H)[:<<N]
 1  1  1  0 0  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t - 0  0  d d d  d d Rdd=mpy(Rs.L,Rt.L)[:<<N]:
                                                                                         rnd
                                                                                         Rdd=mpy(Rs.L,Rt.H)[:<<N]:
 1  1  1  0 0  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t - 0  1  d d d  d d
                                                                                         rnd
                                                                                         Rdd=mpy(Rs.H,Rt.L)[:<<N]:
 1  1  1  0 0  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t - 1  0  d d d  d d
                                                                                         rnd
                                                                                         Rdd=mpy(Rs.H,Rt.H)[:<<N]
 1  1  1  0 0  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t - 1  1  d d d  d d :rnd
   ICLASS     RegType    MajOp         s5       Parse          t5       sH tH     x5
 1  1  1  0 0  1   1  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 0 0  0  x x  x x x Rxx+=mpy(Rs.L,Rt.L)[:<<N
                                                                                         ]
                                                                                         Rxx+=mpy(Rs.L,Rt.H)[:<<N
 1  1  1  0 0  1   1  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 0 0  1  x x  x x x ]
 1  1  1  0 0  1   1  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 0 1  0  x x  x x x Rxx+=mpy(Rs.H,Rt.L)[:<<N
                                                                                         ]
 1  1  1  0 0  1   1  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 0 1  1  x x  x x x Rxx+=mpy(Rs.H,Rt.H)[:<<
                                                                                         N]
 1  1  1  0 0  1   1  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 0 0  0  x x  x x x Rxx-=mpy(Rs.L,Rt.L)[:<<N]
 1  1  1  0 0  1   1  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 0 0  1  x x  x x x Rxx-=mpy(Rs.L,Rt.H)[:<<N]
 1  1  1  0 0  1   1  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 0 1  0  x x  x x x Rxx-=mpy(Rs.H,Rt.L)[:<<N]
                                                                                         Rxx-
 1  1  1  0 0  1   1  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 0 1  1  x x  x x x =mpy(Rs.H,Rt.H)[:<<N]
   ICLASS     RegType    MajOp         s5       Parse          t5       sH tH     d5
 1  1  1  0 1  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 0 0  0  d d d  d d Rd=mpy(Rs.L,Rt.L)[:<<N]
 1  1  1  0 1  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 0 0  1  d d d  d d Rd=mpy(Rs.L,Rt.H)[:<<N]
 1  1  1  0 1  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 0 1  0  d d d  d d Rd=mpy(Rs.H,Rt.L)[:<<N]
 1  1  1  0 1  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 0 1  1  d d d  d d Rd=mpy(Rs.H,Rt.H)[:<<N]
 1  1  1  0 1  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 1 0  0  d d d  d d Rd=mpy(Rs.L,Rt.L)[:<<N]:s
                                                                                         at
                                                                                         Rd=mpy(Rs.L,Rt.H)[:<<N]:s
 1  1  1  0 1  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 1 0  1  d d d  d d at
 1  1  1  0 1  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 1 1  0  d d d  d d Rd=mpy(Rs.H,Rt.L)[:<<N]:s
                                                                                         at
 1  1  1  0 1  1   0  0 N 0   0   s  s  s  s  s P   P  -  t  t  t t t 1 1  1  d d d  d d Rd=mpy(Rs.H,Rt.H)[:<<N]:
                                                                                         sat
                                                                                         Rd=mpy(Rs.L,Rt.L)[:<<N]:r
 1  1  1  0 1  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 0 0  0  d d d  d d nd
 1  1  1  0 1  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 0 0  1  d d d  d d Rd=mpy(Rs.L,Rt.H)[:<<N]:r
                                                                                         nd
 1  1  1  0 1  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 0 1  0  d d d  d d Rd=mpy(Rs.H,Rt.L)[:<<N]:r
                                                                                         nd
                                                                                         Rd=mpy(Rs.H,Rt.H)[:<<N]:r
 1  1  1  0 1  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 0 1  1  d d d  d d nd
 1  1  1  0 1  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 1 0  0  d d d  d d Rd=mpy(Rs.L,Rt.L)[:<<N]:r
                                                                                         nd:sat
 1  1  1  0 1  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 1 0  1  d d d  d d Rd=mpy(Rs.L,Rt.H)[:<<N]:r
                                                                                         nd:sat
                                                                                         Rd=mpy(Rs.H,Rt.L)[:<<N]:r
 1  1  1  0 1  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 1 1  0  d d d  d d nd:sat
 1  1  1  0 1  1   0  0 N 0   1   s  s  s  s  s P   P  -  t  t  t t t 1 1  1  d d d  d d Rd=mpy(Rs.H,Rt.H)[:<<N]:r
                                                                                         nd:sat
80-N2040-45 Rev. B                                                                                             554
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4 3 2  1 0
   ICLASS     RegType    MajOp          s5       Parse          t5       sH tH     x5
 1  1  1  0 1  1   1  0 N 0   0   s  s  s  s  s  P   P -  t   t  t t t 0 0  0  x x x  x x Rx+=mpy(Rs.L,Rt.L)[:<<N]
 1  1  1  0 1  1   1  0 N 0   0   s  s  s  s  s  P   P -  t   t  t t t 0 0  1  x x x  x x Rx+=mpy(Rs.L,Rt.H)[:<<N]
 1  1  1  0 1  1   1  0 N 0   0   s  s  s  s  s  P   P -  t   t  t t t 0 1  0  x x x  x x Rx+=mpy(Rs.H,Rt.L)[:<<N]
 1  1  1  0 1  1   1  0 N 0   0   s  s  s  s  s  P   P -  t   t  t t t 0 1  1  x x x  x x Rx+=mpy(Rs.H,Rt.H)[:<<N]
                                                                                          Rx+=mpy(Rs.L,Rt.L)[:<<N]:
 1  1  1  0 1  1   1  0 N 0   0   s  s  s  s  s  P   P -  t   t  t t t 1 0  0  x x x  x x
                                                                                          sat
                                                                                          Rx+=mpy(Rs.L,Rt.H)[:<<N]:
 1  1  1  0 1  1   1  0 N 0   0   s  s  s  s  s  P   P -  t   t  t t t 1 0  1  x x x  x x sat
                                                                                          Rx+=mpy(Rs.H,Rt.L)[:<<N]:
 1  1  1  0 1  1   1  0 N 0   0   s  s  s  s  s  P   P -  t   t  t t t 1 1  0  x x x  x x
                                                                                          sat
                                                                                          Rx+=mpy(Rs.H,Rt.H)[:<<N]
 1  1  1  0 1  1   1  0 N 0   0   s  s  s  s  s  P   P -  t   t  t t t 1 1  1  x x x  x x
                                                                                          :sat
 1  1  1  0 1  1   1  0 N 0   1   s  s  s  s  s  P   P -  t   t  t t t 0 0  0  x x x  x x Rx-=mpy(Rs.L,Rt.L)[:<<N]
 1  1  1  0 1  1   1  0 N 0   1   s  s  s  s  s  P   P -  t   t  t t t 0 0  1  x x x  x x Rx-=mpy(Rs.L,Rt.H)[:<<N]
 1  1  1  0 1  1   1  0 N 0   1   s  s  s  s  s  P   P -  t   t  t t t 0 1  0  x x x  x x Rx-=mpy(Rs.H,Rt.L)[:<<N]
 1  1  1  0 1  1   1  0 N 0   1   s  s  s  s  s  P   P -  t   t  t t t 0 1  1  x x x  x x Rx-=mpy(Rs.H,Rt.H)[:<<N]
                                                                                          Rx-
 1  1  1  0 1  1   1  0 N 0   1   s  s  s  s  s  P   P -  t   t  t t t 1 0  0  x x x  x x =mpy(Rs.L,Rt.L)[:<<N]:sat
 1  1  1  0 1  1   1  0 N 0   1   s  s  s  s  s  P   P -  t   t  t t t 1 0  1  x x x  x x Rx-
                                                                                          =mpy(Rs.L,Rt.H)[:<<N]:sat
 1  1  1  0 1  1   1  0 N 0   1   s  s  s  s  s  P   P -  t   t  t t t 1 1  0  x x x  x x Rx-
                                                                                          =mpy(Rs.H,Rt.L)[:<<N]:sat
                                                                                          Rx-
 1  1  1  0 1  1   1  0 N 0   1   s  s  s  s  s  P   P -  t   t  t t t 1 1  1  x x x  x x =mpy(Rs.H,Rt.H)[:<<N]:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  sH                Rs is High
                  tH                Rt is High
                  sH                Rs is High
                  tH                Rt is High
                  sH                Rs is High
                  tH                Rt is High
                  sH                Rs is High
                  tH                Rt is High
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                               555
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
        Multiply unsigned halfwords
                  Multiply two unsigned halfwords. Scale the result by 0-3 bits. Optionally, add or subtract
                  the result from the accumulator.
  Rx+=mpyu(Rs.[HL],Rt.[HL])[:<<1]                        Rxx+=mpyu(Rs.[HL],Rt.[HL])[:<<1]
  Rd = mpyu(Rs.[HL],Rt.[HL])[:<<1]                       Rdd = mpyu(Rs.[HL],Rt.[HL])[:<<1]
          Rs                      Rt                          Rs                    Rt
          mux                   mux                           mux                  mux
                     16x16                                              16x16
                                                                                   0x0
                                  0x0
                         32                                                 32
                     <<0-1                                              <<0-1
                                                                                       mux
                                     mux
                           32-bit                                         64-bit Add/
                         Add/Sub                                              Sub
                                         Rx
                                                                                                               Rxx
                   Syntax                           Behavior
                   Rd=mpyu(Rs.[HL],Rt.[HL])[:<<1]    Rd=(Rs.uh[01] * Rt.uh[01])[<<1];
                                                     ;
                   Rdd=mpyu(Rs.[HL],Rt.[HL])[:<<1]   Rdd=(Rs.uh[01] * Rt.uh[01])[<<1];
                                                     ;
                   Rx+=mpyu(Rs.[HL],Rt.[HL])[:<<1]   Rx=Rx+ (Rs.uh[01] * Rt.uh[01])[<<1];
                                                     ;
                   Rx-=mpyu(Rs.[HL],Rt.[HL])[:<<1]   Rx=Rx- (Rs.uh[01] * Rt.uh[01])[<<1];
                                                     ;
                   Rxx+=mpyu(Rs.[HL],Rt.[HL])[:<<1   Rxx=Rxx+ (Rs.uh[01] * Rt.uh[01])[<<1];
                   ]                                 ;
                   Rxx-                              Rxx=Rxx- (Rs.uh[01] * Rt.uh[01])[<<1];
                   =mpyu(Rs.[HL],Rt.[HL])[:<<1]      ;
80-N2040-45 Rev. B                                                                                         556
Hexagon V67 Programmer’s Reference Manual                                       Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=mpyu(Rs.H,Rt.H)      UWord32 Q6_R_mpyu_RhRh(Word32 Rs, Word32 Rt)
                   Rd=mpyu(Rs.H,Rt.H):<<1  UWord32 Q6_R_mpyu_RhRh_s1(Word32 Rs, Word32 Rt)
                   Rd=mpyu(Rs.H,Rt.L)      UWord32 Q6_R_mpyu_RhRl(Word32 Rs, Word32 Rt)
                   Rd=mpyu(Rs.H,Rt.L):<<1  UWord32 Q6_R_mpyu_RhRl_s1(Word32 Rs, Word32 Rt)
                   Rd=mpyu(Rs.L,Rt.H)      UWord32 Q6_R_mpyu_RlRh(Word32 Rs, Word32 Rt)
                   Rd=mpyu(Rs.L,Rt.H):<<1  UWord32 Q6_R_mpyu_RlRh_s1(Word32 Rs, Word32 Rt)
                   Rd=mpyu(Rs.L,Rt.L)      UWord32 Q6_R_mpyu_RlRl(Word32 Rs, Word32 Rt)
                   Rd=mpyu(Rs.L,Rt.L):<<1  UWord32 Q6_R_mpyu_RlRl_s1(Word32 Rs, Word32 Rt)
                   Rdd=mpyu(Rs.H,Rt.H)     UWord64 Q6_P_mpyu_RhRh(Word32 Rs, Word32 Rt)
                   Rdd=mpyu(Rs.H,Rt.H):<<1 UWord64 Q6_P_mpyu_RhRh_s1(Word32 Rs, Word32 Rt)
                   Rdd=mpyu(Rs.H,Rt.L)     UWord64 Q6_P_mpyu_RhRl(Word32 Rs, Word32 Rt)
                   Rdd=mpyu(Rs.H,Rt.L):<<1 UWord64 Q6_P_mpyu_RhRl_s1(Word32 Rs, Word32 Rt)
                   Rdd=mpyu(Rs.L,Rt.H)     UWord64 Q6_P_mpyu_RlRh(Word32 Rs, Word32 Rt)
                   Rdd=mpyu(Rs.L,Rt.H):<<1 UWord64 Q6_P_mpyu_RlRh_s1(Word32 Rs, Word32 Rt)
                   Rdd=mpyu(Rs.L,Rt.L)     UWord64 Q6_P_mpyu_RlRl(Word32 Rs, Word32 Rt)
                   Rdd=mpyu(Rs.L,Rt.L):<<1 UWord64 Q6_P_mpyu_RlRl_s1(Word32 Rs, Word32 Rt)
                   Rx+=mpyu(Rs.H,Rt.H)     Word32 Q6_R_mpyuacc_RhRh(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx+=mpyu(Rs.H,Rt.H):<<1 Word32 Q6_R_mpyuacc_RhRh_s1(Word32 Rx, Word32
                                           Rs, Word32 Rt)
                   Rx+=mpyu(Rs.H,Rt.L)     Word32 Q6_R_mpyuacc_RhRl(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx+=mpyu(Rs.H,Rt.L):<<1 Word32 Q6_R_mpyuacc_RhRl_s1(Word32 Rx, Word32
                                           Rs, Word32 Rt)
                   Rx+=mpyu(Rs.L,Rt.H)     Word32 Q6_R_mpyuacc_RlRh(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx+=mpyu(Rs.L,Rt.H):<<1 Word32 Q6_R_mpyuacc_RlRh_s1(Word32 Rx, Word32
                                           Rs, Word32 Rt)
                   Rx+=mpyu(Rs.L,Rt.L)     Word32 Q6_R_mpyuacc_RlRl(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx+=mpyu(Rs.L,Rt.L):<<1 Word32 Q6_R_mpyuacc_RlRl_s1(Word32 Rx, Word32
                                           Rs, Word32 Rt)
                   Rx-=mpyu(Rs.H,Rt.H)     Word32 Q6_R_mpyunac_RhRh(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx-=mpyu(Rs.H,Rt.H):<<1 Word32 Q6_R_mpyunac_RhRh_s1(Word32 Rx, Word32
                                           Rs, Word32 Rt)
                   Rx-=mpyu(Rs.H,Rt.L)     Word32 Q6_R_mpyunac_RhRl(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx-=mpyu(Rs.H,Rt.L):<<1 Word32 Q6_R_mpyunac_RhRl_s1(Word32 Rx, Word32
                                           Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                          557
Hexagon V67 Programmer’s Reference Manual                                        Instruction Set
                   Rx-=mpyu(Rs.L,Rt.H)      Word32 Q6_R_mpyunac_RlRh(Word32 Rx, Word32 Rs,
                                            Word32 Rt)
                   Rx-=mpyu(Rs.L,Rt.H):<<1  Word32 Q6_R_mpyunac_RlRh_s1(Word32 Rx, Word32
                                            Rs, Word32 Rt)
                   Rx-=mpyu(Rs.L,Rt.L)      Word32 Q6_R_mpyunac_RlRl(Word32 Rx, Word32 Rs,
                                            Word32 Rt)
                   Rx-=mpyu(Rs.L,Rt.L):<<1  Word32 Q6_R_mpyunac_RlRl_s1(Word32 Rx, Word32
                                            Rs, Word32 Rt)
                   Rxx+=mpyu(Rs.H,Rt.H)     Word64 Q6_P_mpyuacc_RhRh(Word64 Rxx, Word32 Rs,
                                            Word32 Rt)
                   Rxx+=mpyu(Rs.H,Rt.H):<<1 Word64 Q6_P_mpyuacc_RhRh_s1(Word64 Rxx, Word32
                                            Rs, Word32 Rt)
                   Rxx+=mpyu(Rs.H,Rt.L)     Word64 Q6_P_mpyuacc_RhRl(Word64 Rxx, Word32 Rs,
                                            Word32 Rt)
                   Rxx+=mpyu(Rs.H,Rt.L):<<1 Word64 Q6_P_mpyuacc_RhRl_s1(Word64 Rxx, Word32
                                            Rs, Word32 Rt)
                   Rxx+=mpyu(Rs.L,Rt.H)     Word64 Q6_P_mpyuacc_RlRh(Word64 Rxx, Word32 Rs,
                                            Word32 Rt)
                   Rxx+=mpyu(Rs.L,Rt.H):<<1 Word64 Q6_P_mpyuacc_RlRh_s1(Word64 Rxx, Word32
                                            Rs, Word32 Rt)
                   Rxx+=mpyu(Rs.L,Rt.L)     Word64 Q6_P_mpyuacc_RlRl(Word64 Rxx, Word32 Rs,
                                            Word32 Rt)
                   Rxx+=mpyu(Rs.L,Rt.L):<<1 Word64 Q6_P_mpyuacc_RlRl_s1(Word64 Rxx, Word32
                                            Rs, Word32 Rt)
                   Rxx-=mpyu(Rs.H,Rt.H)     Word64 Q6_P_mpyunac_RhRh(Word64 Rxx, Word32 Rs,
                                            Word32 Rt)
                   Rxx-=mpyu(Rs.H,Rt.H):<<1 Word64 Q6_P_mpyunac_RhRh_s1(Word64 Rxx, Word32
                                            Rs, Word32 Rt)
                   Rxx-=mpyu(Rs.H,Rt.L)     Word64 Q6_P_mpyunac_RhRl(Word64 Rxx, Word32 Rs,
                                            Word32 Rt)
                   Rxx-=mpyu(Rs.H,Rt.L):<<1 Word64 Q6_P_mpyunac_RhRl_s1(Word64 Rxx, Word32
                                            Rs, Word32 Rt)
                   Rxx-=mpyu(Rs.L,Rt.H)     Word64 Q6_P_mpyunac_RlRh(Word64 Rxx, Word32 Rs,
                                            Word32 Rt)
                   Rxx-=mpyu(Rs.L,Rt.H):<<1 Word64 Q6_P_mpyunac_RlRh_s1(Word64 Rxx, Word32
                                            Rs, Word32 Rt)
                   Rxx-=mpyu(Rs.L,Rt.L)     Word64 Q6_P_mpyunac_RlRl(Word64 Rxx, Word32 Rs,
                                            Word32 Rt)
                   Rxx-=mpyu(Rs.L,Rt.L):<<1 Word64 Q6_P_mpyunac_RlRl_s1(Word64 Rxx, Word32
                                            Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                           558
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6  5 4 3 2  1 0
   ICLASS     RegType    MajOp          s5       Parse         t5       sH tH     d5
                                                                                         Rdd=mpyu(Rs.L,Rt.L)[:<<N
 1  1  1  0 0  1   0  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t - 0  0  d d d  d d
                                                                                         ]
 1  1  1  0 0  1   0  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t - 0  1  d d d  d d Rdd=mpyu(Rs.L,Rt.H)[:<<N
                                                                                         ]
                                                                                         Rdd=mpyu(Rs.H,Rt.L)[:<<N
 1  1  1  0 0  1   0  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t - 1  0  d d d  d d
                                                                                         ]
 1  1  1  0 0  1   0  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t - 1  1  d d d  d d Rdd=mpyu(Rs.H,Rt.H)[:<<
                                                                                         N]
   ICLASS     RegType    MajOp          s5       Parse         t5       sH tH     x5
                                                                                         Rxx+=mpyu(Rs.L,Rt.L)[:<<
 1  1  1  0 0  1   1  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 0  0  x x  x x x
                                                                                         N]
 1  1  1  0 0  1   1  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 0  1  x x  x x x Rxx+=mpyu(Rs.L,Rt.H)[:<<
                                                                                         N]
 1  1  1  0 0  1   1  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 1  0  x x  x x x Rxx+=mpyu(Rs.H,Rt.L)[:<<
                                                                                         N]
                                                                                         Rxx+=mpyu(Rs.H,Rt.H)[:<<
 1  1  1  0 0  1   1  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 1  1  x x  x x x N]
 1  1  1  0 0  1   1  0 N 1   1   s  s  s  s  s  P   P -  t  t  t t t 0 0  0  x x  x x x Rxx-
                                                                                         =mpyu(Rs.L,Rt.L)[:<<N]
 1  1  1  0 0  1   1  0 N 1   1   s  s  s  s  s  P   P -  t  t  t t t 0 0  1  x x  x x x Rxx-
                                                                                         =mpyu(Rs.L,Rt.H)[:<<N]
                                                                                         Rxx-
 1  1  1  0 0  1   1  0 N 1   1   s  s  s  s  s  P   P -  t  t  t t t 0 1  0  x x  x x x =mpyu(Rs.H,Rt.L)[:<<N]
 1  1  1  0 0  1   1  0 N 1   1   s  s  s  s  s  P   P -  t  t  t t t 0 1  1  x x  x x x Rxx-
                                                                                         =mpyu(Rs.H,Rt.H)[:<<N]
   ICLASS     RegType    MajOp          s5       Parse         t5       sH tH     d5
 1  1  1  0 1  1   0  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 0  0  d d d  d d Rd=mpyu(Rs.L,Rt.L)[:<<N]
 1  1  1  0 1  1   0  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 0  1  d d d  d d Rd=mpyu(Rs.L,Rt.H)[:<<N]
 1  1  1  0 1  1   0  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 1  0  d d d  d d Rd=mpyu(Rs.H,Rt.L)[:<<N]
 1  1  1  0 1  1   0  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 1  1  d d d  d d Rd=mpyu(Rs.H,Rt.H)[:<<N]
   ICLASS     RegType    MajOp          s5       Parse         t5       sH tH     x5
 1  1  1  0 1  1   1  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 0  0  x x  x x x Rx+=mpyu(Rs.L,Rt.L)[:<<N
                                                                                         ]
                                                                                         Rx+=mpyu(Rs.L,Rt.H)[:<<N
 1  1  1  0 1  1   1  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 0  1  x x  x x x ]
 1  1  1  0 1  1   1  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 1  0  x x  x x x Rx+=mpyu(Rs.H,Rt.L)[:<<N
                                                                                         ]
 1  1  1  0 1  1   1  0 N 1   0   s  s  s  s  s  P   P -  t  t  t t t 0 1  1  x x  x x x Rx+=mpyu(Rs.H,Rt.H)[:<<
                                                                                         N]
 1  1  1  0 1  1   1  0 N 1   1   s  s  s  s  s  P   P -  t  t  t t t 0 0  0  x x  x x x Rx-=mpyu(Rs.L,Rt.L)[:<<N]
 1  1  1  0 1  1   1  0 N 1   1   s  s  s  s  s  P   P -  t  t  t t t 0 0  1  x x  x x x Rx-=mpyu(Rs.L,Rt.H)[:<<N]
 1  1  1  0 1  1   1  0 N 1   1   s  s  s  s  s  P   P -  t  t  t t t 0 1  0  x x  x x x Rx-=mpyu(Rs.H,Rt.L)[:<<N]
                                                                                         Rx-
 1  1  1  0 1  1   1  0 N 1   1   s  s  s  s  s  P   P -  t  t  t t t 0 1  1  x x  x x x =mpyu(Rs.H,Rt.H)[:<<N]
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  sH                Rs is High
                  tH                Rt is High
80-N2040-45 Rev. B                                                                                              559
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  sH           Rs is High
                  tH           Rt is High
                  sH           Rs is High
                  tH           Rt is High
                  sH           Rs is High
                  tH           Rt is High
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  x5           Field to encode register x
80-N2040-45 Rev. B                                                    560
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
        Polynomial multiply words
                  Perform a 32x32 carryless polynomial multiply using 32-bit source registers Rs and Rt.
                  The 64-bit result is optionally accumulated (XOR’d) with the destination register. Finite
                  field multiply instructions are useful for many algorithms including scramble code
                  generation, cryptographic algorithms, convolutional, and Reed Solomon codes.
                               Rxx += pmpyw(Rs,Rt)
                                     Rs
                                      Rt
                                             32x32
                                            Carryless
                                           Polynomial
                                              mpy      *
                                                  XOR
                    Rxx
                   Syntax                               Behavior
                   Rdd=pmpyw(Rs,Rt)                      x = Rs.uw[0];
                                                         y = Rt.uw[0];
                                                         prod = 0;
                                                         for(i=0; i < 32; i++) {
                                                             if((y >> i) & 1) prod ^= (x << i);
                                                         }
                                                         Rdd = prod;
                   Rxx^=pmpyw(Rs,Rt)                     x = Rs.uw[0];
                                                         y = Rt.uw[0];
                                                         prod = 0;
                                                         for(i=0; i < 32; i++) {
                                                             if((y >> i) & 1) prod ^= (x << i);
                                                         }
                                                         Rxx ^= prod;
80-N2040-45 Rev. B                                                                                         561
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=pmpyw(Rs,Rt)                         Word64 Q6_P_pmpyw_RR(Word32 Rs, Word32 Rt)
                   Rxx^=pmpyw(Rs,Rt)                        Word64 Q6_P_pmpywxacc_RR(Word64 Rxx, Word32 Rs,
                                                            Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 0  1   0  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 d d d  d d Rdd=pmpyw(Rs,Rt)
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 0  1   1  1 0  0   1  s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 x x  x x x Rxx^=pmpyw(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                            562
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Vector reduce multiply word by signed half (32x16)
                  Perform mixed precision vector multiply operations and accumulate the results. A 32-bit
                  word from vector Rss is multiplied by a 16-bit halfword (either even or odd) from vector
                  Rtt. The multiplication is performed as a signed 32x16, which produces a 48-bit result.
                  This result is optionally scaled left by one bit. A similar operation is performed for both
                  words in Rss, and the two results are accumulated. The final result is optionally
                  accumulated with Rxx.
                           s16                 s16                s16              s16           Rtt
                                               mux                                 mux
                                      s32                                 s32                   Rss
                                       *                                   *
                                        48                                    48
                                     <<0-1                                <<0-1
                                                          Add
                                Rxx
                   Syntax                                Behavior
                   Rdd=vrmpyweh(Rss,Rtt)[:<<1]           Rdd = (Rss.w[1] * Rtt.h[2])[<<1] + (Rss.w[0] *
                                                         Rtt.h[0])[<<1];
                                                         ;
                   Rdd=vrmpywoh(Rss,Rtt)[:<<1]           Rdd = (Rss.w[1] * Rtt.h[3])[<<1] + (Rss.w[0] *
                                                         Rtt.h[1])[<<1];
                                                         ;
                   Rxx+=vrmpyweh(Rss,Rtt)[:<<1]          Rxx += (Rss.w[1] * Rtt.h[2])[<<1] + (Rss.w[0] *
                                                         Rtt.h[0])[<<1];
                                                         ;
                   Rxx+=vrmpywoh(Rss,Rtt)[:<<1]          Rxx += (Rss.w[1] * Rtt.h[3])[<<1] + (Rss.w[0] *
                                                         Rtt.h[1])[<<1];
                                                         ;
80-N2040-45 Rev. B                                                                                              563
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vrmpyweh(Rss,Rtt)                    Word64 Q6_P_vrmpyweh_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vrmpyweh(Rss,Rtt):<<1                Word64 Q6_P_vrmpyweh_PP_s1(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vrmpywoh(Rss,Rtt)                    Word64 Q6_P_vrmpywoh_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vrmpywoh(Rss,Rtt):<<1                Word64 Q6_P_vrmpywoh_PP_s1(Word64 Rss, Word64
                                                            Rtt)
                   Rxx+=vrmpyweh(Rss,Rtt)                   Word64 Q6_P_vrmpywehacc_PP(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                   Rxx+=vrmpyweh(Rss,Rtt):<<1               Word64 Q6_P_vrmpywehacc_PP_s1(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                   Rxx+=vrmpywoh(Rss,Rtt)                   Word64 Q6_P_vrmpywohacc_PP(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                   Rxx+=vrmpywoh(Rss,Rtt):<<1               Word64 Q6_P_vrmpywohacc_PP_s1(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5 4 3 2  1 0
   ICLASS     RegType    MajOp         s5        Parse          t5       MinOp      d5
                                                                                           Rdd=vrmpywoh(Rss,Rtt)[:<
 1  1  1  0 1  0   0  0 N 0   1   s  s  s  s  s  P   P 0  t   t  t t t 0   1  0 d d d  d d <N]
 1  1  1  0 1  0   0  0 N 1   0   s  s  s  s  s  P   P 0  t   t  t t t 1   0  0 d d d  d d Rdd=vrmpyweh(Rss,Rtt)[:<
                                                                                           <N]
   ICLASS     RegType    MajOp         s5        Parse          t5       MinOp      x5
 1  1  1  0 1  0   1  0 N 0   1   s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 x x  x x x Rxx+=vrmpyweh(Rss,Rtt)[:
                                                                                           <<N]
 1  1  1  0 1  0   1  0 N 1   1   s  s  s  s  s  P   P 0  t   t  t t t 1   1  0 x x  x x x Rxx+=vrmpywoh(Rss,Rtt)[:
                                                                                           <<N]
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                             564
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Multiply and use upper result
                  Multiply two signed or unsigned 32-bit words. Take the upper 32-bits of this results store
                  to a single destination register. Optional rounding is available.
                                               Rs
                                               Rt
                                   32x32
                                       64
                                         Rd
                   Syntax                                Behavior
                   Rd=mpy(Rs,Rt.H):<<1:rnd:sat           Rd = sat_32(((Rs * Rt.h[1])<<1+0x8000)>>16);
                   Rd=mpy(Rs,Rt.H):<<1:sat               Rd = sat_32(((Rs * Rt.h[1])<<1)>>16);
                   Rd=mpy(Rs,Rt.L):<<1:rnd:sat           Rd = sat_32(((Rs * Rt.h[0])<<1+0x8000)>>16);
                   Rd=mpy(Rs,Rt.L):<<1:sat               Rd = sat_32(((Rs * Rt.h[0])<<1)>>16);
                   Rd=mpy(Rs,Rt)                         Rd=(Rs * Rt)>>32;
                   Rd=mpy(Rs,Rt):<<1                     Rd=(Rs * Rt)>>31;
                   Rd=mpy(Rs,Rt):<<1:sat                 Rd=sat_32((Rs * Rt)>>31);
                   Rd=mpy(Rs,Rt):rnd                     Rd=((Rs * Rt)+0x80000000)>>32;
                   Rd=mpysu(Rs,Rt)                       Rd=(Rs * Rt.uw[0])>>32;
                   Rd=mpyu(Rs,Rt)                        Rd=(Rs.uw[0] * Rt.uw[0])>>32;
                   Rx+=mpy(Rs,Rt):<<1:sat                Rx=sat_32((Rx) + ((Rs * Rt)>>31));
                                                         ;
                   Rx-=mpy(Rs,Rt):<<1:sat                Rx=sat_32((Rx) - ((Rs * Rt)>>31));
                                                         ;
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                              565
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Intrinsics
                   Rd=mpy(Rs,Rt.H):<<1:rnd:sat              Word32 Q6_R_mpy_RRh_s1_rnd_sat(Word32 Rs, Word32
                                                            Rt)
                   Rd=mpy(Rs,Rt.H):<<1:sat                  Word32 Q6_R_mpy_RRh_s1_sat(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs,Rt.L):<<1:rnd:sat              Word32 Q6_R_mpy_RRl_s1_rnd_sat(Word32 Rs, Word32
                                                            Rt)
                   Rd=mpy(Rs,Rt.L):<<1:sat                  Word32 Q6_R_mpy_RRl_s1_sat(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs,Rt)                            Word32 Q6_R_mpy_RR(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs,Rt):<<1                        Word32 Q6_R_mpy_RR_s1(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs,Rt):<<1:sat                    Word32 Q6_R_mpy_RR_s1_sat(Word32 Rs, Word32 Rt)
                   Rd=mpy(Rs,Rt):rnd                        Word32 Q6_R_mpy_RR_rnd(Word32 Rs, Word32 Rt)
                   Rd=mpysu(Rs,Rt)                          Word32 Q6_R_mpysu_RR(Word32 Rs, Word32 Rt)
                   Rd=mpyu(Rs,Rt)                           UWord32 Q6_R_mpyu_RR(Word32 Rs, Word32 Rt)
                   Rx+=mpy(Rs,Rt):<<1:sat                   Word32 Q6_R_mpyacc_RR_s1_sat(Word32 Rx, Word32
                                                            Rs, Word32 Rt)
                   Rx-=mpy(Rs,Rt):<<1:sat                   Word32 Q6_R_mpynac_RR_s1_sat(Word32 Rx, Word32
                                                            Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  1   0  1 0  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rd=mpy(Rs,Rt):rnd
 1  1  1  0 1  1   0  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rd=mpyu(Rs,Rt)
 1  1  1  0 1  1   0  1 0  1   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rd=mpysu(Rs,Rt)
 1  1  1  0 1  1   0  1 1  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d Rd=mpy(Rs,Rt.H):<<1:sat
 1  1  1  0 1  1   0  1 1  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rd=mpy(Rs,Rt.L):<<1:sat
                                                                                           Rd=mpy(Rs,Rt.H):<<1:rnd:
 1  1  1  0 1  1   0  1 1  0   1  s  s  s  s  s  P   P 0  t   t  t t t 1   0  0 d d d  d d sat
 1  1  1  0 1  1   0  1 1  1   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d Rd=mpy(Rs,Rt):<<1:sat
                                                                                           Rd=mpy(Rs,Rt.L):<<1:rnd:s
 1  1  1  0 1  1   0  1 1  1   1  s  s  s  s  s  P   P 0  t   t  t t t 1   0  0 d d d  d d at
 1  1  1  0 1  1   0  1 N 0    N  s  s  s  s  s  P   P 0  t   t  t t t 0   N N  d d d  d d Rd=mpy(Rs,Rt)[:<<N]
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  1   1  1 0  1   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 x x  x x x Rx+=mpy(Rs,Rt):<<1:sat
 1  1  1  0 1  1   1  1 0  1   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x  x x x Rx-=mpy(Rs,Rt):<<1:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
80-N2040-45 Rev. B                                                                                               566
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  s5           Field to encode register s
                  t5           Field to encode register t
                  x5           Field to encode register x
80-N2040-45 Rev. B                                                    567
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
        Multiply and use full result
                  Multiply two signed or unsigned 32-bit words. Optionally, add or subtract this value from
                  the 64-bit accumulator. The result is a full-precision 64-bit value.
                                         Rs
                                         Rt
                           32x32
                                64
                         64-bit Add/Sub
                                                               Rxx
                   Syntax                              Behavior
                   Rdd=mpy(Rs,Rt)                       Rdd=(Rs * Rt);
                   Rdd=mpyu(Rs,Rt)                      Rdd=(Rs.uw[0] * Rt.uw[0]);
                   Rxx[+-]=mpy(Rs,Rt)                   Rxx= Rxx [+-] (Rs * Rt);
                                                        ;
                   Rxx[+-]=mpyu(Rs,Rt)                  Rxx= Rxx [+-] (Rs.uw[0] * Rt.uw[0]);
                                                        ;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=mpy(Rs,Rt)                      Word64 Q6_P_mpy_RR(Word32 Rs, Word32 Rt)
                   Rdd=mpyu(Rs,Rt)                     UWord64 Q6_P_mpyu_RR(Word32 Rs, Word32 Rt)
                   Rxx+=mpy(Rs,Rt)                     Word64 Q6_P_mpyacc_RR(Word64 Rxx, Word32 Rs,
                                                       Word32 Rt)
                   Rxx+=mpyu(Rs,Rt)                    Word64 Q6_P_mpyuacc_RR(Word64 Rxx, Word32 Rs,
                                                       Word32 Rt)
                   Rxx-=mpy(Rs,Rt)                     Word64 Q6_P_mpynac_RR(Word64 Rxx, Word32 Rs,
                                                       Word32 Rt)
                   Rxx-=mpyu(Rs,Rt)                    Word64 Q6_P_mpyunac_RR(Word64 Rxx, Word32 Rs,
                                                       Word32 Rt)
80-N2040-45 Rev. B                                                                                         568
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 0  1   0  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d Rdd=mpy(Rs,Rt)
 1  1  1  0 0  1   0  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 d d d  d d Rdd=mpyu(Rs,Rt)
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 0  1   1  1 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 x x  x x x Rxx+=mpy(Rs,Rt)
 1  1  1  0 0  1   1  1 0  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 x x  x x x Rxx-=mpy(Rs,Rt)
 1  1  1  0 0  1   1  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 x x  x x x Rxx+=mpyu(Rs,Rt)
 1  1  1  0 0  1   1  1 0  1   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0 x x  x x x Rxx-=mpyu(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                             569
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Vector dual multiply
                  Multiply four 16-bit halfwords in Rss by the corresponding 16-bit halfwords in Rtt. The
                  two lower results are scaled and added. The lower word of the accumulator is optionally
                  added. This result is saturated to 32-bits and stored in the lower word of the accumulator.
                  The same operation is performed on the upper two products using the upper word of the
                  accumulator.
                                        Rxx+=vdmpy(Rss,Rtt):sat
                                                                                            Rss
                                                                                            Rtt
                                *                 *               *                *
                                 32                 32              32               32
                              <<0-1             <<0-1           <<0-1             <<0-1
                                       Add                               Add
                                     Sat_32                            Sat_32                      32
                      32
                              High Accumulation                 Low Accumulation
                                                       Rxx
                   Syntax                               Behavior
                   Rdd=vdmpy(Rss,Rtt):<<1:sat           Rdd.w[0]=sat_32((Rss.h[0] * Rtt.h[0])<<1 +
                                                        (Rss.h[1] * Rtt.h[1])<<1);
                                                        Rdd.w[1]=sat_32((Rss.h[2] * Rtt.h[2])<<1 +
                                                        (Rss.h[3] * Rtt.h[3])<<1);
                   Rdd=vdmpy(Rss,Rtt):sat               Rdd.w[0]=sat_32((Rss.h[0] * Rtt.h[0])<<0 +
                                                        (Rss.h[1] * Rtt.h[1])<<0);
                                                        Rdd.w[1]=sat_32((Rss.h[2] * Rtt.h[2])<<0 +
                                                        (Rss.h[3] * Rtt.h[3])<<0);
80-N2040-45 Rev. B                                                                                            570
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                   Syntax                                   Behavior
                   Rxx+=vdmpy(Rss,Rtt):<<1:sat              Rxx.w[0]=sat_32(Rxx.w[0]   +  (Rss.h[0] *
                                                            Rtt.h[0])<<1 + (Rss.h[1]   *  Rtt.h[1])<<1);
                                                            Rxx.w[1]=sat_32(Rxx.w[1]   +  (Rss.h[2] *
                                                            Rtt.h[2])<<1 + (Rss.h[3]   *  Rtt.h[3])<<1);
                                                            ;
                   Rxx+=vdmpy(Rss,Rtt):sat                  Rxx.w[0]=sat_32(Rxx.w[0]   +  (Rss.h[0] *
                                                            Rtt.h[0])<<0 + (Rss.h[1]   *  Rtt.h[1])<<0);
                                                            Rxx.w[1]=sat_32(Rxx.w[1]   +  (Rss.h[2] *
                                                            Rtt.h[2])<<0 + (Rss.h[3]   *  Rtt.h[3])<<0);
                                                            ;
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vdmpy(Rss,Rtt):<<1:sat               Word64 Q6_P_vdmpy_PP_s1_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rdd=vdmpy(Rss,Rtt):sat                   Word64 Q6_P_vdmpy_PP_sat(Word64 Rss, Word64 Rtt)
                   Rxx+=vdmpy(Rss,Rtt):<<1:sat              Word64 Q6_P_vdmpyacc_PP_s1_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                   Rxx+=vdmpy(Rss,Rtt):sat                  Word64 Q6_P_vdmpyacc_PP_sat(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2   1  0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  0  N 0   0  s  s  s  s  s  P   P 0  t   t  t t t 1   0  0 d d d   d  d Rdd=vdmpy(Rss,Rtt)[:<<N]:
                                                                                              sat
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  0   1  0  N 0   0  s  s  s  s  s  P   P 0  t   t  t t t 1   0  0 x x  x  x  x Rxx+=vdmpy(Rss,Rtt)[:<<N
                                                                                              ]:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
80-N2040-45 Rev. B                                                                                                 571
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  s5           Field to encode register s
                  t5           Field to encode register t
                  x5           Field to encode register x
80-N2040-45 Rev. B                                                    572
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Vector dual multiply with round and pack
                  Multiply four 16-bit halfwords in Rss by the corresponding 16-bit halfwords in Rtt. The
                  two lower results are scaled and added together with a rounding constant. This result is
                  saturated to 32-bits, and the upper 16-bits of this result are stored in the lower 16-bits of
                  the destination register. The same operation is performed on the upper two products and
                  the result is stored in the upper 16-bit halfword of the destination.
                                             Rd=vdmpy(Rss,Rtt):rnd:sat
                                                                                                  Rss
                                                                                                   Rtt
                                     *               *                *                 *
                                      32               32               32                32
                    0x8000         <<0-1            <<0-1           <<0-1             <<0-1       0x8000
                                            Add                              Add
                                         Sat_32                            Sat_32
                                                 High 16bits            High 16bits
                                                                                 Rd
                   Syntax                                 Behavior
                   Rd=vdmpy(Rss,Rtt)[:<<1]:rnd:sat        Rd.h[0]=(sat_32((Rss.h[0] * Rtt.h[0])[<<1] +
                                                          (Rss.h[1] * Rtt.h[1])[<<1] + 0x8000)).h[1];
                                                          Rd.h[1]=(sat_32((Rss.h[2] * Rtt.h[2])[<<1] +
                                                          (Rss.h[3] * Rtt.h[3])[<<1] + 0x8000)).h[1];
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■   If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                              573
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Intrinsics
                   Rd=vdmpy(Rss,Rtt):<<1:rnd:sat            Word32 Q6_R_vdmpy_PP_s1_rnd_sat(Word64 Rss,
                                                            Word64 Rtt)
                   Rd=vdmpy(Rss,Rtt):rnd:sat                Word32 Q6_R_vdmpy_PP_rnd_sat(Word64 Rss, Word64
                                                            Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5 4 3 2  1 0
   ICLASS     RegType    MajOp         s5        Parse          t5        MinOp      d5
                                                                                            Rd=vdmpy(Rss,Rtt)[:<<N]:r
 1  1  1  0 1  0   0  1 N 0   0   s  s  s  s  s  P   P 0  t   t  t t t  0   0  0 d d d  d d
                                                                                            nd:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                               574
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Vector reduce multiply bytes
                  Multiply eight 8-bit bytes in Rss by the corresponding 8-bit bytes in Rtt. The four lower
                  results are accumulated. The lower word of the accumulator is optionally added. This
                  result is stored in the lower 32-bits of the accumulator. The same operation is performed
                  on the upper four products using the upper word of the accumulator. The eight bytes of
                  Rss can be treated as either signed or unsigned.
                                                                                              Rss
                                                                                              Rtt
                            *        *       *       *          *      *       *      *
                              16       16     16       16         16     16      16     16
                                        Add                                Add
                      32                                                                             32
                                  High Accumulation                Low Accumulation
                                                           Rxx
                   Syntax                                Behavior
                   Rdd=vrmpybsu(Rss,Rtt)                 Rdd.w[0]=((Rss.b[0] * Rtt.ub[0]) + (Rss.b[1] *
                                                         Rtt.ub[1]) + (Rss.b[2] * Rtt.ub[2]) + (Rss.b[3]
                                                         * Rtt.ub[3]));
                                                         Rdd.w[1]=((Rss.b[4] * Rtt.ub[4]) + (Rss.b[5] *
                                                         Rtt.ub[5]) + (Rss.b[6] * Rtt.ub[6]) + (Rss.b[7]
                                                         * Rtt.ub[7]));
                   Rdd=vrmpybu(Rss,Rtt)                  Rdd.w[0]=((Rss.ub[0] * Rtt.ub[0]) + (Rss.ub[1] *
                                                         Rtt.ub[1]) + (Rss.ub[2] * Rtt.ub[2]) +
                                                         (Rss.ub[3] * Rtt.ub[3]));
                                                         Rdd.w[1]=((Rss.ub[4] * Rtt.ub[4]) + (Rss.ub[5] *
                                                         Rtt.ub[5]) + (Rss.ub[6] * Rtt.ub[6]) +
                                                         (Rss.ub[7] * Rtt.ub[7]));
                   Rxx+=vrmpybsu(Rss,Rtt)                Rxx.w[0]=(Rxx.w[0] + (Rss.b[0] * Rtt.ub[0]) +
                                                         (Rss.b[1] * Rtt.ub[1]) + (Rss.b[2] * Rtt.ub[2])
                                                         + (Rss.b[3] * Rtt.ub[3]));
                                                         Rxx.w[1]=(Rxx.w[1] + (Rss.b[4] * Rtt.ub[4]) +
                                                         (Rss.b[5] * Rtt.ub[5]) + (Rss.b[6] * Rtt.ub[6])
                                                         + (Rss.b[7] * Rtt.ub[7]));
                                                         ;
80-N2040-45 Rev. B                                                                                            575
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Syntax                                   Behavior
                   Rxx+=vrmpybu(Rss,Rtt)                    Rxx.w[0]=(Rxx.w[0] + (Rss.ub[0] * Rtt.ub[0]) +
                                                            (Rss.ub[1] * Rtt.ub[1]) + (Rss.ub[2] *
                                                            Rtt.ub[2]) + (Rss.ub[3] * Rtt.ub[3]));
                                                            Rxx.w[1]=(Rxx.w[1] + (Rss.ub[4] * Rtt.ub[4]) +
                                                            (Rss.ub[5] * Rtt.ub[5]) + (Rss.ub[6] *
                                                            Rtt.ub[6]) + (Rss.ub[7] * Rtt.ub[7]));
                                                            ;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vrmpybsu(Rss,Rtt)                    Word64 Q6_P_vrmpybsu_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vrmpybu(Rss,Rtt)                     Word64 Q6_P_vrmpybu_PP(Word64 Rss, Word64 Rtt)
                   Rxx+=vrmpybsu(Rss,Rtt)                   Word64 Q6_P_vrmpybsuacc_PP(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                   Rxx+=vrmpybu(Rss,Rtt)                    Word64 Q6_P_vrmpybuacc_PP(Word64 Rxx, Word64
                                                            Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  0 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rdd=vrmpybu(Rss,Rtt)
 1  1  1  0 1  0   0  0 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rdd=vrmpybsu(Rss,Rtt)
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  0   1  0 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x  x x x Rxx+=vrmpybu(Rss,Rtt)
 1  1  1  0 1  0   1  0 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x  x x x Rxx+=vrmpybsu(Rss,Rtt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                              576
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Vector dual multiply signed by unsigned bytes
                  Multiply eight 8-bit signed bytes in Rss by the corresponding 8-bit unsigned bytes in Rtt.
                  Add the results in pairs, and optionally add the accumulator. The results are saturated to
                  signed 16-bits and stored in the four halfwords of the destination register.
                                                                                            Rss
                                                                                            Rtt
                        *        *       *        *         *       *       *        *
                          16     16         16    16          16     16       16      16
                            Add               Add              Add              Add
                          Sat_16            Sat_16           Sat_16           Sat_16
                                                                                                    Rxx
                   Syntax                              Behavior
                   Rdd=vdmpybsu(Rss,Rtt):sat            Rdd.h[0]=sat_16(((Rss.b[0]     * Rtt.ub[0]) +
                                                        (Rss.b[1] * Rtt.ub[1])));
                                                        Rdd.h[1]=sat_16(((Rss.b[2]     * Rtt.ub[2]) +
                                                        (Rss.b[3] * Rtt.ub[3])));
                                                        Rdd.h[2]=sat_16(((Rss.b[4]     * Rtt.ub[4]) +
                                                        (Rss.b[5] * Rtt.ub[5])));
                                                        Rdd.h[3]=sat_16(((Rss.b[6]     * Rtt.ub[6]) +
                                                        (Rss.b[7] * Rtt.ub[7])));
                   Rxx+=vdmpybsu(Rss,Rtt):sat           Rxx.h[0]=sat_16((Rxx.h[0] + (Rss.b[0] *
                                                        Rtt.ub[0]) + (Rss.b[1] * Rtt.ub[1])));
                                                        Rxx.h[1]=sat_16((Rxx.h[1] + (Rss.b[2] *
                                                        Rtt.ub[2]) + (Rss.b[3] * Rtt.ub[3])));
                                                        Rxx.h[2]=sat_16((Rxx.h[2] + (Rss.b[4] *
                                                        Rtt.ub[4]) + (Rss.b[5] * Rtt.ub[5])));
                                                        Rxx.h[3]=sat_16((Rxx.h[3] + (Rss.b[6] *
                                                        Rtt.ub[6]) + (Rss.b[7] * Rtt.ub[7])));
                                                        ;
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■  If saturation occurs during execution of this instruction (a result is clamped to
                          either maximum or minimum values), the OVF bit in the Status Register is set.
                          OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                             577
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Intrinsics
                   Rdd=vdmpybsu(Rss,Rtt):sat                Word64 Q6_P_vdmpybsu_PP_sat(Word64 Rss, Word64
                                                            Rtt)
                   Rxx+=vdmpybsu(Rss,Rtt):sat               Word64 Q6_P_vdmpybsuacc_PP_sat(Word64 Rxx,
                                                            Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
                                                                                           Rdd=vdmpybsu(Rss,Rtt):sa
 1  1  1  0 1  0   0  0 1  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d
                                                                                           t
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  0   1  0 0  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x  x x x Rxx+=vdmpybsu(Rss,Rtt):s
                                                                                           at
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                             578
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
        Vector multiply even halfwords
                  Multiply the even 16-bit halfwords from Rss and Rtt separately. Optionally accumulate
                  with the low and high words of the destination register pair and optionally saturate.
                                             Rxx+=vmpyeh(Rss,Rtt):sat
                                                                                        Rss
                                                                                         Rtt
                                             *                               *
                                               32                               32
                                            <<0-1                           <<0-1
                                           Add                              Add
                                         Sat_32                           Sat_32                       32
                            32
                                  High Accumulation                Low Accumulation
                                                          Rxx
                   Syntax                             Behavior
                   Rdd=vmpyeh(Rss,Rtt):<<1:sat        Rdd.w[0]=sat_32((Rss.h[0] * Rtt.h[0])<<1);
                                                      Rdd.w[1]=sat_32((Rss.h[2] * Rtt.h[2])<<1);
                   Rdd=vmpyeh(Rss,Rtt):sat            Rdd.w[0]=sat_32((Rss.h[0] * Rtt.h[0])<<0);
                                                      Rdd.w[1]=sat_32((Rss.h[2] * Rtt.h[2])<<0);
                   Rxx+=vmpyeh(Rss,Rtt)               Rxx.w[0]=Rxx.w[0] + (Rss.h[0] * Rtt.h[0]);
                                                      Rxx.w[1]=Rxx.w[1] + (Rss.h[2] * Rtt.h[2]);
                                                      ;
                   Rxx+=vmpyeh(Rss,Rtt):<<1:sat       Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] *
                                                      Rtt.h[0])<<1);
                                                      Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[2] *
                                                      Rtt.h[2])<<1);
                                                      ;
                   Rxx+=vmpyeh(Rss,Rtt):sat           Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] *
                                                      Rtt.h[0])<<0);
                                                      Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[2] *
                                                      Rtt.h[2])<<0);
                                                      ;
80-N2040-45 Rev. B                                                                                          579
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■   If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vmpyeh(Rss,Rtt):<<1:sat               Word64 Q6_P_vmpyeh_PP_s1_sat(Word64 Rss, Word64
                                                             Rtt)
                   Rdd=vmpyeh(Rss,Rtt):sat                   Word64 Q6_P_vmpyeh_PP_sat(Word64 Rss, Word64
                                                             Rtt)
                   Rxx+=vmpyeh(Rss,Rtt)                      Word64 Q6_P_vmpyehacc_PP(Word64 Rxx, Word64 Rss,
                                                             Word64 Rtt)
                   Rxx+=vmpyeh(Rss,Rtt):<<1:sat              Word64 Q6_P_vmpyehacc_PP_s1_sat(Word64 Rxx,
                                                             Word64 Rss, Word64 Rtt)
                   Rxx+=vmpyeh(Rss,Rtt):sat                  Word64 Q6_P_vmpyehacc_PP_sat(Word64 Rxx, Word64
                                                             Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7   6  5 4 3 2  1 0
   ICLASS     RegType      MajOp        s5        Parse          t5        MinOp      d5
                                                                                             Rdd=vmpyeh(Rss,Rtt)[:<<N
 1  1  1  0 1  0   0  0  N 0    0  s  s  s  s  s  P   P 0  t   t  t t t  1   1  0 d d d  d d ]:sat
   ICLASS     RegType      MajOp        s5        Parse          t5        MinOp      x5
 1  1  1  0 1  0   1  0  0  0   1  s  s  s  s  s  P   P 0  t   t  t t t  0   1  0 x x  x x x Rxx+=vmpyeh(Rss,Rtt)
 1  1  1  0 1  0   1  0  N 0    0  s  s  s  s  s  P   P 0  t   t  t t t  1   1  0 x x  x x x Rxx+=vmpyeh(Rss,Rtt)[:<<
                                                                                             N]:sat
                  Field name         Description
                  ICLASS             Instruction Class
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  RegType            Register Type
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  s5                 Field to encode register s
                  t5                 Field to encode register t
                  x5                 Field to encode register x
80-N2040-45 Rev. B                                                                                                580
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Vector multiply halfwords
                  Multiply two 16-bit halfwords separately, and optionally accumulate with the low and
                  high words of the destination. Optionally saturate, and store the results back to the
                  destination register pair.
                                               Rxx+=vmpyh(Rs,Rt):sat
                                                                             Rs
                                                                             Rt
                                                *               *
                                                  32              32
                                              <<0-1            <<0-1
                                       Add                             Add
                                     Sat_32                           Sat_32                       32
                       32
                              High Accumulation               Low Accumulation
                                                     Rxx
                   Syntax                             Behavior
                   Rdd=vmpyh(Rs,Rt)[:<<1]:sat         Rdd.w[0]=sat_32((Rs.h[0] * Rt.h[0])[<<1]);
                                                      Rdd.w[1]=sat_32((Rs.h[1] * Rt.h[1])[<<1]);
                   Rxx+=vmpyh(Rs,Rt)                  Rxx.w[0]=Rxx.w[0] + (Rs.h[0] * Rt.h[0]);
                                                      Rxx.w[1]=Rxx.w[1] + (Rs.h[1] * Rt.h[1]);
                                                      ;
                   Rxx+=vmpyh(Rs,Rt)[:<<1]:sat        Rxx.w[0]=sat_32(Rxx.w[0] + (Rs.h[0] *
                                                      Rt.h[0])[<<1]);
                                                      Rxx.w[1]=sat_32(Rxx.w[1] + (Rs.h[1] *
                                                      Rt.h[1])[<<1]);
                                                      ;
80-N2040-45 Rev. B                                                                                            581
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■   If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vmpyh(Rs,Rt):<<1:sat                  Word64 Q6_P_vmpyh_RR_s1_sat(Word32 Rs, Word32
                                                             Rt)
                   Rdd=vmpyh(Rs,Rt):sat                      Word64 Q6_P_vmpyh_RR_sat(Word32 Rs, Word32 Rt)
                   Rxx+=vmpyh(Rs,Rt)                         Word64 Q6_P_vmpyhacc_RR(Word64 Rxx, Word32 Rs,
                                                             Word32 Rt)
                   Rxx+=vmpyh(Rs,Rt):<<1:sat                 Word64 Q6_P_vmpyhacc_RR_s1_sat(Word64 Rxx,
                                                             Word32 Rs, Word32 Rt)
                   Rxx+=vmpyh(Rs,Rt):sat                     Word64 Q6_P_vmpyhacc_RR_sat(Word64 Rxx, Word32
                                                             Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType      MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 0  1   0  1  N 0    0  s  s  s  s  s  P   P 0  t   t  t t t 1   0  1 d d d  d d Rdd=vmpyh(Rs,Rt)[:<<N]:s
                                                                                             at
   ICLASS     RegType      MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 0  1   1  1  0  0   1  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x  x x x Rxx+=vmpyh(Rs,Rt)
                                                                                             Rxx+=vmpyh(Rs,Rt)[:<<N]:
 1  1  1  0 0  1   1  1  N 0    0  s  s  s  s  s  P   P 0  t   t  t t t 1   0  1 x x  x x x sat
                  Field name         Description
                  ICLASS             Instruction Class
                  MajOp              Major Opcode
                  MinOp              Minor Opcode
                  RegType            Register Type
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
                  s5                 Field to encode register s
                  t5                 Field to encode register t
                  x5                 Field to encode register x
80-N2040-45 Rev. B                                                                                                582
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
        Vector multiply halfwords with round and pack
                  Multiply two 16-bit halfwords separately. Round the results, and store the high halfwords
                  packed in a single register destination.
                                         Rd=vmpyh(Rs,Rt):rnd:sat
                                                                         Rs
                                                                         Rt
                                           *                *
                                              32              32
                    0x8000                <<0-1            <<0-1               0x8000
                                  Add                               Add
                                Sat_32                            Sat_32
                                      High 16-bits
                                                                 High 16-bits
                                                                            Rd
                   Syntax                               Behavior
                   Rd=vmpyh(Rs,Rt)[:<<1]:rnd:sat        Rd.h[1]=(sat_32((Rs.h[1] * Rt.h[1])[<<1] +
                                                        0x8000)).h[1];
                                                        Rd.h[0]=(sat_32((Rs.h[0] * Rt.h[0])[<<1] +
                                                        0x8000)).h[1];
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■  If saturation occurs during execution of this instruction (a result is clamped to
                          either maximum or minimum values), the OVF bit in the Status Register is set.
                          OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                             583
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Intrinsics
                   Rd=vmpyh(Rs,Rt):<<1:rnd:sat              Word32 Q6_R_vmpyh_RR_s1_rnd_sat(Word32 Rs,
                                                            Word32 Rt)
                   Rd=vmpyh(Rs,Rt):rnd:sat                  Word32 Q6_R_vmpyh_RR_rnd_sat(Word32 Rs, Word32
                                                            Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType    MajOp         s5        Parse          t5       MinOp      d5
                                                                                           Rd=vmpyh(Rs,Rt)[:<<N]:rn
 1  1  1  0 1  1   0  1 N 0   1   s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 d d d  d d
                                                                                           d:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              584
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector multiply halfwords, signed by unsigned
                  Multiply two 16-bit halfwords. Rs is considered signed, Ru unsigned.
                   Syntax                                   Behavior
                   Rdd=vmpyhsu(Rs,Rt)[:<<1]:sat             Rdd.w[0]=sat_32((Rs.h[0] * Rt.uh[0])[<<1]);
                                                            Rdd.w[1]=sat_32((Rs.h[1] * Rt.uh[1])[<<1]);
                   Rxx+=vmpyhsu(Rs,Rt)[:<<1]:sat            Rxx.w[0]=sat_32(Rxx.w[0] + (Rs.h[0] *
                                                            Rt.uh[0])[<<1]);
                                                            Rxx.w[1]=sat_32(Rxx.w[1] + (Rs.h[1] *
                                                            Rt.uh[1])[<<1]);
                                                            ;
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vmpyhsu(Rs,Rt):<<1:sat               Word64 Q6_P_vmpyhsu_RR_s1_sat(Word32 Rs, Word32
                                                            Rt)
                   Rdd=vmpyhsu(Rs,Rt):sat                   Word64 Q6_P_vmpyhsu_RR_sat(Word32 Rs, Word32 Rt)
                   Rxx+=vmpyhsu(Rs,Rt):<<1:sat              Word64 Q6_P_vmpyhsuacc_RR_s1_sat(Word64 Rxx,
                                                            Word32 Rs, Word32 Rt)
                   Rxx+=vmpyhsu(Rs,Rt):sat                  Word64 Q6_P_vmpyhsuacc_RR_sat(Word64 Rxx, Word32
                                                            Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 0  1   0  1  N 0   0  s  s  s  s  s  P   P 0  t   t  t t t 1   1  1 d d d  d d Rdd=vmpyhsu(Rs,Rt)[:<<N]
                                                                                            :sat
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 0  1   1  1  N 1   1  s  s  s  s  s  P   P 0  t   t  t t t 1   0  1 x x  x x x Rxx+=vmpyhsu(Rs,Rt)[:<<
                                                                                            N]:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
80-N2040-45 Rev. B                                                                                              585
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  s5           Field to encode register s
                  t5           Field to encode register t
                  x5           Field to encode register x
80-N2040-45 Rev. B                                                    586
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
        Vector reduce multiply halfwords
                  Multiply each halfword of Rss by the corresponding halfword in Rtt. Add the intermediate
                  products together and then optionally add the accumulator. Store the full 64-bit result in
                  the destination register pair.
                  This instruction is known as "big mac".
                                                                                          Rss
                                                                                          Rtt
                             *                 *                *              *
                                   32                                         32
                                                   32           32
                                                       Add
                                                                                                  64
                                                                                          Rdd
                                               64-bit Register Pair
                   Syntax                               Behavior
                   Rdd=vrmpyh(Rss,Rtt)                   Rdd = (Rss.h[0] * Rtt.h[0]) + (Rss.h[1] *
                                                         Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) + (Rss.h[3] *
                                                         Rtt.h[3]);
                   Rxx+=vrmpyh(Rss,Rtt)                  Rxx = Rxx + (Rss.h[0] * Rtt.h[0]) + (Rss.h[1] *
                                                         Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) + (Rss.h[3] *
                                                         Rtt.h[3]);
                                                         ;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vrmpyh(Rss,Rtt)                   Word64 Q6_P_vrmpyh_PP(Word64 Rss, Word64 Rtt)
                   Rxx+=vrmpyh(Rss,Rtt)                  Word64 Q6_P_vrmpyhacc_PP(Word64 Rxx, Word64 Rss,
                                                         Word64 Rtt)
80-N2040-45 Rev. B                                                                                          587
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 1  0   0  0 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  0 d d d  d d Rdd=vrmpyh(Rss,Rtt)
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 1  0   1  0 0  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   1  0 x x  x x x Rxx+=vrmpyh(Rss,Rtt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                              588
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Vector multiply bytes
                  Four 8-bit bytes from register Rs are multiplied by four 8-bit bytes from Rt. The product is
                  optionally accumulated with the 16-bit value from the destination register. The 16-bit
                  results are packed in the destination register pair. The bytes of Rs can be treated as either
                  signed or unsigned.
                                                                         Rs
                                                                         Rt
                                       *        *        *       *
                           Add              Add              Add              Add
                                                                                             Rxx
                   Syntax                               Behavior
                   Rdd=vmpybsu(Rs,Rt)                   Rdd.h[0]=((Rs.b[0]    *   Rt.ub[0]));
                                                        Rdd.h[1]=((Rs.b[1]    *   Rt.ub[1]));
                                                        Rdd.h[2]=((Rs.b[2]    *   Rt.ub[2]));
                                                        Rdd.h[3]=((Rs.b[3]    *   Rt.ub[3]));
                   Rdd=vmpybu(Rs,Rt)                    Rdd.h[0]=((Rs.ub[0]     *  Rt.ub[0]));
                                                        Rdd.h[1]=((Rs.ub[1]     *  Rt.ub[1]));
                                                        Rdd.h[2]=((Rs.ub[2]     *  Rt.ub[2]));
                                                        Rdd.h[3]=((Rs.ub[3]     *  Rt.ub[3]));
                   Rxx+=vmpybsu(Rs,Rt)                  Rxx.h[0]=(Rxx.h[0]+(Rs.b[0]      *   Rt.ub[0]));
                                                        Rxx.h[1]=(Rxx.h[1]+(Rs.b[1]      *   Rt.ub[1]));
                                                        Rxx.h[2]=(Rxx.h[2]+(Rs.b[2]      *   Rt.ub[2]));
                                                        Rxx.h[3]=(Rxx.h[3]+(Rs.b[3]      *   Rt.ub[3]));
                                                        ;
                   Rxx+=vmpybu(Rs,Rt)                   Rxx.h[0]=(Rxx.h[0]+(Rs.ub[0]       *  Rt.ub[0]));
                                                        Rxx.h[1]=(Rxx.h[1]+(Rs.ub[1]       *  Rt.ub[1]));
                                                        Rxx.h[2]=(Rxx.h[2]+(Rs.ub[2]       *  Rt.ub[2]));
                                                        Rxx.h[3]=(Rxx.h[3]+(Rs.ub[3]       *  Rt.ub[3]));
                                                        ;
80-N2040-45 Rev. B                                                                                              589
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vmpybsu(Rs,Rt)                       Word64 Q6_P_vmpybsu_RR(Word32 Rs, Word32 Rt)
                   Rdd=vmpybu(Rs,Rt)                        Word64 Q6_P_vmpybu_RR(Word32 Rs, Word32 Rt)
                   Rxx+=vmpybsu(Rs,Rt)                      Word64 Q6_P_vmpybsuacc_RR(Word64 Rxx, Word32 Rs,
                                                            Word32 Rt)
                   Rxx+=vmpybu(Rs,Rt)                       Word64 Q6_P_vmpybuacc_RR(Word64 Rxx, Word32 Rs,
                                                            Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      d5
 1  1  1  0 0  1   0  1 0  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rdd=vmpybsu(Rs,Rt)
 1  1  1  0 0  1   0  1 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 d d d  d d Rdd=vmpybu(Rs,Rt)
   ICLASS     RegType     MajOp        s5        Parse          t5       MinOp      x5
 1  1  1  0 0  1   1  1 1  0   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x  x x x Rxx+=vmpybu(Rs,Rt)
 1  1  1  0 0  1   1  1 1  1   0  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1 x x  x x x Rxx+=vmpybsu(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                             590
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
        Vector polynomial multiply halfwords
                  Perform a vector 16x16 carryless polynomial multiply using 32-bit source registers Rs and
                  Rt. The 64-bit result is stored in packed H,H,L,L format in the destination register. The
                  destination register can also be optionally accumulated (XOR’d). Finite field multiply
                  instructions are useful for many algorithms including scramble code generation,
                  cryptographic algorithms, convolutional, and Reed Solomon codes.
                               Rxx += vpmpyh(Rs,Rt)
                                    Rs
                                    Rt
                                  16x16
                                 Carryless                       16x16
                                Polynomial
                                   Mpy         *            *   Carryless
                                                               Polynomial
                                                                  Mpy
                                              XOR        XOR
                                                                          Rxx
                   Syntax                               Behavior
                   Rdd=vpmpyh(Rs,Rt)                     x0 = Rs.uh[0];
                                                         x1 = Rs.uh[1];
                                                         y0 = Rt.uh[0];
                                                         y1 = Rt.uh[1];
                                                         prod0 = prod1 = 0;
                                                         for(i=0; i < 16; i++) {
                                                             if((y0 >> i) & 1) prod0 ^= (x0 << i);
                                                             if((y1 >> i) & 1) prod1 ^= (x1 << i);
                                                         }
                                                         Rdd.h[0]=prod0.uh[0];
                                                         Rdd.h[1]=prod1.uh[0];
                                                         Rdd.h[2]=prod0.uh[1];
                                                         Rdd.h[3]=prod1.uh[1];
80-N2040-45 Rev. B                                                                                          591
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                   Syntax                                   Behavior
                   Rxx^=vpmpyh(Rs,Rt)                       x0 = Rs.uh[0];
                                                            x1 = Rs.uh[1];
                                                            y0 = Rt.uh[0];
                                                            y1 = Rt.uh[1];
                                                            prod0 = prod1 = 0;
                                                            for(i=0; i < 16; i++) {
                                                                 if((y0 >> i) & 1) prod0 ^= (x0 << i);
                                                                 if((y1 >> i) & 1) prod1 ^= (x1 << i);
                                                            }
                                                            Rxx.h[0]=Rxx.uh[0] ^ prod0.uh[0];
                                                            Rxx.h[1]=Rxx.uh[1] ^ prod1.uh[0];
                                                            Rxx.h[2]=Rxx.uh[2] ^ prod0.uh[1];
                                                            Rxx.h[3]=Rxx.uh[3] ^ prod1.uh[1];
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vpmpyh(Rs,Rt)                        Word64 Q6_P_vpmpyh_RR(Word32 Rs, Word32 Rt)
                   Rxx^=vpmpyh(Rs,Rt)                       Word64 Q6_P_vpmpyhxacc_RR(Word64 Rxx, Word32 Rs,
                                                            Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse          t5        MinOp      d5
 1  1  1  0 0  1   0  1 1  1   0  s  s  s  s  s  P   P 0  t   t  t t  t 1   1  1 d d d  d d Rdd=vpmpyh(Rs,Rt)
   ICLASS     RegType     MajOp        s5        Parse          t5        MinOp      x5
 1  1  1  0 0  1   1  1 1  0   1  s  s  s  s  s  P   P 0  t   t  t t  t 1   1  1 x x  x x x Rxx^=vpmpyh(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-45 Rev. B                                                                                              592
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
   11.10.6        XTYPE/PERM
                  The XTYPE/PERM instruction subclass includes instructions which perform
                  permutations.
          CABAC decode bin
                  This is a special-purpose instruction to support H.264 Context Adaptive Binary
                  Arithmetic Coding (CABAC). See Section X.X for a complete description.
                   Syntax                                   Behavior
                   Rdd=decbin(Rss,Rtt)                      state = Rtt.w[1][5:0];
                                                            valMPS = Rtt.w[1][8:8];
                                                            bitpos = Rtt.w[0][4:0];
                                                            range = Rss.w[0];
                                                            offset = Rss.w[1];
                                                            range <<= bitpos;
                                                            offset <<= bitpos;
                                                            rLPS = rLPS_table_64x4[state][ (range >>29)&3];
                                                            rLPS = rLPS << 23;
                                                            rMPS= (range&0xff800000) - rLPS;
                                                            if (offset < rMPS) {
                                                                 Rdd = AC_next_state_MPS_64[state];
                                                                 Rdd[8:8]=valMPS;
                                                                 Rdd[31:23]=(rMPS>>23);
                                                                 Rdd.w[1]=offset;
                                                                 P0=valMPS;
                                                            } else {
                                                                 Rdd = AC_next_state_LPS_64[state];
                                                                 Rdd[8:8]=((!state)?(1-valMPS):(valMPS));
                                                                 Rdd[31:23]=(rLPS>>23);
                                                                 Rdd.w[1]=(offset-rMPS);
                                                                 P0=(valMPS^1);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  The predicate generated by this instruction cannot be used as a .new predicate, nor
                           can it be automatically AND’d with another predicate.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS     RegType     Maj          s5        Parse          t5       Min        d5
 1  1  0  0 0  0   0  1  1  1  -  s  s  s  s  s  P   P -  t   t  t t  t 1  1 -  d d d  d d Rdd=decbin(Rss,Rtt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
80-N2040-45 Rev. B                                                                                             593
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  s5           Field to encode register s
                  t5           Field to encode register t
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    594
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
        Saturate
                  Saturate a single scalar value.
                  sath saturates a signed 32-bit number to a signed 16-bit number, which is sign-extended
                  back to 32 bits and placed in the destination register. The minimum negative value of the
                  result is 0xffff8000 and the maximum positive value is 0x00007fff.
                  satuh saturates a signed 32-bit number to an unsigned 16-bit number, which is zero-
                  extended back to 32 bits and placed in the destination register. The minimum value of the
                  result is 0 and the maximum value is 0x0000ffff.
                  satb saturates a signed 32-bit number to an signed 8-bit number, which is sign-extended
                  back to 32 bits and placed in the destination register. The minimum value of the result is
                  0xffffff80 and the maximum value is 0x0000007f.
                  satub saturates a signed 32-bit number to an unsigned 8-bit number, which is zero-
                  extended back to 32 bits and placed in the destination register. The minimum value of the
                  result is 0 and the maximum value is 0x000000ff.
                   Syntax                                Behavior
                   Rd=sat(Rss)                           Rd = sat_32(Rss);
                   Rd=satb(Rs)                           Rd = sat_8(Rs);
                   Rd=sath(Rs)                           Rd = sat_16(Rs);
                   Rd=satub(Rs)                          Rd = usat_8(Rs);
                   Rd=satuh(Rs)                          Rd = usat_16(Rs);
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■    If saturation occurs during execution of this instruction (a result is clamped to
                            either maximum or minimum values), the OVF bit in the Status Register is set.
                            OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=sat(Rss)                           Word32 Q6_R_sat_P(Word64 Rss)
                   Rd=satb(Rs)                           Word32 Q6_R_satb_R(Word32 Rs)
                   Rd=sath(Rs)                           Word32 Q6_R_sath_R(Word32 Rs)
                   Rd=satub(Rs)                          Word32 Q6_R_satub_R(Word32 Rs)
                   Rd=satuh(Rs)                          Word32 Q6_R_satuh_R(Word32 Rs)
80-N2040-45 Rev. B                                                                                               595
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                  MinOp      d5
 1  0  0  0 1  0   0  0 1  1  0   s  s  s  s  s  P   P -  -  -  - - - 0   0  0 d d d  d d Rd=sat(Rss)
 1  0  0  0 1  1   0  0 1  1  0   s  s  s  s  s  P   P -  -  -  - - - 1   0  0 d d d  d d Rd=sath(Rs)
 1  0  0  0 1  1   0  0 1  1  0   s  s  s  s  s  P   P -  -  -  - - - 1   0  1 d d d  d d Rd=satuh(Rs)
 1  0  0  0 1  1   0  0 1  1  0   s  s  s  s  s  P   P -  -  -  - - - 1   1  0 d d d  d d Rd=satub(Rs)
 1  0  0  0 1  1   0  0 1  1  0   s  s  s  s  s  P   P -  -  -  - - - 1   1  1 d d d  d d Rd=satb(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                            596
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Swizzle bytes
                  Swizzle the bytes of a word. This instruction is useful in converting between little and big
                  endian formats.
                     Rd=swiz(Rs)
                                                             Rs
                                                             Rd
                   Syntax                                   Behavior
                   Rd=swiz(Rs)                              Rd.b[0]=Rs.b[3];
                                                            Rd.b[1]=Rs.b[2];
                                                            Rd.b[2]=Rs.b[1];
                                                            Rd.b[3]=Rs.b[0];
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=swiz(Rs)                              Word32 Q6_R_swiz_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 1  1   0  0 1  0  0   s  s  s  s  s  P   P -  -   - -  - - 1   1  1 d d d  d d Rd=swiz(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                             597
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
          Vector align
                  Align a vector. Use the immediate amount, or the least significant 3 bits of a Predicate
                  register, as the number of bytes to align. Shift the Rss register pair right by this number of
                  bytes. Fill the vacated positions with the least significant elements from Rtt.
                                                                                               #u3/P
                     Rtt                                                                                 Rss
                                                                                         Rdd
                   Syntax                                   Behavior
                   Rdd=valignb(Rtt,Rss,#u3)                 Rdd = (Rss >>> #u*8)|(Rtt << ((8-#u)*8));
                   Rdd=valignb(Rtt,Rss,Pu)                  PREDUSE_TIMING;
                                                            Rdd = Rss >>> (Pu&0x7)*8|(Rtt << (8-
                                                            (Pu&0x7))*8);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=valignb(Rtt,Rss,#u3)                 Word64 Q6_P_valignb_PPI(Word64 Rtt, Word64 Rss,
                                                            Word32 Iu3)
                   Rdd=valignb(Rtt,Rss,Pu)                  Word64 Q6_P_valignb_PPp(Word64 Rtt, Word64 Rss,
                                                            Byte Pu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6    5  4 3 2  1  0
   ICLASS     RegType     Maj          s5        Parse          t5       Min           d5
 1  1  0  0 0  0   0  0  0  -  -  s  s  s  s  s  P   P -  t   t  t t t  i   i    i d d d  d  d Rdd=valignb(Rtt,Rss,#u3)
   ICLASS     RegType     Maj          s5        Parse          t5            u2       d5
 1  1  0  0 0  0   1  0  0  -  -  s  s  s  s  s  P   P -  t   t  t t t  -  u    u  d d d  d  d Rdd=valignb(Rtt,Rss,Pu)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u2                Field to encode register u
80-N2040-45 Rev. B                                                                                                   598
Hexagon V67 Programmer’s Reference Manual    Instruction Set
                  Field name   Description
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                       599
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Vector round and pack
                  Add the constant 0x00008000 to each word in the 64-bit source vector Rss. Optionally
                  saturate this addition to 32bits. Pack the high halfwords of the result into the
                  corresponding halfword of the 32-bit destination register.
                                  Rss.w[1]                           Rss.w[0]                   Rss
                                           0x8000                                0x8000
                                 32-bit Add                           32-bit Add
                                             Rd.h[1]         Rd.h[0]          Rd
                   Syntax                               Behavior
                   Rd=vrndwh(Rss)                        for (i=0;i<2;i++) {
                                                             Rd.h[i]=(Rss.w[i]+0x08000).h[1];
                                                         }
                   Rd=vrndwh(Rss):sat                    for (i=0;i<2;i++) {
                                                             Rd.h[i]=sat_32(Rss.w[i]+0x08000).h[1];
                                                         }
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■   If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=vrndwh(Rss)                       Word32 Q6_R_vrndwh_P(Word64 Rss)
                   Rd=vrndwh(Rss):sat                   Word32 Q6_R_vrndwh_P_sat(Word64 Rss)
80-N2040-45 Rev. B                                                                                              600
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                  MinOp      d5
 1  0  0  0 1  0   0  0 1  0  0   s  s  s  s  s  P   P -  -  -  - - - 1   0  0 d d d  d d Rd=vrndwh(Rss)
 1  0  0  0 1  0   0  0 1  0  0   s  s  s  s  s  P   P -  -  -  - - - 1   1  0 d d d  d d Rd=vrndwh(Rss):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                            601
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
         Vector saturate and pack
                  For each element in the vector, saturate the value to the next smaller size. VSATHUB
                  saturates signed halfwords to unsigned bytes, while VSATHB saturates signed halfwords
                  to signed bytes.
     Rd=vsathub(Rss)                                                      Rd=vsathub(Rs)
        s16            s16          s16          s16                           s16           s16         Rs
                                                          Rss
                                                                              Sat_u8        Sat_u8
       Sat_u8        Sat_u8        Sat_u8       Sat_u8
                    u8     u8    u8     u8     Rd                            0      0    u8      u8      Rd
  Rd=vsathb(Rss)                                                            Rd=vsathb(Rs)
        s16            s16          s16          s16      Rss                   s16           s16         Rs
       Sat_s8        Sat_s8        Sat_s8       Sat_s8                         Sat_s8        Sat_s8
                    s8     s8    s8     s8     Rd                             0      0     s8     s8      Rd
                  VSATWH saturates signed words to signed halfwords, while VSATWUH saturates signed
                  words to unsigned halfwords. The resulting values are packed together into destination
                  register Rd.
  Rd=vsathwh(Rss)                                                Rd=vsathwuh(Rss)
                s32                       s32          Rss                      s32                       s32      Rss
                Sat_s16                 Sat_s16                                                          Sat_u16
                                                                             Sat_u16
                        s16         s16      Rd                                       u16           u16       Rd
80-N2040-45 Rev. B                                                                                             602
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                   Syntax                                   Behavior
                   Rd=vsathb(Rs)                            Rd.b[0]=sat_8(Rs.h[0]);
                                                            Rd.b[1]=sat_8(Rs.h[1]);
                                                            Rd.b[2]=0;
                                                            Rd.b[3]=0;
                   Rd=vsathb(Rss)                           for (i=0;i<4;i++) {
                                                                Rd.b[i]=sat_8(Rss.h[i]);
                                                            }
                   Rd=vsathub(Rs)                           Rd.b[0]=usat_8(Rs.h[0]);
                                                            Rd.b[1]=usat_8(Rs.h[1]);
                                                            Rd.b[2]=0;
                                                            Rd.b[3]=0;
                   Rd=vsathub(Rss)                          for (i=0;i<4;i++) {
                                                                Rd.b[i]=usat_8(Rss.h[i]);
                                                            }
                   Rd=vsatwh(Rss)                           for (i=0;i<2;i++) {
                                                                Rd.h[i]=sat_16(Rss.w[i]);
                                                            }
                   Rd=vsatwuh(Rss)                          for (i=0;i<2;i++) {
                                                                Rd.h[i]=usat_16(Rss.w[i]);
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=vsathb(Rs)                            Word32 Q6_R_vsathb_R(Word32 Rs)
                   Rd=vsathb(Rss)                           Word32 Q6_R_vsathb_P(Word64 Rss)
                   Rd=vsathub(Rs)                           Word32 Q6_R_vsathub_R(Word32 Rs)
                   Rd=vsathub(Rss)                          Word32 Q6_R_vsathub_P(Word64 Rss)
                   Rd=vsatwh(Rss)                           Word32 Q6_R_vsatwh_P(Word64 Rss)
                   Rd=vsatwuh(Rss)                          Word32 Q6_R_vsatwuh_P(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5       Parse                    MinOp      d5
 1  0  0  0 1  0   0  0  0 0   0  s  s  s  s  s P   P  -  -   - -  - - 0   0  0 d d d  d d Rd=vsathub(Rss)
80-N2040-45 Rev. B                                                                                              603
Hexagon V67 Programmer’s Reference Manual                                                     Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
 1  0 0  0  1  0   0 0  0  0  0   s  s  s  s  s  P  P  -  -  -  - - - 0 1 0 d d d d d Rd=vsatwh(Rss)
 1  0 0  0  1  0   0 0  0  0  0   s  s  s  s  s  P  P  -  -  -  - - - 1 0 0 d d d d d Rd=vsatwuh(Rss)
 1  0 0  0  1  0   0 0  0  0  0   s  s  s  s  s  P  P  -  -  -  - - - 1 1 0 d d d d d Rd=vsathb(Rss)
 1  0 0  0  1  1   0 0  1  0   -  s  s  s  s  s  P  P  -  -  -  - - - 0 0 - d d d d d Rd=vsathb(Rs)
 1  0 0  0  1  1   0 0  1  0   -  s  s  s  s  s  P  P  -  -  -  - - - 0 1 - d d d d d Rd=vsathub(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                        604
Hexagon V67 Programmer’s Reference Manual                                                    Instruction Set
        Vector saturate without pack
                  Saturate each element of source vector Rss to the next smaller size. VSATHUB saturates
                  signed halfwords to unsigned bytes. VSATWH saturates signed words to signed
                  halfwords, and VSATWUH saturates signed words to unsigned halfwords. The resulting
                  values are placed in destination register Rdd in unpacked form.
                                              Rdd=vsathub(Rss)
                           s16              s16              s16             s16        Rss
                          Sat_u8           Sat_u8           Sat_u8          Sat_u8
                        0       u8      0        u8       0       u8     0        u8    Rdd
                                               Rdd=vsathb(Rss)
                           s16              s16              s16             s16        Rss
                          Sat_s8           Sat_s8           Sat_s8          Sat_s8
                       se               se               se              se
                                 s8               s8              s8              s8    Rdd
                   Syntax                              Behavior
                   Rdd=vsathb(Rss)                      for (i=0;i<4;i++) {
                                                             Rdd.h[i]=sat_8(Rss.h[i]);
                                                        }
                   Rdd=vsathub(Rss)                     for (i=0;i<4;i++) {
                                                             Rdd.h[i]=usat_8(Rss.h[i]);
                                                        }
                   Rdd=vsatwh(Rss)                      for (i=0;i<2;i++) {
                                                             Rdd.w[i]=sat_16(Rss.w[i]);
                                                        }
                   Rdd=vsatwuh(Rss)                     for (i=0;i<2;i++) {
                                                             Rdd.w[i]=usat_16(Rss.w[i]);
                                                        }
80-N2040-45 Rev. B                                                                                       605
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rdd=vsathb(Rss)                          Word64 Q6_P_vsathb_P(Word64 Rss)
                   Rdd=vsathub(Rss)                         Word64 Q6_P_vsathub_P(Word64 Rss)
                   Rdd=vsatwh(Rss)                          Word64 Q6_P_vsatwh_P(Word64 Rss)
                   Rdd=vsatwuh(Rss)                         Word64 Q6_P_vsatwuh_P(Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0  0 0   0  s  s  s  s  s  P   P -  -   - -  - - 1   0  0 d d d  d d Rdd=vsathub(Rss)
 1  0  0  0 0  0   0  0  0 0   0  s  s  s  s  s  P   P -  -   - -  - - 1   0  1 d d d  d d Rdd=vsatwuh(Rss)
 1  0  0  0 0  0   0  0  0 0   0  s  s  s  s  s  P   P -  -   - -  - - 1   1  0 d d d  d d Rdd=vsatwh(Rss)
 1  0  0  0 0  0   0  0  0 0   0  s  s  s  s  s  P   P -  -   - -  - - 1   1  1 d d d  d d Rdd=vsathb(Rss)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              606
Hexagon V67 Programmer’s Reference Manual                                                    Instruction Set
        Vector shuffle
                  Shuffle odd halfwords (shuffoh) takes the odd halfwords from Rtt and the odd halfwords
                  from Rss and merges them together into vector Rdd. Shuffle even halfwords (shuffeh)
                  performs the same operation on every even halfword in Rss and Rtt. The same operation is
                  available for odd and even bytes.
                               shuffoh                                       shuffeh
                                                    Rtt                                             Rss
                                                    Rss                                              Rtt
                                                    Rdd                                             Rdd
                               shuffob                                        shuffeb
                                                    Rtt                                             Rss
                                                    Rss                                              Rtt
                                                    Rdd                                             Rdd
                   Syntax                             Behavior
                   Rdd=shuffeb(Rss,Rtt)               for (i=0;i<4;i++) {
                                                           Rdd.b[i*2]=Rtt.b[i*2];
                                                           Rdd.b[i*2+1]=Rss.b[i*2];
                                                      }
                   Rdd=shuffeh(Rss,Rtt)               for (i=0;i<2;i++) {
                                                           Rdd.h[i*2]=Rtt.h[i*2];
                                                           Rdd.h[i*2+1]=Rss.h[i*2];
                                                      }
                   Rdd=shuffob(Rtt,Rss)               for (i=0;i<4;i++) {
                                                           Rdd.b[i*2]=Rss.b[i*2+1];
                                                           Rdd.b[i*2+1]=Rtt.b[i*2+1];
                                                      }
                   Rdd=shuffoh(Rtt,Rss)               for (i=0;i<2;i++) {
                                                           Rdd.h[i*2]=Rss.h[i*2+1];
                                                           Rdd.h[i*2+1]=Rtt.h[i*2+1];
                                                      }
80-N2040-45 Rev. B                                                                                       607
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=shuffeb(Rss,Rtt)                     Word64 Q6_P_shuffeb_PP(Word64 Rss, Word64 Rtt)
                   Rdd=shuffeh(Rss,Rtt)                     Word64 Q6_P_shuffeh_PP(Word64 Rss, Word64 Rtt)
                   Rdd=shuffob(Rtt,Rss)                     Word64 Q6_P_shuffob_PP(Word64 Rtt, Word64 Rss)
                   Rdd=shuffoh(Rtt,Rss)                     Word64 Q6_P_shuffoh_PP(Word64 Rtt, Word64 Rss)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS     RegType    Maj           s5        Parse          t5      Min        d5
 1  1  0  0 0  0   0  1 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  1  - d d  d d  d Rdd=shuffeb(Rss,Rtt)
 1  1  0  0 0  0   0  1 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 1  0  - d d  d d  d Rdd=shuffob(Rtt,Rss)
 1  1  0  0 0  0   0  1 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 1  1  - d d  d d  d Rdd=shuffeh(Rss,Rtt)
 1  1  0  0 0  0   0  1 1  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  0 0  d d  d d  d Rdd=shuffoh(Rtt,Rss)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              608
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector splat bytes
                  Replicate the low 8-bits from register Rs into each of the four bytes of destination register
                  Rd.
                          Rd=vsplatb(Rs)
                                                             Rs
                                                            Rd
                   Syntax                                   Behavior
                   Rd=vsplatb(Rs)                           for (i=0;i<4;i++) {
                                                                Rd.b[i]=Rs.b[0];
                                                            }
                   Rdd=vsplatb(Rs)                          for (i=0;i<8;i++) {
                                                                Rdd.b[i]=Rs.b[0];
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=vsplatb(Rs)                           Word32 Q6_R_vsplatb_R(Word32 Rs)
                   Rdd=vsplatb(Rs)                          Word64 Q6_P_vsplatb_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp       d5
 1  0  0  0 0  1   0  0 0  1   -  s  s  s  s  s  P   P -  -   - -  - - 1   0   - d d d  d d Rdd=vsplatb(Rs)
 1  0  0  0 1  1   0  0 0  1  0   s  s  s  s  s  P   P -  -   - -  - - 1   1  1  d d d  d d Rd=vsplatb(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              609
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Vector splat halfwords
                  Replicate the low 16-bits from register Rs into each of the four halfwords of destination
                  Rdd.
                                                              Rdd=vsplath(Rs)
                                                                                            Rs
                                                                                            Rdd
                   Syntax                                   Behavior
                   Rdd=vsplath(Rs)                          for (i=0;i<4;i++) {
                                                                Rdd.h[i]=Rs.h[0];
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vsplath(Rs)                          Word64 Q6_P_vsplath_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp       d5
 1  0  0  0 0  1   0  0 0  1   -  s  s  s  s  s  P   P -  -   - -  - - 0   1   - d d d  d d Rdd=vsplath(Rs)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              610
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
          Vector splice
                  Concatenate the low (8-N) bytes of vector Rtt with the low N bytes of vector Rss. This
                  instruction is helpful to vectorize unaligned stores.
                                                                                        #u3/P
                     Rtt                                                                                   Rss
                                                                                         Rdd
                   Syntax                                   Behavior
                   Rdd=vspliceb(Rss,Rtt,#u3)                Rdd = Rtt << #u*8 | zxt#u*8->64(Rss);
                   Rdd=vspliceb(Rss,Rtt,Pu)                 PREDUSE_TIMING;
                                                            Rdd = Rtt << (Pu&7)*8 | zxt(Pu&7)*8->64(Rss);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vspliceb(Rss,Rtt,#u3)                Word64 Q6_P_vspliceb_PPI(Word64 Rss, Word64 Rtt,
                                                            Word32 Iu3)
                   Rdd=vspliceb(Rss,Rtt,Pu)                 Word64 Q6_P_vspliceb_PPp(Word64 Rss, Word64 Rtt,
                                                            Byte Pu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6    5  4 3 2  1  0
   ICLASS     RegType     Maj          s5        Parse          t5       Min           d5
 1  1  0  0 0  0   0  0  1  -  -  s  s  s  s  s  P   P -  t   t  t t t  i   i    i d d d  d  d Rdd=vspliceb(Rss,Rtt,#u3)
   ICLASS     RegType     Maj          s5        Parse          t5            u2       d5
 1  1  0  0 0  0   1  0  1  0 0   s  s  s  s  s  P   P -  t   t  t t t  -   u   u  d d d  d  d Rdd=vspliceb(Rss,Rtt,Pu)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u2                Field to encode register u
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                                   611
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Vector sign extend
                  vsxtbh sign-extends each byte of a single register source to halfwords, and places the
                  result in the destination register pair.
                  vsxthw sign-extends each halfword of a single register source to words, and places the
                  result in the destination register pair.
                           Rdd=vsxtbh(Rs)                                                      Rs
                        sign              sign              sign               sign           Rdd
                                                                                              Rs
                         Rdd=vsxthw(Rs)
                             sign                               sign                          Rdd
                   Syntax                                   Behavior
                   Rdd=vsxtbh(Rs)                           for (i=0;i<4;i++) {
                                                                  Rdd.h[i]=Rs.b[i];
                                                            }
                   Rdd=vsxthw(Rs)                           for (i=0;i<2;i++) {
                                                                  Rdd.w[i]=Rs.h[i];
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vsxtbh(Rs)                           Word64 Q6_P_vsxtbh_R(Word32 Rs)
                   Rdd=vsxthw(Rs)                           Word64 Q6_P_vsxthw_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7   6  5  4 3 2  1 0
   ICLASS     RegType     MajOp        s5        Parse                     MinOp       d5
 1  0  0  0 0  1   0  0   0  0  - s  s  s   s  s P   P -  -   -   -  - - 0   0   - d d d  d d Rdd=vsxtbh(Rs)
 1  0  0  0 0  1   0  0   0  0  - s  s  s   s  s P   P -  -   -   -  - - 1   0   - d d d  d d Rdd=vsxthw(Rs)
80-N2040-45 Rev. B                                                                                                612
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    613
Hexagon V67 Programmer’s Reference Manual                                                       Instruction Set
        Vector truncate
                  In vtrunehb, for each halfword in a vector, take the even (lower) byte and ignore the other
                  byte. The resulting values are packed into destination register Rd.
                  vtrunohb takes each odd byte of the source vector.
                  vtrunewh uses two source register pairs, Rss and Rtt. The even (lower) halfwords of Rss
                  are packed in the upper word of Rdd, while the lower halfwords of Rtt are packed in the
                  lower word of Rdd.
                  vtrunowh performs the same operation as vtrunewh, but uses the odd (upper) halfwords of
                  the source vectors instead.
  Rd=vtrunehb(Rss)                                               Rdd=vtrunewh(Rss,Rtt)
                                                                                                                Rss
                                                  Rss
                                                                                                                Rtt
                                                   Rd
                                                                                                                Rdd
   Rd=vtrunohb(Rss)
                                                                 Rdd=vtrunowh(Rss,Rtt)
                                                  Rss                                                           Rss
                                                                                                                Rtt
                                                   Rd
                                                                                                                Rdd
                   Syntax                              Behavior
                   Rd=vtrunehb(Rss)                    for (i=0;i<4;i++) {
                                                           Rd.b[i]=Rss.b[i*2];
                                                       }
                   Rd=vtrunohb(Rss)                    for (i=0;i<4;i++) {
                                                           Rd.b[i]=Rss.b[i*2+1];
                                                       }
                   Rdd=vtrunehb(Rss,Rtt)               for (i=0;i<4;i++) {
                                                           Rdd.b[i]=Rtt.b[i*2];
                                                           Rdd.b[i+4]=Rss.b[i*2];
                                                       }
                   Rdd=vtrunewh(Rss,Rtt)               Rdd.h[0]=Rtt.h[0];
                                                       Rdd.h[1]=Rtt.h[2];
                                                       Rdd.h[2]=Rss.h[0];
                                                       Rdd.h[3]=Rss.h[2];
                   Rdd=vtrunohb(Rss,Rtt)               for (i=0;i<4;i++) {
                                                           Rdd.b[i]=Rtt.b[i*2+1];
                                                           Rdd.b[i+4]=Rss.b[i*2+1];
                                                       }
80-N2040-45 Rev. B                                                                                          614
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                   Syntax                                   Behavior
                   Rdd=vtrunowh(Rss,Rtt)                    Rdd.h[0]=Rtt.h[1];
                                                            Rdd.h[1]=Rtt.h[3];
                                                            Rdd.h[2]=Rss.h[1];
                                                            Rdd.h[3]=Rss.h[3];
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=vtrunehb(Rss)                         Word32 Q6_R_vtrunehb_P(Word64 Rss)
                   Rd=vtrunohb(Rss)                         Word32 Q6_R_vtrunohb_P(Word64 Rss)
                   Rdd=vtrunehb(Rss,Rtt)                    Word64 Q6_P_vtrunehb_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vtrunewh(Rss,Rtt)                    Word64 Q6_P_vtrunewh_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vtrunohb(Rss,Rtt)                    Word64 Q6_P_vtrunohb_PP(Word64 Rss, Word64 Rtt)
                   Rdd=vtrunowh(Rss,Rtt)                    Word64 Q6_P_vtrunowh_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 1  0   0  0 1  0  0   s  s  s  s  s  P   P -  -   -  - - - 0   0  0 d d d  d d Rd=vtrunohb(Rss)
 1  0  0  0 1  0   0  0 1  0  0   s  s  s  s  s  P   P -  -   -  - - - 0   1  0 d d d  d d Rd=vtrunehb(Rss)
   ICLASS     RegType    Maj           s5        Parse          t5      Min         d5
 1  1  0  0 0  0   0  1 1  0   -  s  s  s  s  s  P   P -  t   t  t t t 0   1  0 d d d  d d Rdd=vtrunewh(Rss,Rtt)
 1  1  0  0 0  0   0  1 1  0   -  s  s  s  s  s  P   P -  t   t  t t t 0   1  1 d d d  d d Rdd=vtrunehb(Rss,Rtt)
 1  1  0  0 0  0   0  1 1  0   -  s  s  s  s  s  P   P -  t   t  t t t 1   0  0 d d d  d d Rdd=vtrunowh(Rss,Rtt)
 1  1  0  0 0  0   0  1 1  0   -  s  s  s  s  s  P   P -  t   t  t t t 1   0  1 d d d  d d Rdd=vtrunohb(Rss,Rtt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                               615
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Vector zero extend
                  vzxtbh zero-extends each byte of a single register source to halfwords, and places the
                  result in the destination register pair.
                  vzxthw zero-extends each halfword of a single register source to words, and places the
                  result in the destination register pair.
                            Rdd=vzxtbh(Rs)                                                   Rs
                        zero              zero              zero              zero           Rdd
                          Rdd=vzxthw(Rs)                                                      Rs
                              zero                              zero                         Rdd
                   Syntax                                   Behavior
                   Rdd=vzxtbh(Rs)                           for (i=0;i<4;i++) {
                                                                 Rdd.h[i]=Rs.ub[i];
                                                            }
                   Rdd=vzxthw(Rs)                           for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=Rs.uh[i];
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vzxtbh(Rs)                           Word64 Q6_P_vzxtbh_R(Word32 Rs)
                   Rdd=vzxthw(Rs)                           Word64 Q6_P_vzxthw_R(Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5  4 3 2  1 0
   ICLASS     RegType    MajOp         s5        Parse                    MinOp       d5
 1  0  0  0 0  1   0  0   0  0   - s s  s   s  s P   P -  -   -  -  - - 0   1   - d d d  d d Rdd=vzxtbh(Rs)
 1  0  0  0 0  1   0  0   0  0   - s s  s   s  s P   P -  -   -  -  - - 1   1   - d d d  d d Rdd=vzxthw(Rs)
80-N2040-45 Rev. B                                                                                               616
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    617
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
   11.10.7        XTYPE/PRED
                  The XTYPE/PRED instruction subclass includes instructions which perform
                  miscellaneous operations on predicates, including mask generation, predicate transfers,
                  and the Viterbi pack operation.
          Bounds check
                  Determine if Rs falls in the range defined by Rtt.
                  Rtt.w0 is set by the user to the lower bound, and Rtt.w1 is set by the user to the upper
                  bound.
                  All bits of the destination predicate are set if the value falls within the range, or all cleared
                  otherwise.
                   Syntax                                   Behavior
                   Pd=boundscheck(Rs,Rtt)                   if ("Rs & 1") {
                                                                 Assembler mapped to:
                                                            "Pd=boundscheck(Rss,Rtt):raw:hi";
                                                            } else {
                                                                 Assembler mapped to:
                                                            "Pd=boundscheck(Rss,Rtt):raw:lo";
                                                            }
                   Pd=boundscheck(Rss,Rtt):raw:hi           src = Rss.uw[1];
                                                            Pd = (src.uw[0] >= Rtt.uw[0]) && (src.uw[0] <
                                                            Rtt.uw[1]) ? 0xff : 0x00;
                   Pd=boundscheck(Rss,Rtt):raw:lo           src = Rss.uw[0];
                                                            Pd = (src.uw[0] >= Rtt.uw[0]) && (src.uw[0] <
                                                            Rtt.uw[1]) ? 0xff : 0x00;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=boundscheck(Rs,Rtt)                   Byte Q6_p_boundscheck_RP(Word32 Rs, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3  2 1   0
   ICLASS     RegType                  s5       Parse           t5        MinOp           d2
                                                                                              Pd=boundscheck(Rss,Rtt):r
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s P   P 1   t   t  t t  t 1   0  0 - -  -  d  d aw:lo
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s P   P 1   t   t  t t  t 1   0  1 - -  -  d  d Pd=boundscheck(Rss,Rtt):r
                                                                                              aw:hi
80-N2040-45 Rev. B                                                                                                618
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  RegType      Register Type
                  MinOp        Minor Opcode
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d2           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
80-N2040-45 Rev. B                                                    619
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Compare byte
                  These instructions sign- or zero-extend the low 8-bits of the source registers and perform
                  32-bit comparisons on the result. For an extended 32-bit immediate operand, the full 32
                  immediate bits are used for the comparison.
                   Syntax                                   Behavior
                   Pd=cmpb.eq(Rs,#u8)                       Pd=Rs.ub[0] == #u ? 0xff : 0x00;
                   Pd=cmpb.eq(Rs,Rt)                        Pd=Rs.b[0] == Rt.b[0] ? 0xff : 0x00;
                   Pd=cmpb.gt(Rs,#s8)                       Pd=Rs.b[0] > #s ? 0xff : 0x00;
                   Pd=cmpb.gt(Rs,Rt)                        Pd=Rs.b[0] > Rt.b[0] ? 0xff : 0x00;
                   Pd=cmpb.gtu(Rs,#u7)                      apply_extension(#u);
                                                            Pd=Rs.ub[0] > #u.uw[0] ? 0xff : 0x00;
                   Pd=cmpb.gtu(Rs,Rt)                       Pd=Rs.ub[0] > Rt.ub[0] ? 0xff : 0x00;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=cmpb.eq(Rs,#u8)                       Byte Q6_p_cmpb_eq_RI(Word32 Rs, Word32 Iu8)
                   Pd=cmpb.eq(Rs,Rt)                        Byte Q6_p_cmpb_eq_RR(Word32 Rs, Word32 Rt)
                   Pd=cmpb.gt(Rs,#s8)                       Byte Q6_p_cmpb_gt_RI(Word32 Rs, Word32 Is8)
                   Pd=cmpb.gt(Rs,Rt)                        Byte Q6_p_cmpb_gt_RR(Word32 Rs, Word32 Rt)
                   Pd=cmpb.gtu(Rs,#u7)                      Byte Q6_p_cmpb_gtu_RI(Word32 Rs, Word32 Iu7)
                   Pd=cmpb.gtu(Rs,Rt)                       Byte Q6_p_cmpb_gtu_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2 1   0
   ICLASS     RegType     Maj          s5        Parse          t5       Min            d2
 1  1  0  0 0  1   1  1 1   1 0   s  s  s  s  s  P   P -  t   t  t t t 0   1  0 - - - d   d Pd=cmpb.gt(Rs,Rt)
 1  1  0  0 0  1   1  1 1   1 0   s  s  s  s  s  P   P -  t   t  t t t 1   1  0 - - - d   d Pd=cmpb.eq(Rs,Rt)
 1  1  0  0 0  1   1  1 1   1 0   s  s  s  s  s  P   P -  t   t  t t t 1   1  1 - - - d   d Pd=cmpb.gtu(Rs,Rt)
   ICLASS     RegType                  s5        Parse                                  d2
 1  1  0  1 1  1   0  1  -  0 0   s  s  s  s  s  P   P -  i   i  i i i  i   i i 0 0 - d   d Pd=cmpb.eq(Rs,#u8)
 1  1  0  1 1  1   0  1  -  0 1   s  s  s  s  s  P   P -  i   i  i i i  i   i i 0 0 - d   d Pd=cmpb.gt(Rs,#s8)
 1  1  0  1 1  1   0  1  -  1 0   s  s  s  s  s  P   P - 0    i  i i i  i   i i 0 0 - d   d Pd=cmpb.gtu(Rs,#u7)
                  Field name        Description
                  RegType           Register Type
                  MajOp             Major Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
80-N2040-45 Rev. B                                                                                              620
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  s5           Field to encode register s
                  t5           Field to encode register t
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    621
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
          Compare half
                  These instructions sign- or zero-extend the low 16-bits of the source registers and perform
                  32-bit comparisons on the result. For an extended 32-bit immediate operand, the full 32
                  immediate bits are used for the comparison.
                   Syntax                                   Behavior
                   Pd=cmph.eq(Rs,#s8)                       apply_extension(#s);
                                                            Pd=Rs.h[0] == #s ? 0xff : 0x00;
                   Pd=cmph.eq(Rs,Rt)                        Pd=Rs.h[0] == Rt.h[0] ? 0xff : 0x00;
                   Pd=cmph.gt(Rs,#s8)                       apply_extension(#s);
                                                            Pd=Rs.h[0] > #s ? 0xff : 0x00;
                   Pd=cmph.gt(Rs,Rt)                        Pd=Rs.h[0] > Rt.h[0] ? 0xff : 0x00;
                   Pd=cmph.gtu(Rs,#u7)                      apply_extension(#u);
                                                            Pd=Rs.uh[0] > #u.uw[0] ? 0xff : 0x00;
                   Pd=cmph.gtu(Rs,Rt)                       Pd=Rs.uh[0] > Rt.uh[0] ? 0xff : 0x00;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=cmph.eq(Rs,#s8)                       Byte Q6_p_cmph_eq_RI(Word32 Rs, Word32 Is8)
                   Pd=cmph.eq(Rs,Rt)                        Byte Q6_p_cmph_eq_RR(Word32 Rs, Word32 Rt)
                   Pd=cmph.gt(Rs,#s8)                       Byte Q6_p_cmph_gt_RI(Word32 Rs, Word32 Is8)
                   Pd=cmph.gt(Rs,Rt)                        Byte Q6_p_cmph_gt_RR(Word32 Rs, Word32 Rt)
                   Pd=cmph.gtu(Rs,#u7)                      Byte Q6_p_cmph_gtu_RI(Word32 Rs, Word32 Iu7)
                   Pd=cmph.gtu(Rs,Rt)                       Byte Q6_p_cmph_gtu_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2 1   0
   ICLASS     RegType     Maj          s5        Parse          t5       Min            d2
 1  1  0  0 0  1   1  1 1   1 0   s  s  s  s  s  P   P -  t   t  t t t 0   1  1 - - - d   d Pd=cmph.eq(Rs,Rt)
 1  1  0  0 0  1   1  1 1   1 0   s  s  s  s  s  P   P -  t   t  t t t 1   0  0 - - - d   d Pd=cmph.gt(Rs,Rt)
 1  1  0  0 0  1   1  1 1   1 0   s  s  s  s  s  P   P -  t   t  t t t 1   0  1 - - - d   d Pd=cmph.gtu(Rs,Rt)
   ICLASS     RegType                  s5        Parse                                  d2
 1  1  0  1 1  1   0  1  -  0 0   s  s  s  s  s  P   P -  i   i  i i i  i   i i 0 1 - d   d Pd=cmph.eq(Rs,#s8)
 1  1  0  1 1  1   0  1  -  0 1   s  s  s  s  s  P   P -  i   i  i i i  i   i i 0 1 - d   d Pd=cmph.gt(Rs,#s8)
 1  1  0  1 1  1   0  1  -  1 0   s  s  s  s  s  P   P - 0    i  i i i  i   i i 0 1 - d   d Pd=cmph.gtu(Rs,#u7)
                  Field name        Description
                  RegType           Register Type
                  MajOp             Major Opcode
                  ICLASS            Instruction Class
80-N2040-45 Rev. B                                                                                              622
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  Parse        Packet/Loop parse bits
                  d2           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    623
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          Compare doublewords
                  Compare two 64-bit register pairs for unsigned greater than, greater than, or equal. The 8-
                  bit predicate register Pd is set to all 1's or all 0's depending on the result.
                   Syntax                                   Behavior
                   Pd=cmp.eq(Rss,Rtt)                       Pd=Rss==Rtt ? 0xff : 0x00;
                   Pd=cmp.gt(Rss,Rtt)                       Pd=Rss>Rtt ? 0xff : 0x00;
                   Pd=cmp.gtu(Rss,Rtt)                      Pd=Rss.u64>Rtt.u64 ? 0xff : 0x00;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=cmp.eq(Rss,Rtt)                       Byte Q6_p_cmp_eq_PP(Word64 Rss, Word64 Rtt)
                   Pd=cmp.gt(Rss,Rtt)                       Byte Q6_p_cmp_gt_PP(Word64 Rss, Word64 Rtt)
                   Pd=cmp.gtu(Rss,Rtt)                      Byte Q6_p_cmp_gtu_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7   6  5 4 3 2  1   0
   ICLASS     RegType                  s5        Parse          t5         MinOp           d2
 1  1  0  1 0  0   1  0 1  0  0   s  s  s  s  s  P   P -  t   t  t t  t  0   0  0 - - -  d   d Pd=cmp.eq(Rss,Rtt)
 1  1  0  1 0  0   1  0 1  0  0   s  s  s  s  s  P   P -  t   t  t t  t  0   1  0 - - -  d   d Pd=cmp.gt(Rss,Rtt)
 1  1  0  1 0  0   1  0 1  0  0   s  s  s  s  s  P   P -  t   t  t t  t  1   0  0 - - -  d   d Pd=cmp.gtu(Rss,Rtt)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                 624
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
          Compare bit mask
                  If all the bits in the mask in Rt or a short immediate are set (BITSSET) or clear
                  (BITSCLEAR) in Rs, set the Pd to true. Otherwise, set the bits in Pd to false.
                   Syntax                                    Behavior
                   Pd=[!]bitsclr(Rs,#u6)                     Pd=(Rs&#u)[!]=0 ? 0xff : 0x00;
                   Pd=[!]bitsclr(Rs,Rt)                      Pd=(Rs&Rt)[!]=0 ? 0xff : 0x00;
                   Pd=[!]bitsset(Rs,Rt)                      Pd=(Rs&Rt)[!]=Rt ? 0xff : 0x00;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=!bitsclr(Rs,#u6)                       Byte Q6_p_not_bitsclr_RI(Word32 Rs, Word32 Iu6)
                   Pd=!bitsclr(Rs,Rt)                        Byte Q6_p_not_bitsclr_RR(Word32 Rs, Word32 Rt)
                   Pd=!bitsset(Rs,Rt)                        Byte Q6_p_not_bitsset_RR(Word32 Rs, Word32 Rt)
                   Pd=bitsclr(Rs,#u6)                        Byte Q6_p_bitsclr_RI(Word32 Rs, Word32 Iu6)
                   Pd=bitsclr(Rs,Rt)                         Byte Q6_p_bitsclr_RR(Word32 Rs, Word32 Rt)
                   Pd=bitsset(Rs,Rt)                         Byte Q6_p_bitsset_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3  2 1   0
   ICLASS     RegType    MajOp          s5        Parse                                  d2
 1  0  0  0 0  1   0  1  1  0  0   s  s  s  s  s  P   P i  i   i  i i i  - -  - - -  - d   d Pd=bitsclr(Rs,#u6)
 1  0  0  0 0  1   0  1  1  0  1   s  s  s  s  s  P   P i  i   i  i i i  - -  - - -  - d   d Pd=!bitsclr(Rs,#u6)
   ICLASS     RegType     Maj           s5        Parse          t5                      d2
 1  1  0  0 0  1   1  1  0  1  0   s  s  s  s  s  P   P -  t   t  t t t  - -  - - -  - d   d Pd=bitsset(Rs,Rt)
 1  1  0  0 0  1   1  1  0  1  1   s  s  s  s  s  P   P -  t   t  t t t  - -  - - -  - d   d Pd=!bitsset(Rs,Rt)
 1  1  0  0 0  1   1  1  1  0  0   s  s  s  s  s  P   P -  t   t  t t t  - -  - - -  - d   d Pd=bitsclr(Rs,Rt)
 1  1  0  0 0  1   1  1  1  0  1   s  s  s  s  s  P   P -  t   t  t t t  - -  - - -  - d   d Pd=!bitsclr(Rs,Rt)
                  Field name         Description
                  ICLASS             Instruction Class
                  Parse              Packet/Loop parse bits
                  d2                 Field to encode register d
                  s5                 Field to encode register s
                  t5                 Field to encode register t
                  MajOp              Major Opcode
                  Maj                Major Opcode
                  RegType            Register Type
                  RegType            Register Type
80-N2040-45 Rev. B                                                                                                 625
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Mask generate from predicate
                  For each of the low 8 bits in predicate register Pt, if the bit is set, set the corresponding
                  byte in 64-bit register pair Rdd to 0xff, otherwise, set the corresponding byte to 0x00.
                                          7                               0
                                          1   0    1   0    1   0     1   0       Pt
                      0xFF     0x00     0xFF      0x00     0xFF      0x00     0xFF     0x00      Rdd
                   Syntax                                   Behavior
                   Rdd=mask(Pt)                             PREDUSE_TIMING;
                                                            for (i = 0; i < 8; i++) {
                                                                Rdd.b[i]=(Pt.i?(0xff):(0x00));
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=mask(Pt)                             Word64 Q6_P_mask_p(Byte Pt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8 7 6   5 4  3  2  1 0
   ICLASS     RegType                            Parse               t2                 d5
 1  0  0  0 0  1   1  0  -  -  -  -  -  -   -  - P   P -  -   - -  t    t - -   - d  d  d  d d Rdd=mask(Pt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t2                Field to encode register t
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                                626
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Check for TLB match
                  Determine if the TLB entry in Rss matches the ASID:PPN in Rt.
                   Syntax                                   Behavior
                   Pd=tlbmatch(Rss,Rt)                      MASK = 0x07ffffff;
                                                            TLBLO = Rss.uw[0];
                                                            TLBHI = Rss.uw[1];
                                                            SIZE =
                                                            min(6,count_leading_ones(~reverse_bits(TLBLO)));
                                                            MASK &= (0xffffffff << 2*SIZE);
                                                            Pd = TLBHI.31 && ((TLBHI & MASK) == (Rt & MASK))
                                                            ? 0xff : 0x00;
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  The predicate generated by this instruction cannot be used as a .new predicate, nor
                           can it be automatically AND’d with another predicate.
                  Intrinsics
                   Pd=tlbmatch(Rss,Rt)                      Byte Q6_p_tlbmatch_PR(Word64 Rss, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2 1   0
   ICLASS     RegType                  s5        Parse          t5       MinOp          d2
 1  1  0  1 0  0   1  0  0  -  -  s  s  s  s  s  P   P 1  t   t  t t t 0   1  1 - - - d   d Pd=tlbmatch(Rss,Rt)
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                              627
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Predicate transfer
                  Pd=Rs transfers a predicate to the 8 least-significant bits of a general register and zeros the
                  other bits.
                  Rd=Ps transfers the 8 least-significant bits of a general register to a predicate.
                   Syntax                                   Behavior
                   Pd=Rs                                    Pd = Rs.ub[0];
                   Rd=Ps                                    PREDUSE_TIMING;
                                                            Rd = zxt8->32(Ps);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=Rs                                    Byte Q6_p_equals_R(Word32 Rs)
                   Rd=Ps                                    Word32 Q6_R_equals_p(Byte Ps)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6 5 4  3 2  1   0
   ICLASS     RegType   MajOp          s5         Parse                                  d2
 1  0  0  0 0  1   0  1 0  1  0   s  s  s  s    s P   P - -   - -  - -  -  - - -  -  - d   d Pd=Rs
   ICLASS     RegType   MajOp                s2   Parse                             d5
 1  0  0  0 1  0   0  1  - 1   -  -  -  -  s    s P   P - -   - -  - -  -  - - d  d d  d   d Rd=Ps
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  d5                Field to encode register d
                  s2                Field to encode register s
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              628
Hexagon V67 Programmer’s Reference Manual                                                                   Instruction Set
          Test bit
                  Extract a bit from a register. If the bit is true (1), set all the bits of the predicate register
                  destination to 1. If the bit is false (0), set all the bits of the predicate register destination to
                  0. Indicate the bit to test using an immediate or register value.
                  If a register indicates the bit to test, and the value specified is out of range, the predicate
                  result is zero.
                   Syntax                                    Behavior
                   Pd=[!]tstbit(Rs,#u5)                      Pd = (Rs & (1<<#u)) == 0 ? 0xff : 0x00;
                   Pd=[!]tstbit(Rs,Rt)                       Pd = (zxt32->64(Rs) & (sxt7->32(Rt)>0)?(zxt32-
                                                             >64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt)))
                                                             == 0 ? 0xff : 0x00;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=!tstbit(Rs,#u5)                        Byte Q6_p_not_tstbit_RI(Word32 Rs, Word32 Iu5)
                   Pd=!tstbit(Rs,Rt)                         Byte Q6_p_not_tstbit_RR(Word32 Rs, Word32 Rt)
                   Pd=tstbit(Rs,#u5)                         Byte Q6_p_tstbit_RI(Word32 Rs, Word32 Iu5)
                   Pd=tstbit(Rs,Rt)                          Byte Q6_p_tstbit_RR(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8  7   6  5 4  3  2  1   0
   ICLASS     RegType   MajOp          s5        Parse                                        d2
 1  0  0  0 0  1   0  1  0  0  0  s  s  s  s  s  P   P 0   i   i  i  i  i -   -  -  -  - -  d   d Pd=tstbit(Rs,#u5)
 1  0  0  0 0  1   0  1  0  0  1  s  s  s  s  s  P   P 0   i   i  i  i  i -   -  -  -  - -  d   d Pd=!tstbit(Rs,#u5)
   ICLASS     RegType     Maj          s5        Parse           t5                           d2
 1  1  0  0 0  1   1  1  0  0  0  s  s  s  s  s  P   P -   t   t  t  t t  -   -  -  -  - -  d   d Pd=tstbit(Rs,Rt)
 1  1  0  0 0  1   1  1  0  0  1  s  s  s  s  s  P   P -   t   t  t  t t  -   -  -  -  - -  d   d Pd=!tstbit(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  MajOp             Major Opcode
                  Maj               Major Opcode
                  RegType           Register Type
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                                      629
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Vector compare halfwords
                  Compare each of four 16-bit halfwords in two 64-bit vectors and set the corresponding bits
                  in a predicate destination to '11' if true, '00' if false.
                  Halfword comparisons can be for equal, signed greater than, or unsigned greater than.
                                                                                             Rss
                                                                                             Rtt
                             cmp              cmp                 cmp            cmp
                                        1    1    0    0    1    1    0    0      Pd
                                         7                                 0
                   Syntax                                 Behavior
                   Pd=vcmph.eq(Rss,#s8)                    for (i = 0; i < 4; i++) {
                                                                Pd.i*2 = (Rss.h[i] == #s);
                                                                Pd.i*2+1 = (Rss.h[i] == #s);
                                                           }
                   Pd=vcmph.eq(Rss,Rtt)                    for (i = 0; i < 4; i++) {
                                                                Pd.i*2 = (Rss.h[i] == Rtt.h[i]);
                                                                Pd.i*2+1 = (Rss.h[i] == Rtt.h[i]);
                                                           }
                   Pd=vcmph.gt(Rss,#s8)                    for (i = 0; i < 4; i++) {
                                                                Pd.i*2 = (Rss.h[i] > #s);
                                                                Pd.i*2+1 = (Rss.h[i] > #s);
                                                           }
                   Pd=vcmph.gt(Rss,Rtt)                    for (i = 0; i < 4; i++) {
                                                                Pd.i*2 = (Rss.h[i] > Rtt.h[i]);
                                                                Pd.i*2+1 = (Rss.h[i] > Rtt.h[i]);
                                                           }
                   Pd=vcmph.gtu(Rss,#u7)                   for (i = 0; i < 4; i++) {
                                                                Pd.i*2 = (Rss.uh[i] > #u);
                                                                Pd.i*2+1 = (Rss.uh[i] > #u);
                                                           }
                   Pd=vcmph.gtu(Rss,Rtt)                   for (i = 0; i < 4; i++) {
                                                                Pd.i*2 = (Rss.uh[i] > Rtt.uh[i]);
                                                                Pd.i*2+1 = (Rss.uh[i] > Rtt.uh[i]);
                                                           }
80-N2040-45 Rev. B                                                                                           630
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=vcmph.eq(Rss,#s8)                     Byte Q6_p_vcmph_eq_PI(Word64 Rss, Word32 Is8)
                   Pd=vcmph.eq(Rss,Rtt)                     Byte Q6_p_vcmph_eq_PP(Word64 Rss, Word64 Rtt)
                   Pd=vcmph.gt(Rss,#s8)                     Byte Q6_p_vcmph_gt_PI(Word64 Rss, Word32 Is8)
                   Pd=vcmph.gt(Rss,Rtt)                     Byte Q6_p_vcmph_gt_PP(Word64 Rss, Word64 Rtt)
                   Pd=vcmph.gtu(Rss,#u7)                    Byte Q6_p_vcmph_gtu_PI(Word64 Rss, Word32 Iu7)
                   Pd=vcmph.gtu(Rss,Rtt)                    Byte Q6_p_vcmph_gtu_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7    6  5  4 3 2 1   0
   ICLASS     RegType                  s5        Parse          t5        MinOp           d2
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 0  t   t  t t t 0    1  1  - - - d   d Pd=vcmph.eq(Rss,Rtt)
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 0  t   t  t t t 1    0  0  - - - d   d Pd=vcmph.gt(Rss,Rtt)
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 0  t   t  t t t 1    0  1  - - - d   d Pd=vcmph.gtu(Rss,Rtt)
   ICLASS     RegType                  s5        Parse                                    d2
 1  1  0  1 1  1   0  0 0  0  0   s  s  s  s  s  P   P -  i   i  i i i  i    i  i 0 1 - d   d Pd=vcmph.eq(Rss,#s8)
 1  1  0  1 1  1   0  0 0  0  1   s  s  s  s  s  P   P -  i   i  i i i  i    i  i 0 1 - d   d Pd=vcmph.gt(Rss,#s8)
 1  1  0  1 1  1   0  0 0  1  0   s  s  s  s  s  P   P - 0    i  i i i  i    i  i 0 1 - d   d Pd=vcmph.gtu(Rss,#u7)
                  Field name        Description
                  RegType           Register Type
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                  631
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
          Vector compare bytes for any match
                  Compare each byte in two 64-bit source vectors and set a predicate if any of the 8 bytes are
                  equal.
                  This instruction can quickly find the null terminator in a string.
                   Syntax                                   Behavior
                   Pd=!any8(vcmpb.eq(Rss,Rtt))              Pd = 0;
                                                            for (i = 0; i < 8; i++) {
                                                                 if (Rss.b[i] == Rtt.b[i]) Pd = 0xff;
                                                            }
                                                            Pd = ~Pd;
                   Pd=any8(vcmpb.eq(Rss,Rtt))               Pd = 0;
                                                            for (i = 0; i < 8; i++) {
                                                                 if (Rss.b[i] == Rtt.b[i]) Pd = 0xff;
                                                            }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=!any8(vcmpb.eq(Rss,Rtt))              Byte Q6_p_not_any8_vcmpb_eq_PP(Word64 Rss,
                                                            Word64 Rtt)
                   Pd=any8(vcmpb.eq(Rss,Rtt))               Byte Q6_p_any8_vcmpb_eq_PP(Word64 Rss, Word64
                                                            Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7   6  5 4 3 2 1   0
   ICLASS     RegType                  s5        Parse          t5        MinOp          d2
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 1  t   t  t t  t 0   0  0 - - - d   d Pd=any8(vcmpb.eq(Rss,Rtt
                                                                                             ))
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 1  t   t  t t  t 0   0  1 - - - d   d Pd=!any8(vcmpb.eq(Rss,Rt
                                                                                             t))
                  Field name        Description
                  RegType           Register Type
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                               632
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
        Vector compare bytes
                  Compare each of eight bytes in two 64-bit vectors and set the corresponding bit in a
                  predicate destination to 1 if true, 0 if false.
                  Byte comparisons can be for equal or for unsigned greater than.
                  In the following example, every other comparison is true.
                                                                                           Rss
                                                                                           Rtt
                       cmp     cmp     cmp       cmp      cmp      cmp    cmp     cmp
                                      1    0    1   0    1    0   1   0     Pd
                                      7                               0
                   Syntax                                 Behavior
                   Pd=vcmpb.eq(Rss,#u8)                   for (i = 0; i < 8; i++) {
                                                               Pd.i = (Rss.ub[i] == #u);
                                                          }
                   Pd=vcmpb.eq(Rss,Rtt)                   for (i = 0; i < 8; i++) {
                                                               Pd.i = (Rss.b[i] == Rtt.b[i]);
                                                          }
                   Pd=vcmpb.gt(Rss,#s8)                   for (i = 0; i < 8; i++) {
                                                               Pd.i = (Rss.b[i] > #s);
                                                          }
                   Pd=vcmpb.gt(Rss,Rtt)                   for (i = 0; i < 8; i++) {
                                                               Pd.i = (Rss.b[i] > Rtt.b[i]);
                                                          }
                   Pd=vcmpb.gtu(Rss,#u7)                  for (i = 0; i < 8; i++) {
                                                               Pd.i = (Rss.ub[i] > #u);
                                                          }
                   Pd=vcmpb.gtu(Rss,Rtt)                  for (i = 0; i < 8; i++) {
                                                               Pd.i = (Rss.ub[i] > Rtt.ub[i]);
                                                          }
80-N2040-45 Rev. B                                                                                         633
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=vcmpb.eq(Rss,#u8)                     Byte Q6_p_vcmpb_eq_PI(Word64 Rss, Word32 Iu8)
                   Pd=vcmpb.eq(Rss,Rtt)                     Byte Q6_p_vcmpb_eq_PP(Word64 Rss, Word64 Rtt)
                   Pd=vcmpb.gt(Rss,#s8)                     Byte Q6_p_vcmpb_gt_PI(Word64 Rss, Word32 Is8)
                   Pd=vcmpb.gt(Rss,Rtt)                     Byte Q6_p_vcmpb_gt_PP(Word64 Rss, Word64 Rtt)
                   Pd=vcmpb.gtu(Rss,#u7)                    Byte Q6_p_vcmpb_gtu_PI(Word64 Rss, Word32 Iu7)
                   Pd=vcmpb.gtu(Rss,Rtt)                    Byte Q6_p_vcmpb_gtu_PP(Word64 Rss, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7    6  5  4 3 2 1   0
   ICLASS     RegType                  s5        Parse          t5        MinOp           d2
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 0  t   t  t t t 1    1  0  - - - d   d Pd=vcmpb.eq(Rss,Rtt)
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 0  t   t  t t t 1    1  1  - - - d   d Pd=vcmpb.gtu(Rss,Rtt)
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 1  t   t  t t t 0    1  0  - - - d   d Pd=vcmpb.gt(Rss,Rtt)
   ICLASS     RegType                  s5        Parse                                    d2
 1  1  0  1 1  1   0  0 0  0  0   s  s  s  s  s  P   P -  i   i  i i i  i    i  i 0 0 - d   d Pd=vcmpb.eq(Rss,#u8)
 1  1  0  1 1  1   0  0 0  0  1   s  s  s  s  s  P   P -  i   i  i i i  i    i  i 0 0 - d   d Pd=vcmpb.gt(Rss,#s8)
 1  1  0  1 1  1   0  0 0  1  0   s  s  s  s  s  P   P - 0    i  i i i  i    i  i 0 0 - d   d Pd=vcmpb.gtu(Rss,#u7)
                  Field name        Description
                  RegType           Register Type
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                  634
Hexagon V67 Programmer’s Reference Manual                                                      Instruction Set
        Vector compare words
                  Compare each of two 32-bit words in two 64-bit vectors and set the corresponding bits in a
                  predicate destination to '1111' if true, '0000' if false.
                  Word comparisons can be for equal, signed greater than, or unsigned greater than.
                                                                                           Rss
                                                                                           Rtt
                                              cmp                               cmp
                                                         1    1   1    1    0 0  0  0    Pd
                                                         7                          0
                   Syntax                                Behavior
                   Pd=vcmpw.eq(Rss,#s8)                   Pd[3:0] = (Rss.w[0]==#s);
                                                          Pd[7:4] = (Rss.w[1]==#s);
                   Pd=vcmpw.eq(Rss,Rtt)                   Pd[3:0] = (Rss.w[0]==Rtt.w[0]);
                                                          Pd[7:4] = (Rss.w[1]==Rtt.w[1]);
                   Pd=vcmpw.gt(Rss,#s8)                   Pd[3:0] = (Rss.w[0]>#s);
                                                          Pd[7:4] = (Rss.w[1]>#s);
                   Pd=vcmpw.gt(Rss,Rtt)                   Pd[3:0] = (Rss.w[0]>Rtt.w[0]);
                                                          Pd[7:4] = (Rss.w[1]>Rtt.w[1]);
                   Pd=vcmpw.gtu(Rss,#u7)                  Pd[3:0] = (Rss.uw[0]>#u.uw[0]);
                                                          Pd[7:4] = (Rss.uw[1]>#u.uw[0]);
                   Pd=vcmpw.gtu(Rss,Rtt)                  Pd[3:0] = (Rss.uw[0]>Rtt.uw[0]);
                                                          Pd[7:4] = (Rss.uw[1]>Rtt.uw[1]);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Pd=vcmpw.eq(Rss,#s8)                  Byte Q6_p_vcmpw_eq_PI(Word64 Rss, Word32 Is8)
                   Pd=vcmpw.eq(Rss,Rtt)                  Byte Q6_p_vcmpw_eq_PP(Word64 Rss, Word64 Rtt)
                   Pd=vcmpw.gt(Rss,#s8)                  Byte Q6_p_vcmpw_gt_PI(Word64 Rss, Word32 Is8)
                   Pd=vcmpw.gt(Rss,Rtt)                  Byte Q6_p_vcmpw_gt_PP(Word64 Rss, Word64 Rtt)
                   Pd=vcmpw.gtu(Rss,#u7)                 Byte Q6_p_vcmpw_gtu_PI(Word64 Rss, Word32 Iu7)
                   Pd=vcmpw.gtu(Rss,Rtt)                 Byte Q6_p_vcmpw_gtu_PP(Word64 Rss, Word64 Rtt)
80-N2040-45 Rev. B                                                                                         635
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5  4 3 2 1   0
   ICLASS     RegType                  s5        Parse          t5       MinOp           d2
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 0  t   t  t t t 0   0  0  - - - d   d Pd=vcmpw.eq(Rss,Rtt)
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 0  t   t  t t t 0   0  1  - - - d   d Pd=vcmpw.gt(Rss,Rtt)
 1  1  0  1 0  0   1  0 0   -  -  s  s  s  s  s  P   P 0  t   t  t t t 0   1  0  - - - d   d Pd=vcmpw.gtu(Rss,Rtt)
   ICLASS     RegType                  s5        Parse                                   d2
 1  1  0  1 1  1   0  0 0  0  0   s  s  s  s  s  P   P -  i   i  i i i i    i  i 1 0 - d   d Pd=vcmpw.eq(Rss,#s8)
 1  1  0  1 1  1   0  0 0  0  1   s  s  s  s  s  P   P -  i   i  i i i i    i  i 1 0 - d   d Pd=vcmpw.gt(Rss,#s8)
 1  1  0  1 1  1   0  0 0  1  0   s  s  s  s  s  P   P - 0    i  i i i i    i  i 1 0 - d   d Pd=vcmpw.gtu(Rss,#u7)
                  Field name        Description
                  RegType           Register Type
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                 636
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
          Viterbi pack even and odd predicate bits
                   Pack the even and odd bits of two predicate registers into a single destination register. A
                   variant of this instruction is the R3:2 |= vitpack(P1,P0). This places the packed predicate
                   bits into the lower 8 bits of the register pair that is preshifted by 8 bits.
                   This instruction is useful in Viterbi decoding. Repeated use of the push version enables a
                   history to store for traceback purposes.
                                                               7                            0
                                                                                                 Ps
                                                                                                 Pt
                                        0                                                         Rd
                      31                                   8 7                              0
                   Syntax                                     Behavior
                    Rd=vitpack(Ps,Pt)                         PREDUSE_TIMING;
                                                              Rd = (Ps&0x55) | (Pt&0xAA);
                   Class: XTYPE (slots 2,3)
                   Intrinsics
                    Rd=vitpack(Ps,Pt)                         Word32 Q6_R_vitpack_pp(Byte Ps, Byte Pt)
                   Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9       8 7 6 5 4 3  2  1  0
   ICLASS      RegType   MajOp                s2   Parse               t2              d5
 1  0  0  0  1  0   0  1  - 0  0   -  -  -  s    s P   P -  -   - -  t    t - - - d d  d  d  d Rd=vitpack(Ps,Pt)
                   Field name        Description
                   ICLASS            Instruction Class
                   Parse             Packet/Loop parse bits
                   d5                Field to encode register d
                   s2                Field to encode register s
                   t2                Field to encode register t
                   MajOp             Major Opcode
                   RegType           Register Type
80-N2040-45 Rev. B                                                                                                  637
Hexagon V67 Programmer’s Reference Manual                                                                   Instruction Set
          Vector mux
                  Perform an element-wise byte selection between two vectors.
                  For each of the low 8 bits of predicate register Pu, if the bit is set, the corresponding byte
                  in Rdd is set to the corresponding byte from Rss. Otherwise, set the byte in Rdd to the byte
                  from Rtt.
                                                                                                       Rss
                                                                                                       Rtt
                         mux       mux       mux       mux       mux       mux       mux      mux
                     P[7]      P[6]      P[5]      P[4]      P[3]      P[2]      P[1]     P[0]
                                                                                                      Rdd
                   Syntax                                       Behavior
                   Rdd=vmux(Pu,Rss,Rtt)                         PREDUSE_TIMING;
                                                                for (i = 0; i < 8; i++) {
                                                                     Rdd.b[i]=(Pu.i?(Rss.b[i]):(Rtt.b[i]));
                                                                }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vmux(Pu,Rss,Rtt)                         Word64 Q6_P_vmux_pPP(Byte Pu, Word64 Rss, Word64
                                                                Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9         8 7   6   5 4  3   2 1 0
   ICLASS     RegType                     s5        Parse           t5             u2         d5
 1  1  0  1 0  0   0   1  -  -   -  s  s   s  s  s  P   P  -  t   t  t  t   t  -  u   u d  d   d d d Rdd=vmux(Pu,Rss,Rtt)
                  Field name          Description
                  RegType             Register Type
                  MinOp               Minor Opcode
                  ICLASS              Instruction Class
                  Parse               Packet/Loop parse bits
                  d5                  Field to encode register d
                  s5                  Field to encode register s
                  t5                  Field to encode register t
                  u2                  Field to encode register u
80-N2040-45 Rev. B                                                                                                        638
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
   11.10.8        XTYPE/SHIFT
                  The XTYPE/SHIFT instruction subclass includes instructions which perform shifts.
          Mask generate from immediate
                  Generate a mask from two immediate values.
                   Syntax                                   Behavior
                   Rd=mask(#u5,#U5)                         Rd = ((1<<#u)-1) << #U;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=mask(#u5,#U5)                         Word32 Q6_R_mask_II(Word32 Iu5, Word32 IU5)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7    6  5  4 3 2  1 0
   ICLASS     RegType   MajOp                    Parse                    MinOp       d5
 1  0  0  0 1  1   0  1 0   I  I  -  -  -   -  - P   P 1  i   i i  i i  I    I  I d d d  d d Rd=mask(#u5,#U5)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              639
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
        Shift by immediate
                  Shift the source register value right or left based on the type of instruction. In these
                  instructions, the shift amount is contained in an unsigned immediate (5 bits for 32-bit
                  shifts, 6 bits for 64-bit shifts) and the shift instruction gives the shift direction.
                  Arithmetic right shifts place the sign bit of the source value in the vacated positions, while
                  logical right shifts place zeros in the vacated positions. Left shifts always zero-fill the
                  vacated bits.
                                    ASR                                              LSR
                                               Lost        Rs                                    Lost       Rs
                      Sign-ext                             Rd            Zero-fill                          Rd
                                    ASL
                         Lost                             Rs
                                              Zero-fill  Rd
                   Syntax                                  Behavior
                   Rd=asl(Rs,#u5)                          Rd = Rs << #u;
                   Rd=asr(Rs,#u5)                          Rd = Rs >> #u;
                   Rd=lsr(Rs,#u5)                          Rd = Rs >>> #u;
                   Rd=rol(Rs,#u5)                          Rd = Rs <<R #u;
                   Rdd=asl(Rss,#u6)                        Rdd = Rss << #u;
                   Rdd=asr(Rss,#u6)                        Rdd = Rss >> #u;
                   Rdd=lsr(Rss,#u6)                        Rdd = Rss >>> #u;
                   Rdd=rol(Rss,#u6)                        Rdd = Rss <<R #u;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=asl(Rs,#u5)                          Word32 Q6_R_asl_RI(Word32 Rs, Word32 Iu5)
                   Rd=asr(Rs,#u5)                          Word32 Q6_R_asr_RI(Word32 Rs, Word32 Iu5)
                   Rd=lsr(Rs,#u5)                          Word32 Q6_R_lsr_RI(Word32 Rs, Word32 Iu5)
80-N2040-45 Rev. B                                                                                                 640
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                   Rd=rol(Rs,#u5)                           Word32 Q6_R_rol_RI(Word32 Rs, Word32 Iu5)
                   Rdd=asl(Rss,#u6)                         Word64 Q6_P_asl_PI(Word64 Rss, Word32 Iu6)
                   Rdd=asr(Rss,#u6)                         Word64 Q6_P_asr_PI(Word64 Rss, Word32 Iu6)
                   Rdd=lsr(Rss,#u6)                         Word64 Q6_P_lsr_PI(Word64 Rss, Word32 Iu6)
                   Rdd=rol(Rss,#u6)                         Word64 Q6_P_rol_PI(Word64 Rss, Word32 Iu6)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0 0  0  0   s  s  s  s  s  P   P i  i   i i  i i 0   0  0 d d d  d d Rdd=asr(Rss,#u6)
 1  0  0  0 0  0   0  0 0  0  0   s  s  s  s  s  P   P i  i   i i  i i 0   0  1 d d d  d d Rdd=lsr(Rss,#u6)
 1  0  0  0 0  0   0  0 0  0  0   s  s  s  s  s  P   P i  i   i i  i i 0   1  0 d d d  d d Rdd=asl(Rss,#u6)
 1  0  0  0 0  0   0  0 0  0  0   s  s  s  s  s  P   P i  i   i i  i i 0   1  1 d d d  d d Rdd=rol(Rss,#u6)
 1  0  0  0 1  1   0  0 0  0  0   s  s  s  s  s  P   P 0  i   i i  i i 0   0  0 d d d  d d Rd=asr(Rs,#u5)
 1  0  0  0 1  1   0  0 0  0  0   s  s  s  s  s  P   P 0  i   i i  i i 0   0  1 d d d  d d Rd=lsr(Rs,#u5)
 1  0  0  0 1  1   0  0 0  0  0   s  s  s  s  s  P   P 0  i   i i  i i 0   1  0 d d d  d d Rd=asl(Rs,#u5)
 1  0  0  0 1  1   0  0 0  0  0   s  s  s  s  s  P   P 0  i   i i  i i 0   1  1 d d d  d d Rd=rol(Rs,#u5)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              641
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
        Shift by immediate and accumulate
                  Shift the source register value right or left based on the type of instruction. In these
                  instructions, the shift amount is contained in an unsigned immediate (5 bits for 32-bit
                  shifts, 6 bits for 64-bit shifts) and the shift instruction gives the shift direction.
                  Arithmetic right shifts place the sign bit of the source value in the vacated positions, while
                  logical right shifts place zeros in the vacated positions. Left shifts always zero-fill the
                  vacated bits.
                  After shifting, add or subtract the shifted value from the destination register or register
                  pair.
             Rss                            # / Rt                          Rs                            # / Rt
      64-bit Shift Value                Shift Amt                    32-bit Shift Value               Shift Amt
                     64-bit Shift                                                  32-bit Shift
                   64-bit Add/Sub                                                32-bit Add/Sub
                            64 bit result           Rxx                                   32 bit result            Rx
                   Syntax                                 Behavior
                   Rx=add(#u8,asl(Rx,#U5))                 Rx=apply_extension(#u)+(Rx<<#U);
                   Rx=add(#u8,lsr(Rx,#U5))                 Rx=apply_extension(#u)+(((unsigned int)Rx)>>#U);
                   Rx=sub(#u8,asl(Rx,#U5))                 Rx=apply_extension(#u)-(Rx<<#U);
                   Rx=sub(#u8,lsr(Rx,#U5))                 Rx=apply_extension(#u)-(((unsigned int)Rx)>>#U);
                   Rx[+-]=asl(Rs,#u5)                      Rx = Rx [+-] Rs << #u;
                   Rx[+-]=asr(Rs,#u5)                      Rx = Rx [+-] Rs >> #u;
                   Rx[+-]=lsr(Rs,#u5)                      Rx = Rx [+-] Rs >>> #u;
                   Rx[+-]=rol(Rs,#u5)                      Rx = Rx [+-] Rs <<R #u;
                   Rxx[+-]=asl(Rss,#u6)                    Rxx = Rxx [+-] Rss << #u;
                   Rxx[+-]=asr(Rss,#u6)                    Rxx = Rxx [+-] Rss >> #u;
                   Rxx[+-]=lsr(Rss,#u6)                    Rxx = Rxx [+-] Rss >>> #u;
                   Rxx[+-]=rol(Rss,#u6)                    Rxx = Rxx [+-] Rss <<R #u;
80-N2040-45 Rev. B                                                                                                  642
Hexagon V67 Programmer’s Reference Manual                                       Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx+=asl(Rs,#u5)         Word32 Q6_R_aslacc_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx+=asr(Rs,#u5)         Word32 Q6_R_asracc_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx+=lsr(Rs,#u5)         Word32 Q6_R_lsracc_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx+=rol(Rs,#u5)         Word32 Q6_R_rolacc_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx-=asl(Rs,#u5)         Word32 Q6_R_aslnac_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx-=asr(Rs,#u5)         Word32 Q6_R_asrnac_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx-=lsr(Rs,#u5)         Word32 Q6_R_lsrnac_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx-=rol(Rs,#u5)         Word32 Q6_R_rolnac_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx=add(#u8,asl(Rx,#U5)) Word32 Q6_R_add_asl_IRI(Word32 Iu8, Word32 Rx,
                                           Word32 IU5)
                   Rx=add(#u8,lsr(Rx,#U5)) Word32 Q6_R_add_lsr_IRI(Word32 Iu8, Word32 Rx,
                                           Word32 IU5)
                   Rx=sub(#u8,asl(Rx,#U5)) Word32 Q6_R_sub_asl_IRI(Word32 Iu8, Word32 Rx,
                                           Word32 IU5)
                   Rx=sub(#u8,lsr(Rx,#U5)) Word32 Q6_R_sub_lsr_IRI(Word32 Iu8, Word32 Rx,
                                           Word32 IU5)
                   Rxx+=asl(Rss,#u6)       Word64 Q6_P_aslacc_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
                   Rxx+=asr(Rss,#u6)       Word64 Q6_P_asracc_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
                   Rxx+=lsr(Rss,#u6)       Word64 Q6_P_lsracc_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
                   Rxx+=rol(Rss,#u6)       Word64 Q6_P_rolacc_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
                   Rxx-=asl(Rss,#u6)       Word64 Q6_P_aslnac_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
                   Rxx-=asr(Rss,#u6)       Word64 Q6_P_asrnac_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
                   Rxx-=lsr(Rss,#u6)       Word64 Q6_P_lsrnac_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
                   Rxx-=rol(Rss,#u6)       Word64 Q6_P_rolnac_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
80-N2040-45 Rev. B                                                                          643
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7   6  5  4 3   2  1 0
   ICLASS     RegType   MajOp          s5        Parse                  MinOp        x5
 1  0  0  0 0  0   1  0 0  0   -  s  s  s  s  s  P   P i  i  i  i i i 0   0  0  x x   x  x x Rxx-=asr(Rss,#u6)
 1  0  0  0 0  0   1  0 0  0   -  s  s  s  s  s  P   P i  i  i  i i i 0   0  1  x x   x  x x Rxx-=lsr(Rss,#u6)
 1  0  0  0 0  0   1  0 0  0   -  s  s  s  s  s  P   P i  i  i  i i i 0   1  0  x x   x  x x Rxx-=asl(Rss,#u6)
 1  0  0  0 0  0   1  0 0  0   -  s  s  s  s  s  P   P i  i  i  i i i 0   1  1  x x   x  x x Rxx-=rol(Rss,#u6)
 1  0  0  0 0  0   1  0 0  0   -  s  s  s  s  s  P   P i  i  i  i i i 1   0  0  x x   x  x x Rxx+=asr(Rss,#u6)
 1  0  0  0 0  0   1  0 0  0   -  s  s  s  s  s  P   P i  i  i  i i i 1   0  1  x x   x  x x Rxx+=lsr(Rss,#u6)
 1  0  0  0 0  0   1  0 0  0   -  s  s  s  s  s  P   P i  i  i  i i i 1   1  0  x x   x  x x Rxx+=asl(Rss,#u6)
 1  0  0  0 0  0   1  0 0  0   -  s  s  s  s  s  P   P i  i  i  i i i 1   1  1  x x   x  x x Rxx+=rol(Rss,#u6)
 1  0  0  0 1  1   1  0 0  0   -  s  s  s  s  s  P   P 0  i  i  i i i 0   0  0  x x   x  x x Rx-=asr(Rs,#u5)
 1  0  0  0 1  1   1  0 0  0   -  s  s  s  s  s  P   P 0  i  i  i i i 0   0  1  x x   x  x x Rx-=lsr(Rs,#u5)
 1  0  0  0 1  1   1  0 0  0   -  s  s  s  s  s  P   P 0  i  i  i i i 0   1  0  x x   x  x x Rx-=asl(Rs,#u5)
 1  0  0  0 1  1   1  0 0  0   -  s  s  s  s  s  P   P 0  i  i  i i i 0   1  1  x x   x  x x Rx-=rol(Rs,#u5)
 1  0  0  0 1  1   1  0 0  0   -  s  s  s  s  s  P   P 0  i  i  i i i 1   0  0  x x   x  x x Rx+=asr(Rs,#u5)
 1  0  0  0 1  1   1  0 0  0   -  s  s  s  s  s  P   P 0  i  i  i i i 1   0  1  x x   x  x x Rx+=lsr(Rs,#u5)
 1  0  0  0 1  1   1  0 0  0   -  s  s  s  s  s  P   P 0  i  i  i i i 1   1  0  x x   x  x x Rx+=asl(Rs,#u5)
 1  0  0  0 1  1   1  0 0  0   -  s  s  s  s  s  P   P 0  i  i  i i i 1   1  1  x x   x  x x Rx+=rol(Rs,#u5)
   ICLASS     RegType                  x5        Parse                              MajOp
 1  1  0  1 1  1   1  0  i  i  i  x  x  x  x  x  P   P i  I  I  I I I i    i  i 0 i  1   0 - Rx=add(#u8,asl(Rx,#U5))
 1  1  0  1 1  1   1  0  i  i  i  x  x  x  x  x  P   P i  I  I  I I I i    i  i 0 i  1   1 - Rx=sub(#u8,asl(Rx,#U5))
 1  1  0  1 1  1   1  0  i  i  i  x  x  x  x  x  P   P i  I  I  I I I i    i  i 1 i  1   0 - Rx=add(#u8,lsr(Rx,#U5))
 1  1  0  1 1  1   1  0  i  i  i  x  x  x  x  x  P   P i  I  I  I I I i    i  i 1 i  1   1 - Rx=sub(#u8,lsr(Rx,#U5))
                  Field name        Description
                  RegType           Register Type
                  MajOp             Major Opcode
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  x5                Field to encode register x
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                                 644
Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
          Shift by immediate and add
                  Shift Rs left by 0-7 bits, add to Rt, and place the result in Rd.
                  This instruction is useful for calculating array pointers, where destruction of the base
                  pointer is undesirable.
                   Syntax                                   Behavior
                   Rd=addasl(Rt,Rs,#u3)                     Rd = Rt + Rs << #u;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=addasl(Rt,Rs,#u3)                     Word32 Q6_R_addasl_RRI(Word32 Rt, Word32 Rs,
                                                            Word32 Iu3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5 4 3 2  1 0
   ICLASS     RegType    Maj           s5        Parse          t5       Min        d5
 1  1  0  0 0  1   0  0 0  0  0   s  s  s  s  s  P   P 0  t   t  t t t  i   i i d d d  d d Rd=addasl(Rt,Rs,#u3)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              645
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
        Shift by immediate and logical
                  Shift the source register value right or left based on the type of instruction. In these
                  instructions, the shift amount is contained in an unsigned immediate (5 bits for 32-bit
                  shifts, 6 bits for 64-bit shifts) and the shift instruction gives the shift direction.
                  Arithmetic right shifts place the sign bit of the source value in the vacated positions, while
                  logical right shifts place zeros in the vacated positions. Left shifts always zero-fill the
                  vacated bits.
                  After shifting, take the logical AND, OR, or XOR of the shifted amount and the
                  destination register or register pair, and place the result back in the destination register or
                  register pair.
                  Saturation is not available for these instructions.
             Rss                            # / Rt                          Rs                            # / Rt
      64-bit Shift Value                Shift Amt                    32-bit Shift Value               Shift Amt
                     64-bit Shift                                                  32-bit Shift
                   64-bit AND/OR                                                 32-bit AND/OR
                            64 bit result           Rxx                                   32 bit result            Rx
                   Syntax                                 Behavior
                   Rx=and(#u8,asl(Rx,#U5))                 Rx=apply_extension(#u)&(Rx<<#U);
                   Rx=and(#u8,lsr(Rx,#U5))                 Rx=apply_extension(#u)&(((unsigned int)Rx)>>#U);
                   Rx=or(#u8,asl(Rx,#U5))                  Rx=apply_extension(#u)|(Rx<<#U);
                   Rx=or(#u8,lsr(Rx,#U5))                  Rx=apply_extension(#u)|(((unsigned int)Rx)>>#U);
                   Rx[&|]=asl(Rs,#u5)                      Rx = Rx [|&] Rs << #u;
                   Rx[&|]=asr(Rs,#u5)                      Rx = Rx [|&] Rs >> #u;
                   Rx[&|]=lsr(Rs,#u5)                      Rx = Rx [|&] Rs >>> #u;
                   Rx[&|]=rol(Rs,#u5)                      Rx = Rx [|&] Rs <<R #u;
                   Rx^=asl(Rs,#u5)                         Rx = Rx ^ Rs << #u;
                   Rx^=lsr(Rs,#u5)                         Rx = Rx ^ Rs >>> #u;
                   Rx^=rol(Rs,#u5)                         Rx = Rx ^ Rs <<R #u;
                   Rxx[&|]=asl(Rss,#u6)                    Rxx = Rxx [|&] Rss << #u;
                   Rxx[&|]=asr(Rss,#u6)                    Rxx = Rxx [|&] Rss >> #u;
80-N2040-45 Rev. B                                                                                                  646
Hexagon V67 Programmer’s Reference Manual                                       Instruction Set
                   Syntax                  Behavior
                   Rxx[&|]=lsr(Rss,#u6)    Rxx = Rxx [|&] Rss >>> #u;
                   Rxx[&|]=rol(Rss,#u6)    Rxx = Rxx [|&] Rss <<R #u;
                   Rxx^=asl(Rss,#u6)       Rxx = Rxx ^ Rss << #u;
                   Rxx^=lsr(Rss,#u6)       Rxx = Rxx ^ Rss >>> #u;
                   Rxx^=rol(Rss,#u6)       Rxx = Rxx ^ Rss <<R #u;
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx&=asl(Rs,#u5)         Word32 Q6_R_asland_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx&=asr(Rs,#u5)         Word32 Q6_R_asrand_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx&=lsr(Rs,#u5)         Word32 Q6_R_lsrand_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx&=rol(Rs,#u5)         Word32 Q6_R_roland_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx=and(#u8,asl(Rx,#U5)) Word32 Q6_R_and_asl_IRI(Word32 Iu8, Word32 Rx,
                                           Word32 IU5)
                   Rx=and(#u8,lsr(Rx,#U5)) Word32 Q6_R_and_lsr_IRI(Word32 Iu8, Word32 Rx,
                                           Word32 IU5)
                   Rx=or(#u8,asl(Rx,#U5))  Word32 Q6_R_or_asl_IRI(Word32 Iu8, Word32 Rx,
                                           Word32 IU5)
                   Rx=or(#u8,lsr(Rx,#U5))  Word32 Q6_R_or_lsr_IRI(Word32 Iu8, Word32 Rx,
                                           Word32 IU5)
                   Rx^=asl(Rs,#u5)         Word32 Q6_R_aslxacc_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx^=lsr(Rs,#u5)         Word32 Q6_R_lsrxacc_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx^=rol(Rs,#u5)         Word32 Q6_R_rolxacc_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx|=asl(Rs,#u5)         Word32 Q6_R_aslor_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx|=asr(Rs,#u5)         Word32 Q6_R_asror_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx|=lsr(Rs,#u5)         Word32 Q6_R_lsror_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rx|=rol(Rs,#u5)         Word32 Q6_R_rolor_RI(Word32 Rx, Word32 Rs,
                                           Word32 Iu5)
                   Rxx&=asl(Rss,#u6)       Word64 Q6_P_asland_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
                   Rxx&=asr(Rss,#u6)       Word64 Q6_P_asrand_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
                   Rxx&=lsr(Rss,#u6)       Word64 Q6_P_lsrand_PI(Word64 Rxx, Word64 Rss,
                                           Word32 Iu6)
80-N2040-45 Rev. B                                                                          647
Hexagon V67 Programmer’s Reference Manual                                                                Instruction Set
                   Rxx&=rol(Rss,#u6)                        Word64 Q6_P_roland_PI(Word64 Rxx, Word64 Rss,
                                                            Word32 Iu6)
                   Rxx^=asl(Rss,#u6)                        Word64 Q6_P_aslxacc_PI(Word64 Rxx, Word64 Rss,
                                                            Word32 Iu6)
                   Rxx^=lsr(Rss,#u6)                        Word64 Q6_P_lsrxacc_PI(Word64 Rxx, Word64 Rss,
                                                            Word32 Iu6)
                   Rxx^=rol(Rss,#u6)                        Word64 Q6_P_rolxacc_PI(Word64 Rxx, Word64 Rss,
                                                            Word32 Iu6)
                   Rxx|=asl(Rss,#u6)                        Word64 Q6_P_aslor_PI(Word64 Rxx, Word64 Rss,
                                                            Word32 Iu6)
                   Rxx|=asr(Rss,#u6)                        Word64 Q6_P_asror_PI(Word64 Rxx, Word64 Rss,
                                                            Word32 Iu6)
                   Rxx|=lsr(Rss,#u6)                        Word64 Q6_P_lsror_PI(Word64 Rxx, Word64 Rss,
                                                            Word32 Iu6)
                   Rxx|=rol(Rss,#u6)                        Word64 Q6_P_rolor_PI(Word64 Rxx, Word64 Rss,
                                                            Word32 Iu6)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6  5  4 3   2  1 0
   ICLASS     RegType   MajOp          s5       Parse                     MinOp        x5
 1  0  0  0 0  0   1  0 0  1   -  s  s  s  s  s P   P  i  i   i i  i i  0   0  0  x x   x  x x Rxx&=asr(Rss,#u6)
 1  0  0  0 0  0   1  0 0  1   -  s  s  s  s  s P   P  i  i   i i  i i  0   0  1  x x   x  x x Rxx&=lsr(Rss,#u6)
 1  0  0  0 0  0   1  0 0  1   -  s  s  s  s  s P   P  i  i   i i  i i  0   1  0  x x   x  x x Rxx&=asl(Rss,#u6)
 1  0  0  0 0  0   1  0 0  1   -  s  s  s  s  s P   P  i  i   i i  i i  0   1  1  x x   x  x x Rxx&=rol(Rss,#u6)
 1  0  0  0 0  0   1  0 0  1   -  s  s  s  s  s P   P  i  i   i i  i i  1   0  0  x x   x  x x Rxx|=asr(Rss,#u6)
 1  0  0  0 0  0   1  0 0  1   -  s  s  s  s  s P   P  i  i   i i  i i  1   0  1  x x   x  x x Rxx|=lsr(Rss,#u6)
 1  0  0  0 0  0   1  0 0  1   -  s  s  s  s  s P   P  i  i   i i  i i  1   1  0  x x   x  x x Rxx|=asl(Rss,#u6)
 1  0  0  0 0  0   1  0 0  1   -  s  s  s  s  s P   P  i  i   i i  i i  1   1  1  x x   x  x x Rxx|=rol(Rss,#u6)
 1  0  0  0 0  0   1  0 1  0   -  s  s  s  s  s P   P  i  i   i i  i i  0   0  1  x x   x  x x Rxx^=lsr(Rss,#u6)
 1  0  0  0 0  0   1  0 1  0   -  s  s  s  s  s P   P  i  i   i i  i i  0   1  0  x x   x  x x Rxx^=asl(Rss,#u6)
 1  0  0  0 0  0   1  0 1  0   -  s  s  s  s  s P   P  i  i   i i  i i  0   1  1  x x   x  x x Rxx^=rol(Rss,#u6)
 1  0  0  0 1  1   1  0 0  1   -  s  s  s  s  s P   P 0   i   i i  i i  0   0  0  x x   x  x x Rx&=asr(Rs,#u5)
 1  0  0  0 1  1   1  0 0  1   -  s  s  s  s  s P   P 0   i   i i  i i  0   0  1  x x   x  x x Rx&=lsr(Rs,#u5)
 1  0  0  0 1  1   1  0 0  1   -  s  s  s  s  s P   P 0   i   i i  i i  0   1  0  x x   x  x x Rx&=asl(Rs,#u5)
 1  0  0  0 1  1   1  0 0  1   -  s  s  s  s  s P   P 0   i   i i  i i  0   1  1  x x   x  x x Rx&=rol(Rs,#u5)
 1  0  0  0 1  1   1  0 0  1   -  s  s  s  s  s P   P 0   i   i i  i i  1   0  0  x x   x  x x Rx|=asr(Rs,#u5)
 1  0  0  0 1  1   1  0 0  1   -  s  s  s  s  s P   P 0   i   i i  i i  1   0  1  x x   x  x x Rx|=lsr(Rs,#u5)
 1  0  0  0 1  1   1  0 0  1   -  s  s  s  s  s P   P 0   i   i i  i i  1   1  0  x x   x  x x Rx|=asl(Rs,#u5)
 1  0  0  0 1  1   1  0 0  1   -  s  s  s  s  s P   P 0   i   i i  i i  1   1  1  x x   x  x x Rx|=rol(Rs,#u5)
 1  0  0  0 1  1   1  0 1  0   -  s  s  s  s  s P   P 0   i   i i  i i  0   0  1  x x   x  x x Rx^=lsr(Rs,#u5)
 1  0  0  0 1  1   1  0 1  0   -  s  s  s  s  s P   P 0   i   i i  i i  0   1  0  x x   x  x x Rx^=asl(Rs,#u5)
 1  0  0  0 1  1   1  0 1  0   -  s  s  s  s  s P   P 0   i   i i  i i  0   1  1  x x   x  x x Rx^=rol(Rs,#u5)
   ICLASS     RegType                  x5       Parse                                 MajOp
 1  1  0  1 1  1   1  0  i  i  i  x  x  x  x  x P   P  i  I   I I  I I  i    i  i 0 i  0   0 - Rx=and(#u8,asl(Rx,#U5))
 1  1  0  1 1  1   1  0  i  i  i  x  x  x  x  x P   P  i  I   I I  I I  i    i  i 0 i  0   1 - Rx=or(#u8,asl(Rx,#U5))
 1  1  0  1 1  1   1  0  i  i  i  x  x  x  x  x P   P  i  I   I I  I I  i    i  i 1 i  0   0 - Rx=and(#u8,lsr(Rx,#U5))
 1  1  0  1 1  1   1  0  i  i  i  x  x  x  x  x P   P  i  I   I I  I I  i    i  i 1 i  0   1 - Rx=or(#u8,lsr(Rx,#U5))
80-N2040-45 Rev. B                                                                                                    648
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  RegType      Register Type
                  MajOp        Major Opcode
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  s5           Field to encode register s
                  x5           Field to encode register x
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    649
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Shift right by immediate with rounding
                  Perform an arithmetic right shift by an immediate amount, and then round the result. This
                  instruction works by first shifting right, then adding the value +1 to the result, and finally
                  shifting right again by one bit. The right shifts always inserts the sign-bit in the vacated
                  position.
                  When using asrrnd, the assembler adjusts the immediate appropriately.
                                             Lost       Rs
                      Sign-ext
                                +1
                                32-bit Add
                                                        Rd
                   Syntax                                Behavior
                   Rd=asr(Rs,#u5):rnd                    Rd = ((Rs >> #u)+1) >> 1;
                   Rd=asrrnd(Rs,#u5)                     if ("#u5==0") {
                                                              Assembler mapped to: "Rd=Rs";
                                                         } else {
                                                              Assembler mapped to: "Rd=asr(Rs,#u5-1):rnd";
                                                         }
                   Rdd=asr(Rss,#u6):rnd                  tmp = Rss >> #u;
                                                         rnd = tmp & 1;
                                                         Rdd = tmp >> 1 + rnd;
                   Rdd=asrrnd(Rss,#u6)                   if ("#u6==0") {
                                                              Assembler mapped to: "Rdd=Rss";
                                                         } else {
                                                              Assembler mapped to: "Rdd=asr(Rss,#u6-
                                                         1):rnd";
                                                         }
80-N2040-45 Rev. B                                                                                              650
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=asr(Rs,#u5):rnd                       Word32 Q6_R_asr_RI_rnd(Word32 Rs, Word32 Iu5)
                   Rd=asrrnd(Rs,#u5)                        Word32 Q6_R_asrrnd_RI(Word32 Rs, Word32 Iu5)
                   Rdd=asr(Rss,#u6):rnd                     Word64 Q6_P_asr_PI_rnd(Word64 Rss, Word32 Iu6)
                   Rdd=asrrnd(Rss,#u6)                      Word64 Q6_P_asrrnd_PI(Word64 Rss, Word32 Iu6)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 0  0   0  0 1  1  0   s  s  s  s  s  P   P i  i   i i  i i 1   1  1 d d d  d d Rdd=asr(Rss,#u6):rnd
 1  0  0  0 1  1   0  0 0  1  0   s  s  s  s  s  P   P 0  i   i i  i i 0   0  0 d d d  d d Rd=asr(Rs,#u5):rnd
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              651
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
          Shift left by immediate with saturation
                  Perform a left shift of the 32-bit source register value by an immediate amount and
                  saturate.
                  Saturation works by first sign-extending the 32-bit Rs register to 64 bits. It is then left
                  shifted by the immediate amount. If this 64-bit value cannot fit in a signed 32-bit number
                  (the upper word is not the sign-extension of bit 31), saturation is performed based on the
                  sign of the original value. Saturation clamps the 32-bit result to the range 0x8000_0000 to
                  0x7fff_ffff.
                   Syntax                                   Behavior
                   Rd=asl(Rs,#u5):sat                       Rd = sat_32(sxt32->64(Rs) << #u);
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=asl(Rs,#u5):sat                       Word32 Q6_R_asl_RI_sat(Word32 Rs, Word32 Iu5)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7   6  5 4 3  2 1  0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 1  1   0  0  0  1  0  s  s  s  s  s  P   P 0  i   i i  i i 0   1  0 d d  d d  d Rd=asl(Rs,#u5):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              652
Hexagon V67 Programmer’s Reference Manual                                                              Instruction Set
        Shift by register
                  The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                  If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicted in the
                  opcode is reversed (see Figure).
                  The source data to be shifted is always performed as a 64-bit shift. When the Rs source
                  register is a 32-bit register, this register is first sign or zero-extended to 64-bits. Arithmetic
                  shifts sign-extend the 32-bit source to 64-bits, while logical shifts zero extend.
                  The 64-bit source value is then right or left shifted based on the shift amount and the type
                  of instruction. Arithmetic right shifts place the sign bit of the source value in the vacated
                  positions. Logical right shifts place zeros in the vacated positions.
                          ASR w/ Positive Rt                                     LSR w/ Positive Rt
                          ASL w/ Negative Rt                                     LSL w/ Negative Rt
                                                Lost       Rs                                     Lost      Rs
                       Sign-ext                            Rd              Zero-fill                        Rd
                           ASL w/ Positive Rt
                           LSL w/ Positive Rt
                           ASR w/ Negative Rt
                           LSR w/ Negative Rt
                         Lost                             Rs
                                             Zero-fill    Rd
                   Syntax                                  Behavior
                   Rd=asl(Rs,Rt)                            shamt=sxt7->32(Rt);
                                                            Rd = (shamt>0)?(sxt32->64(Rs)<<shamt):(sxt32-
                                                            >64(Rs)>>shamt);
                   Rd=asr(Rs,Rt)                            shamt=sxt7->32(Rt);
                                                            Rd = (shamt>0)?(sxt32->64(Rs)>>shamt):(sxt32-
                                                            >64(Rs)<<shamt);
                   Rd=lsl(#s6,Rt)                           shamt = sxt7->32(Rt);
                                                            Rd = (shamt>0)?(zxt32->64(#s)<<shamt):(zxt32-
                                                            >64(#s)>>>shamt);
                   Rd=lsl(Rs,Rt)                            shamt=sxt7->32(Rt);
                                                            Rd = (shamt>0)?(zxt32->64(Rs)<<shamt):(zxt32-
                                                            >64(Rs)>>>shamt);
80-N2040-45 Rev. B                                                                                                 653
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                   Syntax                                   Behavior
                   Rd=lsr(Rs,Rt)                            shamt=sxt7->32(Rt);
                                                            Rd = (shamt>0)?(zxt32->64(Rs)>>>shamt):(zxt32-
                                                            >64(Rs)<<shamt);
                   Rdd=asl(Rss,Rt)                          shamt=sxt7->32(Rt);
                                                            Rdd = (shamt>0)?(Rss<<shamt):(Rss>>shamt);
                   Rdd=asr(Rss,Rt)                          shamt=sxt7->32(Rt);
                                                            Rdd = (shamt>0)?(Rss>>shamt):(Rss<<shamt);
                   Rdd=lsl(Rss,Rt)                          shamt=sxt7->32(Rt);
                                                            Rdd = (shamt>0)?(Rss<<shamt):(Rss>>>shamt);
                   Rdd=lsr(Rss,Rt)                          shamt=sxt7->32(Rt);
                                                            Rdd = (shamt>0)?(Rss>>>shamt):(Rss<<shamt);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=asl(Rs,Rt)                            Word32 Q6_R_asl_RR(Word32 Rs, Word32 Rt)
                   Rd=asr(Rs,Rt)                            Word32 Q6_R_asr_RR(Word32 Rs, Word32 Rt)
                   Rd=lsl(#s6,Rt)                           Word32 Q6_R_lsl_IR(Word32 Is6, Word32 Rt)
                   Rd=lsl(Rs,Rt)                            Word32 Q6_R_lsl_RR(Word32 Rs, Word32 Rt)
                   Rd=lsr(Rs,Rt)                            Word32 Q6_R_lsr_RR(Word32 Rs, Word32 Rt)
                   Rdd=asl(Rss,Rt)                          Word64 Q6_P_asl_PR(Word64 Rss, Word32 Rt)
                   Rdd=asr(Rss,Rt)                          Word64 Q6_P_asr_PR(Word64 Rss, Word32 Rt)
                   Rdd=lsl(Rss,Rt)                          Word64 Q6_P_lsl_PR(Word64 Rss, Word32 Rt)
                   Rdd=lsr(Rss,Rt)                          Word64 Q6_P_lsr_PR(Word64 Rss, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6 5  4 3  2 1  0
   ICLASS     RegType    Maj           s5       Parse           t5       Min        d5
 1  1  0  0 0  0   1  1 1  0   -  s  s  s  s  s P   P  -  t   t  t t t  0  0 -  d d  d d  d Rdd=asr(Rss,Rt)
 1  1  0  0 0  0   1  1 1  0   -  s  s  s  s  s P   P  -  t   t  t t t  0  1 -  d d  d d  d Rdd=lsr(Rss,Rt)
 1  1  0  0 0  0   1  1 1  0   -  s  s  s  s  s P   P  -  t   t  t t t  1  0 -  d d  d d  d Rdd=asl(Rss,Rt)
 1  1  0  0 0  0   1  1 1  0   -  s  s  s  s  s P   P  -  t   t  t t t  1  1 -  d d  d d  d Rdd=lsl(Rss,Rt)
 1  1  0  0 0  1   1  0 0  1   -  s  s  s  s  s P   P  -  t   t  t t t  0  0 -  d d  d d  d Rd=asr(Rs,Rt)
 1  1  0  0 0  1   1  0 0  1   -  s  s  s  s  s P   P  -  t   t  t t t  0  1 -  d d  d d  d Rd=lsr(Rs,Rt)
 1  1  0  0 0  1   1  0 0  1   -  s  s  s  s  s P   P  -  t   t  t t t  1  0 -  d d  d d  d Rd=asl(Rs,Rt)
 1  1  0  0 0  1   1  0 0  1   -  s  s  s  s  s P   P  -  t   t  t t t  1  1 -  d d  d d  d Rd=lsl(Rs,Rt)
   ICLASS     RegType    Maj                    Parse           t5       Min        d5
 1  1  0  0 0  1   1  0 1  0   -  i  i  i  i  i P   P  -  t   t  t t t  1  1 i  d d  d d  d Rd=lsl(#s6,Rt)
80-N2040-45 Rev. B                                                                                               654
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    655
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
        Shift by register and accumulate
                  The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                  If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicted in the
                  opcode is reversed.
                  Shift the source register value right or left based on the shift amount and the type of
                  instruction. Arithmetic right shifts place the sign bit of the source value in the vacated
                  positions. Logical right shifts place zeros in the vacated positions.
                  The shift operation is always performed as a 64-bit shift. When Rs is a 32-bit register, this
                  register is first sign- or zero-extended to 64-bits. Arithmetic shifts sign-extend the 32-bit
                  source to 64-bits, while logical shifts zero extend.
                  After shifting, add or subtract the 64-bit shifted amount from the destination register or
                  register pair.
             Rss                            # / Rt                         Rs                           # / Rt
      64-bit Shift Value                 Shift Amt                 32-bit Shift Value                Shift Amt
                     64-bit Shift                                                32-bit Shift
                   64-bit Add/Sub                                              32-bit Add/Sub
                            64 bit result          Rxx                                  32 bit result            Rx
                   Syntax                                Behavior
                   Rx[+-]=asl(Rs,Rt)                     shamt=sxt7->32(Rt);
                                                         Rx = Rx [+-] (shamt>0)?(sxt32-
                                                         >64(Rs)<<shamt):(sxt32->64(Rs)>>shamt);
                   Rx[+-]=asr(Rs,Rt)                     shamt=sxt7->32(Rt);
                                                         Rx = Rx [+-] (shamt>0)?(sxt32-
                                                         >64(Rs)>>shamt):(sxt32->64(Rs)<<shamt);
                   Rx[+-]=lsl(Rs,Rt)                     shamt=sxt7->32(Rt);
                                                         Rx = Rx [+-] (shamt>0)?(zxt32-
                                                         >64(Rs)<<shamt):(zxt32->64(Rs)>>>shamt);
80-N2040-45 Rev. B                                                                                                656
Hexagon V67 Programmer’s Reference Manual                                         Instruction Set
                   Syntax                  Behavior
                   Rx[+-]=lsr(Rs,Rt)       shamt=sxt7->32(Rt);
                                           Rx = Rx [+-] (shamt>0)?(zxt32-
                                           >64(Rs)>>>shamt):(zxt32->64(Rs)<<shamt);
                   Rxx[+-]=asl(Rss,Rt)     shamt=sxt7->32(Rt);
                                           Rxx = Rxx [+-]
                                           (shamt>0)?(Rss<<shamt):(Rss>>shamt);
                   Rxx[+-]=asr(Rss,Rt)     shamt=sxt7->32(Rt);
                                           Rxx = Rxx [+-]
                                           (shamt>0)?(Rss>>shamt):(Rss<<shamt);
                   Rxx[+-]=lsl(Rss,Rt)     shamt=sxt7->32(Rt);
                                           Rxx = Rxx [+-]
                                           (shamt>0)?(Rss<<shamt):(Rss>>>shamt);
                   Rxx[+-]=lsr(Rss,Rt)     shamt=sxt7->32(Rt);
                                           Rxx = Rxx [+-]
                                           (shamt>0)?(Rss>>>shamt):(Rss<<shamt);
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx+=asl(Rs,Rt)          Word32 Q6_R_aslacc_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx+=asr(Rs,Rt)          Word32 Q6_R_asracc_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx+=lsl(Rs,Rt)          Word32 Q6_R_lslacc_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx+=lsr(Rs,Rt)          Word32 Q6_R_lsracc_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx-=asl(Rs,Rt)          Word32 Q6_R_aslnac_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx-=asr(Rs,Rt)          Word32 Q6_R_asrnac_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx-=lsl(Rs,Rt)          Word32 Q6_R_lslnac_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx-=lsr(Rs,Rt)          Word32 Q6_R_lsrnac_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rxx+=asl(Rss,Rt)        Word64 Q6_P_aslacc_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx+=asr(Rss,Rt)        Word64 Q6_P_asracc_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx+=lsl(Rss,Rt)        Word64 Q6_P_lslacc_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
80-N2040-45 Rev. B                                                                            657
Hexagon V67 Programmer’s Reference Manual                                                            Instruction Set
                   Rxx+=lsr(Rss,Rt)                         Word64 Q6_P_lsracc_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Rt)
                   Rxx-=asl(Rss,Rt)                         Word64 Q6_P_aslnac_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Rt)
                   Rxx-=asr(Rss,Rt)                         Word64 Q6_P_asrnac_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Rt)
                   Rxx-=lsl(Rss,Rt)                         Word64 Q6_P_lslnac_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Rt)
                   Rxx-=lsr(Rss,Rt)                         Word64 Q6_P_lsrnac_PR(Word64 Rxx, Word64 Rss,
                                                            Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS     RegType    Maj           s5        Parse          t5      Min        x5
 1  1  0  0 1  0   1  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t 0  0  - x x  x x  x Rxx-=asr(Rss,Rt)
 1  1  0  0 1  0   1  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t 0  1  - x x  x x  x Rxx-=lsr(Rss,Rt)
 1  1  0  0 1  0   1  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t 1  0  - x x  x x  x Rxx-=asl(Rss,Rt)
 1  1  0  0 1  0   1  1 1  0  0   s  s  s  s  s  P   P -  t   t  t t t 1  1  - x x  x x  x Rxx-=lsl(Rss,Rt)
 1  1  0  0 1  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t t 0  0  - x x  x x  x Rxx+=asr(Rss,Rt)
 1  1  0  0 1  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t t 0  1  - x x  x x  x Rxx+=lsr(Rss,Rt)
 1  1  0  0 1  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t t 1  0  - x x  x x  x Rxx+=asl(Rss,Rt)
 1  1  0  0 1  0   1  1 1  1  0   s  s  s  s  s  P   P -  t   t  t t t 1  1  - x x  x x  x Rxx+=lsl(Rss,Rt)
 1  1  0  0 1  1   0  0 1  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  0  - x x  x x  x Rx-=asr(Rs,Rt)
 1  1  0  0 1  1   0  0 1  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  1  - x x  x x  x Rx-=lsr(Rs,Rt)
 1  1  0  0 1  1   0  0 1  0   -  s  s  s  s  s  P   P -  t   t  t t t 1  0  - x x  x x  x Rx-=asl(Rs,Rt)
 1  1  0  0 1  1   0  0 1  0   -  s  s  s  s  s  P   P -  t   t  t t t 1  1  - x x  x x  x Rx-=lsl(Rs,Rt)
 1  1  0  0 1  1   0  0 1  1   -  s  s  s  s  s  P   P -  t   t  t t t 0  0  - x x  x x  x Rx+=asr(Rs,Rt)
 1  1  0  0 1  1   0  0 1  1   -  s  s  s  s  s  P   P -  t   t  t t t 0  1  - x x  x x  x Rx+=lsr(Rs,Rt)
 1  1  0  0 1  1   0  0 1  1   -  s  s  s  s  s  P   P -  t   t  t t t 1  0  - x x  x x  x Rx+=asl(Rs,Rt)
 1  1  0  0 1  1   0  0 1  1   -  s  s  s  s  s  P   P -  t   t  t t t 1  1  - x x  x x  x Rx+=lsl(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                               658
Hexagon V67 Programmer’s Reference Manual                                                               Instruction Set
        Shift by register and logical
                  The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                  If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicted in the
                  opcode is reversed.
                  Shift the source register value right or left based on the shift amount and the type of
                  instruction. Arithmetic right shifts place the sign bit of the source value in the vacated
                  positions. Logical right shifts place zeros in the vacated positions.
                  The shift operation is always performed as a 64-bit shift. When the Rs source register is a
                  32-bit register, this register is first sign or zero-extended to 64-bits. Arithmetic shifts sign-
                  extend the 32-bit source to 64-bits, while logical shifts zero extend.
                  After shifting, take the logical AND or OR of the shifted amount and the destination
                  register or register pair, and place the result back in the destination register or register pair.
                  Saturation is not available for these instructions.
             Rss                           # / Rt                           Rs                            # / Rt
      64-bit Shift Value                Shift Amt                    32-bit Shift Value               Shift Amt
                     64-bit Shift                                                  32-bit Shift
                   64-bit AND/OR                                                 32-bit AND/OR
                            64 bit result           Rxx                                   32 bit result            Rx
80-N2040-45 Rev. B                                                                                                  659
Hexagon V67 Programmer’s Reference Manual                                        Instruction Set
                   Syntax                 Behavior
                   Rx[&|]=asl(Rs,Rt)      shamt=sxt7->32(Rt);
                                          Rx = Rx [|&] (shamt>0)?(sxt32-
                                          >64(Rs)<<shamt):(sxt32->64(Rs)>>shamt);
                   Rx[&|]=asr(Rs,Rt)      shamt=sxt7->32(Rt);
                                          Rx = Rx [|&] (shamt>0)?(sxt32-
                                          >64(Rs)>>shamt):(sxt32->64(Rs)<<shamt);
                   Rx[&|]=lsl(Rs,Rt)      shamt=sxt7->32(Rt);
                                          Rx = Rx [|&] (shamt>0)?(zxt32-
                                          >64(Rs)<<shamt):(zxt32->64(Rs)>>>shamt);
                   Rx[&|]=lsr(Rs,Rt)      shamt=sxt7->32(Rt);
                                          Rx = Rx [|&] (shamt>0)?(zxt32-
                                          >64(Rs)>>>shamt):(zxt32->64(Rs)<<shamt);
                   Rxx[&|]=asl(Rss,Rt)    shamt=sxt7->32(Rt);
                                          Rxx = Rxx [|&]
                                          (shamt>0)?(Rss<<shamt):(Rss>>shamt);
                   Rxx[&|]=asr(Rss,Rt)    shamt=sxt7->32(Rt);
                                          Rxx = Rxx [|&]
                                          (shamt>0)?(Rss>>shamt):(Rss<<shamt);
                   Rxx[&|]=lsl(Rss,Rt)    shamt=sxt7->32(Rt);
                                          Rxx = Rxx [|&]
                                          (shamt>0)?(Rss<<shamt):(Rss>>>shamt);
                   Rxx[&|]=lsr(Rss,Rt)    shamt=sxt7->32(Rt);
                                          Rxx = Rxx [|&]
                                          (shamt>0)?(Rss>>>shamt):(Rss<<shamt);
                   Rxx^=asl(Rss,Rt)       shamt=sxt7->32(Rt);
                                          Rxx = Rxx ^ (shamt>0)?(Rss<<shamt):(Rss>>shamt);
                   Rxx^=asr(Rss,Rt)       shamt=sxt7->32(Rt);
                                          Rxx = Rxx ^ (shamt>0)?(Rss>>shamt):(Rss<<shamt);
                   Rxx^=lsl(Rss,Rt)       shamt=sxt7->32(Rt);
                                          Rxx = Rxx ^
                                          (shamt>0)?(Rss<<shamt):(Rss>>>shamt);
                   Rxx^=lsr(Rss,Rt)       shamt=sxt7->32(Rt);
                                          Rxx = Rxx ^
                                          (shamt>0)?(Rss>>>shamt):(Rss<<shamt);
80-N2040-45 Rev. B                                                                           660
Hexagon V67 Programmer’s Reference Manual                                       Instruction Set
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rx&=asl(Rs,Rt)          Word32 Q6_R_asland_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx&=asr(Rs,Rt)          Word32 Q6_R_asrand_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx&=lsl(Rs,Rt)          Word32 Q6_R_lsland_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx&=lsr(Rs,Rt)          Word32 Q6_R_lsrand_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx|=asl(Rs,Rt)          Word32 Q6_R_aslor_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx|=asr(Rs,Rt)          Word32 Q6_R_asror_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx|=lsl(Rs,Rt)          Word32 Q6_R_lslor_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rx|=lsr(Rs,Rt)          Word32 Q6_R_lsror_RR(Word32 Rx, Word32 Rs,
                                           Word32 Rt)
                   Rxx&=asl(Rss,Rt)        Word64 Q6_P_asland_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx&=asr(Rss,Rt)        Word64 Q6_P_asrand_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx&=lsl(Rss,Rt)        Word64 Q6_P_lsland_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx&=lsr(Rss,Rt)        Word64 Q6_P_lsrand_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx^=asl(Rss,Rt)        Word64 Q6_P_aslxacc_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx^=asr(Rss,Rt)        Word64 Q6_P_asrxacc_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx^=lsl(Rss,Rt)        Word64 Q6_P_lslxacc_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx^=lsr(Rss,Rt)        Word64 Q6_P_lsrxacc_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx|=asl(Rss,Rt)        Word64 Q6_P_aslor_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx|=asr(Rss,Rt)        Word64 Q6_P_asror_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx|=lsl(Rss,Rt)        Word64 Q6_P_lslor_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
                   Rxx|=lsr(Rss,Rt)        Word64 Q6_P_lsror_PR(Word64 Rxx, Word64 Rss,
                                           Word32 Rt)
80-N2040-45 Rev. B                                                                          661
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5 4 3 2  1 0
   ICLASS     RegType    Maj           s5        Parse          t5      Min       x5
 1  1  0  0 1  0   1  1 0  0  0   s  s  s  s  s  P   P -  t   t  t t t 0  0 - x x x  x x Rxx|=asr(Rss,Rt)
 1  1  0  0 1  0   1  1 0  0  0   s  s  s  s  s  P   P -  t   t  t t t 0  1 - x x x  x x Rxx|=lsr(Rss,Rt)
 1  1  0  0 1  0   1  1 0  0  0   s  s  s  s  s  P   P -  t   t  t t t 1  0 - x x x  x x Rxx|=asl(Rss,Rt)
 1  1  0  0 1  0   1  1 0  0  0   s  s  s  s  s  P   P -  t   t  t t t 1  1 - x x x  x x Rxx|=lsl(Rss,Rt)
 1  1  0  0 1  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 0  0 - x x x  x x Rxx&=asr(Rss,Rt)
 1  1  0  0 1  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 0  1 - x x x  x x Rxx&=lsr(Rss,Rt)
 1  1  0  0 1  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 1  0 - x x x  x x Rxx&=asl(Rss,Rt)
 1  1  0  0 1  0   1  1 0  1  0   s  s  s  s  s  P   P -  t   t  t t t 1  1 - x x x  x x Rxx&=lsl(Rss,Rt)
 1  1  0  0 1  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 0  0 - x x x  x x Rxx^=asr(Rss,Rt)
 1  1  0  0 1  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 0  1 - x x x  x x Rxx^=lsr(Rss,Rt)
 1  1  0  0 1  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 1  0 - x x x  x x Rxx^=asl(Rss,Rt)
 1  1  0  0 1  0   1  1 0  1  1   s  s  s  s  s  P   P -  t   t  t t t 1  1 - x x x  x x Rxx^=lsl(Rss,Rt)
 1  1  0  0 1  1   0  0 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  0 - x x x  x x Rx|=asr(Rs,Rt)
 1  1  0  0 1  1   0  0 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  1 - x x x  x x Rx|=lsr(Rs,Rt)
 1  1  0  0 1  1   0  0 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 1  0 - x x x  x x Rx|=asl(Rs,Rt)
 1  1  0  0 1  1   0  0 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 1  1 - x x x  x x Rx|=lsl(Rs,Rt)
 1  1  0  0 1  1   0  0 0  1   -  s  s  s  s  s  P   P -  t   t  t t t 0  0 - x x x  x x Rx&=asr(Rs,Rt)
 1  1  0  0 1  1   0  0 0  1   -  s  s  s  s  s  P   P -  t   t  t t t 0  1 - x x x  x x Rx&=lsr(Rs,Rt)
 1  1  0  0 1  1   0  0 0  1   -  s  s  s  s  s  P   P -  t   t  t t t 1  0 - x x x  x x Rx&=asl(Rs,Rt)
 1  1  0  0 1  1   0  0 0  1   -  s  s  s  s  s  P   P -  t   t  t t t 1  1 - x x x  x x Rx&=lsl(Rs,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  x5                Field to encode register x
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                             662
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
          Shift by register with saturation
                  The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                  If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicted in the
                  opcode is reversed.
                  Saturation is available for 32-bit arithmetic left shifts. This can be either an ASL
                  instruction with positive Rt, or an ASR instruction with negative Rt. Saturation works by
                  first sign-extending the 32-bit Rs register to 64 bits. It is then shifted by the shift amount.
                  If this 64-bit value cannot fit in a signed 32-bit number (the upper word is not the sign-
                  extension of bit 31), saturation is performed based on the sign of the original value.
                  Saturation clamps the 32-bit result to the range 0x80000000 to 0x7fffffff.
                   Syntax                                   Behavior
                   Rd=asl(Rs,Rt):sat                        shamt=sxt7->32(Rt);
                                                            Rd = bidir_shiftl(Rs,shamt);
                   Rd=asr(Rs,Rt):sat                        shamt=sxt7->32(Rt);
                                                            Rd = bidir_shiftr(Rs,shamt);
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■  If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=asl(Rs,Rt):sat                        Word32 Q6_R_asl_RR_sat(Word32 Rs, Word32 Rt)
                   Rd=asr(Rs,Rt):sat                        Word32 Q6_R_asr_RR_sat(Word32 Rs, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6 5  4  3  2 1  0
   ICLASS     RegType     Maj          s5        Parse          t5       Min         d5
 1  1  0  0 0  1   1  0  0  0  -  s  s  s  s  s  P   P -  t   t  t t t 0   0 -  d  d  d  d d Rd=asr(Rs,Rt):sat
 1  1  0  0 0  1   1  0  0  0  -  s  s  s  s  s  P   P -  t   t  t t t 1   0 -  d  d  d  d d Rd=asl(Rs,Rt):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
80-N2040-45 Rev. B                                                                                                663
Hexagon V67 Programmer’s Reference Manual    Instruction Set
                  Field name   Description
                  Maj          Major Opcode
                  Min          Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                       664
Hexagon V67 Programmer’s Reference Manual                                                                      Instruction Set
          Vector shift halfwords by immediate
                  Shift individual halfwords of the source vector. Arithmetic right shifts place the sign bit of
                  the source values in the vacated positions. Logical right shifts place zeros in the vacated
                  positions.
                                         Rdd = vaslh(Rss,#)                            Shift Amount    Rt/#u4
                       lost                 lost                lost                 lost              Rss
                                    0                     0                    0                    0
                                                                                                          Rdd
                   Syntax                                     Behavior
                   Rdd=vaslh(Rss,#u4)                         for (i=0;i<4;i++) {
                                                                     Rdd.h[i]=(Rss.h[i]<<#u);
                                                              }
                   Rdd=vasrh(Rss,#u4)                         for (i=0;i<4;i++) {
                                                                     Rdd.h[i]=(Rss.h[i]>>#u);
                                                              }
                   Rdd=vlsrh(Rss,#u4)                         for (i=0;i<4;i++) {
                                                                     Rdd.h[i]=(Rss.uh[i]>>#u);
                                                              }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vaslh(Rss,#u4)                         Word64 Q6_P_vaslh_PI(Word64 Rss, Word32 Iu4)
                   Rdd=vasrh(Rss,#u4)                         Word64 Q6_P_vasrh_PI(Word64 Rss, Word32 Iu4)
                   Rdd=vlsrh(Rss,#u4)                         Word64 Q6_P_vlsrh_PI(Word64 Rss, Word32 Iu4)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9       8 7    6 5   4   3  2  1  0
   ICLASS     RegType     MajOp          s5        Parse                      MinOp           d5
 1  0  0  0 0  0   0  0    1 0  0 s    s  s   s  s P   P 0  0   i    i i  i 0    0 0   d   d  d  d  d Rdd=vasrh(Rss,#u4)
 1  0  0  0 0  0   0  0    1 0  0 s    s  s   s  s P   P 0  0   i    i i  i 0    0 1   d   d  d  d  d Rdd=vlsrh(Rss,#u4)
 1  0  0  0 0  0   0  0    1 0  0 s    s  s   s  s P   P 0  0   i    i i  i 0    1 0   d   d  d  d  d Rdd=vaslh(Rss,#u4)
                  Field name          Description
                  ICLASS              Instruction Class
                  Parse               Packet/Loop parse bits
                  d5                  Field to encode register d
80-N2040-45 Rev. B                                                                                                         665
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  s5           Field to encode register s
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    666
Hexagon V67 Programmer’s Reference Manual                                                                   Instruction Set
          Vector arithmetic shift halfwords with round
                  For each halfword in the vector, round then arithmetic shift right by an immediate amount.
                  The results are stored in the destination register.
                                          Rdd = vasrh(Rss,#u):rnd
                            1<<(#u-1)           1<<(#u-1)          1<<(#u-1)         1<<(#u-1)
                            +                   +                  +                +
                                 lost                lost               lost             lost
                     Sign-              Sign-             Sign-              Sign-
                       ext               ext               ext                ext
                   Syntax                                      Behavior
                   Rdd=vasrh(Rss,#u4):raw                      for (i=0;i<4;i++) {
                                                                     Rdd.h[i]=( ((Rss.h[i] >> #u)+1)>>1 );
                                                               }
                   Rdd=vasrh(Rss,#u4):rnd                      if ("#u4==0") {
                                                                     Assembler mapped to: "Rdd=Rss";
                                                               } else {
                                                                     Assembler mapped to: "Rdd=vasrh(Rss,#u4-
                                                               1):raw";
                                                               }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vasrh(Rss,#u4):rnd                      Word64 Q6_P_vasrh_PI_rnd(Word64 Rss, Word32 Iu4)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9        8 7    6 5  4  3   2 1 0
   ICLASS     RegType    MajOp           s5        Parse                       MinOp        d5
 1  0  0  0 0  0   0  0   0 0  1  s   s   s   s  s P   P 0   0   i   i i   i 0   0  0  d  d   d d d Rdd=vasrh(Rss,#u4):raw
                  Field name         Description
                  ICLASS             Instruction Class
                  Parse              Packet/Loop parse bits
                  d5                 Field to encode register d
80-N2040-45 Rev. B                                                                                                       667
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  s5           Field to encode register s
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    668
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
        Vector arithmetic shift halfwords with saturate and pack
                  For each halfword in the vector, optionally round, then arithmetic shift right by an
                  immediate amount. The results are saturated to unsigned [0-255] and then packed in the
                  destination register.
                                         Rd = vasrhub(Rss,#u):rnd:sat
                           1<<(#u-1)       1<<(#u-1)       1<<(#u-1)       1<<(#u-1)
                           +               +               +               +
                                 lost           lost            lost            lost
                         Sat_u8          Sat_u8         Sat_u8          Sat_u8
                   Syntax                               Behavior
                   Rd=vasrhub(Rss,#u4):raw              for (i=0;i<4;i++) {
                                                             Rd.b[i]=usat_8(((Rss.h[i] >> #u )+1)>>1);
                                                        }
                   Rd=vasrhub(Rss,#u4):rnd:sat          if ("#u4==0") {
                                                             Assembler mapped to: "Rd=vsathub(Rss)";
                                                        } else {
                                                             Assembler mapped to: "Rd=vasrhub(Rss,#u4-
                                                        1):raw";
                                                        }
                   Rd=vasrhub(Rss,#u4):sat              for (i=0;i<4;i++) {
                                                             Rd.b[i]=usat_8(Rss.h[i] >> #u);
                                                        }
                  Class: XTYPE (slots 2,3)
                  Notes
                       ■   If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
80-N2040-45 Rev. B                                                                                              669
Hexagon V67 Programmer’s Reference Manual                                                          Instruction Set
                  Intrinsics
                   Rd=vasrhub(Rss,#u4):rnd:sat             Word32 Q6_R_vasrhub_PI_rnd_sat(Word64 Rss,
                                                           Word32 Iu4)
                   Rd=vasrhub(Rss,#u4):sat                 Word32 Q6_R_vasrhub_PI_sat(Word64 Rss, Word32
                                                           Iu4)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8  7   6  5 4 3 2  1 0
   ICLASS     RegType   MajOp          s5        Parse                   MinOp      d5
 1  0  0  0 1  0   0  0 0  1  1   s  s  s  s  s  P   P 0 0   i  i i i  1   0  0 d d d  d d Rd=vasrhub(Rss,#u4):raw
 1  0  0  0 1  0   0  0 0  1  1   s  s  s  s  s  P   P 0 0   i  i i i  1   0  1 d d d  d d Rd=vasrhub(Rss,#u4):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  MajOp             Major Opcode
                  MinOp             Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                               670
Hexagon V67 Programmer’s Reference Manual                                                                Instruction Set
        Vector shift halfwords by register
                  The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                  If the shift amount is negative, the direction of the shift is reversed. Shift the source values
                  right or left based on the shift amount and the type of instruction. Arithmetic right shifts
                  place the sign bit of the source value in the vacated positions. Logical right shifts place
                  zeros in the vacated positions.
                                        Rdd = vaslh(Rss,#)                         Shift Amount    Rt/#u4
                       lost                lost               lost               lost               Rss
                                    0                   0                   0                   0
                                                                                                      Rdd
                   Syntax                                  Behavior
                   Rdd=vaslh(Rss,Rt)                        for (i=0;i<4;i++) {
                                                                   Rdd.h[i]=(sxt7->32(Rt)>0)?(sxt16-
                                                            >64(Rss.h[i])<<sxt7->32(Rt)):(sxt16-
                                                            >64(Rss.h[i])>>sxt7->32(Rt));
                                                            }
                   Rdd=vasrh(Rss,Rt)                        for (i=0;i<4;i++) {
                                                                   Rdd.h[i]=(sxt7->32(Rt)>0)?(sxt16-
                                                            >64 (Rss.h[i])>>sxt  7->32(Rt)):(sxt16-
                                                            >64(Rss.h[i])<<sxt7->32(Rt));
                                                            }
                   Rdd=vlslh(Rss,Rt)                        for (i=0;i<4;i++) {
                                                                   Rdd.h[i]=(sxt7->32(Rt)>0)?(zxt16-
                                                            >64 (Rss.uh[i])<<sxt   7->32(Rt)):(zxt16-
                                                            >64 (Rss.uh[i])>>>sxt     7->32(Rt));
                                                            }
                   Rdd=vlsrh(Rss,Rt)                        for (i=0;i<4;i++) {
                                                                   Rdd.h[i]=(sxt7->32(Rt)>0)?(zxt16-
                                                            >64 (Rss.uh[i])>>>sxt     7->32(Rt)):(zxt16-
                                                            >64 (Rss.uh[i])<<sxt   7->32(Rt));
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                         ■  If the number of bits to be shifted is greater than the width of the vector element,
                            the result is either all sign-bits (for arithmetic right shifts) or all zeros for logical
                            and left shifts.
80-N2040-45 Rev. B                                                                                                   671
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Intrinsics
                   Rdd=vaslh(Rss,Rt)                        Word64 Q6_P_vaslh_PR(Word64 Rss, Word32 Rt)
                   Rdd=vasrh(Rss,Rt)                        Word64 Q6_P_vasrh_PR(Word64 Rss, Word32 Rt)
                   Rdd=vlslh(Rss,Rt)                        Word64 Q6_P_vlslh_PR(Word64 Rss, Word32 Rt)
                   Rdd=vlsrh(Rss,Rt)                        Word64 Q6_P_vlsrh_PR(Word64 Rss, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS     RegType    Maj           s5        Parse          t5      Min        d5
 1  1  0  0 0  0   1  1 0  1   -  s  s  s  s  s  P   P -  t   t  t t t 0  0  - d d  d d  d Rdd=vasrh(Rss,Rt)
 1  1  0  0 0  0   1  1 0  1   -  s  s  s  s  s  P   P -  t   t  t t t 0  1  - d d  d d  d Rdd=vlsrh(Rss,Rt)
 1  1  0  0 0  0   1  1 0  1   -  s  s  s  s  s  P   P -  t   t  t t t 1  0  - d d  d d  d Rdd=vaslh(Rss,Rt)
 1  1  0  0 0  0   1  1 0  1   -  s  s  s  s  s  P   P -  t   t  t t t 1  1  - d d  d d  d Rdd=vlslh(Rss,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              672
Hexagon V67 Programmer’s Reference Manual                                                                  Instruction Set
          Vector shift words by immediate
                  Shift individual words of the source vector. Arithmetic right shifts place the sign bit of the
                  source values in the vacated positions. Logical right shifts place zeros in the vacated
                  positions.
                        Rdd = vaslw(Rss,{Rt/#})                        Shift Amount       Rt/#u5
                        lost                              lost                              Rss
                                                0                                 0   0    Rdd
                   Syntax                                    Behavior
                   Rdd=vaslw(Rss,#u5)                        for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=(Rss.w[i]<<#u);
                                                             }
                   Rdd=vasrw(Rss,#u5)                        for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=(Rss.w[i]>>#u);
                                                             }
                   Rdd=vlsrw(Rss,#u5)                        for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=(Rss.uw[i]>>#u);
                                                             }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rdd=vaslw(Rss,#u5)                        Word64 Q6_P_vaslw_PI(Word64 Rss, Word32 Iu5)
                   Rdd=vasrw(Rss,#u5)                        Word64 Q6_P_vasrw_PI(Word64 Rss, Word32 Iu5)
                   Rdd=vlsrw(Rss,#u5)                        Word64 Q6_P_vlsrw_PI(Word64 Rss, Word32 Iu5)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8   7   6 5   4   3  2  1  0
   ICLASS     RegType   MajOp          s5         Parse                    MinOp          d5
 1  0  0  0 0  0   0  0 0   1 0   s  s  s  s  s   P   P 0  i   i i  i i  0    0 0   d   d  d  d  d Rdd=vasrw(Rss,#u5)
 1  0  0  0 0  0   0  0 0   1 0   s  s  s  s  s   P   P 0  i   i i  i i  0    0 1   d   d  d  d  d Rdd=vlsrw(Rss,#u5)
 1  0  0  0 0  0   0  0 0   1 0   s  s  s  s  s   P   P 0  i   i i  i i  0    1 0   d   d  d  d  d Rdd=vaslw(Rss,#u5)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
80-N2040-45 Rev. B                                                                                                     673
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  s5           Field to encode register s
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  RegType      Register Type
80-N2040-45 Rev. B                                                    674
Hexagon V67 Programmer’s Reference Manual                                                                Instruction Set
        Vector shift words by register
                  The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
                  If the shift amount is negative, the direction of the shift is reversed. Shift the source values
                  right or left based on the shift amount and the type of instruction. Arithmetic right shifts
                  place the sign bit of the source value in the vacated positions. Logical right shifts place
                  zeros in the vacated positions.
                        Rdd = vaslw(Rss,{Rt/#})                         Shift Amount   Rt/#u5
                         lost                             lost                           Rss
                                                0                                 0  0  Rdd
                   Syntax                                  Behavior
                   Rdd=vaslw(Rss,Rt)                        for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=(sxt7->32(Rt)>0)?(sxt32-
                                                            >64(Rss.w[i])<<sxt7->32(Rt)):(sxt32-
                                                            >64(Rss.w[i])>>sxt7->32(Rt));
                                                            }
                   Rdd=vasrw(Rss,Rt)                        for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=(sxt7->32(Rt)>0)?(sxt32-
                                                            >64(Rss.w[i])>>sxt7->32(Rt)):(sxt32-
                                                            >64(Rss.w[i])<<sxt7->32(Rt));
                                                            }
                   Rdd=vlslw(Rss,Rt)                        for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=(sxt7->32(Rt)>0)?(zxt32-
                                                            >64(Rss.uw[i])<<sxt7->32(Rt)):(zxt32-
                                                            >64(Rss.uw[i])>>>sxt7->32(Rt));
                                                            }
                   Rdd=vlsrw(Rss,Rt)                        for (i=0;i<2;i++) {
                                                                 Rdd.w[i]=(sxt7->32(Rt)>0)?(zxt32-
                                                            >64(Rss.uw[i])>>>sxt7->32(Rt)):(zxt32-
                                                            >64(Rss.uw[i])<<sxt7->32(Rt));
                                                            }
                  Class: XTYPE (slots 2,3)
                  Notes
                        ■   If the number of bits to be shifted is greater than the width of the vector element,
                            the result is either all sign-bits (for arithmetic right shifts) or all zeros for logical
                            and left shifts.
80-N2040-45 Rev. B                                                                                                   675
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
                  Intrinsics
                   Rdd=vaslw(Rss,Rt)                        Word64 Q6_P_vaslw_PR(Word64 Rss, Word32 Rt)
                   Rdd=vasrw(Rss,Rt)                        Word64 Q6_P_vasrw_PR(Word64 Rss, Word32 Rt)
                   Rdd=vlslw(Rss,Rt)                        Word64 Q6_P_vlslw_PR(Word64 Rss, Word32 Rt)
                   Rdd=vlsrw(Rss,Rt)                        Word64 Q6_P_vlsrw_PR(Word64 Rss, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS     RegType    Maj           s5        Parse          t5      Min        d5
 1  1  0  0 0  0   1  1 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  0  - d d  d d  d Rdd=vasrw(Rss,Rt)
 1  1  0  0 0  0   1  1 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 0  1  - d d  d d  d Rdd=vlsrw(Rss,Rt)
 1  1  0  0 0  0   1  1 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 1  0  - d d  d d  d Rdd=vaslw(Rss,Rt)
 1  1  0  0 0  0   1  1 0  0   -  s  s  s  s  s  P   P -  t   t  t t t 1  1  - d d  d d  d Rdd=vlslw(Rss,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s5                Field to encode register s
                  t5                Field to encode register t
                  Maj               Major Opcode
                  Min               Minor Opcode
                  RegType           Register Type
80-N2040-45 Rev. B                                                                                              676
Hexagon V67 Programmer’s Reference Manual                                                                 Instruction Set
          Vector shift words with truncate and pack
                  Shift individual words of the source vector Rss right by a register or immediate amount.
                  The low 16-bits of each word are packed into destination register Rd.
                            Rd = vasrw(Rss,{Rt/#})                       Shift Amount     Rt/#u5
                                             lost                                 lost     Rss
                        sxt                                 sxt
                                                        Low 16bits                 Low 16bits
                                                                                           Rd
                   Syntax                                    Behavior
                   Rd=vasrw(Rss,#u5)                         for (i=0;i<2;i++) {
                                                                   Rd.h[i]=(Rss.w[i]>>#u).h[0];
                                                             }
                   Rd=vasrw(Rss,Rt)                          for (i=0;i<2;i++) {
                                                                   Rd.h[i]=(sxt7->32(Rt)>0)?(sxt32-
                                                             >64(Rss.w[i])>>sxt7->32(Rt)):(sxt32-
                                                             >64(Rss.w[i])<<sxt7->32(Rt)).h[0];
                                                             }
                  Class: XTYPE (slots 2,3)
                  Intrinsics
                   Rd=vasrw(Rss,#u5)                         Word32 Q6_R_vasrw_PI(Word64 Rss, Word32 Iu5)
                   Rd=vasrw(Rss,Rt)                          Word32 Q6_R_vasrw_PR(Word64 Rss, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8  7    6 5   4 3 2   1 0
   ICLASS     RegType   MajOp          s5         Parse                      MinOp        d5
 1  0  0  0 1  0   0  0  1  1  0  s  s  s  s   s  P   P 0  i    i  i i  i  0   1  0   d d d   d d Rd=vasrw(Rss,#u5)
   ICLASS     RegType                  s5         Parse           t5        Min           d5
 1  1  0  0 0  1   0  1  -   - -  s  s  s  s   s  P   P  - t    t  t t  t  0   1  0   d d d   d d Rd=vasrw(Rss,Rt)
80-N2040-45 Rev. B                                                                                                    677
Hexagon V67 Programmer’s Reference Manual                 Instruction Set
                  Field name   Description
                  ICLASS       Instruction Class
                  Parse        Packet/Loop parse bits
                  d5           Field to encode register d
                  s5           Field to encode register s
                  t5           Field to encode register t
                  MajOp        Major Opcode
                  MinOp        Minor Opcode
                  Min          Minor Opcode
                  RegType      Register Type
                  RegType      Register Type
80-N2040-45 Rev. B                                                    678
Instruction Index
A                                          any8
                                               Pd=any8(Ps) 212
abs
    Rd=abs(Rs)[:sat] 387                   asl
    Rdd=abs(Rss) 386                           Rd=asl(Rs,#u5) 640
                                               Rd=asl(Rs,#u5):sat 652
                                               Rd=asl(Rs,Rt) 653
add
                                               Rd=asl(Rs,Rt):sat 663
    if ([!]Pu[.new]) Rd=add(Rs,#s8) 193
                                               Rdd=asl(Rss,#u6) 640
    if ([!]Pu[.new]) Rd=add(Rs,Rt) 193
                                               Rdd=asl(Rss,Rt) 654
    Rd=add(#u6,mpyi(Rs,#U6)) 538
                                               Rx^=asl(Rs,#u5) 646
    Rd=add(#u6,mpyi(Rs,Rt)) 538
                                               Rx[&|]=asl(Rs,#u5) 646
    Rd=add(Rs,#s16) 169
                                               Rx[&|]=asl(Rs,Rt) 660
    Rd=add(Rs,add(Ru,#s6)) 388
                                               Rx[+-]=asl(Rs,#u5) 642
    Rd=add(Rs,Rt) 169
                                               Rx[+-]=asl(Rs,Rt) 656
    Rd=add(Rs,Rt):sat 169
                                               Rx=add(#u8,asl(Rx,#U5)) 642
    Rd=add(Rs,Rt):sat:deprecated 390
                                               Rx=and(#u8,asl(Rx,#U5)) 646
    Rd=add(Rt.[HL],Rs.[HL])[:sat]:<<16 392
                                               Rx=or(#u8,asl(Rx,#U5)) 646
    Rd=add(Rt.L,Rs.[HL])[:sat] 392
                                               Rx=sub(#u8,asl(Rx,#U5)) 642
    Rd=add(Ru,mpyi(#u6:2,Rs)) 538
                                               Rxx^=asl(Rss,#u6) 647
    Rd=add(Ru,mpyi(Rs,#u6)) 538
                                               Rxx^=asl(Rss,Rt) 660
    Rdd=add(Rs,Rtt) 390
                                               Rxx[&|]=asl(Rss,#u6) 646
    Rdd=add(Rss,Rtt,Px):carry 394
                                               Rxx[&|]=asl(Rss,Rt) 660
    Rdd=add(Rss,Rtt) 390
                                               Rxx[+-]=asl(Rss,#u6) 642
    Rdd=add(Rss,Rtt):raw:hi 390
                                               Rxx[+-]=asl(Rss,Rt) 657
    Rdd=add(Rss,Rtt):raw:lo 390
    Rdd=add(Rss,Rtt):sat 390
    Rx+=add(Rs,#s8) 388                    aslh
    Rx+=add(Rs,Rt) 388                         if ([!]Pu[.new]) Rd=aslh(Rs) 195
    Rx-=add(Rs,#s8) 388                        Rd=aslh(Rs) 190
    Rx-=add(Rs,Rt) 388
    Ry=add(Ru,mpyi(Ry,Rs)) 539             asr
                                               Rd=asr(Rs,#u5) 640
addasl                                         Rd=asr(Rs,#u5):rnd 650
    Rd=addasl(Rt,Rs,#u3) 645                   Rd=asr(Rs,Rt) 653
                                               Rd=asr(Rs,Rt):sat 663
                                               Rdd=asr(Rss,#u6) 640
all8
                                               Rdd=asr(Rss,#u6):rnd 650
    Pd=all8(Ps) 212                            Rdd=asr(Rss,Rt) 654
                                               Rx[&|]=asr(Rs,#u5) 646
allocframe                                     Rx[&|]=asr(Rs,Rt) 660
    allocframe(#u11:3) 325                     Rx[+-]=asr(Rs,#u5) 642
    allocframe(Rx,#u11:3):raw 325              Rx[+-]=asr(Rs,Rt) 656
                                               Rxx^=asr(Rss,Rt) 660
and                                            Rxx[&|]=asr(Rss,#u6) 646
    if ([!]Pu[.new]) Rd=and(Rs,Rt) 198         Rxx[&|]=asr(Rss,Rt) 660
    Pd=and(Ps,and(Pt,[!]Pu)) 218               Rxx[+-]=asr(Rss,#u6) 642
    Pd=and(Pt,[!]Ps) 218                       Rxx[+-]=asr(Rss,Rt) 657
    Rd=and(Rs,#s10) 171
    Rd=and(Rs,Rt) 171                      asrh
    Rd=and(Rt,~Rs) 171                         if ([!]Pu[.new]) Rd=asrh(Rs) 195
    Rdd=and(Rss,Rtt) 396                       Rd=asrh(Rs) 190
    Rdd=and(Rtt,~Rss) 396
    Rx[&|^]=and(Rs,~Rt) 399                asrrnd
    Rx[&|^]=and(Rs,Rt) 399
                                               Rd=asrrnd(Rs,#u5) 650
    Rx|=and(Rs,#s10) 399
                                               Rdd=asrrnd(Rss,#u6) 650
80-N2040-45 Rev. B                                                              679
Hexagon V67 Programmer’s Reference Manual                                      Instruction Index
B                                         cmp.eq
                                             if ([!]cmp.eq(Ns.new,#-1)) jump:<hint> #r9:2 285
                                             if ([!]cmp.eq(Ns.new,#U5)) jump:<hint> #r9:2 285
barrier
                                             if ([!]cmp.eq(Ns.new,Rt)) jump:<hint> #r9:2 285
    barrier 370                              p[01]=cmp.eq(Rs,#-1) 227
                                             p[01]=cmp.eq(Rs,#U5) 227
bitsclr                                      p[01]=cmp.eq(Rs,Rt) 227
    Pd=[!]bitsclr(Rs,#u6) 625                Pd=[!]cmp.eq(Rs,#s10) 206
    Pd=[!]bitsclr(Rs,Rt) 625                 Pd=[!]cmp.eq(Rs,Rt) 206
                                             Pd=cmp.eq(Rss,Rtt) 624
bitsplit                                     Rd=[!]cmp.eq(Rs,#s8) 208
    Rdd=bitsplit(Rs,#u5) 477                 Rd=[!]cmp.eq(Rs,Rt) 208
    Rdd=bitsplit(Rs,Rt) 477
                                          cmp.ge
bitsset                                      Pd=cmp.ge(Rs,#s8) 206
    Pd=[!]bitsset(Rs,Rt) 625
                                          cmp.geu
boundscheck                                  Pd=cmp.geu(Rs,#u8) 206
    Pd=boundscheck(Rs,Rtt) 618
    Pd=boundscheck(Rss,Rtt):raw:hi 618    cmp.gt
    Pd=boundscheck(Rss,Rtt):raw:lo 618       if ([!]cmp.gt(Ns.new,#-1)) jump:<hint> #r9:2 285
                                             if ([!]cmp.gt(Ns.new,#U5)) jump:<hint> #r9:2 285
brev                                         if ([!]cmp.gt(Ns.new,Rt)) jump:<hint> #r9:2 286
    Rd=brev(Rs) 474                          if ([!]cmp.gt(Rt,Ns.new)) jump:<hint> #r9:2 286
    Rdd=brev(Rss) 474                        p[01]=cmp.gt(Rs,#-1) 227
                                             p[01]=cmp.gt(Rs,#U5) 227
                                             p[01]=cmp.gt(Rs,Rt) 227
brkpt
                                             Pd=[!]cmp.gt(Rs,#s10) 206
    brkpt 371                                Pd=[!]cmp.gt(Rs,Rt) 206
                                             Pd=cmp.gt(Rss,Rtt) 624
C
                                          cmp.gtu
call                                         if ([!]cmp.gtu(Ns.new,#U5)) jump:<hint> #r9:2 286
    call #r22:2 225                          if ([!]cmp.gtu(Ns.new,Rt)) jump:<hint> #r9:2 286
    if ([!]Pu) call #r15:2 225               if ([!]cmp.gtu(Rt,Ns.new)) jump:<hint> #r9:2 286
                                             p[01]=cmp.gtu(Rs,#U5) 227
callr                                        p[01]=cmp.gtu(Rs,Rt) 228
    callr Rs 221                             Pd=[!]cmp.gtu(Rs,#u9) 206
    if ([!]Pu) callr Rs 221                  Pd=[!]cmp.gtu(Rs,Rt) 206
                                             Pd=cmp.gtu(Rss,Rtt) 624
ciad
    ciad(Rs) 329                          cmp.lt
                                             Pd=cmp.lt(Rs,Rt) 206
cl0
    Rd=cl0(Rs) 461                        cmp.ltu
    Rd=cl0(Rss) 461                          Pd=cmp.ltu(Rs,Rt) 206
cl1                                       cmpb.eq
    Rd=cl1(Rs) 461                           Pd=cmpb.eq(Rs,#u8) 620
    Rd=cl1(Rss) 462                          Pd=cmpb.eq(Rs,Rt) 620
clb                                       cmpb.gt
    Rd=add(clb(Rs),#s6) 461                  Pd=cmpb.gt(Rs,#s8) 620
    Rd=add(clb(Rss),#s6) 461                 Pd=cmpb.gt(Rs,Rt) 620
    Rd=clb(Rs) 462
    Rd=clb(Rss) 462                       cmpb.gtu
                                             Pd=cmpb.gtu(Rs,#u7) 620
clip                                         Pd=cmpb.gtu(Rs,Rt) 620
    Rd=clip(Rs,#u5) 395
                                          cmph.eq
clrbit                                       Pd=cmph.eq(Rs,#s8) 622
    memb(Rs+#u6:0)=clrbit(#U5) 281           Pd=cmph.eq(Rs,Rt) 622
    memh(Rs+#u6:1)=clrbit(#U5) 283
    memw(Rs+#u6:2)=clrbit(#U5) 284        cmph.gt
    Rd=clrbit(Rs,#u5) 475                    Pd=cmph.gt(Rs,#s8) 622
    Rd=clrbit(Rs,Rt) 475                     Pd=cmph.gt(Rs,Rt) 622
80-N2040-45 Rev. B                                                                           680
Hexagon V67 Programmer’s Reference Manual                                       Instruction Index
cmph.gtu                                    convert_df2sf
    Pd=cmph.gtu(Rs,#u7) 622                     Rd=convert_df2sf(Rss) 521
    Pd=cmph.gtu(Rs,Rt) 622
                                            convert_df2ud
cmpy                                            Rdd=convert_df2ud(Rss) 524
    Rd=cmpy(Rs,Rt)[:<<1]:rnd:sat 492            Rdd=convert_df2ud(Rss):chop 524
    Rd=cmpy(Rs,Rt*)[:<<1]:rnd:sat 492
    Rdd=cmpy(Rs,Rt)[:<<1]:sat 487           convert_df2uw
    Rdd=cmpy(Rs,Rt*)[:<<1]:sat 487              Rd=convert_df2uw(Rss) 524
    Rxx+=cmpy(Rs,Rt)[:<<1]:sat 488              Rd=convert_df2uw(Rss):chop 524
    Rxx+=cmpy(Rs,Rt*)[:<<1]:sat 488
    Rxx-=cmpy(Rs,Rt)[:<<1]:sat 488
    Rxx-=cmpy(Rs,Rt*)[:<<1]:sat 488
                                            convert_df2w
                                                Rd=convert_df2w(Rss) 524
                                                Rd=convert_df2w(Rss):chop 524
cmpyi
    Rdd=cmpyi(Rs,Rt) 490
    Rxx+=cmpyi(Rs,Rt) 490
                                            convert_sf2d
                                                Rdd=convert_sf2d(Rs) 524
                                                Rdd=convert_sf2d(Rs):chop 524
cmpyiw
    Rd=cmpyiw(Rss,Rtt):<<1:rnd:sat 496
    Rd=cmpyiw(Rss,Rtt):<<1:sat 496
                                            convert_sf2df
    Rd=cmpyiw(Rss,Rtt*):<<1:rnd:sat 496         Rdd=convert_sf2df(Rs) 521
    Rd=cmpyiw(Rss,Rtt*):<<1:sat 496
    Rdd=cmpyiw(Rss,Rtt) 497                 convert_sf2ud
    Rdd=cmpyiw(Rss,Rtt*) 497                    Rdd=convert_sf2ud(Rs) 524
    Rxx+=cmpyiw(Rss,Rtt) 497                    Rdd=convert_sf2ud(Rs):chop 524
    Rxx+=cmpyiw(Rss,Rtt*) 497
                                            convert_sf2uw
cmpyiwh                                         Rd=convert_sf2uw(Rs) 524
    Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat 494          Rd=convert_sf2uw(Rs):chop 524
    Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat 494
                                            convert_sf2w
cmpyr                                           Rd=convert_sf2w(Rs) 524
    Rdd=cmpyr(Rs,Rt) 490                        Rd=convert_sf2w(Rs):chop 524
    Rxx+=cmpyr(Rs,Rt) 490
                                            convert_ud2df
cmpyrw                                          Rdd=convert_ud2df(Rss) 522
    Rd=cmpyrw(Rss,Rtt):<<1:rnd:sat 496
    Rd=cmpyrw(Rss,Rtt):<<1:sat 496          convert_ud2sf
    Rd=cmpyrw(Rss,Rtt*):<<1:rnd:sat 497         Rd=convert_ud2sf(Rss) 522
    Rd=cmpyrw(Rss,Rtt*):<<1:sat 497
    Rdd=cmpyrw(Rss,Rtt) 497
    Rdd=cmpyrw(Rss,Rtt*) 497
                                            convert_uw2df
    Rxx+=cmpyrw(Rss,Rtt) 497                    Rdd=convert_uw2df(Rs) 522
    Rxx+=cmpyrw(Rss,Rtt*) 497
                                            convert_uw2sf
cmpyrwh                                         Rd=convert_uw2sf(Rs) 522
    Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat 494
    Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat 494     convert_w2df
                                                Rdd=convert_w2df(Rs) 522
combine
    if ([!]Pu[.new]) Rdd=combine(Rs,Rt) 197 convert_w2sf
    Rd=combine(Rt.[HL],Rs.[HL]) 186             Rd=convert_w2sf(Rs) 522
    Rdd=combine(#s8,#S8) 186
    Rdd=combine(#s8,#U6) 186                cround
    Rdd=combine(#s8,Rs) 186                     Rd=cround(Rs,#u5) 407
    Rdd=combine(Rs,#s8) 186                     Rd=cround(Rs,Rt) 407
    Rdd=combine(Rs,Rt) 187                      Rdd=cround(Rss,#u6) 407
                                                Rdd=cround(Rss,Rt) 408
convert_d2df
    Rdd=convert_d2df(Rss) 522               cswi
                                                cswi(Rs) 331
convert_d2sf
    Rd=convert_d2sf(Rss) 522                ct0
                                                Rd=ct0(Rs) 465
convert_df2d                                    Rd=ct0(Rss) 465
    Rdd=convert_df2d(Rss) 524
    Rdd=convert_df2d(Rss):chop 524
80-N2040-45 Rev. B                                                                            681
Hexagon V67 Programmer’s Reference Manual                                         Instruction Index
ct1                                                  dfadd
    Rd=ct1(Rs) 465                                      Rdd=dfadd(Rss,Rtt) 517
    Rd=ct1(Rss) 465
                                                     dfclass
ctlbw                                                   Pd=dfclass(Rss,#u5) 518
    Rd=ctlbw(Rss,Rt)  361
                                                     dfcmp.eq
D                                                       Pd=dfcmp.eq(Rss,Rtt) 519
dccleana                                             dfcmp.ge
    dccleana(Rs)  373                                   Pd=dfcmp.ge(Rss,Rtt) 519
dccleanidx                                           dfcmp.gt
    dccleanidx(Rs)  333                                 Pd=dfcmp.gt(Rss,Rtt) 519
dccleaninva                                          dfcmp.uo
    dccleaninva(Rs)  373                                Pd=dfcmp.uo(Rss,Rtt) 519
dccleaninvidx                                        dfmake
    dccleaninvidx(Rs)  333                              Rdd=dfmake(#u10):neg 532
                                                        Rdd=dfmake(#u10):pos 532
dcfetch
    dcfetch(Rs) 372                                  dfmax
    dcfetch(Rs+#u11:3)  372                             Rdd=dfmax(Rss,Rtt) 533
dcinva                                               dfmin
    dcinva(Rs) 373                                      Rdd=dfmin(Rss,Rtt) 534
dcinvidx                                             dfmpyfix
    dcinvidx(Rs)  333                                   Rdd=dfmpyfix(Rss,Rtt) 535
dckill                                               dfmpyhh
    dckill 332                                          Rxx+=dfmpyhh(Rss,Rtt) 527
dctagr                                               dfmpylh
    Rd=dctagr(Rs)  333                                  Rxx+=dfmpylh(Rss,Rtt) 527
dctagw                                               dfmpyll
    dctagw(Rs,Rt)  333                                  Rdd=dfmpyll(Rss,Rtt) 535
dczeroa                                              dfsub
    dczeroa(Rs) 369                                     Rdd=dfsub(Rss,Rtt) 537
dealloc_return                                       diag
    dealloc_return 271                                  diag(Rs) 375
    if ([!]Pv.new) Rdd=dealloc_return(Rs):nt:raw 271
    if ([!]Pv.new) Rdd=dealloc_return(Rs):t:raw 271
                                                     diag0
    if ([!]Pv) dealloc_return 271
    if ([!]Pv) Rdd=dealloc_return(Rs):raw 271
                                                        diag0(Rss,Rtt) 375
    nt
        if ([!]Pv.new) dealloc_return:nt 271         diag1
    Rdd=dealloc_return(Rs):raw 271                      diag1(Rss,Rtt) 375
    t
        if ([!]Pv.new) dealloc_return:t 271          E
deallocframe                                         endloop0
    deallocframe 269                                    endloop0 209
    Rdd=deallocframe(Rs):raw  269
                                                     endloop01
decbin                                                  endloop01 209
    Rdd=decbin(Rss,Rtt)  593
                                                     endloop1
deinterleave                                            endloop1 209
    Rdd=deinterleave(Rss)  471
80-N2040-45 Rev. B                                                                              682
Hexagon V67 Programmer’s Reference Manual                                          Instruction Index
extract                                       interleave
     Rd=extract(Rs,#u5,#U5) 466                  Rdd=interleave(Rss) 471
     Rd=extract(Rs,Rtt) 466
     Rdd=extract(Rss,#u6,#U6) 467             isync
     Rdd=extract(Rss,Rtt) 467                    isync 377
extractu                                      J
     Rd=extractu(Rs,#u5,#U5) 466
     Rd=extractu(Rs,Rtt) 467                  jump
     Rdd=extractu(Rss,#u6,#U6) 467
                                                 if ([!]Pu.new) jump:<hint> #r15:2 233
     Rdd=extractu(Rss,Rtt) 467
                                                 if ([!]Pu) jump #r15:2 231
                                                 if ([!]Pu) jump:<hint> #r15:2 231
F                                                jump #r22:2 231
                                                 nt
fastcorner9                                          if (Rs!=#0) jump:nt #r13:2 234
     Pd=[!]fastcorner9(Ps,Pt)   211                  if (Rs<=#0) jump:nt #r13:2 234
                                                     if (Rs==#0) jump:nt #r13:2 234
G                                                    if (Rs>=#0) jump:nt #r13:2 234
                                                 Rd=#U6 236
                                                 Rd=Rs 236
getimask                                         t
     Rd=getimask(Rs)  335                            if (Rs!=#0) jump:t #r13:2 234
                                                     if (Rs<=#0) jump:t #r13:2 234
H                                                    if (Rs==#0) jump:t #r13:2 234
                                                     if (Rs>=#0) jump:t #r13:2 234
hintjr
                                              jump #r9:2 236, 236
     hintjr(Rs)  223
I                                             jumpr
                                                 if ([!]Pu) jumpr Rs 224
iassignr                                         if ([!]Pu[.new]) jumpr:<hint> Rs 224
                                                 jumpr Rs 224
     Rd=iassignr(Rs)  338
                                              K
iassignw
     iassignw(Rs)  340                        k0lock
                                                 k0lock 336
icdatar
     Rd=icdatar(Rs)  342                      k0unlock
                                                 k0unlock 337
icdataw
     icdataw(Rs,Rt)  343                      L
icinva                                        l2cleanidx
     icinva(Rs)  376                             l2cleanidx(Rs) 344
icinvidx                                      l2cleaninvidx
     icinvidx(Rs)  342                           l2cleaninvidx(Rs) 344
ickill                                        l2fetch
     ickill 343                                  l2fetch(Rs,Rt) 379
                                                 l2fetch(Rs,Rtt) 379
ictagr
     Rd=ictagr(Rs)  342                       l2gclean
                                                 l2gclean 345
ictagw                                           l2gclean(Rtt) 345
     ictagw(Rs,Rt)  343
                                              l2gcleaninv
if ([!]p[01].new) jump:<hint> #r9:2 227, 227,    l2gcleaninv 345
227, 227, 227, 227, 227, 228, 228                l2gcleaninv(Rtt) 345
insert                                        l2gunlock
     Rx=insert(Rs,#u5,#U5) 469                   l2gunlock 345
     Rx=insert(Rs,Rtt) 469
     Rxx=insert(Rss,#u6,#U6) 469              l2invidx
     Rxx=insert(Rss,Rtt) 470                     l2invidx(Rs) 344
80-N2040-45 Rev. B                                                                               683
Hexagon V67 Programmer’s Reference Manual                                      Instruction Index
l2kill                                    maxu
    l2kill 345                               Rd=maxu(Rs,Rt) 401
                                             Rdd=maxu(Rss,Rtt) 402
l2locka
    Pd=l2locka(Rs)  347                   memb
                                             if ([!]Pt[.new]) Rd=memb(#u6) 244
l2tagr                                       if ([!]Pt[.new]) Rd=memb(Rs+#u6:0) 244
    Rd=l2tagr(Rs)  349                       if ([!]Pt[.new]) Rd=memb(Rx++#s4:0) 244
                                             if ([!]Pv[.new]) memb(#u6)=Nt.new 291
                                             if ([!]Pv[.new]) memb(#u6)=Rt 311
l2tagw                                       if ([!]Pv[.new]) memb(Rs+#u6:0)=#S6 311
    l2tagw(Rs,Rt)  349                       if ([!]Pv[.new]) memb(Rs+#u6:0)=Nt.new 291
                                             if ([!]Pv[.new]) memb(Rs+#u6:0)=Rt 311
l2unlocka                                    if ([!]Pv[.new]) memb(Rs+Ru<<#u2)=Nt.new 291
    l2unlocka(Rs)  347                       if ([!]Pv[.new]) memb(Rs+Ru<<#u2)=Rt 311
                                             if ([!]Pv[.new]) memb(Rx++#s4:0)=Nt.new 291
lfs                                          if ([!]Pv[.new]) memb(Rx++#s4:0)=Rt 311
    Rdd=lfs(Rss,Rtt)  472                    if ([!]Pv[.new]) Rd=memb(Rs+Rt<<#u2) 244
                                             memb(gp+#u16:0)=Nt.new 289
                                             memb(gp+#u16:0)=Rt 309
loop0                                        memb(Re=#U6)=Nt.new 289
    loop0(#r7:2,#U10) 213                    memb(Re=#U6)=Rt 309
    loop0(#r7:2,Rs) 213                      memb(Rs+#s11:0)=Nt.new 289
                                             memb(Rs+#s11:0)=Rt 309
loop1                                        memb(Rs+#u6:0)[+-]=#U5 281
    loop1(#r7:2,#U10) 213                    memb(Rs+#u6:0)[+-|&]=Rt 281
    loop1(#r7:2,Rs) 213                      memb(Rs+#u6:0)=#S8 309
                                             memb(Rs+Ru<<#u2)=Nt.new 289
lsl                                          memb(Rs+Ru<<#u2)=Rt 309
    Rd=lsl(#s6,Rt) 653                       memb(Ru<<#u2+#U6)=Nt.new 289
    Rd=lsl(Rs,Rt) 653                        memb(Ru<<#u2+#U6)=Rt 309
    Rdd=lsl(Rss,Rt) 654                      memb(Rx++#s4:0:circ(Mu))=Nt.new 289
    Rx[&|]=lsl(Rs,Rt) 660                    memb(Rx++#s4:0:circ(Mu))=Rt 309
    Rx[+-]=lsl(Rs,Rt) 656                    memb(Rx++#s4:0)=Nt.new 289
    Rxx^=lsl(Rss,Rt) 660                     memb(Rx++#s4:0)=Rt 309
    Rxx[&|]=lsl(Rss,Rt) 660                  memb(Rx++I:circ(Mu))=Nt.new 289
    Rxx[+-]=lsl(Rss,Rt) 657                  memb(Rx++I:circ(Mu))=Rt 309
                                             memb(Rx++Mu:brev)=Nt.new 289
                                             memb(Rx++Mu:brev)=Rt 309
lsr                                          memb(Rx++Mu)=Nt.new 289
    Rd=lsr(Rs,#u5) 640                       memb(Rx++Mu)=Rt 309
    Rd=lsr(Rs,Rt) 654                        Rd=memb(gp+#u16:0) 242
    Rdd=lsr(Rss,#u6) 640                     Rd=memb(Re=#U6) 242
    Rdd=lsr(Rss,Rt) 654                      Rd=memb(Rs+#s11:0) 242
    Rx^=lsr(Rs,#u5) 646                      Rd=memb(Rs+Rt<<#u2) 242
    Rx[&|]=lsr(Rs,#u5) 646                   Rd=memb(Rt<<#u2+#U6) 242
    Rx[&|]=lsr(Rs,Rt) 660                    Rd=memb(Rx++#s4:0:circ(Mu)) 242
    Rx[+-]=lsr(Rs,#u5) 642                   Rd=memb(Rx++#s4:0) 242
    Rx[+-]=lsr(Rs,Rt) 657                    Rd=memb(Rx++I:circ(Mu)) 242
    Rx=add(#u8,lsr(Rx,#U5)) 642              Rd=memb(Rx++Mu:brev) 242
    Rx=and(#u8,lsr(Rx,#U5)) 646              Rd=memb(Rx++Mu) 242
    Rx=or(#u8,lsr(Rx,#U5)) 646
    Rx=sub(#u8,lsr(Rx,#U5)) 642
    Rxx^=lsr(Rss,#u6) 647
                                          memb_fifo
    Rxx^=lsr(Rss,Rt) 660                     Ryy=memb_fifo(Re=#U6) 246
    Rxx[&|]=lsr(Rss,#u6) 647                 Ryy=memb_fifo(Rs) 246
    Rxx[&|]=lsr(Rss,Rt) 660                  Ryy=memb_fifo(Rs+#s11:0) 246
    Rxx[+-]=lsr(Rss,#u6) 642                 Ryy=memb_fifo(Rt<<#u2+#U6) 246
    Rxx[+-]=lsr(Rss,Rt) 657                  Ryy=memb_fifo(Rx++#s4:0:circ(Mu)) 247
                                             Ryy=memb_fifo(Rx++#s4:0) 247
M                                            Ryy=memb_fifo(Rx++I:circ(Mu)) 247
                                             Ryy=memb_fifo(Rx++Mu:brev) 247
                                             Ryy=memb_fifo(Rx++Mu) 247
mask
    Rd=mask(#u5,#U5)  639
    Rdd=mask(Pt) 626
max
    Rd=max(Rs,Rt) 401
    Rdd=max(Rss,Rtt) 402
80-N2040-45 Rev. B                                                                           684
Hexagon V67 Programmer’s Reference Manual                                          Instruction Index
membh                                         memh
    Rd=membh(Re=#U6) 273                         if ([!]Pt[.new]) Rd=memh(#u6) 254
    Rd=membh(Rs) 273                             if ([!]Pt[.new]) Rd=memh(Rs+#u6:1) 254
    Rd=membh(Rs+#s11:1) 273                      if ([!]Pt[.new]) Rd=memh(Rx++#s4:1) 254
    Rd=membh(Rt<<#u2+#U6) 273                    if ([!]Pv[.new]) memh(#u6)=Nt.new 296
    Rd=membh(Rx++#s4:1:circ(Mu)) 274             if ([!]Pv[.new]) memh(#u6)=Rt 317
    Rd=membh(Rx++#s4:1) 274                      if ([!]Pv[.new]) memh(#u6)=Rt.H 317
    Rd=membh(Rx++I:circ(Mu)) 274                 if ([!]Pv[.new]) memh(Rs+#u6:1)=#S6 317
    Rd=membh(Rx++Mu:brev) 274                    if ([!]Pv[.new]) memh(Rs+#u6:1)=Nt.new 296
    Rd=membh(Rx++Mu) 274                         if ([!]Pv[.new]) memh(Rs+#u6:1)=Rt 317
    Rdd=membh(Re=#U6) 276                        if ([!]Pv[.new]) memh(Rs+#u6:1)=Rt.H 317
    Rdd=membh(Rs) 276                            if ([!]Pv[.new]) memh(Rs+Ru<<#u2)=Nt.new 296
    Rdd=membh(Rs+#s11:2) 276                     if ([!]Pv[.new]) memh(Rs+Ru<<#u2)=Rt 317
    Rdd=membh(Rt<<#u2+#U6) 276                   if ([!]Pv[.new]) memh(Rs+Ru<<#u2)=Rt.H 317
    Rdd=membh(Rx++#s4:2:circ(Mu)) 276            if ([!]Pv[.new]) memh(Rx++#s4:1)=Nt.new 296
    Rdd=membh(Rx++#s4:2) 276                     if ([!]Pv[.new]) memh(Rx++#s4:1)=Rt 318
    Rdd=membh(Rx++I:circ(Mu)) 277                if ([!]Pv[.new]) memh(Rx++#s4:1)=Rt.H 318
    Rdd=membh(Rx++Mu:brev) 277                   if ([!]Pv[.new]) Rd=memh(Rs+Rt<<#u2) 254
    Rdd=membh(Rx++Mu) 277                        memh(gp+#u16:1)=Nt.new 294
                                                 memh(gp+#u16:1)=Rt 315
memd                                             memh(gp+#u16:1)=Rt.H 315
    if ([!]Pt[.new]) Rdd=memd(#u6) 240           memh(Re=#U6)=Nt.new 294
    if ([!]Pt[.new]) Rdd=memd(Rs+#u6:3) 240      memh(Re=#U6)=Rt 314
    if ([!]Pt[.new]) Rdd=memd(Rx++#s4:3) 240     memh(Re=#U6)=Rt.H 314
    if ([!]Pv[.new]) memd(#u6)=Rtt 307           memh(Rs+#s11:1)=Nt.new 294
    if ([!]Pv[.new]) memd(Rs+#u6:3)=Rtt 307      memh(Rs+#s11:1)=Rt 314
    if ([!]Pv[.new]) memd(Rs+Ru<<#u2)=Rtt 307    memh(Rs+#s11:1)=Rt.H 314
    if ([!]Pv[.new]) memd(Rx++#s4:3)=Rtt 307     memh(Rs+#u6:1)[+-]=#U5 283
    if ([!]Pv[.new]) Rdd=memd(Rs+Rt<<#u2) 240    memh(Rs+#u6:1)[+-|&]=Rt 283
    memd(gp+#u16:3)=Rtt 304                      memh(Rs+#u6:1)=#S8 314
    memd(Re=#U6)=Rtt 304                         memh(Rs+Ru<<#u2)=Nt.new 294
    memd(Rs+#s11:3)=Rtt 304                      memh(Rs+Ru<<#u2)=Rt 314
    memd(Rs+Ru<<#u2)=Rtt 304                     memh(Rs+Ru<<#u2)=Rt.H 314
    memd(Ru<<#u2+#U6)=Rtt 304                    memh(Ru<<#u2+#U6)=Nt.new 294
    memd(Rx++#s4:3:circ(Mu))=Rtt 304             memh(Ru<<#u2+#U6)=Rt 314
    memd(Rx++#s4:3)=Rtt 304                      memh(Ru<<#u2+#U6)=Rt.H 314
    memd(Rx++I:circ(Mu))=Rtt 304                 memh(Rx++#s4:1:circ(Mu))=Nt.new 294
    memd(Rx++Mu:brev)=Rtt 304                    memh(Rx++#s4:1:circ(Mu))=Rt 314
    memd(Rx++Mu)=Rtt 304                         memh(Rx++#s4:1:circ(Mu))=Rt.H 314
    Rdd=memd(gp+#u16:3) 237                      memh(Rx++#s4:1)=Nt.new 294
    Rdd=memd(Re=#U6) 237                         memh(Rx++#s4:1)=Rt 314
    Rdd=memd(Rs+#s11:3) 237                      memh(Rx++#s4:1)=Rt.H 314
    Rdd=memd(Rs+Rt<<#u2) 237                     memh(Rx++I:circ(Mu))=Nt.new 294
    Rdd=memd(Rt<<#u2+#U6) 237                    memh(Rx++I:circ(Mu))=Rt 314
    Rdd=memd(Rx++#s4:3:circ(Mu)) 237             memh(Rx++I:circ(Mu))=Rt.H 314
    Rdd=memd(Rx++#s4:3) 237                      memh(Rx++Mu:brev)=Nt.new 294
    Rdd=memd(Rx++I:circ(Mu)) 237                 memh(Rx++Mu:brev)=Rt 315
    Rdd=memd(Rx++Mu:brev) 237                    memh(Rx++Mu:brev)=Rt.H 315
    Rdd=memd(Rx++Mu) 237                         memh(Rx++Mu)=Nt.new 294
                                                 memh(Rx++Mu)=Rt 315
                                                 memh(Rx++Mu)=Rt.H 315
memd_locked                                      Rd=memh(gp+#u16:1) 252
    memd_locked(Rs,Pd)=Rtt 367                   Rd=memh(Re=#U6) 252
    Rdd=memd_locked(Rs) 366                      Rd=memh(Rs+#s11:1) 252
                                                 Rd=memh(Rs+Rt<<#u2) 252
                                                 Rd=memh(Rt<<#u2+#U6) 252
                                                 Rd=memh(Rx++#s4:1:circ(Mu)) 252
                                                 Rd=memh(Rx++#s4:1) 252
                                                 Rd=memh(Rx++I:circ(Mu)) 252
                                                 Rd=memh(Rx++Mu:brev) 252
                                                 Rd=memh(Rx++Mu) 252
80-N2040-45 Rev. B                                                                               685
Hexagon V67 Programmer’s Reference Manual                                           Instruction Index
memh_fifo                                     memw
    Ryy=memh_fifo(Re=#U6) 249                     if ([!]Pt[.new]) Rd=memw(#u6) 267
    Ryy=memh_fifo(Rs) 249                         if ([!]Pt[.new]) Rd=memw(Rs+#u6:2) 267
    Ryy=memh_fifo(Rs+#s11:1) 249                  if ([!]Pt[.new]) Rd=memw(Rx++#s4:2) 267
    Ryy=memh_fifo(Rt<<#u2+#U6) 249                if ([!]Pv[.new]) memw(#u6)=Nt.new 301
    Ryy=memh_fifo(Rx++#s4:1:circ(Mu)) 250         if ([!]Pv[.new]) memw(#u6)=Rt 322
    Ryy=memh_fifo(Rx++#s4:1) 250                  if ([!]Pv[.new]) memw(Rs+#u6:2)=#S6 322
    Ryy=memh_fifo(Rx++I:circ(Mu)) 250             if ([!]Pv[.new]) memw(Rs+#u6:2)=Nt.new 301
    Ryy=memh_fifo(Rx++Mu:brev) 250                if ([!]Pv[.new]) memw(Rs+#u6:2)=Rt 322
    Ryy=memh_fifo(Rx++Mu) 250                     if ([!]Pv[.new]) memw(Rs+Ru<<#u2)=Nt.new 301
                                                  if ([!]Pv[.new]) memw(Rs+Ru<<#u2)=Rt 322
memub                                             if ([!]Pv[.new]) memw(Rx++#s4:2)=Nt.new 301
    if ([!]Pt[.new]) Rd=memub(#u6) 259            if ([!]Pv[.new]) memw(Rx++#s4:2)=Rt 322
    if ([!]Pt[.new]) Rd=memub(Rs+#u6:0) 259       if ([!]Pv[.new]) Rd=memw(Rs+Rt<<#u2) 267
    if ([!]Pt[.new]) Rd=memub(Rx++#s4:0) 259      memw(gp+#u16:2)=Nt.new 299
    if ([!]Pv[.new]) Rd=memub(Rs+Rt<<#u2) 259     memw(gp+#u16:2)=Rt 320
    Rd=memub(gp+#u16:0) 257                       memw(Re=#U6)=Nt.new 299
    Rd=memub(Re=#U6) 257                          memw(Re=#U6)=Rt 320
    Rd=memub(Rs+#s11:0) 257                       memw(Rs+#s11:2)=Nt.new 299
    Rd=memub(Rs+Rt<<#u2) 257                      memw(Rs+#s11:2)=Rt 320
    Rd=memub(Rt<<#u2+#U6) 257                     memw(Rs+#u6:2)[+-]=#U5 284
    Rd=memub(Rx++#s4:0:circ(Mu)) 257              memw(Rs+#u6:2)[+-|&]=Rt 284
    Rd=memub(Rx++#s4:0) 257                       memw(Rs+#u6:2)=#S8 320
    Rd=memub(Rx++I:circ(Mu)) 257                  memw(Rs+Ru<<#u2)=Nt.new 299
    Rd=memub(Rx++Mu:brev) 257                     memw(Rs+Ru<<#u2)=Rt 320
    Rd=memub(Rx++Mu) 257                          memw(Ru<<#u2+#U6)=Nt.new 299
                                                  memw(Ru<<#u2+#U6)=Rt 320
                                                  memw(Rx++#s4:2:circ(Mu))=Nt.new 299
memubh                                            memw(Rx++#s4:2:circ(Mu))=Rt 320
    Rd=memubh(Re=#U6) 274                         memw(Rx++#s4:2)=Nt.new 299
    Rd=memubh(Rs+#s11:1) 275                      memw(Rx++#s4:2)=Rt 320
    Rd=memubh(Rt<<#u2+#U6) 275                    memw(Rx++I:circ(Mu))=Nt.new 299
    Rd=memubh(Rx++#s4:1:circ(Mu)) 275             memw(Rx++I:circ(Mu))=Rt 320
    Rd=memubh(Rx++#s4:1) 275                      memw(Rx++Mu:brev)=Nt.new 299
    Rd=memubh(Rx++I:circ(Mu)) 275                 memw(Rx++Mu:brev)=Rt 320
    Rd=memubh(Rx++Mu:brev) 276                    memw(Rx++Mu)=Nt.new 299
    Rd=memubh(Rx++Mu) 275                         memw(Rx++Mu)=Rt 320
    Rdd=memubh(Re=#U6) 277                        Rd=memw(gp+#u16:2) 265
    Rdd=memubh(Rs+#s11:2) 277                     Rd=memw(Re=#U6) 265
    Rdd=memubh(Rt<<#u2+#U6) 277                   Rd=memw(Rs+#s11:2) 265
    Rdd=memubh(Rx++#s4:2:circ(Mu)) 278            Rd=memw(Rs+Rt<<#u2) 265
    Rdd=memubh(Rx++#s4:2) 278                     Rd=memw(Rt<<#u2+#U6) 265
    Rdd=memubh(Rx++I:circ(Mu)) 278                Rd=memw(Rx++#s4:2:circ(Mu)) 265
    Rdd=memubh(Rx++Mu:brev) 278                   Rd=memw(Rx++#s4:2) 265
    Rdd=memubh(Rx++Mu) 278                        Rd=memw(Rx++I:circ(Mu)) 265
                                                  Rd=memw(Rx++Mu:brev) 265
memuh                                             Rd=memw(Rx++Mu) 265
    if ([!]Pt[.new]) Rd=memuh(#u6) 263
    if ([!]Pt[.new]) Rd=memuh(Rs+#u6:1) 263   memw_locked
    if ([!]Pt[.new]) Rd=memuh(Rx++#s4:1) 263      memw_locked(Rs,Pd)=Rt 367
    if ([!]Pv[.new]) Rd=memuh(Rs+Rt<<#u2) 263     Rd=memw_locked(Rs) 366
    Rd=memuh(gp+#u16:1) 261
    Rd=memuh(Re=#U6) 261
    Rd=memuh(Rs+#s11:1) 261
                                              memw_phys
    Rd=memuh(Rs+Rt<<#u2) 261                      Rd=memw_phys(Rs,Rt) 351
    Rd=memuh(Rt<<#u2+#U6) 261
    Rd=memuh(Rx++#s4:1:circ(Mu)) 261          min
    Rd=memuh(Rx++#s4:1) 261                       Rd=min(Rt,Rs) 403
    Rd=memuh(Rx++I:circ(Mu)) 261                  Rdd=min(Rtt,Rss) 404
    Rd=memuh(Rx++Mu:brev) 261
    Rd=memuh(Rx++Mu) 261                      minu
                                                  Rd=minu(Rt,Rs) 403
                                                  Rdd=minu(Rtt,Rss) 404
                                              modwrap
                                                  Rd=modwrap(Rs,Rt) 405
80-N2040-45 Rev. B                                                                                686
Hexagon V67 Programmer’s Reference Manual                                               Instruction Index
mpy                                               no mnemonic
    Rd=mpy(Rs,Rt.H):<<1:rnd:sat 565                   Cd=Rs 220
    Rd=mpy(Rs,Rt.H):<<1:sat 565                       Cdd=Rss 220
    Rd=mpy(Rs,Rt.L):<<1:rnd:sat 565                   Gd=Rs 327
    Rd=mpy(Rs,Rt.L):<<1:sat 565                       Gdd=Rss 327
    Rd=mpy(Rs,Rt) 565                                 if ([!]Pu[.new]) Rd=#s12 203
    Rd=mpy(Rs,Rt):<<1 565                             if ([!]Pu[.new]) Rd=Rs 203
    Rd=mpy(Rs,Rt):<<1:sat 565                         if ([!]Pu[.new]) Rdd=Rss 203
    Rd=mpy(Rs,Rt):rnd 565                             Pd=Ps 218
    Rd=mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd][:sat] 549     Pd=Rs 628
    Rdd=mpy(Rs,Rt) 568                                Rd=#s16 178
    Rdd=mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd] 550          Rd=Cs 220
    Rx+=mpy(Rs,Rt):<<1:sat 565                        Rd=Gs 327
    Rx+=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat] 550          Rd=Ps 628
    Rx-=mpy(Rs,Rt):<<1:sat 565                        Rd=Rs 180
    Rx-=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat] 550          Rd=Ss 363
    Rxx[+-]=mpy(Rs,Rt) 568                            Rdd=#s8 178
    Rxx+=mpy(Rs.[HL],Rt.[HL])[:<<1] 550               Rdd=Css 220
    Rxx-=mpy(Rs.[HL],Rt.[HL])[:<<1] 550               Rdd=Gss 327
                                                      Rdd=Rss 180
mpyi                                                  Rdd=Sss 363
    Rd=+mpyi(Rs,#u8) 538                              Rx.[HL]=#u16 178
    Rd=mpyi(Rs,#m9) 539                               Sd=Rs 363
    Rd=-mpyi(Rs,#u8) 538                              Sdd=Rss 363
    Rd=mpyi(Rs,Rt) 539
    Rx+=mpyi(Rs,#u8) 539                          nop
    Rx+=mpyi(Rs,Rt) 539                               nop 174
    Rx-=mpyi(Rs,#u8) 539
    Rx-=mpyi(Rs,Rt) 539                           normamt
                                                      Rd=normamt(Rs) 462
mpysu                                                 Rd=normamt(Rss) 462
    Rd=mpysu(Rs,Rt) 565
                                                  not
mpyu                                                  Pd=not(Ps) 218
    Rd=mpyu(Rs,Rt) 565                                Rd=not(Rs) 171
    Rd=mpyu(Rs.[HL],Rt.[HL])[:<<1] 556                Rdd=not(Rss) 396
    Rdd=mpyu(Rs,Rt) 568
    Rdd=mpyu(Rs.[HL],Rt.[HL])[:<<1] 556           O
    Rx+=mpyu(Rs.[HL],Rt.[HL])[:<<1] 556
    Rx-=mpyu(Rs.[HL],Rt.[HL])[:<<1] 556           or
    Rxx[+-]=mpyu(Rs,Rt) 568
                                                      if ([!]Pu[.new]) Rd=or(Rs,Rt) 198
    Rxx+=mpyu(Rs.[HL],Rt.[HL])[:<<1] 556
                                                      Pd=and(Ps,or(Pt,[!]Pu)) 218
    Rxx-=mpyu(Rs.[HL],Rt.[HL])[:<<1] 556
                                                      Pd=or(Ps,and(Pt,[!]Pu)) 218
                                                      Pd=or(Ps,or(Pt,[!]Pu)) 218
mpyui                                                 Pd=or(Pt,[!]Ps) 218
    Rd=mpyui(Rs,Rt) 539                               Rd=or(Rs,#s10) 171
                                                      Rd=or(Rs,Rt) 171
mux                                                   Rd=or(Rt,~Rs) 171
    Rd=mux(Pu,#s8,#S8) 188                            Rdd=or(Rss,Rtt) 396
    Rd=mux(Pu,#s8,Rs) 188                             Rdd=or(Rtt,~Rss) 396
    Rd=mux(Pu,Rs,#s8) 188                             Rx[&|^]=or(Rs,Rt) 399
    Rd=mux(Pu,Rs,Rt) 188                              Rx=or(Ru,and(Rx,#s10)) 399
                                                      Rx|=or(Rs,#s10) 399
N
                                                  P
neg
    Rd=neg(Rs) 173                                packhl
    Rd=neg(Rs):sat 406                                Rdd=packhl(Rs,Rt) 192
    Rdd=neg(Rss) 406
                                                  parity
nmi                                                   Rd=parity(Rs,Rt) 473
    nmi(Rs) 352                                       Rd=parity(Rss,Rtt) 473
                                                  pause
                                                      pause(#u8) 381
                                                  pc
                                                      Rd=add(pc,#u6) 215
80-N2040-45 Rev. B                                                                                    687
Hexagon V67 Programmer’s Reference Manual                                    Instruction Index
pmpyw                                     sfcmp.eq
    Rdd=pmpyw(Rs,Rt) 561                      Pd=sfcmp.eq(Rs,Rt) 519
    Rxx^=pmpyw(Rs,Rt) 561
                                          sfcmp.ge
popcount                                      Pd=sfcmp.ge(Rs,Rt) 519
    Rd=popcount(Rss)  464
                                          sfcmp.gt
R                                             Pd=sfcmp.gt(Rs,Rt) 519
resume                                    sfcmp.uo
    resume(Rs) 353                            Pd=sfcmp.uo(Rs,Rt) 519
rol                                       sffixupd
    Rd=rol(Rs,#u5) 640                        Rd=sffixupd(Rs,Rt) 526
    Rdd=rol(Rss,#u6) 640
    Rx^=rol(Rs,#u5) 646
                                          sffixupn
    Rx[&|]=rol(Rs,#u5) 646
    Rx[+-]=rol(Rs,#u5) 642
                                              Rd=sffixupn(Rs,Rt) 526
    Rxx^=rol(Rss,#u6) 647
    Rxx[&|]=rol(Rss,#u6) 647              sffixupr
    Rxx[+-]=rol(Rss,#u6) 642                  Rd=sffixupr(Rs) 526
round                                     sfinvsqrta
    Rd=round(Rs,#u5)[:sat] 407                Rd,Pe=sfinvsqrta(Rs) 529
    Rd=round(Rs,Rt)[:sat] 407
    Rd=round(Rss):sat 407                 sfmake
                                              Rd=sfmake(#u10):neg 532
rte                                           Rd=sfmake(#u10):pos 532
    rte 354
                                          sfmax
S                                             Rd=sfmax(Rs,Rt) 533
sat                                       sfmin
    Rd=sat(Rss) 595                           Rd=sfmin(Rs,Rt) 534
satb                                      sfmpy
    Rd=satb(Rs) 595                           Rd=sfmpy(Rs,Rt) 535
                                              Rx+=sfmpy(Rs,Rt,Pu):scale  528
sath                                          Rx+=sfmpy(Rs,Rt) 527
    Rd=sath(Rs) 595                           Rx+=sfmpy(Rs,Rt):lib 530
                                              Rx-=sfmpy(Rs,Rt) 527
                                              Rx-=sfmpy(Rs,Rt):lib 530
satub
    Rd=satub(Rs)  595
                                          sfrecipa
satuh                                         Rd,Pe=sfrecipa(Rs,Rt) 536
    Rd=satuh(Rs)  595
                                          sfsub
setbit                                        Rd=sfsub(Rs,Rt) 537
    memb(Rs+#u6:0)=setbit(#U5) 281
    memh(Rs+#u6:1)=setbit(#U5) 283        sgp
    memw(Rs+#u6:2)=setbit(#U5) 284            crswap(Rx,sgp) 330
    Rd=setbit(Rs,#u5) 475
    Rd=setbit(Rs,Rt) 475                  sgp0
                                              crswap(Rx,sgp0) 330
setimask
    setimask(Pt,Rs)  355                  sgp1
                                              0
setprio                                           crswap(Rxx,sgp1:0)  330
    setprio(Pt,Rs)  356                       crswap(Rx,sgp1) 330
sfadd                                     shuffeb
    Rd=sfadd(Rs,Rt)  517                      Rdd=shuffeb(Rss,Rtt) 607
sfclass                                   shuffeh
    Pd=sfclass(Rs,#u5)  518                   Rdd=shuffeh(Rss,Rtt) 607
80-N2040-45 Rev. B                                                                         688
Hexagon V67 Programmer’s Reference Manual                                       Instruction Index
shuffob                                    tableidxd
    Rdd=shuffob(Rtt,Rss) 607                  Rx=tableidxd(Rs,#u4,#S6):raw 480
                                              Rx=tableidxd(Rs,#u4,#U5) 480
shuffoh
    Rdd=shuffoh(Rtt,Rss) 607               tableidxh
                                              Rx=tableidxh(Rs,#u4,#S6):raw 480
siad                                          Rx=tableidxh(Rs,#u4,#U5) 480
    siad(Rs) 357
                                           tableidxw
sp1loop0                                      Rx=tableidxw(Rs,#u4,#S6):raw 480
    p3=sp1loop0(#r7:2,#U10) 216               Rx=tableidxw(Rs,#u4,#U5) 480
    p3=sp1loop0(#r7:2,Rs) 216
                                           tlbinvasid
sp2loop0                                      tlbinvasid(Rs) 362
    p3=sp2loop0(#r7:2,#U10) 216
    p3=sp2loop0(#r7:2,Rs) 216              tlblock
                                              tlblock 336
sp3loop0
    p3=sp3loop0(#r7:2,#U10) 216            tlbmatch
    p3=sp3loop0(#r7:2,Rs) 216                 Pd=tlbmatch(Rss,Rt) 627
start                                      tlboc
    start(Rs) 358                             Rd=tlboc(Rss) 361
stop                                       tlbp
    stop(Rs) 359                              Rd=tlbp(Rs) 361
sub                                        tlbr
    if ([!]Pu[.new]) Rd=sub(Rt,Rs) 200        Rdd=tlbr(Rs) 361
    Rd=add(Rs,sub(#s6,Ru)) 388
    Rd=sub(#s10,Rs) 175                    tlbunlock
    Rd=sub(Rt,Rs) 175                         tlbunlock 337
    Rd=sub(Rt,Rs):sat 175
    Rd=sub(Rt,Rs):sat:deprecated 410
    Rd=sub(Rt.[HL],Rs.[HL])[:sat]:<<16 412 tlbw
    Rd=sub(Rt.L,Rs.[HL])[:sat] 412            tlbw(Rss,Rt) 362
    Rdd=sub(Rss,Rtt,Px):carry 394
    Rdd=sub(Rtt,Rss) 410                   togglebit
    Rx+=sub(Rt,Rs) 411                        Rd=togglebit(Rs,#u5) 475
                                              Rd=togglebit(Rs,Rt) 475
swi
    swi(Rs) 360                            trace
                                              trace(Rs) 383
swiz
    Rd=swiz(Rs) 597                        trap0
                                              trap0(#u8) 384
sxtb
    if ([!]Pu[.new]) Rd=sxtb(Rs) 201       trap1
    Rd=sxtb(Rs) 177                           trap1(#u8) 384
                                              trap1(Rx,#u8) 384
sxth
    if ([!]Pu[.new]) Rd=sxth(Rs) 201       tstbit
    Rd=sxth(Rs) 177                           if ([!]tstbit(Ns.new,#0)) jump:<hint> #r9:2  286
                                              p[01]=tstbit(Rs,#0) 228
sxtw                                          Pd=[!]tstbit(Rs,#u5) 629
    Rdd=sxtw(Rs)  414                         Pd=[!]tstbit(Rs,Rt) 629
                                           V
syncht
    syncht 382
                                           vabsdiffb
T                                             Rdd=vabsdiffb(Rtt,Rss) 417
tableidxb                                  vabsdiffh
    Rx=tableidxb(Rs,#u4,#S6):raw 479          Rdd=vabsdiffh(Rtt,Rss) 418
    Rx=tableidxb(Rs,#u4,#U5) 479
80-N2040-45 Rev. B                                                                            689
Hexagon V67 Programmer’s Reference Manual                                      Instruction Index
vabsdiffub                                vavgh
    Rdd=vabsdiffub(Rtt,Rss) 417              Rd=vavgh(Rs,Rt) 182
                                             Rd=vavgh(Rs,Rt):rnd 182
vabsdiffw                                    Rdd=vavgh(Rss,Rtt) 432
    Rdd=vabsdiffw(Rtt,Rss) 419               Rdd=vavgh(Rss,Rtt):crnd 432
                                             Rdd=vavgh(Rss,Rtt):rnd 432
vabsh
    Rdd=vabsh(Rss) 415
                                          vavgub
    Rdd=vabsh(Rss):sat 415                   Rdd=vavgub(Rss,Rtt) 434
                                             Rdd=vavgub(Rss,Rtt):rnd 434
vabsw
    Rdd=vabsw(Rss) 416
                                          vavguh
    Rdd=vabsw(Rss):sat 416                   Rdd=vavguh(Rss,Rtt) 432
                                             Rdd=vavguh(Rss,Rtt):rnd 432
vacsh
    Rxx,Pe=vacsh(Rss,Rtt) 421             vavguw
                                             Rdd=vavguw(Rss,Rtt)[:rnd] 435
vaddb
    Rdd=vaddb(Rss,Rtt) 430                vavgw
                                             Rdd=vavgw(Rss,Rtt):crnd 435
                                             Rdd=vavgw(Rss,Rtt)[:rnd] 435
vaddh
    Rd=vaddh(Rs,Rt)[:sat] 181
    Rdd=vaddh(Rss,Rtt)[:sat] 423
                                          vclip
                                             Rdd=vclip(Rss,#u5) 437
vaddhub
    Rd=vaddhub(Rss,Rtt):sat 425           vcmpb.eq
                                             Pd=!any8(vcmpb.eq(Rss,Rtt)) 632
                                             Pd=any8(vcmpb.eq(Rss,Rtt)) 632
vaddub                                       Pd=vcmpb.eq(Rss,#u8) 633
    Rdd=vaddub(Rss,Rtt)[:sat] 430            Pd=vcmpb.eq(Rss,Rtt) 633
vadduh                                    vcmpb.gt
    Rd=vadduh(Rs,Rt):sat 181                 Pd=vcmpb.gt(Rss,#s8) 633
    Rdd=vadduh(Rss,Rtt):sat 423              Pd=vcmpb.gt(Rss,Rtt) 633
vaddw                                     vcmpb.gtu
    Rdd=vaddw(Rss,Rtt)[:sat] 431             Pd=vcmpb.gtu(Rss,#u7) 633
                                             Pd=vcmpb.gtu(Rss,Rtt) 633
valignb
    Rdd=valignb(Rtt,Rss,#u3) 598          vcmph.eq
    Rdd=valignb(Rtt,Rss,Pu) 598              Pd=vcmph.eq(Rss,#s8) 630
                                             Pd=vcmph.eq(Rss,Rtt) 630
vaslh
    Rdd=vaslh(Rss,#u4) 665                vcmph.gt
    Rdd=vaslh(Rss,Rt) 671                    Pd=vcmph.gt(Rss,#s8) 630
                                             Pd=vcmph.gt(Rss,Rtt) 630
vaslw
    Rdd=vaslw(Rss,#u5) 673                vcmph.gtu
    Rdd=vaslw(Rss,Rt) 675                    Pd=vcmph.gtu(Rss,#u7) 630
                                             Pd=vcmph.gtu(Rss,Rtt) 630
vasrh
    Rdd=vasrh(Rss,#u4) 665                vcmpw.eq
    Rdd=vasrh(Rss,#u4):raw 667               Pd=vcmpw.eq(Rss,#s8) 635
    Rdd=vasrh(Rss,#u4):rnd 667               Pd=vcmpw.eq(Rss,Rtt) 635
    Rdd=vasrh(Rss,Rt) 671
                                          vcmpw.gt
vasrhub                                      Pd=vcmpw.gt(Rss,#s8) 635
    Rd=vasrhub(Rss,#u4):raw 669              Pd=vcmpw.gt(Rss,Rtt) 635
    Rd=vasrhub(Rss,#u4):rnd:sat 669
    Rd=vasrhub(Rss,#u4):sat 669
                                          vcmpw.gtu
                                             Pd=vcmpw.gtu(Rss,#u7) 635
vasrw                                        Pd=vcmpw.gtu(Rss,Rtt) 635
    Rd=vasrw(Rss,#u5) 677
    Rd=vasrw(Rss,Rt) 677
    Rdd=vasrw(Rss,#u5) 673
                                          vcmpyi
    Rdd=vasrw(Rss,Rt) 675                    Rdd=vcmpyi(Rss,Rtt)[:<<1]:sat 500
                                             Rxx+=vcmpyi(Rss,Rtt):sat 501
80-N2040-45 Rev. B                                                                           690
Hexagon V67 Programmer’s Reference Manual                                      Instruction Index
vcmpyr                                    vminub
    Rdd=vcmpyr(Rss,Rtt)[:<<1]:sat 500        Rdd,Pe=vminub(Rtt,Rss) 438
    Rxx+=vcmpyr(Rss,Rtt):sat 501             Rdd=vminub(Rtt,Rss) 447
vcnegh                                    vminuh
    Rdd=vcnegh(Rss,Rt) 439                   Rdd=vminuh(Rtt,Rss) 448
vconj                                     vminuw
    Rdd=vconj(Rss):sat 503                   Rdd=vminuw(Rtt,Rss) 453
vcrotate                                  vminw
    Rdd=vcrotate(Rss,Rt) 504                 Rdd=vminw(Rtt,Rss) 453
vdmpy                                     vmpybsu
    Rd=vdmpy(Rss,Rtt)[:<<1]:rnd:sat 573      Rdd=vmpybsu(Rs,Rt) 589
    Rdd=vdmpy(Rss,Rtt):<<1:sat 570           Rxx+=vmpybsu(Rs,Rt) 589
    Rdd=vdmpy(Rss,Rtt):sat 570
    Rxx+=vdmpy(Rss,Rtt):<<1:sat 571       vmpybu
    Rxx+=vdmpy(Rss,Rtt):sat 571              Rdd=vmpybu(Rs,Rt) 589
                                             Rxx+=vmpybu(Rs,Rt) 589
vdmpybsu
    Rdd=vdmpybsu(Rss,Rtt):sat 577         vmpyeh
    Rxx+=vdmpybsu(Rss,Rtt):sat 577           Rdd=vmpyeh(Rss,Rtt):<<1:sat 579
                                             Rdd=vmpyeh(Rss,Rtt):sat 579
vitpack                                      Rxx+=vmpyeh(Rss,Rtt) 579
    Rd=vitpack(Ps,Pt) 637                    Rxx+=vmpyeh(Rss,Rtt):<<1:sat 579
                                             Rxx+=vmpyeh(Rss,Rtt):sat 579
vlslh
    Rdd=vlslh(Rss,Rt) 671                 vmpyh
                                             Rd=vmpyh(Rs,Rt)[:<<1]:rnd:sat 583
vlslw                                        Rdd=vmpyh(Rs,Rt)[:<<1]:sat 581
    Rdd=vlslw(Rss,Rt) 675                    Rxx+=vmpyh(Rs,Rt) 581
                                             Rxx+=vmpyh(Rs,Rt)[:<<1]:sat 581
vlsrh
    Rdd=vlsrh(Rss,#u4) 665
                                          vmpyhsu
    Rdd=vlsrh(Rss,Rt) 671                    Rdd=vmpyhsu(Rs,Rt)[:<<1]:sat 585
                                             Rxx+=vmpyhsu(Rs,Rt)[:<<1]:sat 585
vlsrw
    Rdd=vlsrw(Rss,#u5) 673
                                          vmpyweh
    Rdd=vlsrw(Rss,Rt) 675                    Rdd=vmpyweh(Rss,Rtt)[:<<1]:rnd:sat 541
                                             Rdd=vmpyweh(Rss,Rtt)[:<<1]:sat 542
                                             Rxx+=vmpyweh(Rss,Rtt)[:<<1]:rnd:sat 542
vmaxb                                        Rxx+=vmpyweh(Rss,Rtt)[:<<1]:sat 542
    Rdd=vmaxb(Rtt,Rss) 440
                                          vmpyweuh
vmaxh                                        Rdd=vmpyweuh(Rss,Rtt)[:<<1]:rnd:sat 545
    Rdd=vmaxh(Rtt,Rss) 441                   Rdd=vmpyweuh(Rss,Rtt)[:<<1]:sat 546
                                             Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:rnd:sat 546
vmaxub                                       Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:sat 546
    Rdd=vmaxub(Rtt,Rss) 440
                                          vmpywoh
vmaxuh                                       Rdd=vmpywoh(Rss,Rtt)[:<<1]:rnd:sat 542
    Rdd=vmaxuh(Rtt,Rss) 441                  Rdd=vmpywoh(Rss,Rtt)[:<<1]:sat 542
                                             Rxx+=vmpywoh(Rss,Rtt)[:<<1]:rnd:sat 542
vmaxuw                                       Rxx+=vmpywoh(Rss,Rtt)[:<<1]:sat 542
    Rdd=vmaxuw(Rtt,Rss) 446
                                          vmpywouh
vmaxw                                        Rdd=vmpywouh(Rss,Rtt)[:<<1]:rnd:sat 546
    Rdd=vmaxw(Rtt,Rss) 446                   Rdd=vmpywouh(Rss,Rtt)[:<<1]:sat 546
                                             Rxx+=vmpywouh(Rss,Rtt)[:<<1]:rnd:sat 546
                                             Rxx+=vmpywouh(Rss,Rtt)[:<<1]:sat 546
vminb
    Rdd=vminb(Rtt,Rss) 447
                                          vmux
                                             Rdd=vmux(Pu,Rss,Rtt) 638
vminh
    Rdd=vminh(Rtt,Rss) 448
80-N2040-45 Rev. B                                                                           691
Hexagon V67 Programmer’s Reference Manual                                          Instruction Index
vnavgh                                         vrminh
    Rd=vnavgh(Rt,Rs) 182                          Rxx=vrminh(Rss,Ru) 449
    Rdd=vnavgh(Rtt,Rss) 432
    Rdd=vnavgh(Rtt,Rss):crnd:sat 432           vrminuh
    Rdd=vnavgh(Rtt,Rss):rnd:sat 432               Rxx=vrminuh(Rss,Ru) 449
vnavgw                                         vrminuw
    Rdd=vnavgw(Rtt,Rss) 435                       Rxx=vrminuw(Rss,Ru) 451
    Rdd=vnavgw(Rtt,Rss):crnd:sat 435
    Rdd=vnavgw(Rtt,Rss):rnd:sat 435
                                               vrminw
                                                  Rxx=vrminw(Rss,Ru) 451
vpmpyh
    Rdd=vpmpyh(Rs,Rt) 591
    Rxx^=vpmpyh(Rs,Rt) 592
                                               vrmpybsu
                                                  Rdd=vrmpybsu(Rss,Rtt) 575
                                                  Rxx+=vrmpybsu(Rss,Rtt) 575
vraddh
    Rd=vraddh(Rss,Rtt) 428
                                               vrmpybu
                                                  Rdd=vrmpybu(Rss,Rtt) 575
vraddub                                           Rxx+=vrmpybu(Rss,Rtt) 576
    Rdd=vraddub(Rss,Rtt) 426
    Rxx+=vraddub(Rss,Rtt) 426
                                               vrmpyh
                                                  Rdd=vrmpyh(Rss,Rtt) 587
vradduh                                           Rxx+=vrmpyh(Rss,Rtt) 587
    Rd=vradduh(Rss,Rtt) 428
                                               vrmpyweh
vrcmpyi                                           Rdd=vrmpyweh(Rss,Rtt)[:<<1] 563
    Rdd=vrcmpyi(Rss,Rtt) 506                      Rxx+=vrmpyweh(Rss,Rtt)[:<<1] 563
    Rdd=vrcmpyi(Rss,Rtt*) 506
    Rxx+=vrcmpyi(Rss,Rtt) 507
    Rxx+=vrcmpyi(Rss,Rtt*) 507
                                               vrmpywoh
                                                  Rdd=vrmpywoh(Rss,Rtt)[:<<1] 563
                                                  Rxx+=vrmpywoh(Rss,Rtt)[:<<1] 563
vrcmpyr
    Rdd=vrcmpyr(Rss,Rtt) 506
    Rdd=vrcmpyr(Rss,Rtt*) 507
                                               vrndwh
    Rxx+=vrcmpyr(Rss,Rtt) 507                     Rd=vrndwh(Rss) 600
    Rxx+=vrcmpyr(Rss,Rtt*) 507                    Rd=vrndwh(Rss):sat 600
vrcmpys                                        vrsadub
    Rd=vrcmpys(Rss,Rt):<<1:rnd:sat 512            Rdd=vrsadub(Rss,Rtt) 455
    Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi 512    Rxx+=vrsadub(Rss,Rtt) 455
    Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo 513
    Rdd=vrcmpys(Rss,Rt):<<1:sat 509            vsathb
    Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi 509       Rd=vsathb(Rs) 603
    Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo 510       Rd=vsathb(Rss) 603
    Rxx+=vrcmpys(Rss,Rt):<<1:sat 510              Rdd=vsathb(Rss) 605
    Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi 510
    Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo 510   vsathub
                                                  Rd=vsathub(Rs) 603
vrcnegh                                           Rd=vsathub(Rss) 603
    Rxx+=vrcnegh(Rss,Rt) 454                      Rdd=vsathub(Rss) 605
vrcrotate                                      vsatwh
    Rdd=vrcrotate(Rss,Rt,#u2) 515                 Rd=vsatwh(Rss) 603
    Rxx+=vrcrotate(Rss,Rt,#u2) 515                Rdd=vsatwh(Rss) 605
vrmaxh                                         vsatwuh
    Rxx=vrmaxh(Rss,Ru) 442                        Rd=vsatwuh(Rss) 603
                                                  Rdd=vsatwuh(Rss) 605
vrmaxuh
    Rxx=vrmaxuh(Rss,Ru) 442                    vsplatb
                                                  Rd=vsplatb(Rs) 609
vrmaxuw                                           Rdd=vsplatb(Rs) 609
    Rxx=vrmaxuw(Rss,Ru) 444
                                               vsplath
vrmaxw                                            Rdd=vsplath(Rs) 610
    Rxx=vrmaxw(Rss,Ru) 444
80-N2040-45 Rev. B                                                                               692
Hexagon V67 Programmer’s Reference Manual                                        Instruction Index
vspliceb                                   X
    Rdd=vspliceb(Rss,Rtt,#u3) 611
    Rdd=vspliceb(Rss,Rtt,Pu) 611
                                           xor
                                               if ([!]Pu[.new]) Rd=xor(Rs,Rt) 198
vsubb                                          Pd=xor(Ps,Pt) 218
    Rdd=vsubb(Rss,Rtt) 459                     Rd=xor(Rs,Rt) 171
                                               Rdd=xor(Rss,Rtt) 396
vsubh                                          Rx[&|^]=xor(Rs,Rt) 399
    Rd=vsubh(Rt,Rs)[:sat] 183                  Rxx^=xor(Rss,Rtt) 398
    Rdd=vsubh(Rtt,Rss)[:sat] 457
                                           Z
vsubub
    Rdd=vsubub(Rtt,Rss)[:sat] 459          zxtb
                                               if ([!]Pu[.new]) Rd=zxtb(Rs) 204
vsubuh                                         Rd=zxtb(Rs) 185
    Rd=vsubuh(Rt,Rs):sat 183
    Rdd=vsubuh(Rtt,Rss):sat 457            zxth
                                               if ([!]Pu[.new]) Rd=zxth(Rs) 204
vsubw                                          Rd=zxth(Rs) 185
    Rdd=vsubw(Rtt,Rss)[:sat] 460
vsxtbh
    Rdd=vsxtbh(Rs) 612
vsxthw
    Rdd=vsxthw(Rs) 612
vtrunehb
    Rd=vtrunehb(Rss) 614
    Rdd=vtrunehb(Rss,Rtt) 614
vtrunewh
    Rdd=vtrunewh(Rss,Rtt) 614
vtrunohb
    Rd=vtrunohb(Rss) 614
    Rdd=vtrunohb(Rss,Rtt) 614
vtrunowh
    Rdd=vtrunowh(Rss,Rtt) 615
vxaddsubh
    Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat 483
    Rdd=vxaddsubh(Rss,Rtt):sat 483
vxaddsubw
    Rdd=vxaddsubw(Rss,Rtt):sat 485
vxsubaddh
    Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat 483
    Rdd=vxsubaddh(Rss,Rtt):sat 483
vxsubaddw
    Rdd=vxsubaddw(Rss,Rtt):sat 485
vzxtbh
    Rdd=vzxtbh(Rs) 616
vzxthw
    Rdd=vzxthw(Rs) 616
W
wait
    wait(Rs) 365
80-N2040-45 Rev. B                                                                             693
Intrinsics Index
A
abs
Rd=abs(Rs)                 Word32 Q6_R_abs_R(Word32 Rs)                                 387
Rd=abs(Rs):sat             Word32 Q6_R_abs_R_sat(Word32 Rs)                             387
Rdd=abs(Rss)               Word64 Q6_P_abs_P(Word64 Rss)                                386
add
Rd=add(#u6,mpyi(Rs,#U6))   Word32 Q6_R_add_mpyi_IRI(Word32 Iu6, Word32 Rs, Word32 IU6)  539
Rd=add(#u6,mpyi(Rs,Rt))    Word32 Q6_R_add_mpyi_IRR(Word32 Iu6, Word32 Rs, Word32 Rt)   539
Rd=add(Rs,#s16)            Word32 Q6_R_add_RI(Word32 Rs, Word32 Is16)                   169
Rd=add(Rs,add(Ru,#s6))     Word32 Q6_R_add_add_RRI(Word32 Rs, Word32 Ru, Word32 Is6)    388
Rd=add(Rs,Rt)              Word32 Q6_R_add_RR(Word32 Rs, Word32 Rt)                     169
Rd=add(Rs,Rt):sat          Word32 Q6_R_add_RR_sat(Word32 Rs, Word32 Rt)                 169
Rd=add(Rt.H,Rs.H):<<16     Word32 Q6_R_add_RhRh_s16(Word32 Rt, Word32 Rs)               393
Rd=add(Rt.H,Rs.H):sat:<<16 Word32 Q6_R_add_RhRh_sat_s16(Word32 Rt, Word32 Rs)           393
Rd=add(Rt.H,Rs.L):<<16     Word32 Q6_R_add_RhRl_s16(Word32 Rt, Word32 Rs)               393
Rd=add(Rt.H,Rs.L):sat:<<16 Word32 Q6_R_add_RhRl_sat_s16(Word32 Rt, Word32 Rs)           393
Rd=add(Rt.L,Rs.H)          Word32 Q6_R_add_RlRh(Word32 Rt, Word32 Rs)                   393
Rd=add(Rt.L,Rs.H):<<16     Word32 Q6_R_add_RlRh_s16(Word32 Rt, Word32 Rs)               393
Rd=add(Rt.L,Rs.H):sat      Word32 Q6_R_add_RlRh_sat(Word32 Rt, Word32 Rs)               393
Rd=add(Rt.L,Rs.H):sat:<<16 Word32 Q6_R_add_RlRh_sat_s16(Word32 Rt, Word32 Rs)           393
Rd=add(Rt.L,Rs.L)          Word32 Q6_R_add_RlRl(Word32 Rt, Word32 Rs)                   393
Rd=add(Rt.L,Rs.L):<<16     Word32 Q6_R_add_RlRl_s16(Word32 Rt, Word32 Rs)               393
Rd=add(Rt.L,Rs.L):sat      Word32 Q6_R_add_RlRl_sat(Word32 Rt, Word32 Rs)               393
Rd=add(Rt.L,Rs.L):sat:<<16 Word32 Q6_R_add_RlRl_sat_s16(Word32 Rt, Word32 Rs)           393
Rd=add(Ru,mpyi(#u6:2,Rs))  Word32 Q6_R_add_mpyi_RIR(Word32 Ru, Word32 Iu6_2, Word32 Rs) 539
Rd=add(Ru,mpyi(Rs,#u6))    Word32 Q6_R_add_mpyi_RRI(Word32 Ru, Word32 Rs, Word32 Iu6)   539
Rdd=add(Rs,Rtt)            Word64 Q6_P_add_RP(Word32 Rs, Word64 Rtt)                    390
Rdd=add(Rss,Rtt)           Word64 Q6_P_add_PP(Word64 Rss, Word64 Rtt)                   390
Rdd=add(Rss,Rtt):sat       Word64 Q6_P_add_PP_sat(Word64 Rss, Word64 Rtt)               390
Rx+=add(Rs,#s8)            Word32 Q6_R_addacc_RI(Word32 Rx, Word32 Rs, Word32 Is8)      388
Rx+=add(Rs,Rt)             Word32 Q6_R_addacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)       388
Rx-=add(Rs,#s8)            Word32 Q6_R_addnac_RI(Word32 Rx, Word32 Rs, Word32 Is8)      388
Rx-=add(Rs,Rt)             Word32 Q6_R_addnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)       388
Ry=add(Ru,mpyi(Ry,Rs))     Word32 Q6_R_add_mpyi_RRR(Word32 Ru, Word32 Ry, Word32 Rs)    539
addasl
Rd=addasl(Rt,Rs,#u3)       Word32 Q6_R_addasl_RRI(Word32 Rt, Word32 Rs, Word32 Iu3)     645
all8
Pd=all8(Ps)                Byte Q6_p_all8_p(Byte Ps)                                    212
80-N2040-45 Rev. B                                                                      694
Hexagon V67 Programmer’s Reference Manual                                                 Intrinsics Index
and
Pd=and(Ps,and(Pt,!Pu))         Byte Q6_p_and_and_ppnp(Byte Ps, Byte Pt, Byte Pu)                       218
Pd=and(Ps,and(Pt,Pu))          Byte Q6_p_and_and_ppp(Byte Ps, Byte Pt, Byte Pu)                        218
Pd=and(Pt,!Ps)                 Byte Q6_p_and_pnp(Byte Pt, Byte Ps)                                     218
Pd=and(Pt,Ps)                  Byte Q6_p_and_pp(Byte Pt, Byte Ps)                                      218
Rd=and(Rs,#s10)                Word32 Q6_R_and_RI(Word32 Rs, Word32 Is10)                              171
Rd=and(Rs,Rt)                  Word32 Q6_R_and_RR(Word32 Rs, Word32 Rt)                                171
Rd=and(Rt,~Rs)                 Word32 Q6_R_and_RnR(Word32 Rt, Word32 Rs)                               171
Rdd=and(Rss,Rtt)               Word64 Q6_P_and_PP(Word64 Rss, Word64 Rtt)                              396
Rdd=and(Rtt,~Rss)              Word64 Q6_P_and_PnP(Word64 Rtt, Word64 Rss)                             396
Rx^=and(Rs,~Rt)                Word32 Q6_R_andxacc_RnR(Word32 Rx, Word32 Rs, Word32 Rt)                399
Rx^=and(Rs,Rt)                 Word32 Q6_R_andxacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                 399
Rx&=and(Rs,~Rt)                Word32 Q6_R_andand_RnR(Word32 Rx, Word32 Rs, Word32 Rt)                 399
Rx&=and(Rs,Rt)                 Word32 Q6_R_andand_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  399
Rx|=and(Rs,#s10)               Word32 Q6_R_andor_RI(Word32 Rx, Word32 Rs, Word32 Is10)                 399
Rx|=and(Rs,~Rt)                Word32 Q6_R_andor_RnR(Word32 Rx, Word32 Rs, Word32 Rt)                  400
Rx|=and(Rs,Rt)                 Word32 Q6_R_andor_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   400
any8
Pd=any8(Ps)                    Byte Q6_p_any8_p(Byte Ps)                                               212
asl
Rd=asl(Rs,#u5)                 Word32 Q6_R_asl_RI(Word32 Rs, Word32 Iu5)                               640
Rd=asl(Rs,#u5):sat             Word32 Q6_R_asl_RI_sat(Word32 Rs, Word32 Iu5)                           652
Rd=asl(Rs,Rt)                  Word32 Q6_R_asl_RR(Word32 Rs, Word32 Rt)                                654
Rd=asl(Rs,Rt):sat              Word32 Q6_R_asl_RR_sat(Word32 Rs, Word32 Rt)                            663
Rdd=asl(Rss,#u6)               Word64 Q6_P_asl_PI(Word64 Rss, Word32 Iu6)                              641
Rdd=asl(Rss,Rt)                Word64 Q6_P_asl_PR(Word64 Rss, Word32 Rt)                               654
Rx^=asl(Rs,#u5)                Word32 Q6_R_aslxacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                647
Rx&=asl(Rs,#u5)                Word32 Q6_R_asland_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 647
Rx&=asl(Rs,Rt)                 Word32 Q6_R_asland_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  661
Rx+=asl(Rs,#u5)                Word32 Q6_R_aslacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 643
Rx+=asl(Rs,Rt)                 Word32 Q6_R_aslacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  657
Rx=add(#u8,asl(Rx,#U5))        Word32 Q6_R_add_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              643
Rx=and(#u8,asl(Rx,#U5))        Word32 Q6_R_and_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              647
Rx-=asl(Rs,#u5)                Word32 Q6_R_aslnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 643
Rx-=asl(Rs,Rt)                 Word32 Q6_R_aslnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  657
Rx=or(#u8,asl(Rx,#U5))         Word32 Q6_R_or_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)               647
Rx=sub(#u8,asl(Rx,#U5))        Word32 Q6_R_sub_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              643
Rx|=asl(Rs,#u5)                Word32 Q6_R_aslor_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                  647
Rx|=asl(Rs,Rt)                 Word32 Q6_R_aslor_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   661
Rxx^=asl(Rss,#u6)              Word64 Q6_P_aslxacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              648
Rxx^=asl(Rss,Rt)               Word64 Q6_P_aslxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               661
Rxx&=asl(Rss,#u6)              Word64 Q6_P_asland_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               647
Rxx&=asl(Rss,Rt)               Word64 Q6_P_asland_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                661
Rxx+=asl(Rss,#u6)              Word64 Q6_P_aslacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               643
Rxx+=asl(Rss,Rt)               Word64 Q6_P_aslacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                657
Rxx-=asl(Rss,#u6)              Word64 Q6_P_aslnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               643
Rxx-=asl(Rss,Rt)               Word64 Q6_P_aslnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                658
Rxx|=asl(Rss,#u6)              Word64 Q6_P_aslor_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)                648
Rxx|=asl(Rss,Rt)               Word64 Q6_P_aslor_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                 661
aslh
Rd=aslh(Rs)                    Word32 Q6_R_aslh_R(Word32 Rs)                                           190
80-N2040-45 Rev. B                                                                                     695
Hexagon V67 Programmer’s Reference Manual                                                Intrinsics Index
asr
Rd=asr(Rs,#u5)                 Word32 Q6_R_asr_RI(Word32 Rs, Word32 Iu5)                              640
Rd=asr(Rs,#u5):rnd             Word32 Q6_R_asr_RI_rnd(Word32 Rs, Word32 Iu5)                          651
Rd=asr(Rs,Rt)                  Word32 Q6_R_asr_RR(Word32 Rs, Word32 Rt)                               654
Rd=asr(Rs,Rt):sat              Word32 Q6_R_asr_RR_sat(Word32 Rs, Word32 Rt)                           663
Rdd=asr(Rss,#u6)               Word64 Q6_P_asr_PI(Word64 Rss, Word32 Iu6)                             641
Rdd=asr(Rss,#u6):rnd           Word64 Q6_P_asr_PI_rnd(Word64 Rss, Word32 Iu6)                         651
Rdd=asr(Rss,Rt)                Word64 Q6_P_asr_PR(Word64 Rss, Word32 Rt)                              654
Rx&=asr(Rs,#u5)                Word32 Q6_R_asrand_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                647
Rx&=asr(Rs,Rt)                 Word32 Q6_R_asrand_RR(Word32 Rx, Word32 Rs, Word32 Rt)                 661
Rx+=asr(Rs,#u5)                Word32 Q6_R_asracc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                643
Rx+=asr(Rs,Rt)                 Word32 Q6_R_asracc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                 657
Rx-=asr(Rs,#u5)                Word32 Q6_R_asrnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                643
Rx-=asr(Rs,Rt)                 Word32 Q6_R_asrnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                 657
Rx|=asr(Rs,#u5)                Word32 Q6_R_asror_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 647
Rx|=asr(Rs,Rt)                 Word32 Q6_R_asror_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  661
Rxx^=asr(Rss,Rt)               Word64 Q6_P_asrxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)              661
Rxx&=asr(Rss,#u6)              Word64 Q6_P_asrand_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              647
Rxx&=asr(Rss,Rt)               Word64 Q6_P_asrand_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               661
Rxx+=asr(Rss,#u6)              Word64 Q6_P_asracc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              643
Rxx+=asr(Rss,Rt)               Word64 Q6_P_asracc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               657
Rxx-=asr(Rss,#u6)              Word64 Q6_P_asrnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              643
Rxx-=asr(Rss,Rt)               Word64 Q6_P_asrnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               658
Rxx|=asr(Rss,#u6)              Word64 Q6_P_asror_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               648
Rxx|=asr(Rss,Rt)               Word64 Q6_P_asror_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                661
asrh
Rd=asrh(Rs)                    Word32 Q6_R_asrh_R(Word32 Rs)                                          190
asrrnd
Rd=asrrnd(Rs,#u5)              Word32 Q6_R_asrrnd_RI(Word32 Rs, Word32 Iu5)                           651
Rdd=asrrnd(Rss,#u6)            Word64 Q6_P_asrrnd_PI(Word64 Rss, Word32 Iu6)                          651
B
bitsclr
Pd=!bitsclr(Rs,#u6)            Byte Q6_p_not_bitsclr_RI(Word32 Rs, Word32 Iu6)                        625
Pd=!bitsclr(Rs,Rt)             Byte Q6_p_not_bitsclr_RR(Word32 Rs, Word32 Rt)                         625
Pd=bitsclr(Rs,#u6)             Byte Q6_p_bitsclr_RI(Word32 Rs, Word32 Iu6)                            625
Pd=bitsclr(Rs,Rt)              Byte Q6_p_bitsclr_RR(Word32 Rs, Word32 Rt)                             625
bitsplit
Rdd=bitsplit(Rs,#u5)           Word64 Q6_P_bitsplit_RI(Word32 Rs, Word32 Iu5)                         477
Rdd=bitsplit(Rs,Rt)            Word64 Q6_P_bitsplit_RR(Word32 Rs, Word32 Rt)                          477
bitsset
Pd=!bitsset(Rs,Rt)             Byte Q6_p_not_bitsset_RR(Word32 Rs, Word32 Rt)                         625
Pd=bitsset(Rs,Rt)              Byte Q6_p_bitsset_RR(Word32 Rs, Word32 Rt)                             625
boundscheck
Pd=boundscheck(Rs,Rtt)         Byte Q6_p_boundscheck_RP(Word32 Rs, Word64 Rtt)                        618
brev
Rd=brev(Rs)                    Word32 Q6_R_brev_R(Word32 Rs)                                          474
80-N2040-45 Rev. B                                                                                    696
Hexagon V67 Programmer’s Reference Manual                                       Intrinsics Index
Rdd=brev(Rss)                  Word64 Q6_P_brev_P(Word64 Rss)                                474
C
cl0
Rd=cl0(Rs)                     Word32 Q6_R_cl0_R(Word32 Rs)                                  462
Rd=cl0(Rss)                    Word32 Q6_R_cl0_P(Word64 Rss)                                 462
cl1
Rd=cl1(Rs)                     Word32 Q6_R_cl1_R(Word32 Rs)                                  462
Rd=cl1(Rss)                    Word32 Q6_R_cl1_P(Word64 Rss)                                 462
clb
Rd=add(clb(Rs),#s6)            Word32 Q6_R_add_clb_RI(Word32 Rs, Word32 Is6)                 462
Rd=add(clb(Rss),#s6)           Word32 Q6_R_add_clb_PI(Word64 Rss, Word32 Is6)                462
Rd=clb(Rs)                     Word32 Q6_R_clb_R(Word32 Rs)                                  462
Rd=clb(Rss)                    Word32 Q6_R_clb_P(Word64 Rss)                                 462
clip
Rd=clip(Rs,#u5)                Word32 Q6_R_clip_RI(Word32 Rs, Word32 Iu5)                    395
clrbit
Rd=clrbit(Rs,#u5)              Word32 Q6_R_clrbit_RI(Word32 Rs, Word32 Iu5)                  475
Rd=clrbit(Rs,Rt)               Word32 Q6_R_clrbit_RR(Word32 Rs, Word32 Rt)                   475
cmp.eq
Pd=!cmp.eq(Rs,#s10)            Byte Q6_p_not_cmp_eq_RI(Word32 Rs, Word32 Is10)               206
Pd=!cmp.eq(Rs,Rt)              Byte Q6_p_not_cmp_eq_RR(Word32 Rs, Word32 Rt)                 206
Pd=cmp.eq(Rs,#s10)             Byte Q6_p_cmp_eq_RI(Word32 Rs, Word32 Is10)                   206
Pd=cmp.eq(Rs,Rt)               Byte Q6_p_cmp_eq_RR(Word32 Rs, Word32 Rt)                     206
Pd=cmp.eq(Rss,Rtt)             Byte Q6_p_cmp_eq_PP(Word64 Rss, Word64 Rtt)                   624
Rd=!cmp.eq(Rs,#s8)             Word32 Q6_R_not_cmp_eq_RI(Word32 Rs, Word32 Is8)              208
Rd=!cmp.eq(Rs,Rt)              Word32 Q6_R_not_cmp_eq_RR(Word32 Rs, Word32 Rt)               208
Rd=cmp.eq(Rs,#s8)              Word32 Q6_R_cmp_eq_RI(Word32 Rs, Word32 Is8)                  208
Rd=cmp.eq(Rs,Rt)               Word32 Q6_R_cmp_eq_RR(Word32 Rs, Word32 Rt)                   208
cmp.ge
Pd=cmp.ge(Rs,#s8)              Byte Q6_p_cmp_ge_RI(Word32 Rs, Word32 Is8)                    206
cmp.geu
Pd=cmp.geu(Rs,#u8)             Byte Q6_p_cmp_geu_RI(Word32 Rs, Word32 Iu8)                   206
cmp.gt
Pd=!cmp.gt(Rs,#s10)            Byte Q6_p_not_cmp_gt_RI(Word32 Rs, Word32 Is10)               206
Pd=!cmp.gt(Rs,Rt)              Byte Q6_p_not_cmp_gt_RR(Word32 Rs, Word32 Rt)                 206
Pd=cmp.gt(Rs,#s10)             Byte Q6_p_cmp_gt_RI(Word32 Rs, Word32 Is10)                   206
Pd=cmp.gt(Rs,Rt)               Byte Q6_p_cmp_gt_RR(Word32 Rs, Word32 Rt)                     207
Pd=cmp.gt(Rss,Rtt)             Byte Q6_p_cmp_gt_PP(Word64 Rss, Word64 Rtt)                   624
cmp.gtu
Pd=!cmp.gtu(Rs,#u9)            Byte Q6_p_not_cmp_gtu_RI(Word32 Rs, Word32 Iu9)               206
Pd=!cmp.gtu(Rs,Rt)             Byte Q6_p_not_cmp_gtu_RR(Word32 Rs, Word32 Rt)                206
Pd=cmp.gtu(Rs,#u9)             Byte Q6_p_cmp_gtu_RI(Word32 Rs, Word32 Iu9)                   207
Pd=cmp.gtu(Rs,Rt)              Byte Q6_p_cmp_gtu_RR(Word32 Rs, Word32 Rt)                    207
80-N2040-45 Rev. B                                                                           697
Hexagon V67 Programmer’s Reference Manual                                                    Intrinsics Index
Pd=cmp.gtu(Rss,Rtt)            Byte Q6_p_cmp_gtu_PP(Word64 Rss, Word64 Rtt)                               624
cmp.lt
Pd=cmp.lt(Rs,Rt)               Byte Q6_p_cmp_lt_RR(Word32 Rs, Word32 Rt)                                  207
cmp.ltu
Pd=cmp.ltu(Rs,Rt)              Byte Q6_p_cmp_ltu_RR(Word32 Rs, Word32 Rt)                                 207
cmpb.eq
Pd=cmpb.eq(Rs,#u8)             Byte Q6_p_cmpb_eq_RI(Word32 Rs, Word32 Iu8)                                620
Pd=cmpb.eq(Rs,Rt)              Byte Q6_p_cmpb_eq_RR(Word32 Rs, Word32 Rt)                                 620
cmpb.gt
Pd=cmpb.gt(Rs,#s8)             Byte Q6_p_cmpb_gt_RI(Word32 Rs, Word32 Is8)                                620
Pd=cmpb.gt(Rs,Rt)              Byte Q6_p_cmpb_gt_RR(Word32 Rs, Word32 Rt)                                 620
cmpb.gtu
Pd=cmpb.gtu(Rs,#u7)            Byte Q6_p_cmpb_gtu_RI(Word32 Rs, Word32 Iu7)                               620
Pd=cmpb.gtu(Rs,Rt)             Byte Q6_p_cmpb_gtu_RR(Word32 Rs, Word32 Rt)                                620
cmph.eq
Pd=cmph.eq(Rs,#s8)             Byte Q6_p_cmph_eq_RI(Word32 Rs, Word32 Is8)                                622
Pd=cmph.eq(Rs,Rt)              Byte Q6_p_cmph_eq_RR(Word32 Rs, Word32 Rt)                                 622
cmph.gt
Pd=cmph.gt(Rs,#s8)             Byte Q6_p_cmph_gt_RI(Word32 Rs, Word32 Is8)                                622
Pd=cmph.gt(Rs,Rt)              Byte Q6_p_cmph_gt_RR(Word32 Rs, Word32 Rt)                                 622
cmph.gtu
Pd=cmph.gtu(Rs,#u7)            Byte Q6_p_cmph_gtu_RI(Word32 Rs, Word32 Iu7)                               622
Pd=cmph.gtu(Rs,Rt)             Byte Q6_p_cmph_gtu_RR(Word32 Rs, Word32 Rt)                                622
cmpy
Rd=cmpy(Rs,Rt):<<1:rnd:sat     Word32 Q6_R_cmpy_RR_s1_rnd_sat(Word32 Rs, Word32 Rt)                       493
Rd=cmpy(Rs,Rt):rnd:sat         Word32 Q6_R_cmpy_RR_rnd_sat(Word32 Rs, Word32 Rt)                          493
Rd=cmpy(Rs,Rt*):<<1:rnd:sat    Word32 Q6_R_cmpy_RR_conj_s1_rnd_sat(Word32 Rs, Word32 Rt)                  493
Rd=cmpy(Rs,Rt*):rnd:sat        Word32 Q6_R_cmpy_RR_conj_rnd_sat(Word32 Rs, Word32 Rt)                     493
Rdd=cmpy(Rs,Rt):<<1:sat        Word64 Q6_P_cmpy_RR_s1_sat(Word32 Rs, Word32 Rt)                           488
Rdd=cmpy(Rs,Rt):sat            Word64 Q6_P_cmpy_RR_sat(Word32 Rs, Word32 Rt)                              488
Rdd=cmpy(Rs,Rt*):<<1:sat       Word64 Q6_P_cmpy_RR_conj_s1_sat(Word32 Rs, Word32 Rt)                      488
Rdd=cmpy(Rs,Rt*):sat           Word64 Q6_P_cmpy_RR_conj_sat(Word32 Rs, Word32 Rt)                         488
Rxx+=cmpy(Rs,Rt):<<1:sat       Word64 Q6_P_cmpyacc_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)            488
Rxx+=cmpy(Rs,Rt):sat           Word64 Q6_P_cmpyacc_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)               488
Rxx+=cmpy(Rs,Rt*):<<1:sat      Word64 Q6_P_cmpyacc_RR_conj_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)       488
Rxx+=cmpy(Rs,Rt*):sat          Word64 Q6_P_cmpyacc_RR_conj_sat(Word64 Rxx, Word32 Rs, Word32 Rt)          489
Rxx-=cmpy(Rs,Rt):<<1:sat       Word64 Q6_P_cmpynac_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)            489
Rxx-=cmpy(Rs,Rt):sat           Word64 Q6_P_cmpynac_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)               489
Rxx-=cmpy(Rs,Rt*):<<1:sat      Word64 Q6_P_cmpynac_RR_conj_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)       489
Rxx-=cmpy(Rs,Rt*):sat          Word64 Q6_P_cmpynac_RR_conj_sat(Word64 Rxx, Word32 Rs, Word32 Rt)          489
cmpyi
Rdd=cmpyi(Rs,Rt)               Word64 Q6_P_cmpyi_RR(Word32 Rs, Word32 Rt)                                 490
Rxx+=cmpyi(Rs,Rt)              Word64 Q6_P_cmpyiacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                  490
80-N2040-45 Rev. B                                                                                        698
Hexagon V67 Programmer’s Reference Manual                                                     Intrinsics Index
cmpyiw
Rd=cmpyiw(Rss,Rtt):<<1:rnd:sat  Word32 Q6_R_cmpyiw_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)                   498
Rd=cmpyiw(Rss,Rtt):<<1:sat      Word32 Q6_R_cmpyiw_PP_s1_sat(Word64 Rss, Word64 Rtt)                       498
Rd=cmpyiw(Rss,Rtt*):<<1:rnd:sat Word32 Q6_R_cmpyiw_PP_conj_s1_rnd_sat(Word64 Rss, Word64 Rtt)              498
Rd=cmpyiw(Rss,Rtt*):<<1:sat     Word32 Q6_R_cmpyiw_PP_conj_s1_sat(Word64 Rss, Word64 Rtt)                  498
Rdd=cmpyiw(Rss,Rtt)             Word64 Q6_P_cmpyiw_PP(Word64 Rss, Word64 Rtt)                              498
Rdd=cmpyiw(Rss,Rtt*)            Word64 Q6_P_cmpyiw_PP_conj(Word64 Rss, Word64 Rtt)                         498
Rxx+=cmpyiw(Rss,Rtt)            Word64 Q6_P_cmpyiwacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)               498
Rxx+=cmpyiw(Rss,Rtt*)           Word64 Q6_P_cmpyiwacc_PP_conj(Word64 Rxx, Word64 Rss, Word64 Rtt)          498
cmpyiwh
Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat  Word32 Q6_R_cmpyiwh_PR_s1_rnd_sat(Word64 Rss, Word32 Rt)                   495
Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat Word32 Q6_R_cmpyiwh_PR_conj_s1_rnd_sat(Word64 Rss, Word32 Rt)              495
cmpyr
Rdd=cmpyr(Rs,Rt)                Word64 Q6_P_cmpyr_RR(Word32 Rs, Word32 Rt)                                 490
Rxx+=cmpyr(Rs,Rt)               Word64 Q6_P_cmpyracc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                  490
cmpyrw
Rd=cmpyrw(Rss,Rtt):<<1:rnd:sat  Word32 Q6_R_cmpyrw_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)                   498
Rd=cmpyrw(Rss,Rtt):<<1:sat      Word32 Q6_R_cmpyrw_PP_s1_sat(Word64 Rss, Word64 Rtt)                       498
Rd=cmpyrw(Rss,Rtt*):<<1:rnd:sat Word32 Q6_R_cmpyrw_PP_conj_s1_rnd_sat(Word64 Rss, Word64 Rtt)              498
Rd=cmpyrw(Rss,Rtt*):<<1:sat     Word32 Q6_R_cmpyrw_PP_conj_s1_sat(Word64 Rss, Word64 Rtt)                  498
Rdd=cmpyrw(Rss,Rtt)             Word64 Q6_P_cmpyrw_PP(Word64 Rss, Word64 Rtt)                              498
Rdd=cmpyrw(Rss,Rtt*)            Word64 Q6_P_cmpyrw_PP_conj(Word64 Rss, Word64 Rtt)                         498
Rxx+=cmpyrw(Rss,Rtt)            Word64 Q6_P_cmpyrwacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)               498
Rxx+=cmpyrw(Rss,Rtt*)           Word64 Q6_P_cmpyrwacc_PP_conj(Word64 Rxx, Word64 Rss, Word64 Rtt)          498
cmpyrwh
Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat  Word32 Q6_R_cmpyrwh_PR_s1_rnd_sat(Word64 Rss, Word32 Rt)                   495
Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat Word32 Q6_R_cmpyrwh_PR_conj_s1_rnd_sat(Word64 Rss, Word32 Rt)              495
combine
Rd=combine(Rt.H,Rs.H)           Word32 Q6_R_combine_RhRh(Word32 Rt, Word32 Rs)                             187
Rd=combine(Rt.H,Rs.L)           Word32 Q6_R_combine_RhRl(Word32 Rt, Word32 Rs)                             187
Rd=combine(Rt.L,Rs.H)           Word32 Q6_R_combine_RlRh(Word32 Rt, Word32 Rs)                             187
Rd=combine(Rt.L,Rs.L)           Word32 Q6_R_combine_RlRl(Word32 Rt, Word32 Rs)                             187
Rdd=combine(#s8,#S8)            Word64 Q6_P_combine_II(Word32 Is8, Word32 IS8)                             187
Rdd=combine(#s8,Rs)             Word64 Q6_P_combine_IR(Word32 Is8, Word32 Rs)                              187
Rdd=combine(Rs,#s8)             Word64 Q6_P_combine_RI(Word32 Rs, Word32 Is8)                              187
Rdd=combine(Rs,Rt)              Word64 Q6_P_combine_RR(Word32 Rs, Word32 Rt)                               187
convert_d2df
Rdd=convert_d2df(Rss)           Word64 Q6_P_convert_d2df_P(Word64 Rss)                                     522
convert_d2sf
Rd=convert_d2sf(Rss)            Word32 Q6_R_convert_d2sf_P(Word64 Rss)                                     522
convert_df2d
Rdd=convert_df2d(Rss)           Word64 Q6_P_convert_df2d_P(Word64 Rss)                                     525
Rdd=convert_df2d(Rss):chop      Word64 Q6_P_convert_df2d_P_chop(Word64 Rss)                                525
convert_df2sf
Rd=convert_df2sf(Rss)           Word32 Q6_R_convert_df2sf_P(Word64 Rss)                                    521
80-N2040-45 Rev. B                                                                                         699
Hexagon V67 Programmer’s Reference Manual                                    Intrinsics Index
convert_df2ud
Rdd=convert_df2ud(Rss)         Word64 Q6_P_convert_df2ud_P(Word64 Rss)                    525
Rdd=convert_df2ud(Rss):chop    Word64 Q6_P_convert_df2ud_P_chop(Word64 Rss)               525
convert_df2uw
Rd=convert_df2uw(Rss)          Word32 Q6_R_convert_df2uw_P(Word64 Rss)                    524
Rd=convert_df2uw(Rss):chop     Word32 Q6_R_convert_df2uw_P_chop(Word64 Rss)               524
convert_df2w
Rd=convert_df2w(Rss)           Word32 Q6_R_convert_df2w_P(Word64 Rss)                     524
Rd=convert_df2w(Rss):chop      Word32 Q6_R_convert_df2w_P_chop(Word64 Rss)                524
convert_sf2d
Rdd=convert_sf2d(Rs)           Word64 Q6_P_convert_sf2d_R(Word32 Rs)                      525
Rdd=convert_sf2d(Rs):chop      Word64 Q6_P_convert_sf2d_R_chop(Word32 Rs)                 525
convert_sf2df
Rdd=convert_sf2df(Rs)          Word64 Q6_P_convert_sf2df_R(Word32 Rs)                     521
convert_sf2ud
Rdd=convert_sf2ud(Rs)          Word64 Q6_P_convert_sf2ud_R(Word32 Rs)                     525
Rdd=convert_sf2ud(Rs):chop     Word64 Q6_P_convert_sf2ud_R_chop(Word32 Rs)                525
convert_sf2uw
Rd=convert_sf2uw(Rs)           Word32 Q6_R_convert_sf2uw_R(Word32 Rs)                     524
Rd=convert_sf2uw(Rs):chop      Word32 Q6_R_convert_sf2uw_R_chop(Word32 Rs)                524
convert_sf2w
Rd=convert_sf2w(Rs)            Word32 Q6_R_convert_sf2w_R(Word32 Rs)                      525
Rd=convert_sf2w(Rs):chop       Word32 Q6_R_convert_sf2w_R_chop(Word32 Rs)                 525
convert_ud2df
Rdd=convert_ud2df(Rss)         Word64 Q6_P_convert_ud2df_P(Word64 Rss)                    522
convert_ud2sf
Rd=convert_ud2sf(Rss)          Word32 Q6_R_convert_ud2sf_P(Word64 Rss)                    522
convert_uw2df
Rdd=convert_uw2df(Rs)          Word64 Q6_P_convert_uw2df_R(Word32 Rs)                     522
convert_uw2sf
Rd=convert_uw2sf(Rs)           Word32 Q6_R_convert_uw2sf_R(Word32 Rs)                     522
convert_w2df
Rdd=convert_w2df(Rs)           Word64 Q6_P_convert_w2df_R(Word32 Rs)                      522
convert_w2sf
Rd=convert_w2sf(Rs)            Word32 Q6_R_convert_w2sf_R(Word32 Rs)                      522
cround
Rd=cround(Rs,#u5)              Word32 Q6_R_cround_RI(Word32 Rs, Word32 Iu5)               408
Rd=cround(Rs,Rt)               Word32 Q6_R_cround_RR(Word32 Rs, Word32 Rt)                408
Rdd=cround(Rss,#u6)            Word64 Q6_P_cround_PI(Word64 Rss, Word32 Iu6)              408
Rdd=cround(Rss,Rt)             Word64 Q6_P_cround_PR(Word64 Rss, Word32 Rt)               408
80-N2040-45 Rev. B                                                                        700
Hexagon V67 Programmer’s Reference Manual                                    Intrinsics Index
ct0
Rd=ct0(Rs)                     Word32 Q6_R_ct0_R(Word32 Rs)                               465
Rd=ct0(Rss)                    Word32 Q6_R_ct0_P(Word64 Rss)                              465
ct1
Rd=ct1(Rs)                     Word32 Q6_R_ct1_R(Word32 Rs)                               465
Rd=ct1(Rss)                    Word32 Q6_R_ct1_P(Word64 Rss)                              465
D
dccleana
dccleana(Rs)                   void Q6_dccleana_A(Address a)                              373
dccleaninva
dccleaninva(Rs)                void Q6_dccleaninva_A(Address a)                           373
dcfetch
dcfetch(Rs)                    void Q6_dcfetch_A(Address a)                               372
dcinva
dcinva(Rs)                     void Q6_dcinva_A(Address a)                                373
dczeroa
dczeroa(Rs)                    void Q6_dczeroa_A(Address a)                               369
deinterleave
Rdd=deinterleave(Rss)          Word64 Q6_P_deinterleave_P(Word64 Rss)                     471
dfadd
Rdd=dfadd(Rss,Rtt)             Word64 Q6_P_dfadd_PP(Word64 Rss, Word64 Rtt)               517
dfclass
Pd=dfclass(Rss,#u5)            Byte Q6_p_dfclass_PI(Word64 Rss, Word32 Iu5)               518
dfcmp.eq
Pd=dfcmp.eq(Rss,Rtt)           Byte Q6_p_dfcmp_eq_PP(Word64 Rss, Word64 Rtt)              519
dfcmp.ge
Pd=dfcmp.ge(Rss,Rtt)           Byte Q6_p_dfcmp_ge_PP(Word64 Rss, Word64 Rtt)              519
dfcmp.gt
Pd=dfcmp.gt(Rss,Rtt)           Byte Q6_p_dfcmp_gt_PP(Word64 Rss, Word64 Rtt)              519
dfcmp.uo
Pd=dfcmp.uo(Rss,Rtt)           Byte Q6_p_dfcmp_uo_PP(Word64 Rss, Word64 Rtt)              519
dfmake
Rdd=dfmake(#u10):neg           Word64 Q6_P_dfmake_I_neg(Word32 Iu10)                      532
Rdd=dfmake(#u10):pos           Word64 Q6_P_dfmake_I_pos(Word32 Iu10)                      532
dfmax
Rdd=dfmax(Rss,Rtt)             Word64 Q6_P_dfmax_PP(Word64 Rss, Word64 Rtt)               533
80-N2040-45 Rev. B                                                                        701
Hexagon V67 Programmer’s Reference Manual                                                        Intrinsics Index
dfmin
Rdd=dfmin(Rss,Rtt)             Word64 Q6_P_dfmin_PP(Word64 Rss, Word64 Rtt)                                   534
dfmpyfix
Rdd=dfmpyfix(Rss,Rtt)          Word64 Q6_P_dfmpyfix_PP(Word64 Rss, Word64 Rtt)                                535
dfmpyhh
Rxx+=dfmpyhh(Rss,Rtt)          Word64 Q6_P_dfmpyhhacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)                  527
dfmpylh
Rxx+=dfmpylh(Rss,Rtt)          Word64 Q6_P_dfmpylhacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)                  527
dfmpyll
Rdd=dfmpyll(Rss,Rtt)           Word64 Q6_P_dfmpyll_PP(Word64 Rss, Word64 Rtt)                                 535
dfsub
Rdd=dfsub(Rss,Rtt)             Word64 Q6_P_dfsub_PP(Word64 Rss, Word64 Rtt)                                   537
E
extract
Rd=extract(Rs,#u5,#U5)         Word32 Q6_R_extract_RII(Word32 Rs, Word32 Iu5, Word32 IU5)                     467
Rd=extract(Rs,Rtt)             Word32 Q6_R_extract_RP(Word32 Rs, Word64 Rtt)                                  467
Rdd=extract(Rss,#u6,#U6)       Word64 Q6_P_extract_PII(Word64 Rss, Word32 Iu6, Word32 IU6)                    467
Rdd=extract(Rss,Rtt)           Word64 Q6_P_extract_PP(Word64 Rss, Word64 Rtt)                                 467
extractu
Rd=extractu(Rs,#u5,#U5)        Word32 Q6_R_extractu_RII(Word32 Rs, Word32 Iu5, Word32 IU5)                    467
Rd=extractu(Rs,Rtt)            Word32 Q6_R_extractu_RP(Word32 Rs, Word64 Rtt)                                 467
Rdd=extractu(Rss,#u6,#U6)      Word64 Q6_P_extractu_PII(Word64 Rss, Word32 Iu6, Word32 IU6)                   467
Rdd=extractu(Rss,Rtt)          Word64 Q6_P_extractu_PP(Word64 Rss, Word64 Rtt)                                467
F
fastcorner9
Pd=!fastcorner9(Ps,Pt)         Byte Q6_p_not_fastcorner9_pp(Byte Ps, Byte Pt)                                 211
Pd=fastcorner9(Ps,Pt)          Byte Q6_p_fastcorner9_pp(Byte Ps, Byte Pt)                                     211
I
insert
Rx=insert(Rs,#u5,#U5)          Word32 Q6_R_insert_RII(Word32 Rx, Word32 Rs, Word32 Iu5, Word32 IU5)           470
Rx=insert(Rs,Rtt)              Word32 Q6_R_insert_RP(Word32 Rx, Word32 Rs, Word64 Rtt)                        470
Rxx=insert(Rss,#u6,#U6)        Word64 Q6_P_insert_PII(Word64 Rxx, Word64 Rss, Word32 Iu6, Word32 IU6)         470
Rxx=insert(Rss,Rtt)            Word64 Q6_P_insert_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)                      470
interleave
Rdd=interleave(Rss)            Word64 Q6_P_interleave_P(Word64 Rss)                                           471
L
l2fetch
l2fetch(Rs,Rt)                 void Q6_l2fetch_AR(Address a, Word32 Rt)                                       379
l2fetch(Rs,Rtt)                void Q6_l2fetch_AP(Address a, Word64 Rtt)                                      379
80-N2040-45 Rev. B                                                                                            702
Hexagon V67 Programmer’s Reference Manual                                                 Intrinsics Index
lfs
Rdd=lfs(Rss,Rtt)               Word64 Q6_P_lfs_PP(Word64 Rss, Word64 Rtt)                              472
lsl
Rd=lsl(#s6,Rt)                 Word32 Q6_R_lsl_IR(Word32 Is6, Word32 Rt)                               654
Rd=lsl(Rs,Rt)                  Word32 Q6_R_lsl_RR(Word32 Rs, Word32 Rt)                                654
Rdd=lsl(Rss,Rt)                Word64 Q6_P_lsl_PR(Word64 Rss, Word32 Rt)                               654
Rx&=lsl(Rs,Rt)                 Word32 Q6_R_lsland_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  661
Rx+=lsl(Rs,Rt)                 Word32 Q6_R_lslacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  657
Rx-=lsl(Rs,Rt)                 Word32 Q6_R_lslnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  657
Rx|=lsl(Rs,Rt)                 Word32 Q6_R_lslor_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   661
Rxx^=lsl(Rss,Rt)               Word64 Q6_P_lslxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               661
Rxx&=lsl(Rss,Rt)               Word64 Q6_P_lsland_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                661
Rxx+=lsl(Rss,Rt)               Word64 Q6_P_lslacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                657
Rxx-=lsl(Rss,Rt)               Word64 Q6_P_lslnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                658
Rxx|=lsl(Rss,Rt)               Word64 Q6_P_lslor_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                 661
lsr
Rd=lsr(Rs,#u5)                 Word32 Q6_R_lsr_RI(Word32 Rs, Word32 Iu5)                               640
Rd=lsr(Rs,Rt)                  Word32 Q6_R_lsr_RR(Word32 Rs, Word32 Rt)                                654
Rdd=lsr(Rss,#u6)               Word64 Q6_P_lsr_PI(Word64 Rss, Word32 Iu6)                              641
Rdd=lsr(Rss,Rt)                Word64 Q6_P_lsr_PR(Word64 Rss, Word32 Rt)                               654
Rx^=lsr(Rs,#u5)                Word32 Q6_R_lsrxacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                647
Rx&=lsr(Rs,#u5)                Word32 Q6_R_lsrand_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 647
Rx&=lsr(Rs,Rt)                 Word32 Q6_R_lsrand_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  661
Rx+=lsr(Rs,#u5)                Word32 Q6_R_lsracc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 643
Rx+=lsr(Rs,Rt)                 Word32 Q6_R_lsracc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  657
Rx=add(#u8,lsr(Rx,#U5))        Word32 Q6_R_add_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              643
Rx=and(#u8,lsr(Rx,#U5))        Word32 Q6_R_and_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              647
Rx-=lsr(Rs,#u5)                Word32 Q6_R_lsrnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 643
Rx-=lsr(Rs,Rt)                 Word32 Q6_R_lsrnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  657
Rx=or(#u8,lsr(Rx,#U5))         Word32 Q6_R_or_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)               647
Rx=sub(#u8,lsr(Rx,#U5))        Word32 Q6_R_sub_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)              643
Rx|=lsr(Rs,#u5)                Word32 Q6_R_lsror_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                  647
Rx|=lsr(Rs,Rt)                 Word32 Q6_R_lsror_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   661
Rxx^=lsr(Rss,#u6)              Word64 Q6_P_lsrxacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              648
Rxx^=lsr(Rss,Rt)               Word64 Q6_P_lsrxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)               661
Rxx&=lsr(Rss,#u6)              Word64 Q6_P_lsrand_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               647
Rxx&=lsr(Rss,Rt)               Word64 Q6_P_lsrand_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                661
Rxx+=lsr(Rss,#u6)              Word64 Q6_P_lsracc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               643
Rxx+=lsr(Rss,Rt)               Word64 Q6_P_lsracc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                658
Rxx-=lsr(Rss,#u6)              Word64 Q6_P_lsrnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               643
Rxx-=lsr(Rss,Rt)               Word64 Q6_P_lsrnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                658
Rxx|=lsr(Rss,#u6)              Word64 Q6_P_lsror_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)                648
Rxx|=lsr(Rss,Rt)               Word64 Q6_P_lsror_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                 661
M
mask
Rd=mask(#u5,#U5)               Word32 Q6_R_mask_II(Word32 Iu5, Word32 IU5)                             639
Rdd=mask(Pt)                   Word64 Q6_P_mask_p(Byte Pt)                                             626
max
Rd=max(Rs,Rt)                  Word32 Q6_R_max_RR(Word32 Rs, Word32 Rt)                                401
80-N2040-45 Rev. B                                                                                     703
Hexagon V67 Programmer’s Reference Manual                                                          Intrinsics Index
Rdd=max(Rss,Rtt)               Word64 Q6_P_max_PP(Word64 Rss, Word64 Rtt)                                       402
maxu
Rd=maxu(Rs,Rt)                 UWord32 Q6_R_maxu_RR(Word32 Rs, Word32 Rt)                                       401
Rdd=maxu(Rss,Rtt)              UWord64 Q6_P_maxu_PP(Word64 Rss, Word64 Rtt)                                     402
memb
memb(Rx++#s4:0:circ(Mu))=Rt    void Q6_memb_IMR_circ(void** StartAddress, Word32 Is4_0, Word32 Mu, Word32 Rt, void*
                               BaseAddress)                                                                     309
memb(Rx++I:circ(Mu))=Rt        void Q6_memb_MR_circ(void** StartAddress, Word32 Mu, Word32 Rt, void* BaseAddress)
                               309
Rd=memb(Rx++#s4:0:circ(Mu))    Word32 Q6_R_memb_IM_circ(void** StartAddress, Word32 Is4_0, Word32 Mu, void* Base-
                               Address)                                                                         242
Rd=memb(Rx++I:circ(Mu))        Word32 Q6_R_memb_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress)       242
memd
memd(Rx++#s4:3:circ(Mu))=Rtt   void Q6_memd_IMP_circ(void** StartAddress, Word32 Is4_3, Word32 Mu, Word64 Rtt, void*
                               BaseAddress)                                                                     305
memd(Rx++I:circ(Mu))=Rtt       void Q6_memd_MP_circ(void** StartAddress, Word32 Mu, Word64 Rtt, void* BaseAddress)
                               305
Rdd=memd(Rx++#s4:3:circ(Mu))   Word32 Q6_R_memd_IM_circ(void** StartAddress, Word32 Is4_3, Word32 Mu, void* Base-
                               Address)                                                                         238
Rdd=memd(Rx++I:circ(Mu))       Word32 Q6_R_memd_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress)       238
memh
memh(Rx++#s4:1:circ(Mu))=Rt    void Q6_memh_IMR_circ(void** StartAddress, Word32 Is4_1, Word32 Mu, Word32 Rt, void*
                               BaseAddress)                                                                     315
memh(Rx++#s4:1:circ(Mu))=Rt.H  void Q6_memh_IMRh_circ(void** StartAddress, Word32 Is4_1, Word32 Mu, Word32 Rt,
                               void* BaseAddress)                                                               315
memh(Rx++I:circ(Mu))=Rt        void Q6_memh_MR_circ(void** StartAddress, Word32 Mu, Word32 Rt, void* BaseAddress)
                               315
memh(Rx++I:circ(Mu))=Rt.H      void Q6_memh_MRh_circ(void** StartAddress, Word32 Mu, Word32 Rt, void* BaseAddress)
                               315
Rd=memh(Rx++#s4:1:circ(Mu))    Word32 Q6_R_memh_IM_circ(void** StartAddress, Word32 Is4_1, Word32 Mu, void* Base-
                               Address)                                                                         252
Rd=memh(Rx++I:circ(Mu))        Word32 Q6_R_memh_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress)       252
memub
Rd=memub(Rx++#s4:0:circ(Mu))   Word32 Q6_R_memub_IM_circ(void** StartAddress, Word32 Is4_0, Word32 Mu, void* Ba-
                               seAddress)                                                                       257
Rd=memub(Rx++I:circ(Mu))       Word32 Q6_R_memub_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress) 257
memuh
Rd=memuh(Rx++#s4:1:circ(Mu))   Word32 Q6_R_memuh_IM_circ(void** StartAddress, Word32 Is4_1, Word32 Mu, void* Ba-
                               seAddress)                                                                       261
Rd=memuh(Rx++I:circ(Mu))       Word32 Q6_R_memuh_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress) 261
memw
memw(Rx++#s4:2:circ(Mu))=Rt    void Q6_memw_IMR_circ(void** StartAddress, Word32 Is4_2, Word32 Mu, Word32 Rt, void*
                               BaseAddress)                                                                     320
memw(Rx++I:circ(Mu))=Rt        void Q6_memw_MR_circ(void** StartAddress, Word32 Mu, Word32 Rt, void* BaseAddress)
                               320
Rd=memw(Rx++#s4:2:circ(Mu))    Word32 Q6_R_memw_IM_circ(void** StartAddress, Word32 Is4_2, Word32 Mu, void* Base-
                               Address)                                                                         265
80-N2040-45 Rev. B                                                                                              704
Hexagon V67 Programmer’s Reference Manual                                                       Intrinsics Index
Rd=memw(Rx++I:circ(Mu))        Word32 Q6_R_memw_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress)    265
min
Rd=min(Rt,Rs)                  Word32 Q6_R_min_RR(Word32 Rt, Word32 Rs)                                      403
Rdd=min(Rtt,Rss)               Word64 Q6_P_min_PP(Word64 Rtt, Word64 Rss)                                    404
minu
Rd=minu(Rt,Rs)                 UWord32 Q6_R_minu_RR(Word32 Rt, Word32 Rs)                                    403
Rdd=minu(Rtt,Rss)              UWord64 Q6_P_minu_PP(Word64 Rtt, Word64 Rss)                                  404
modwrap
Rd=modwrap(Rs,Rt)              Word32 Q6_R_modwrap_RR(Word32 Rs, Word32 Rt)                                  405
mpy
Rd=mpy(Rs,Rt.H):<<1:rnd:sat    Word32 Q6_R_mpy_RRh_s1_rnd_sat(Word32 Rs, Word32 Rt)                          566
Rd=mpy(Rs,Rt.H):<<1:sat        Word32 Q6_R_mpy_RRh_s1_sat(Word32 Rs, Word32 Rt)                              566
Rd=mpy(Rs,Rt.L):<<1:rnd:sat    Word32 Q6_R_mpy_RRl_s1_rnd_sat(Word32 Rs, Word32 Rt)                          566
Rd=mpy(Rs,Rt.L):<<1:sat        Word32 Q6_R_mpy_RRl_s1_sat(Word32 Rs, Word32 Rt)                              566
Rd=mpy(Rs,Rt)                  Word32 Q6_R_mpy_RR(Word32 Rs, Word32 Rt)                                      566
Rd=mpy(Rs,Rt):<<1              Word32 Q6_R_mpy_RR_s1(Word32 Rs, Word32 Rt)                                   566
Rd=mpy(Rs,Rt):<<1:sat          Word32 Q6_R_mpy_RR_s1_sat(Word32 Rs, Word32 Rt)                               566
Rd=mpy(Rs,Rt):rnd              Word32 Q6_R_mpy_RR_rnd(Word32 Rs, Word32 Rt)                                  566
Rd=mpy(Rs.H,Rt.H)              Word32 Q6_R_mpy_RhRh(Word32 Rs, Word32 Rt)                                    550
Rd=mpy(Rs.H,Rt.H):<<1          Word32 Q6_R_mpy_RhRh_s1(Word32 Rs, Word32 Rt)                                 550
Rd=mpy(Rs.H,Rt.H):<<1:rnd      Word32 Q6_R_mpy_RhRh_s1_rnd(Word32 Rs, Word32 Rt)                             550
Rd=mpy(Rs.H,Rt.H):<<1:rnd:sat  Word32 Q6_R_mpy_RhRh_s1_rnd_sat(Word32 Rs, Word32 Rt)                         550
Rd=mpy(Rs.H,Rt.H):<<1:sat      Word32 Q6_R_mpy_RhRh_s1_sat(Word32 Rs, Word32 Rt)                             550
Rd=mpy(Rs.H,Rt.H):rnd          Word32 Q6_R_mpy_RhRh_rnd(Word32 Rs, Word32 Rt)                                550
Rd=mpy(Rs.H,Rt.H):rnd:sat      Word32 Q6_R_mpy_RhRh_rnd_sat(Word32 Rs, Word32 Rt)                            550
Rd=mpy(Rs.H,Rt.H):sat          Word32 Q6_R_mpy_RhRh_sat(Word32 Rs, Word32 Rt)                                550
Rd=mpy(Rs.H,Rt.L)              Word32 Q6_R_mpy_RhRl(Word32 Rs, Word32 Rt)                                    550
Rd=mpy(Rs.H,Rt.L):<<1          Word32 Q6_R_mpy_RhRl_s1(Word32 Rs, Word32 Rt)                                 550
Rd=mpy(Rs.H,Rt.L):<<1:rnd      Word32 Q6_R_mpy_RhRl_s1_rnd(Word32 Rs, Word32 Rt)                             550
Rd=mpy(Rs.H,Rt.L):<<1:rnd:sat  Word32 Q6_R_mpy_RhRl_s1_rnd_sat(Word32 Rs, Word32 Rt)                         550
Rd=mpy(Rs.H,Rt.L):<<1:sat      Word32 Q6_R_mpy_RhRl_s1_sat(Word32 Rs, Word32 Rt)                             550
Rd=mpy(Rs.H,Rt.L):rnd          Word32 Q6_R_mpy_RhRl_rnd(Word32 Rs, Word32 Rt)                                550
Rd=mpy(Rs.H,Rt.L):rnd:sat      Word32 Q6_R_mpy_RhRl_rnd_sat(Word32 Rs, Word32 Rt)                            550
Rd=mpy(Rs.H,Rt.L):sat          Word32 Q6_R_mpy_RhRl_sat(Word32 Rs, Word32 Rt)                                550
Rd=mpy(Rs.L,Rt.H)              Word32 Q6_R_mpy_RlRh(Word32 Rs, Word32 Rt)                                    551
Rd=mpy(Rs.L,Rt.H):<<1          Word32 Q6_R_mpy_RlRh_s1(Word32 Rs, Word32 Rt)                                 551
Rd=mpy(Rs.L,Rt.H):<<1:rnd      Word32 Q6_R_mpy_RlRh_s1_rnd(Word32 Rs, Word32 Rt)                             551
Rd=mpy(Rs.L,Rt.H):<<1:rnd:sat  Word32 Q6_R_mpy_RlRh_s1_rnd_sat(Word32 Rs, Word32 Rt)                         551
Rd=mpy(Rs.L,Rt.H):<<1:sat      Word32 Q6_R_mpy_RlRh_s1_sat(Word32 Rs, Word32 Rt)                             551
Rd=mpy(Rs.L,Rt.H):rnd          Word32 Q6_R_mpy_RlRh_rnd(Word32 Rs, Word32 Rt)                                551
Rd=mpy(Rs.L,Rt.H):rnd:sat      Word32 Q6_R_mpy_RlRh_rnd_sat(Word32 Rs, Word32 Rt)                            551
Rd=mpy(Rs.L,Rt.H):sat          Word32 Q6_R_mpy_RlRh_sat(Word32 Rs, Word32 Rt)                                551
Rd=mpy(Rs.L,Rt.L)              Word32 Q6_R_mpy_RlRl(Word32 Rs, Word32 Rt)                                    551
Rd=mpy(Rs.L,Rt.L):<<1          Word32 Q6_R_mpy_RlRl_s1(Word32 Rs, Word32 Rt)                                 551
Rd=mpy(Rs.L,Rt.L):<<1:rnd      Word32 Q6_R_mpy_RlRl_s1_rnd(Word32 Rs, Word32 Rt)                             551
Rd=mpy(Rs.L,Rt.L):<<1:rnd:sat  Word32 Q6_R_mpy_RlRl_s1_rnd_sat(Word32 Rs, Word32 Rt)                         551
Rd=mpy(Rs.L,Rt.L):<<1:sat      Word32 Q6_R_mpy_RlRl_s1_sat(Word32 Rs, Word32 Rt)                             551
Rd=mpy(Rs.L,Rt.L):rnd          Word32 Q6_R_mpy_RlRl_rnd(Word32 Rs, Word32 Rt)                                551
Rd=mpy(Rs.L,Rt.L):rnd:sat      Word32 Q6_R_mpy_RlRl_rnd_sat(Word32 Rs, Word32 Rt)                            551
Rd=mpy(Rs.L,Rt.L):sat          Word32 Q6_R_mpy_RlRl_sat(Word32 Rs, Word32 Rt)                                551
80-N2040-45 Rev. B                                                                                           705
Hexagon V67 Programmer’s Reference Manual                                                      Intrinsics Index
Rdd=mpy(Rs,Rt)                 Word64 Q6_P_mpy_RR(Word32 Rs, Word32 Rt)                                     568
Rdd=mpy(Rs.H,Rt.H)             Word64 Q6_P_mpy_RhRh(Word32 Rs, Word32 Rt)                                   551
Rdd=mpy(Rs.H,Rt.H):<<1         Word64 Q6_P_mpy_RhRh_s1(Word32 Rs, Word32 Rt)                                551
Rdd=mpy(Rs.H,Rt.H):<<1:rnd     Word64 Q6_P_mpy_RhRh_s1_rnd(Word32 Rs, Word32 Rt)                            551
Rdd=mpy(Rs.H,Rt.H):rnd         Word64 Q6_P_mpy_RhRh_rnd(Word32 Rs, Word32 Rt)                               551
Rdd=mpy(Rs.H,Rt.L)             Word64 Q6_P_mpy_RhRl(Word32 Rs, Word32 Rt)                                   551
Rdd=mpy(Rs.H,Rt.L):<<1         Word64 Q6_P_mpy_RhRl_s1(Word32 Rs, Word32 Rt)                                551
Rdd=mpy(Rs.H,Rt.L):<<1:rnd     Word64 Q6_P_mpy_RhRl_s1_rnd(Word32 Rs, Word32 Rt)                            551
Rdd=mpy(Rs.H,Rt.L):rnd         Word64 Q6_P_mpy_RhRl_rnd(Word32 Rs, Word32 Rt)                               551
Rdd=mpy(Rs.L,Rt.H)             Word64 Q6_P_mpy_RlRh(Word32 Rs, Word32 Rt)                                   551
Rdd=mpy(Rs.L,Rt.H):<<1         Word64 Q6_P_mpy_RlRh_s1(Word32 Rs, Word32 Rt)                                551
Rdd=mpy(Rs.L,Rt.H):<<1:rnd     Word64 Q6_P_mpy_RlRh_s1_rnd(Word32 Rs, Word32 Rt)                            551
Rdd=mpy(Rs.L,Rt.H):rnd         Word64 Q6_P_mpy_RlRh_rnd(Word32 Rs, Word32 Rt)                               551
Rdd=mpy(Rs.L,Rt.L)             Word64 Q6_P_mpy_RlRl(Word32 Rs, Word32 Rt)                                   551
Rdd=mpy(Rs.L,Rt.L):<<1         Word64 Q6_P_mpy_RlRl_s1(Word32 Rs, Word32 Rt)                                551
Rdd=mpy(Rs.L,Rt.L):<<1:rnd     Word64 Q6_P_mpy_RlRl_s1_rnd(Word32 Rs, Word32 Rt)                            551
Rdd=mpy(Rs.L,Rt.L):rnd         Word64 Q6_P_mpy_RlRl_rnd(Word32 Rs, Word32 Rt)                               551
Rx+=mpy(Rs,Rt):<<1:sat         Word32 Q6_R_mpyacc_RR_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)                566
Rx+=mpy(Rs.H,Rt.H)             Word32 Q6_R_mpyacc_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)                     552
Rx+=mpy(Rs.H,Rt.H):<<1         Word32 Q6_R_mpyacc_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  552
Rx+=mpy(Rs.H,Rt.H):<<1:sat     Word32 Q6_R_mpyacc_RhRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              552
Rx+=mpy(Rs.H,Rt.H):sat         Word32 Q6_R_mpyacc_RhRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 552
Rx+=mpy(Rs.H,Rt.L)             Word32 Q6_R_mpyacc_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)                     552
Rx+=mpy(Rs.H,Rt.L):<<1         Word32 Q6_R_mpyacc_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  552
Rx+=mpy(Rs.H,Rt.L):<<1:sat     Word32 Q6_R_mpyacc_RhRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              552
Rx+=mpy(Rs.H,Rt.L):sat         Word32 Q6_R_mpyacc_RhRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 552
Rx+=mpy(Rs.L,Rt.H)             Word32 Q6_R_mpyacc_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)                     552
Rx+=mpy(Rs.L,Rt.H):<<1         Word32 Q6_R_mpyacc_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  552
Rx+=mpy(Rs.L,Rt.H):<<1:sat     Word32 Q6_R_mpyacc_RlRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              552
Rx+=mpy(Rs.L,Rt.H):sat         Word32 Q6_R_mpyacc_RlRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 552
Rx+=mpy(Rs.L,Rt.L)             Word32 Q6_R_mpyacc_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)                     552
Rx+=mpy(Rs.L,Rt.L):<<1         Word32 Q6_R_mpyacc_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  552
Rx+=mpy(Rs.L,Rt.L):<<1:sat     Word32 Q6_R_mpyacc_RlRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              552
Rx+=mpy(Rs.L,Rt.L):sat         Word32 Q6_R_mpyacc_RlRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 552
Rx-=mpy(Rs,Rt):<<1:sat         Word32 Q6_R_mpynac_RR_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)                566
Rx-=mpy(Rs.H,Rt.H)             Word32 Q6_R_mpynac_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)                     552
Rx-=mpy(Rs.H,Rt.H):<<1         Word32 Q6_R_mpynac_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  552
Rx-=mpy(Rs.H,Rt.H):<<1:sat     Word32 Q6_R_mpynac_RhRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              552
Rx-=mpy(Rs.H,Rt.H):sat         Word32 Q6_R_mpynac_RhRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 552
Rx-=mpy(Rs.H,Rt.L)             Word32 Q6_R_mpynac_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)                     552
Rx-=mpy(Rs.H,Rt.L):<<1         Word32 Q6_R_mpynac_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  552
Rx-=mpy(Rs.H,Rt.L):<<1:sat     Word32 Q6_R_mpynac_RhRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              552
Rx-=mpy(Rs.H,Rt.L):sat         Word32 Q6_R_mpynac_RhRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 552
Rx-=mpy(Rs.L,Rt.H)             Word32 Q6_R_mpynac_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)                     553
Rx-=mpy(Rs.L,Rt.H):<<1         Word32 Q6_R_mpynac_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  553
Rx-=mpy(Rs.L,Rt.H):<<1:sat     Word32 Q6_R_mpynac_RlRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              553
Rx-=mpy(Rs.L,Rt.H):sat         Word32 Q6_R_mpynac_RlRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 553
Rx-=mpy(Rs.L,Rt.L)             Word32 Q6_R_mpynac_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)                     553
Rx-=mpy(Rs.L,Rt.L):<<1         Word32 Q6_R_mpynac_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)                  553
Rx-=mpy(Rs.L,Rt.L):<<1:sat     Word32 Q6_R_mpynac_RlRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)              553
Rx-=mpy(Rs.L,Rt.L):sat         Word32 Q6_R_mpynac_RlRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)                 553
Rxx+=mpy(Rs,Rt)                Word64 Q6_P_mpyacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                      568
Rxx+=mpy(Rs.H,Rt.H)            Word64 Q6_P_mpyacc_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)                    553
Rxx+=mpy(Rs.H,Rt.H):<<1        Word64 Q6_P_mpyacc_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)                 553
80-N2040-45 Rev. B                                                                                          706
Hexagon V67 Programmer’s Reference Manual                                                   Intrinsics Index
Rxx+=mpy(Rs.H,Rt.L)            Word64 Q6_P_mpyacc_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 553
Rxx+=mpy(Rs.H,Rt.L):<<1        Word64 Q6_P_mpyacc_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              553
Rxx+=mpy(Rs.L,Rt.H)            Word64 Q6_P_mpyacc_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 553
Rxx+=mpy(Rs.L,Rt.H):<<1        Word64 Q6_P_mpyacc_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              553
Rxx+=mpy(Rs.L,Rt.L)            Word64 Q6_P_mpyacc_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 553
Rxx+=mpy(Rs.L,Rt.L):<<1        Word64 Q6_P_mpyacc_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              553
Rxx-=mpy(Rs,Rt)                Word64 Q6_P_mpynac_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                   568
Rxx-=mpy(Rs.H,Rt.H)            Word64 Q6_P_mpynac_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 553
Rxx-=mpy(Rs.H,Rt.H):<<1        Word64 Q6_P_mpynac_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              553
Rxx-=mpy(Rs.H,Rt.L)            Word64 Q6_P_mpynac_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 553
Rxx-=mpy(Rs.H,Rt.L):<<1        Word64 Q6_P_mpynac_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              553
Rxx-=mpy(Rs.L,Rt.H)            Word64 Q6_P_mpynac_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 553
Rxx-=mpy(Rs.L,Rt.H):<<1        Word64 Q6_P_mpynac_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              553
Rxx-=mpy(Rs.L,Rt.L)            Word64 Q6_P_mpynac_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 553
Rxx-=mpy(Rs.L,Rt.L):<<1        Word64 Q6_P_mpynac_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              553
mpyi
Rd=mpyi(Rs,#m9)                Word32 Q6_R_mpyi_RI(Word32 Rs, Word32 Im9)                                539
Rd=mpyi(Rs,Rt)                 Word32 Q6_R_mpyi_RR(Word32 Rs, Word32 Rt)                                 539
Rx+=mpyi(Rs,#u8)               Word32 Q6_R_mpyiacc_RI(Word32 Rx, Word32 Rs, Word32 Iu8)                  539
Rx+=mpyi(Rs,Rt)                Word32 Q6_R_mpyiacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   539
Rx-=mpyi(Rs,#u8)               Word32 Q6_R_mpyinac_RI(Word32 Rx, Word32 Rs, Word32 Iu8)                  539
Rx-=mpyi(Rs,Rt)                Word32 Q6_R_mpyinac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   539
mpysu
Rd=mpysu(Rs,Rt)                Word32 Q6_R_mpysu_RR(Word32 Rs, Word32 Rt)                                566
mpyu
Rd=mpyu(Rs,Rt)                 UWord32 Q6_R_mpyu_RR(Word32 Rs, Word32 Rt)                                566
Rd=mpyu(Rs.H,Rt.H)             UWord32 Q6_R_mpyu_RhRh(Word32 Rs, Word32 Rt)                              557
Rd=mpyu(Rs.H,Rt.H):<<1         UWord32 Q6_R_mpyu_RhRh_s1(Word32 Rs, Word32 Rt)                           557
Rd=mpyu(Rs.H,Rt.L)             UWord32 Q6_R_mpyu_RhRl(Word32 Rs, Word32 Rt)                              557
Rd=mpyu(Rs.H,Rt.L):<<1         UWord32 Q6_R_mpyu_RhRl_s1(Word32 Rs, Word32 Rt)                           557
Rd=mpyu(Rs.L,Rt.H)             UWord32 Q6_R_mpyu_RlRh(Word32 Rs, Word32 Rt)                              557
Rd=mpyu(Rs.L,Rt.H):<<1         UWord32 Q6_R_mpyu_RlRh_s1(Word32 Rs, Word32 Rt)                           557
Rd=mpyu(Rs.L,Rt.L)             UWord32 Q6_R_mpyu_RlRl(Word32 Rs, Word32 Rt)                              557
Rd=mpyu(Rs.L,Rt.L):<<1         UWord32 Q6_R_mpyu_RlRl_s1(Word32 Rs, Word32 Rt)                           557
Rdd=mpyu(Rs,Rt)                UWord64 Q6_P_mpyu_RR(Word32 Rs, Word32 Rt)                                568
Rdd=mpyu(Rs.H,Rt.H)            UWord64 Q6_P_mpyu_RhRh(Word32 Rs, Word32 Rt)                              557
Rdd=mpyu(Rs.H,Rt.H):<<1        UWord64 Q6_P_mpyu_RhRh_s1(Word32 Rs, Word32 Rt)                           557
Rdd=mpyu(Rs.H,Rt.L)            UWord64 Q6_P_mpyu_RhRl(Word32 Rs, Word32 Rt)                              557
Rdd=mpyu(Rs.H,Rt.L):<<1        UWord64 Q6_P_mpyu_RhRl_s1(Word32 Rs, Word32 Rt)                           557
Rdd=mpyu(Rs.L,Rt.H)            UWord64 Q6_P_mpyu_RlRh(Word32 Rs, Word32 Rt)                              557
Rdd=mpyu(Rs.L,Rt.H):<<1        UWord64 Q6_P_mpyu_RlRh_s1(Word32 Rs, Word32 Rt)                           557
Rdd=mpyu(Rs.L,Rt.L)            UWord64 Q6_P_mpyu_RlRl(Word32 Rs, Word32 Rt)                              557
Rdd=mpyu(Rs.L,Rt.L):<<1        UWord64 Q6_P_mpyu_RlRl_s1(Word32 Rs, Word32 Rt)                           557
Rx+=mpyu(Rs.H,Rt.H)            Word32 Q6_R_mpyuacc_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)                 557
Rx+=mpyu(Rs.H,Rt.H):<<1        Word32 Q6_R_mpyuacc_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)              557
Rx+=mpyu(Rs.H,Rt.L)            Word32 Q6_R_mpyuacc_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)                 557
Rx+=mpyu(Rs.H,Rt.L):<<1        Word32 Q6_R_mpyuacc_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)              557
Rx+=mpyu(Rs.L,Rt.H)            Word32 Q6_R_mpyuacc_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)                 557
Rx+=mpyu(Rs.L,Rt.H):<<1        Word32 Q6_R_mpyuacc_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)              557
Rx+=mpyu(Rs.L,Rt.L)            Word32 Q6_R_mpyuacc_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)                 557
Rx+=mpyu(Rs.L,Rt.L):<<1        Word32 Q6_R_mpyuacc_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)              557
80-N2040-45 Rev. B                                                                                       707
Hexagon V67 Programmer’s Reference Manual                                                    Intrinsics Index
Rx-=mpyu(Rs.H,Rt.H)            Word32 Q6_R_mpyunac_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)                  557
Rx-=mpyu(Rs.H,Rt.H):<<1        Word32 Q6_R_mpyunac_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)               557
Rx-=mpyu(Rs.H,Rt.L)            Word32 Q6_R_mpyunac_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)                  557
Rx-=mpyu(Rs.H,Rt.L):<<1        Word32 Q6_R_mpyunac_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)               557
Rx-=mpyu(Rs.L,Rt.H)            Word32 Q6_R_mpyunac_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)                  558
Rx-=mpyu(Rs.L,Rt.H):<<1        Word32 Q6_R_mpyunac_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)               558
Rx-=mpyu(Rs.L,Rt.L)            Word32 Q6_R_mpyunac_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)                  558
Rx-=mpyu(Rs.L,Rt.L):<<1        Word32 Q6_R_mpyunac_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)               558
Rxx+=mpyu(Rs,Rt)               Word64 Q6_P_mpyuacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                   568
Rxx+=mpyu(Rs.H,Rt.H)           Word64 Q6_P_mpyuacc_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 558
Rxx+=mpyu(Rs.H,Rt.H):<<1       Word64 Q6_P_mpyuacc_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              558
Rxx+=mpyu(Rs.H,Rt.L)           Word64 Q6_P_mpyuacc_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 558
Rxx+=mpyu(Rs.H,Rt.L):<<1       Word64 Q6_P_mpyuacc_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              558
Rxx+=mpyu(Rs.L,Rt.H)           Word64 Q6_P_mpyuacc_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 558
Rxx+=mpyu(Rs.L,Rt.H):<<1       Word64 Q6_P_mpyuacc_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              558
Rxx+=mpyu(Rs.L,Rt.L)           Word64 Q6_P_mpyuacc_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 558
Rxx+=mpyu(Rs.L,Rt.L):<<1       Word64 Q6_P_mpyuacc_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              558
Rxx-=mpyu(Rs,Rt)               Word64 Q6_P_mpyunac_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                   568
Rxx-=mpyu(Rs.H,Rt.H)           Word64 Q6_P_mpyunac_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 558
Rxx-=mpyu(Rs.H,Rt.H):<<1       Word64 Q6_P_mpyunac_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              558
Rxx-=mpyu(Rs.H,Rt.L)           Word64 Q6_P_mpyunac_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 558
Rxx-=mpyu(Rs.H,Rt.L):<<1       Word64 Q6_P_mpyunac_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              558
Rxx-=mpyu(Rs.L,Rt.H)           Word64 Q6_P_mpyunac_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)                 558
Rxx-=mpyu(Rs.L,Rt.H):<<1       Word64 Q6_P_mpyunac_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              558
Rxx-=mpyu(Rs.L,Rt.L)           Word64 Q6_P_mpyunac_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)                 558
Rxx-=mpyu(Rs.L,Rt.L):<<1       Word64 Q6_P_mpyunac_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)              558
mpyui
Rd=mpyui(Rs,Rt)                Word32 Q6_R_mpyui_RR(Word32 Rs, Word32 Rt)                                 539
mux
Rd=mux(Pu,#s8,#S8)             Word32 Q6_R_mux_pII(Byte Pu, Word32 Is8, Word32 IS8)                       188
Rd=mux(Pu,#s8,Rs)              Word32 Q6_R_mux_pIR(Byte Pu, Word32 Is8, Word32 Rs)                        188
Rd=mux(Pu,Rs,#s8)              Word32 Q6_R_mux_pRI(Byte Pu, Word32 Rs, Word32 Is8)                        188
Rd=mux(Pu,Rs,Rt)               Word32 Q6_R_mux_pRR(Byte Pu, Word32 Rs, Word32 Rt)                         188
N
neg
Rd=neg(Rs)                     Word32 Q6_R_neg_R(Word32 Rs)                                               173
Rd=neg(Rs):sat                 Word32 Q6_R_neg_R_sat(Word32 Rs)                                           406
Rdd=neg(Rss)                   Word64 Q6_P_neg_P(Word64 Rss)                                              406
no mnemonic
Pd=Ps                          Byte Q6_p_equals_p(Byte Ps)                                                218
Pd=Rs                          Byte Q6_p_equals_R(Word32 Rs)                                              628
Rd=#s16                        Word32 Q6_R_equals_I(Word32 Is16)                                          178
Rd=Ps                          Word32 Q6_R_equals_p(Byte Ps)                                              628
Rd=Rs                          Word32 Q6_R_equals_R(Word32 Rs)                                            180
Rdd=#s8                        Word64 Q6_P_equals_I(Word32 Is8)                                           178
Rdd=Rss                        Word64 Q6_P_equals_P(Word64 Rss)                                           180
Rx.H=#u16                      Word32 Q6_Rh_equals_I(Word32 Rx, Word32 Iu16)                              178
Rx.L=#u16                      Word32 Q6_Rl_equals_I(Word32 Rx, Word32 Iu16)                              178
80-N2040-45 Rev. B                                                                                        708
Hexagon V67 Programmer’s Reference Manual                                                 Intrinsics Index
normamt
Rd=normamt(Rs)                 Word32 Q6_R_normamt_R(Word32 Rs)                                        462
Rd=normamt(Rss)                Word32 Q6_R_normamt_P(Word64 Rss)                                       462
not
Pd=not(Ps)                     Byte Q6_p_not_p(Byte Ps)                                                218
Rd=not(Rs)                     Word32 Q6_R_not_R(Word32 Rs)                                            171
Rdd=not(Rss)                   Word64 Q6_P_not_P(Word64 Rss)                                           396
O
or
Pd=and(Ps,or(Pt,!Pu))          Byte Q6_p_and_or_ppnp(Byte Ps, Byte Pt, Byte Pu)                        218
Pd=and(Ps,or(Pt,Pu))           Byte Q6_p_and_or_ppp(Byte Ps, Byte Pt, Byte Pu)                         218
Pd=or(Ps,and(Pt,!Pu))          Byte Q6_p_or_and_ppnp(Byte Ps, Byte Pt, Byte Pu)                        218
Pd=or(Ps,and(Pt,Pu))           Byte Q6_p_or_and_ppp(Byte Ps, Byte Pt, Byte Pu)                         218
Pd=or(Ps,or(Pt,!Pu))           Byte Q6_p_or_or_ppnp(Byte Ps, Byte Pt, Byte Pu)                         219
Pd=or(Ps,or(Pt,Pu))            Byte Q6_p_or_or_ppp(Byte Ps, Byte Pt, Byte Pu)                          219
Pd=or(Pt,!Ps)                  Byte Q6_p_or_pnp(Byte Pt, Byte Ps)                                      219
Pd=or(Pt,Ps)                   Byte Q6_p_or_pp(Byte Pt, Byte Ps)                                       219
Rd=or(Rs,#s10)                 Word32 Q6_R_or_RI(Word32 Rs, Word32 Is10)                               171
Rd=or(Rs,Rt)                   Word32 Q6_R_or_RR(Word32 Rs, Word32 Rt)                                 171
Rd=or(Rt,~Rs)                  Word32 Q6_R_or_RnR(Word32 Rt, Word32 Rs)                                171
Rdd=or(Rss,Rtt)                Word64 Q6_P_or_PP(Word64 Rss, Word64 Rtt)                               396
Rdd=or(Rtt,~Rss)               Word64 Q6_P_or_PnP(Word64 Rtt, Word64 Rss)                              396
Rx^=or(Rs,Rt)                  Word32 Q6_R_orxacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  399
Rx&=or(Rs,Rt)                  Word32 Q6_R_orand_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   399
Rx=or(Ru,and(Rx,#s10))         Word32 Q6_R_or_and_RRI(Word32 Ru, Word32 Rx, Word32 Is10)               399
Rx|=or(Rs,#s10)                Word32 Q6_R_oror_RI(Word32 Rx, Word32 Rs, Word32 Is10)                  400
Rx|=or(Rs,Rt)                  Word32 Q6_R_oror_RR(Word32 Rx, Word32 Rs, Word32 Rt)                    400
P
packhl
Rdd=packhl(Rs,Rt)              Word64 Q6_P_packhl_RR(Word32 Rs, Word32 Rt)                             192
parity
Rd=parity(Rs,Rt)               Word32 Q6_R_parity_RR(Word32 Rs, Word32 Rt)                             473
Rd=parity(Rss,Rtt)             Word32 Q6_R_parity_PP(Word64 Rss, Word64 Rtt)                           473
pmpyw
Rdd=pmpyw(Rs,Rt)               Word64 Q6_P_pmpyw_RR(Word32 Rs, Word32 Rt)                              562
Rxx^=pmpyw(Rs,Rt)              Word64 Q6_P_pmpywxacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)              562
popcount
Rd=popcount(Rss)               Word32 Q6_R_popcount_P(Word64 Rss)                                      464
R
rol
Rd=rol(Rs,#u5)                 Word32 Q6_R_rol_RI(Word32 Rs, Word32 Iu5)                               641
Rdd=rol(Rss,#u6)               Word64 Q6_P_rol_PI(Word64 Rss, Word32 Iu6)                              641
Rx^=rol(Rs,#u5)                Word32 Q6_R_rolxacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                647
Rx&=rol(Rs,#u5)                Word32 Q6_R_roland_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 647
Rx+=rol(Rs,#u5)                Word32 Q6_R_rolacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 643
80-N2040-45 Rev. B                                                                                     709
Hexagon V67 Programmer’s Reference Manual                                                 Intrinsics Index
Rx-=rol(Rs,#u5)                Word32 Q6_R_rolnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                 643
Rx|=rol(Rs,#u5)                Word32 Q6_R_rolor_RI(Word32 Rx, Word32 Rs, Word32 Iu5)                  647
Rxx^=rol(Rss,#u6)              Word64 Q6_P_rolxacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)              648
Rxx&=rol(Rss,#u6)              Word64 Q6_P_roland_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               648
Rxx+=rol(Rss,#u6)              Word64 Q6_P_rolacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               643
Rxx-=rol(Rss,#u6)              Word64 Q6_P_rolnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)               643
Rxx|=rol(Rss,#u6)              Word64 Q6_P_rolor_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)                648
round
Rd=round(Rs,#u5)               Word32 Q6_R_round_RI(Word32 Rs, Word32 Iu5)                             408
Rd=round(Rs,#u5):sat           Word32 Q6_R_round_RI_sat(Word32 Rs, Word32 Iu5)                         408
Rd=round(Rs,Rt)                Word32 Q6_R_round_RR(Word32 Rs, Word32 Rt)                              408
Rd=round(Rs,Rt):sat            Word32 Q6_R_round_RR_sat(Word32 Rs, Word32 Rt)                          408
Rd=round(Rss):sat              Word32 Q6_R_round_P_sat(Word64 Rss)                                     408
S
sat
Rd=sat(Rss)                    Word32 Q6_R_sat_P(Word64 Rss)                                           595
satb
Rd=satb(Rs)                    Word32 Q6_R_satb_R(Word32 Rs)                                           595
sath
Rd=sath(Rs)                    Word32 Q6_R_sath_R(Word32 Rs)                                           595
satub
Rd=satub(Rs)                   Word32 Q6_R_satub_R(Word32 Rs)                                          595
satuh
Rd=satuh(Rs)                   Word32 Q6_R_satuh_R(Word32 Rs)                                          595
setbit
Rd=setbit(Rs,#u5)              Word32 Q6_R_setbit_RI(Word32 Rs, Word32 Iu5)                            475
Rd=setbit(Rs,Rt)               Word32 Q6_R_setbit_RR(Word32 Rs, Word32 Rt)                             475
sfadd
Rd=sfadd(Rs,Rt)                Word32 Q6_R_sfadd_RR(Word32 Rs, Word32 Rt)                              517
sfclass
Pd=sfclass(Rs,#u5)             Byte Q6_p_sfclass_RI(Word32 Rs, Word32 Iu5)                             518
sfcmp.eq
Pd=sfcmp.eq(Rs,Rt)             Byte Q6_p_sfcmp_eq_RR(Word32 Rs, Word32 Rt)                             519
sfcmp.ge
Pd=sfcmp.ge(Rs,Rt)             Byte Q6_p_sfcmp_ge_RR(Word32 Rs, Word32 Rt)                             519
sfcmp.gt
Pd=sfcmp.gt(Rs,Rt)             Byte Q6_p_sfcmp_gt_RR(Word32 Rs, Word32 Rt)                             519
sfcmp.uo
Pd=sfcmp.uo(Rs,Rt)             Byte Q6_p_sfcmp_uo_RR(Word32 Rs, Word32 Rt)                             519
80-N2040-45 Rev. B                                                                                     710
Hexagon V67 Programmer’s Reference Manual                                                     Intrinsics Index
sffixupd
Rd=sffixupd(Rs,Rt)             Word32 Q6_R_sffixupd_RR(Word32 Rs, Word32 Rt)                               526
sffixupn
Rd=sffixupn(Rs,Rt)             Word32 Q6_R_sffixupn_RR(Word32 Rs, Word32 Rt)                               526
sffixupr
Rd=sffixupr(Rs)                Word32 Q6_R_sffixupr_R(Word32 Rs)                                           526
sfmake
Rd=sfmake(#u10):neg            Word32 Q6_R_sfmake_I_neg(Word32 Iu10)                                       532
Rd=sfmake(#u10):pos            Word32 Q6_R_sfmake_I_pos(Word32 Iu10)                                       532
sfmax
Rd=sfmax(Rs,Rt)                Word32 Q6_R_sfmax_RR(Word32 Rs, Word32 Rt)                                  533
sfmin
Rd=sfmin(Rs,Rt)                Word32 Q6_R_sfmin_RR(Word32 Rs, Word32 Rt)                                  534
sfmpy
Rd=sfmpy(Rs,Rt)                Word32 Q6_R_sfmpy_RR(Word32 Rs, Word32 Rt)                                  535
Rx+=sfmpy(Rs,Rt,Pu):scale      Word32 Q6_R_sfmpyacc_RRp_scale(Word32 Rx, Word32 Rs, Word32 Rt, Byte Pu)    528
Rx+=sfmpy(Rs,Rt)               Word32 Q6_R_sfmpyacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                    527
Rx+=sfmpy(Rs,Rt):lib           Word32 Q6_R_sfmpyacc_RR_lib(Word32 Rx, Word32 Rs, Word32 Rt)                530
Rx-=sfmpy(Rs,Rt)               Word32 Q6_R_sfmpynac_RR(Word32 Rx, Word32 Rs, Word32 Rt)                    527
Rx-=sfmpy(Rs,Rt):lib           Word32 Q6_R_sfmpynac_RR_lib(Word32 Rx, Word32 Rs, Word32 Rt)                530
sfsub
Rd=sfsub(Rs,Rt)                Word32 Q6_R_sfsub_RR(Word32 Rs, Word32 Rt)                                  537
shuffeb
Rdd=shuffeb(Rss,Rtt)           Word64 Q6_P_shuffeb_PP(Word64 Rss, Word64 Rtt)                              608
shuffeh
Rdd=shuffeh(Rss,Rtt)           Word64 Q6_P_shuffeh_PP(Word64 Rss, Word64 Rtt)                              608
shuffob
Rdd=shuffob(Rtt,Rss)           Word64 Q6_P_shuffob_PP(Word64 Rtt, Word64 Rss)                              608
shuffoh
Rdd=shuffoh(Rtt,Rss)           Word64 Q6_P_shuffoh_PP(Word64 Rtt, Word64 Rss)                              608
sub
Rd=add(Rs,sub(#s6,Ru))         Word32 Q6_R_add_sub_RIR(Word32 Rs, Word32 Is6, Word32 Ru)                   388
Rd=sub(#s10,Rs)                Word32 Q6_R_sub_IR(Word32 Is10, Word32 Rs)                                  175
Rd=sub(Rt,Rs)                  Word32 Q6_R_sub_RR(Word32 Rt, Word32 Rs)                                    175
Rd=sub(Rt,Rs):sat              Word32 Q6_R_sub_RR_sat(Word32 Rt, Word32 Rs)                                175
Rd=sub(Rt.H,Rs.H):<<16         Word32 Q6_R_sub_RhRh_s16(Word32 Rt, Word32 Rs)                              413
Rd=sub(Rt.H,Rs.H):sat:<<16     Word32 Q6_R_sub_RhRh_sat_s16(Word32 Rt, Word32 Rs)                          413
Rd=sub(Rt.H,Rs.L):<<16         Word32 Q6_R_sub_RhRl_s16(Word32 Rt, Word32 Rs)                              413
Rd=sub(Rt.H,Rs.L):sat:<<16     Word32 Q6_R_sub_RhRl_sat_s16(Word32 Rt, Word32 Rs)                          413
Rd=sub(Rt.L,Rs.H)              Word32 Q6_R_sub_RlRh(Word32 Rt, Word32 Rs)                                  413
Rd=sub(Rt.L,Rs.H):<<16         Word32 Q6_R_sub_RlRh_s16(Word32 Rt, Word32 Rs)                              413
Rd=sub(Rt.L,Rs.H):sat          Word32 Q6_R_sub_RlRh_sat(Word32 Rt, Word32 Rs)                              413
80-N2040-45 Rev. B                                                                                         711
Hexagon V67 Programmer’s Reference Manual                                                       Intrinsics Index
Rd=sub(Rt.L,Rs.H):sat:<<16     Word32 Q6_R_sub_RlRh_sat_s16(Word32 Rt, Word32 Rs)                            413
Rd=sub(Rt.L,Rs.L)              Word32 Q6_R_sub_RlRl(Word32 Rt, Word32 Rs)                                    413
Rd=sub(Rt.L,Rs.L):<<16         Word32 Q6_R_sub_RlRl_s16(Word32 Rt, Word32 Rs)                                413
Rd=sub(Rt.L,Rs.L):sat          Word32 Q6_R_sub_RlRl_sat(Word32 Rt, Word32 Rs)                                413
Rd=sub(Rt.L,Rs.L):sat:<<16     Word32 Q6_R_sub_RlRl_sat_s16(Word32 Rt, Word32 Rs)                            413
Rdd=sub(Rtt,Rss)               Word64 Q6_P_sub_PP(Word64 Rtt, Word64 Rss)                                    410
Rx+=sub(Rt,Rs)                 Word32 Q6_R_subacc_RR(Word32 Rx, Word32 Rt, Word32 Rs)                        411
swiz
Rd=swiz(Rs)                    Word32 Q6_R_swiz_R(Word32 Rs)                                                 597
sxtb
Rd=sxtb(Rs)                    Word32 Q6_R_sxtb_R(Word32 Rs)                                                 177
sxth
Rd=sxth(Rs)                    Word32 Q6_R_sxth_R(Word32 Rs)                                                 177
sxtw
Rdd=sxtw(Rs)                   Word64 Q6_P_sxtw_R(Word32 Rs)                                                 414
T
tableidxb
Rx=tableidxb(Rs,#u4,#U5)       Word32 Q6_R_tableidxb_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)       480
tableidxd
Rx=tableidxd(Rs,#u4,#U5)       Word32 Q6_R_tableidxd_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)       480
tableidxh
Rx=tableidxh(Rs,#u4,#U5)       Word32 Q6_R_tableidxh_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)       480
tableidxw
Rx=tableidxw(Rs,#u4,#U5)       Word32 Q6_R_tableidxw_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)       480
tlbmatch
Pd=tlbmatch(Rss,Rt)            Byte Q6_p_tlbmatch_PR(Word64 Rss, Word32 Rt)                                  627
togglebit
Rd=togglebit(Rs,#u5)           Word32 Q6_R_togglebit_RI(Word32 Rs, Word32 Iu5)                               475
Rd=togglebit(Rs,Rt)            Word32 Q6_R_togglebit_RR(Word32 Rs, Word32 Rt)                                475
tstbit
Pd=!tstbit(Rs,#u5)             Byte Q6_p_not_tstbit_RI(Word32 Rs, Word32 Iu5)                                629
Pd=!tstbit(Rs,Rt)              Byte Q6_p_not_tstbit_RR(Word32 Rs, Word32 Rt)                                 629
Pd=tstbit(Rs,#u5)              Byte Q6_p_tstbit_RI(Word32 Rs, Word32 Iu5)                                    629
Pd=tstbit(Rs,Rt)               Byte Q6_p_tstbit_RR(Word32 Rs, Word32 Rt)                                     629
V
vabsdiffb
Rdd=vabsdiffb(Rtt,Rss)         Word64 Q6_P_vabsdiffb_PP(Word64 Rtt, Word64 Rss)                              417
vabsdiffh
Rdd=vabsdiffh(Rtt,Rss)         Word64 Q6_P_vabsdiffh_PP(Word64 Rtt, Word64 Rss)                              418
80-N2040-45 Rev. B                                                                                           712
Hexagon V67 Programmer’s Reference Manual                                                  Intrinsics Index
vabsdiffub
Rdd=vabsdiffub(Rtt,Rss)        Word64 Q6_P_vabsdiffub_PP(Word64 Rtt, Word64 Rss)                        417
vabsdiffw
Rdd=vabsdiffw(Rtt,Rss)         Word64 Q6_P_vabsdiffw_PP(Word64 Rtt, Word64 Rss)                         419
vabsh
Rdd=vabsh(Rss)                 Word64 Q6_P_vabsh_P(Word64 Rss)                                          415
Rdd=vabsh(Rss):sat             Word64 Q6_P_vabsh_P_sat(Word64 Rss)                                      415
vabsw
Rdd=vabsw(Rss)                 Word64 Q6_P_vabsw_P(Word64 Rss)                                          416
Rdd=vabsw(Rss):sat             Word64 Q6_P_vabsw_P_sat(Word64 Rss)                                      416
vaddb
Rdd=vaddb(Rss,Rtt)             Word64 Q6_P_vaddb_PP(Word64 Rss, Word64 Rtt)                             430
vaddh
Rd=vaddh(Rs,Rt)                Word32 Q6_R_vaddh_RR(Word32 Rs, Word32 Rt)                               181
Rd=vaddh(Rs,Rt):sat            Word32 Q6_R_vaddh_RR_sat(Word32 Rs, Word32 Rt)                           181
Rdd=vaddh(Rss,Rtt)             Word64 Q6_P_vaddh_PP(Word64 Rss, Word64 Rtt)                             423
Rdd=vaddh(Rss,Rtt):sat         Word64 Q6_P_vaddh_PP_sat(Word64 Rss, Word64 Rtt)                         423
vaddhub
Rd=vaddhub(Rss,Rtt):sat        Word32 Q6_R_vaddhub_PP_sat(Word64 Rss, Word64 Rtt)                       425
vaddub
Rdd=vaddub(Rss,Rtt)            Word64 Q6_P_vaddub_PP(Word64 Rss, Word64 Rtt)                            430
Rdd=vaddub(Rss,Rtt):sat        Word64 Q6_P_vaddub_PP_sat(Word64 Rss, Word64 Rtt)                        430
vadduh
Rd=vadduh(Rs,Rt):sat           Word32 Q6_R_vadduh_RR_sat(Word32 Rs, Word32 Rt)                          181
Rdd=vadduh(Rss,Rtt):sat        Word64 Q6_P_vadduh_PP_sat(Word64 Rss, Word64 Rtt)                        423
vaddw
Rdd=vaddw(Rss,Rtt)             Word64 Q6_P_vaddw_PP(Word64 Rss, Word64 Rtt)                             431
Rdd=vaddw(Rss,Rtt):sat         Word64 Q6_P_vaddw_PP_sat(Word64 Rss, Word64 Rtt)                         431
valignb
Rdd=valignb(Rtt,Rss,#u3)       Word64 Q6_P_valignb_PPI(Word64 Rtt, Word64 Rss, Word32 Iu3)              598
Rdd=valignb(Rtt,Rss,Pu)        Word64 Q6_P_valignb_PPp(Word64 Rtt, Word64 Rss, Byte Pu)                 598
vaslh
Rdd=vaslh(Rss,#u4)             Word64 Q6_P_vaslh_PI(Word64 Rss, Word32 Iu4)                             665
Rdd=vaslh(Rss,Rt)              Word64 Q6_P_vaslh_PR(Word64 Rss, Word32 Rt)                              672
vaslw
Rdd=vaslw(Rss,#u5)             Word64 Q6_P_vaslw_PI(Word64 Rss, Word32 Iu5)                             673
Rdd=vaslw(Rss,Rt)              Word64 Q6_P_vaslw_PR(Word64 Rss, Word32 Rt)                              676
vasrh
Rdd=vasrh(Rss,#u4)             Word64 Q6_P_vasrh_PI(Word64 Rss, Word32 Iu4)                             665
Rdd=vasrh(Rss,#u4):rnd         Word64 Q6_P_vasrh_PI_rnd(Word64 Rss, Word32 Iu4)                         667
Rdd=vasrh(Rss,Rt)              Word64 Q6_P_vasrh_PR(Word64 Rss, Word32 Rt)                              672
80-N2040-45 Rev. B                                                                                      713
Hexagon V67 Programmer’s Reference Manual                                             Intrinsics Index
vasrhub
Rd=vasrhub(Rss,#u4):rnd:sat    Word32 Q6_R_vasrhub_PI_rnd_sat(Word64 Rss, Word32 Iu4)              670
Rd=vasrhub(Rss,#u4):sat        Word32 Q6_R_vasrhub_PI_sat(Word64 Rss, Word32 Iu4)                  670
vasrw
Rd=vasrw(Rss,#u5)              Word32 Q6_R_vasrw_PI(Word64 Rss, Word32 Iu5)                        677
Rd=vasrw(Rss,Rt)               Word32 Q6_R_vasrw_PR(Word64 Rss, Word32 Rt)                         677
Rdd=vasrw(Rss,#u5)             Word64 Q6_P_vasrw_PI(Word64 Rss, Word32 Iu5)                        673
Rdd=vasrw(Rss,Rt)              Word64 Q6_P_vasrw_PR(Word64 Rss, Word32 Rt)                         676
vavgh
Rd=vavgh(Rs,Rt)                Word32 Q6_R_vavgh_RR(Word32 Rs, Word32 Rt)                          182
Rd=vavgh(Rs,Rt):rnd            Word32 Q6_R_vavgh_RR_rnd(Word32 Rs, Word32 Rt)                      182
Rdd=vavgh(Rss,Rtt)             Word64 Q6_P_vavgh_PP(Word64 Rss, Word64 Rtt)                        433
Rdd=vavgh(Rss,Rtt):crnd        Word64 Q6_P_vavgh_PP_crnd(Word64 Rss, Word64 Rtt)                   433
Rdd=vavgh(Rss,Rtt):rnd         Word64 Q6_P_vavgh_PP_rnd(Word64 Rss, Word64 Rtt)                    433
vavgub
Rdd=vavgub(Rss,Rtt)            Word64 Q6_P_vavgub_PP(Word64 Rss, Word64 Rtt)                       434
Rdd=vavgub(Rss,Rtt):rnd        Word64 Q6_P_vavgub_PP_rnd(Word64 Rss, Word64 Rtt)                   434
vavguh
Rdd=vavguh(Rss,Rtt)            Word64 Q6_P_vavguh_PP(Word64 Rss, Word64 Rtt)                       433
Rdd=vavguh(Rss,Rtt):rnd        Word64 Q6_P_vavguh_PP_rnd(Word64 Rss, Word64 Rtt)                   433
vavguw
Rdd=vavguw(Rss,Rtt)            Word64 Q6_P_vavguw_PP(Word64 Rss, Word64 Rtt)                       436
Rdd=vavguw(Rss,Rtt):rnd        Word64 Q6_P_vavguw_PP_rnd(Word64 Rss, Word64 Rtt)                   436
vavgw
Rdd=vavgw(Rss,Rtt)             Word64 Q6_P_vavgw_PP(Word64 Rss, Word64 Rtt)                        436
Rdd=vavgw(Rss,Rtt):crnd        Word64 Q6_P_vavgw_PP_crnd(Word64 Rss, Word64 Rtt)                   436
Rdd=vavgw(Rss,Rtt):rnd         Word64 Q6_P_vavgw_PP_rnd(Word64 Rss, Word64 Rtt)                    436
vclip
Rdd=vclip(Rss,#u5)             Word64 Q6_P_vclip_PI(Word64 Rss, Word32 Iu5)                        437
vcmpb.eq
Pd=!any8(vcmpb.eq(Rss,Rtt))    Byte Q6_p_not_any8_vcmpb_eq_PP(Word64 Rss, Word64 Rtt)              632
Pd=any8(vcmpb.eq(Rss,Rtt))     Byte Q6_p_any8_vcmpb_eq_PP(Word64 Rss, Word64 Rtt)                  632
Pd=vcmpb.eq(Rss,#u8)           Byte Q6_p_vcmpb_eq_PI(Word64 Rss, Word32 Iu8)                       634
Pd=vcmpb.eq(Rss,Rtt)           Byte Q6_p_vcmpb_eq_PP(Word64 Rss, Word64 Rtt)                       634
vcmpb.gt
Pd=vcmpb.gt(Rss,#s8)           Byte Q6_p_vcmpb_gt_PI(Word64 Rss, Word32 Is8)                       634
Pd=vcmpb.gt(Rss,Rtt)           Byte Q6_p_vcmpb_gt_PP(Word64 Rss, Word64 Rtt)                       634
vcmpb.gtu
Pd=vcmpb.gtu(Rss,#u7)          Byte Q6_p_vcmpb_gtu_PI(Word64 Rss, Word32 Iu7)                      634
Pd=vcmpb.gtu(Rss,Rtt)          Byte Q6_p_vcmpb_gtu_PP(Word64 Rss, Word64 Rtt)                      634
vcmph.eq
Pd=vcmph.eq(Rss,#s8)           Byte Q6_p_vcmph_eq_PI(Word64 Rss, Word32 Is8)                       631
Pd=vcmph.eq(Rss,Rtt)           Byte Q6_p_vcmph_eq_PP(Word64 Rss, Word64 Rtt)                       631
80-N2040-45 Rev. B                                                                                 714
Hexagon V67 Programmer’s Reference Manual                                                      Intrinsics Index
vcmph.gt
Pd=vcmph.gt(Rss,#s8)           Byte Q6_p_vcmph_gt_PI(Word64 Rss, Word32 Is8)                                631
Pd=vcmph.gt(Rss,Rtt)           Byte Q6_p_vcmph_gt_PP(Word64 Rss, Word64 Rtt)                                631
vcmph.gtu
Pd=vcmph.gtu(Rss,#u7)          Byte Q6_p_vcmph_gtu_PI(Word64 Rss, Word32 Iu7)                               631
Pd=vcmph.gtu(Rss,Rtt)          Byte Q6_p_vcmph_gtu_PP(Word64 Rss, Word64 Rtt)                               631
vcmpw.eq
Pd=vcmpw.eq(Rss,#s8)           Byte Q6_p_vcmpw_eq_PI(Word64 Rss, Word32 Is8)                                635
Pd=vcmpw.eq(Rss,Rtt)           Byte Q6_p_vcmpw_eq_PP(Word64 Rss, Word64 Rtt)                                635
vcmpw.gt
Pd=vcmpw.gt(Rss,#s8)           Byte Q6_p_vcmpw_gt_PI(Word64 Rss, Word32 Is8)                                635
Pd=vcmpw.gt(Rss,Rtt)           Byte Q6_p_vcmpw_gt_PP(Word64 Rss, Word64 Rtt)                                635
vcmpw.gtu
Pd=vcmpw.gtu(Rss,#u7)          Byte Q6_p_vcmpw_gtu_PI(Word64 Rss, Word32 Iu7)                               635
Pd=vcmpw.gtu(Rss,Rtt)          Byte Q6_p_vcmpw_gtu_PP(Word64 Rss, Word64 Rtt)                               635
vcmpyi
Rdd=vcmpyi(Rss,Rtt):<<1:sat    Word64 Q6_P_vcmpyi_PP_s1_sat(Word64 Rss, Word64 Rtt)                         501
Rdd=vcmpyi(Rss,Rtt):sat        Word64 Q6_P_vcmpyi_PP_sat(Word64 Rss, Word64 Rtt)                            501
Rxx+=vcmpyi(Rss,Rtt):sat       Word64 Q6_P_vcmpyiacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)             501
vcmpyr
Rdd=vcmpyr(Rss,Rtt):<<1:sat    Word64 Q6_P_vcmpyr_PP_s1_sat(Word64 Rss, Word64 Rtt)                         501
Rdd=vcmpyr(Rss,Rtt):sat        Word64 Q6_P_vcmpyr_PP_sat(Word64 Rss, Word64 Rtt)                            501
Rxx+=vcmpyr(Rss,Rtt):sat       Word64 Q6_P_vcmpyracc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)             501
vcnegh
Rdd=vcnegh(Rss,Rt)             Word64 Q6_P_vcnegh_PR(Word64 Rss, Word32 Rt)                                 439
vconj
Rdd=vconj(Rss):sat             Word64 Q6_P_vconj_P_sat(Word64 Rss)                                          503
vcrotate
Rdd=vcrotate(Rss,Rt)           Word64 Q6_P_vcrotate_PR(Word64 Rss, Word32 Rt)                               505
vdmpy
Rd=vdmpy(Rss,Rtt):<<1:rnd:sat  Word32 Q6_R_vdmpy_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)                      574
Rd=vdmpy(Rss,Rtt):rnd:sat      Word32 Q6_R_vdmpy_PP_rnd_sat(Word64 Rss, Word64 Rtt)                         574
Rdd=vdmpy(Rss,Rtt):<<1:sat     Word64 Q6_P_vdmpy_PP_s1_sat(Word64 Rss, Word64 Rtt)                          571
Rdd=vdmpy(Rss,Rtt):sat         Word64 Q6_P_vdmpy_PP_sat(Word64 Rss, Word64 Rtt)                             571
Rxx+=vdmpy(Rss,Rtt):<<1:sat    Word64 Q6_P_vdmpyacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)           571
Rxx+=vdmpy(Rss,Rtt):sat        Word64 Q6_P_vdmpyacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)              571
vdmpybsu
Rdd=vdmpybsu(Rss,Rtt):sat      Word64 Q6_P_vdmpybsu_PP_sat(Word64 Rss, Word64 Rtt)                          578
Rxx+=vdmpybsu(Rss,Rtt):sat     Word64 Q6_P_vdmpybsuacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)           578
vitpack
Rd=vitpack(Ps,Pt)              Word32 Q6_R_vitpack_pp(Byte Ps, Byte Pt)                                     637
80-N2040-45 Rev. B                                                                                          715
Hexagon V67 Programmer’s Reference Manual                                                  Intrinsics Index
vlslh
Rdd=vlslh(Rss,Rt)              Word64 Q6_P_vlslh_PR(Word64 Rss, Word32 Rt)                              672
vlslw
Rdd=vlslw(Rss,Rt)              Word64 Q6_P_vlslw_PR(Word64 Rss, Word32 Rt)                              676
vlsrh
Rdd=vlsrh(Rss,#u4)             Word64 Q6_P_vlsrh_PI(Word64 Rss, Word32 Iu4)                             665
Rdd=vlsrh(Rss,Rt)              Word64 Q6_P_vlsrh_PR(Word64 Rss, Word32 Rt)                              672
vlsrw
Rdd=vlsrw(Rss,#u5)             Word64 Q6_P_vlsrw_PI(Word64 Rss, Word32 Iu5)                             673
Rdd=vlsrw(Rss,Rt)              Word64 Q6_P_vlsrw_PR(Word64 Rss, Word32 Rt)                              676
vmaxb
Rdd=vmaxb(Rtt,Rss)             Word64 Q6_P_vmaxb_PP(Word64 Rtt, Word64 Rss)                             440
vmaxh
Rdd=vmaxh(Rtt,Rss)             Word64 Q6_P_vmaxh_PP(Word64 Rtt, Word64 Rss)                             441
vmaxub
Rdd=vmaxub(Rtt,Rss)            Word64 Q6_P_vmaxub_PP(Word64 Rtt, Word64 Rss)                            440
vmaxuh
Rdd=vmaxuh(Rtt,Rss)            Word64 Q6_P_vmaxuh_PP(Word64 Rtt, Word64 Rss)                            441
vmaxuw
Rdd=vmaxuw(Rtt,Rss)            Word64 Q6_P_vmaxuw_PP(Word64 Rtt, Word64 Rss)                            446
vmaxw
Rdd=vmaxw(Rtt,Rss)             Word64 Q6_P_vmaxw_PP(Word64 Rtt, Word64 Rss)                             446
vminb
Rdd=vminb(Rtt,Rss)             Word64 Q6_P_vminb_PP(Word64 Rtt, Word64 Rss)                             447
vminh
Rdd=vminh(Rtt,Rss)             Word64 Q6_P_vminh_PP(Word64 Rtt, Word64 Rss)                             448
vminub
Rdd=vminub(Rtt,Rss)            Word64 Q6_P_vminub_PP(Word64 Rtt, Word64 Rss)                            447
vminuh
Rdd=vminuh(Rtt,Rss)            Word64 Q6_P_vminuh_PP(Word64 Rtt, Word64 Rss)                            448
vminuw
Rdd=vminuw(Rtt,Rss)            Word64 Q6_P_vminuw_PP(Word64 Rtt, Word64 Rss)                            453
vminw
Rdd=vminw(Rtt,Rss)             Word64 Q6_P_vminw_PP(Word64 Rtt, Word64 Rss)                             453
vmpybsu
Rdd=vmpybsu(Rs,Rt)             Word64 Q6_P_vmpybsu_RR(Word32 Rs, Word32 Rt)                             590
Rxx+=vmpybsu(Rs,Rt)            Word64 Q6_P_vmpybsuacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)              590
80-N2040-45 Rev. B                                                                                      716
Hexagon V67 Programmer’s Reference Manual                                                        Intrinsics Index
vmpybu
Rdd=vmpybu(Rs,Rt)                  Word64 Q6_P_vmpybu_RR(Word32 Rs, Word32 Rt)                                590
Rxx+=vmpybu(Rs,Rt)                 Word64 Q6_P_vmpybuacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                 590
vmpyeh
Rdd=vmpyeh(Rss,Rtt):<<1:sat        Word64 Q6_P_vmpyeh_PP_s1_sat(Word64 Rss, Word64 Rtt)                       580
Rdd=vmpyeh(Rss,Rtt):sat            Word64 Q6_P_vmpyeh_PP_sat(Word64 Rss, Word64 Rtt)                          580
Rxx+=vmpyeh(Rss,Rtt)               Word64 Q6_P_vmpyehacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)               580
Rxx+=vmpyeh(Rss,Rtt):<<1:sat       Word64 Q6_P_vmpyehacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)        580
Rxx+=vmpyeh(Rss,Rtt):sat           Word64 Q6_P_vmpyehacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)           580
vmpyh
Rd=vmpyh(Rs,Rt):<<1:rnd:sat        Word32 Q6_R_vmpyh_RR_s1_rnd_sat(Word32 Rs, Word32 Rt)                      584
Rd=vmpyh(Rs,Rt):rnd:sat            Word32 Q6_R_vmpyh_RR_rnd_sat(Word32 Rs, Word32 Rt)                         584
Rdd=vmpyh(Rs,Rt):<<1:sat           Word64 Q6_P_vmpyh_RR_s1_sat(Word32 Rs, Word32 Rt)                          582
Rdd=vmpyh(Rs,Rt):sat               Word64 Q6_P_vmpyh_RR_sat(Word32 Rs, Word32 Rt)                             582
Rxx+=vmpyh(Rs,Rt)                  Word64 Q6_P_vmpyhacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                  582
Rxx+=vmpyh(Rs,Rt):<<1:sat          Word64 Q6_P_vmpyhacc_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)           582
Rxx+=vmpyh(Rs,Rt):sat              Word64 Q6_P_vmpyhacc_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)              582
vmpyhsu
Rdd=vmpyhsu(Rs,Rt):<<1:sat         Word64 Q6_P_vmpyhsu_RR_s1_sat(Word32 Rs, Word32 Rt)                        585
Rdd=vmpyhsu(Rs,Rt):sat             Word64 Q6_P_vmpyhsu_RR_sat(Word32 Rs, Word32 Rt)                           585
Rxx+=vmpyhsu(Rs,Rt):<<1:sat        Word64 Q6_P_vmpyhsuacc_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)         585
Rxx+=vmpyhsu(Rs,Rt):sat            Word64 Q6_P_vmpyhsuacc_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)            585
vmpyweh
Rdd=vmpyweh(Rss,Rtt):<<1:rnd:sat   Word64 Q6_P_vmpyweh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)                  543
Rdd=vmpyweh(Rss,Rtt):<<1:sat       Word64 Q6_P_vmpyweh_PP_s1_sat(Word64 Rss, Word64 Rtt)                      543
Rdd=vmpyweh(Rss,Rtt):rnd:sat       Word64 Q6_P_vmpyweh_PP_rnd_sat(Word64 Rss, Word64 Rtt)                     543
Rdd=vmpyweh(Rss,Rtt):sat           Word64 Q6_P_vmpyweh_PP_sat(Word64 Rss, Word64 Rtt)                         543
Rxx+=vmpyweh(Rss,Rtt):<<1:rnd:sat  Word64 Q6_P_vmpywehacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 543
Rxx+=vmpyweh(Rss,Rtt):<<1:sat      Word64 Q6_P_vmpywehacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)       543
Rxx+=vmpyweh(Rss,Rtt):rnd:sat      Word64 Q6_P_vmpywehacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)      543
Rxx+=vmpyweh(Rss,Rtt):sat          Word64 Q6_P_vmpywehacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)          543
vmpyweuh
Rdd=vmpyweuh(Rss,Rtt):<<1:rnd:sat  Word64 Q6_P_vmpyweuh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)                 547
Rdd=vmpyweuh(Rss,Rtt):<<1:sat      Word64 Q6_P_vmpyweuh_PP_s1_sat(Word64 Rss, Word64 Rtt)                     547
Rdd=vmpyweuh(Rss,Rtt):rnd:sat      Word64 Q6_P_vmpyweuh_PP_rnd_sat(Word64 Rss, Word64 Rtt)                    547
Rdd=vmpyweuh(Rss,Rtt):sat          Word64 Q6_P_vmpyweuh_PP_sat(Word64 Rss, Word64 Rtt)                        547
Rxx+=vmpyweuh(Rss,Rtt):<<1:rnd:sat Word64 Q6_P_vmpyweuhacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 547
Rxx+=vmpyweuh(Rss,Rtt):<<1:sat     Word64 Q6_P_vmpyweuhacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)      547
Rxx+=vmpyweuh(Rss,Rtt):rnd:sat     Word64 Q6_P_vmpyweuhacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)     547
Rxx+=vmpyweuh(Rss,Rtt):sat         Word64 Q6_P_vmpyweuhacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)         547
vmpywoh
Rdd=vmpywoh(Rss,Rtt):<<1:rnd:sat   Word64 Q6_P_vmpywoh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)                  543
Rdd=vmpywoh(Rss,Rtt):<<1:sat       Word64 Q6_P_vmpywoh_PP_s1_sat(Word64 Rss, Word64 Rtt)                      543
Rdd=vmpywoh(Rss,Rtt):rnd:sat       Word64 Q6_P_vmpywoh_PP_rnd_sat(Word64 Rss, Word64 Rtt)                     543
Rdd=vmpywoh(Rss,Rtt):sat           Word64 Q6_P_vmpywoh_PP_sat(Word64 Rss, Word64 Rtt)                         543
Rxx+=vmpywoh(Rss,Rtt):<<1:rnd:sat  Word64 Q6_P_vmpywohacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 543
Rxx+=vmpywoh(Rss,Rtt):<<1:sat      Word64 Q6_P_vmpywohacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)       543
Rxx+=vmpywoh(Rss,Rtt):rnd:sat      Word64 Q6_P_vmpywohacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)      543
80-N2040-45 Rev. B                                                                                            717
Hexagon V67 Programmer’s Reference Manual                                                         Intrinsics Index
Rxx+=vmpywoh(Rss,Rtt):sat          Word64 Q6_P_vmpywohacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)           543
vmpywouh
Rdd=vmpywouh(Rss,Rtt):<<1:rnd:sat  Word64 Q6_P_vmpywouh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)                  547
Rdd=vmpywouh(Rss,Rtt):<<1:sat      Word64 Q6_P_vmpywouh_PP_s1_sat(Word64 Rss, Word64 Rtt)                      547
Rdd=vmpywouh(Rss,Rtt):rnd:sat      Word64 Q6_P_vmpywouh_PP_rnd_sat(Word64 Rss, Word64 Rtt)                     547
Rdd=vmpywouh(Rss,Rtt):sat          Word64 Q6_P_vmpywouh_PP_sat(Word64 Rss, Word64 Rtt)                         547
Rxx+=vmpywouh(Rss,Rtt):<<1:rnd:sat Word64 Q6_P_vmpywouhacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 547
Rxx+=vmpywouh(Rss,Rtt):<<1:sat     Word64 Q6_P_vmpywouhacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)       547
Rxx+=vmpywouh(Rss,Rtt):rnd:sat     Word64 Q6_P_vmpywouhacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)      547
Rxx+=vmpywouh(Rss,Rtt):sat         Word64 Q6_P_vmpywouhacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)          547
vmux
Rdd=vmux(Pu,Rss,Rtt)               Word64 Q6_P_vmux_pPP(Byte Pu, Word64 Rss, Word64 Rtt)                       638
vnavgh
Rd=vnavgh(Rt,Rs)                   Word32 Q6_R_vnavgh_RR(Word32 Rt, Word32 Rs)                                 182
Rdd=vnavgh(Rtt,Rss)                Word64 Q6_P_vnavgh_PP(Word64 Rtt, Word64 Rss)                               433
Rdd=vnavgh(Rtt,Rss):crnd:sat       Word64 Q6_P_vnavgh_PP_crnd_sat(Word64 Rtt, Word64 Rss)                      433
Rdd=vnavgh(Rtt,Rss):rnd:sat        Word64 Q6_P_vnavgh_PP_rnd_sat(Word64 Rtt, Word64 Rss)                       433
vnavgw
Rdd=vnavgw(Rtt,Rss)                Word64 Q6_P_vnavgw_PP(Word64 Rtt, Word64 Rss)                               436
Rdd=vnavgw(Rtt,Rss):crnd:sat       Word64 Q6_P_vnavgw_PP_crnd_sat(Word64 Rtt, Word64 Rss)                      436
Rdd=vnavgw(Rtt,Rss):rnd:sat        Word64 Q6_P_vnavgw_PP_rnd_sat(Word64 Rtt, Word64 Rss)                       436
vpmpyh
Rdd=vpmpyh(Rs,Rt)                  Word64 Q6_P_vpmpyh_RR(Word32 Rs, Word32 Rt)                                 592
Rxx^=vpmpyh(Rs,Rt)                 Word64 Q6_P_vpmpyhxacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)                 592
vraddh
Rd=vraddh(Rss,Rtt)                 Word32 Q6_R_vraddh_PP(Word64 Rss, Word64 Rtt)                               428
vraddub
Rdd=vraddub(Rss,Rtt)               Word64 Q6_P_vraddub_PP(Word64 Rss, Word64 Rtt)                              426
Rxx+=vraddub(Rss,Rtt)              Word64 Q6_P_vraddubacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)               426
vradduh
Rd=vradduh(Rss,Rtt)                Word32 Q6_R_vradduh_PP(Word64 Rss, Word64 Rtt)                              428
vrcmpyi
Rdd=vrcmpyi(Rss,Rtt)               Word64 Q6_P_vrcmpyi_PP(Word64 Rss, Word64 Rtt)                              507
Rdd=vrcmpyi(Rss,Rtt*)              Word64 Q6_P_vrcmpyi_PP_conj(Word64 Rss, Word64 Rtt)                         507
Rxx+=vrcmpyi(Rss,Rtt)              Word64 Q6_P_vrcmpyiacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)               507
Rxx+=vrcmpyi(Rss,Rtt*)             Word64 Q6_P_vrcmpyiacc_PP_conj(Word64 Rxx, Word64 Rss, Word64 Rtt)          507
vrcmpyr
Rdd=vrcmpyr(Rss,Rtt)               Word64 Q6_P_vrcmpyr_PP(Word64 Rss, Word64 Rtt)                              507
Rdd=vrcmpyr(Rss,Rtt*)              Word64 Q6_P_vrcmpyr_PP_conj(Word64 Rss, Word64 Rtt)                         507
Rxx+=vrcmpyr(Rss,Rtt)              Word64 Q6_P_vrcmpyracc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)               507
Rxx+=vrcmpyr(Rss,Rtt*)             Word64 Q6_P_vrcmpyracc_PP_conj(Word64 Rxx, Word64 Rss, Word64 Rtt)          507
vrcmpys
Rd=vrcmpys(Rss,Rt):<<1:rnd:sat     Word32 Q6_R_vrcmpys_PR_s1_rnd_sat(Word64 Rss, Word32 Rt)                    513
80-N2040-45 Rev. B                                                                                             718
Hexagon V67 Programmer’s Reference Manual                                                       Intrinsics Index
Rdd=vrcmpys(Rss,Rt):<<1:sat    Word64 Q6_P_vrcmpys_PR_s1_sat(Word64 Rss, Word32 Rt)                          510
Rxx+=vrcmpys(Rss,Rt):<<1:sat   Word64 Q6_P_vrcmpysacc_PR_s1_sat(Word64 Rxx, Word64 Rss, Word32 Rt)           510
vrcnegh
Rxx+=vrcnegh(Rss,Rt)           Word64 Q6_P_vrcneghacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)                  454
vrcrotate
Rdd=vrcrotate(Rss,Rt,#u2)      Word64 Q6_P_vrcrotate_PRI(Word64 Rss, Word32 Rt, Word32 Iu2)                  515
Rxx+=vrcrotate(Rss,Rt,#u2)     Word64 Q6_P_vrcrotateacc_PRI(Word64 Rxx, Word64 Rss, Word32 Rt, Word32 Iu2) 515
vrmaxh
Rxx=vrmaxh(Rss,Ru)             Word64 Q6_P_vrmaxh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                      442
vrmaxuh
Rxx=vrmaxuh(Rss,Ru)            Word64 Q6_P_vrmaxuh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                     442
vrmaxuw
Rxx=vrmaxuw(Rss,Ru)            Word64 Q6_P_vrmaxuw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                     444
vrmaxw
Rxx=vrmaxw(Rss,Ru)             Word64 Q6_P_vrmaxw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                      444
vrminh
Rxx=vrminh(Rss,Ru)             Word64 Q6_P_vrminh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                      449
vrminuh
Rxx=vrminuh(Rss,Ru)            Word64 Q6_P_vrminuh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                     449
vrminuw
Rxx=vrminuw(Rss,Ru)            Word64 Q6_P_vrminuw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                     451
vrminw
Rxx=vrminw(Rss,Ru)             Word64 Q6_P_vrminw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)                      451
vrmpybsu
Rdd=vrmpybsu(Rss,Rtt)          Word64 Q6_P_vrmpybsu_PP(Word64 Rss, Word64 Rtt)                               576
Rxx+=vrmpybsu(Rss,Rtt)         Word64 Q6_P_vrmpybsuacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)                576
vrmpybu
Rdd=vrmpybu(Rss,Rtt)           Word64 Q6_P_vrmpybu_PP(Word64 Rss, Word64 Rtt)                                576
Rxx+=vrmpybu(Rss,Rtt)          Word64 Q6_P_vrmpybuacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)                 576
vrmpyh
Rdd=vrmpyh(Rss,Rtt)            Word64 Q6_P_vrmpyh_PP(Word64 Rss, Word64 Rtt)                                 587
Rxx+=vrmpyh(Rss,Rtt)           Word64 Q6_P_vrmpyhacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)                  587
vrmpyweh
Rdd=vrmpyweh(Rss,Rtt)          Word64 Q6_P_vrmpyweh_PP(Word64 Rss, Word64 Rtt)                               564
Rdd=vrmpyweh(Rss,Rtt):<<1      Word64 Q6_P_vrmpyweh_PP_s1(Word64 Rss, Word64 Rtt)                            564
Rxx+=vrmpyweh(Rss,Rtt)         Word64 Q6_P_vrmpywehacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)                564
Rxx+=vrmpyweh(Rss,Rtt):<<1     Word64 Q6_P_vrmpywehacc_PP_s1(Word64 Rxx, Word64 Rss, Word64 Rtt)             564
vrmpywoh
Rdd=vrmpywoh(Rss,Rtt)          Word64 Q6_P_vrmpywoh_PP(Word64 Rss, Word64 Rtt)                               564
80-N2040-45 Rev. B                                                                                           719
Hexagon V67 Programmer’s Reference Manual                                                     Intrinsics Index
Rdd=vrmpywoh(Rss,Rtt):<<1      Word64 Q6_P_vrmpywoh_PP_s1(Word64 Rss, Word64 Rtt)                          564
Rxx+=vrmpywoh(Rss,Rtt)         Word64 Q6_P_vrmpywohacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)              564
Rxx+=vrmpywoh(Rss,Rtt):<<1     Word64 Q6_P_vrmpywohacc_PP_s1(Word64 Rxx, Word64 Rss, Word64 Rtt)           564
vrndwh
Rd=vrndwh(Rss)                 Word32 Q6_R_vrndwh_P(Word64 Rss)                                            600
Rd=vrndwh(Rss):sat             Word32 Q6_R_vrndwh_P_sat(Word64 Rss)                                        600
vrsadub
Rdd=vrsadub(Rss,Rtt)           Word64 Q6_P_vrsadub_PP(Word64 Rss, Word64 Rtt)                              456
Rxx+=vrsadub(Rss,Rtt)          Word64 Q6_P_vrsadubacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)               456
vsathb
Rd=vsathb(Rs)                  Word32 Q6_R_vsathb_R(Word32 Rs)                                             603
Rd=vsathb(Rss)                 Word32 Q6_R_vsathb_P(Word64 Rss)                                            603
Rdd=vsathb(Rss)                Word64 Q6_P_vsathb_P(Word64 Rss)                                            606
vsathub
Rd=vsathub(Rs)                 Word32 Q6_R_vsathub_R(Word32 Rs)                                            603
Rd=vsathub(Rss)                Word32 Q6_R_vsathub_P(Word64 Rss)                                           603
Rdd=vsathub(Rss)               Word64 Q6_P_vsathub_P(Word64 Rss)                                           606
vsatwh
Rd=vsatwh(Rss)                 Word32 Q6_R_vsatwh_P(Word64 Rss)                                            603
Rdd=vsatwh(Rss)                Word64 Q6_P_vsatwh_P(Word64 Rss)                                            606
vsatwuh
Rd=vsatwuh(Rss)                Word32 Q6_R_vsatwuh_P(Word64 Rss)                                           603
Rdd=vsatwuh(Rss)               Word64 Q6_P_vsatwuh_P(Word64 Rss)                                           606
vsplatb
Rd=vsplatb(Rs)                 Word32 Q6_R_vsplatb_R(Word32 Rs)                                            609
Rdd=vsplatb(Rs)                Word64 Q6_P_vsplatb_R(Word32 Rs)                                            609
vsplath
Rdd=vsplath(Rs)                Word64 Q6_P_vsplath_R(Word32 Rs)                                            610
vspliceb
Rdd=vspliceb(Rss,Rtt,#u3)      Word64 Q6_P_vspliceb_PPI(Word64 Rss, Word64 Rtt, Word32 Iu3)                611
Rdd=vspliceb(Rss,Rtt,Pu)       Word64 Q6_P_vspliceb_PPp(Word64 Rss, Word64 Rtt, Byte Pu)                   611
vsubb
Rdd=vsubb(Rss,Rtt)             Word64 Q6_P_vsubb_PP(Word64 Rss, Word64 Rtt)                                459
vsubh
Rd=vsubh(Rt,Rs)                Word32 Q6_R_vsubh_RR(Word32 Rt, Word32 Rs)                                  183
Rd=vsubh(Rt,Rs):sat            Word32 Q6_R_vsubh_RR_sat(Word32 Rt, Word32 Rs)                              183
Rdd=vsubh(Rtt,Rss)             Word64 Q6_P_vsubh_PP(Word64 Rtt, Word64 Rss)                                457
Rdd=vsubh(Rtt,Rss):sat         Word64 Q6_P_vsubh_PP_sat(Word64 Rtt, Word64 Rss)                            457
vsubub
Rdd=vsubub(Rtt,Rss)            Word64 Q6_P_vsubub_PP(Word64 Rtt, Word64 Rss)                               459
Rdd=vsubub(Rtt,Rss):sat        Word64 Q6_P_vsubub_PP_sat(Word64 Rtt, Word64 Rss)                           459
80-N2040-45 Rev. B                                                                                         720
Hexagon V67 Programmer’s Reference Manual                                                       Intrinsics Index
vsubuh
Rd=vsubuh(Rt,Rs):sat               Word32 Q6_R_vsubuh_RR_sat(Word32 Rt, Word32 Rs)                           183
Rdd=vsubuh(Rtt,Rss):sat            Word64 Q6_P_vsubuh_PP_sat(Word64 Rtt, Word64 Rss)                         457
vsubw
Rdd=vsubw(Rtt,Rss)                 Word64 Q6_P_vsubw_PP(Word64 Rtt, Word64 Rss)                              460
Rdd=vsubw(Rtt,Rss):sat             Word64 Q6_P_vsubw_PP_sat(Word64 Rtt, Word64 Rss)                          460
vsxtbh
Rdd=vsxtbh(Rs)                     Word64 Q6_P_vsxtbh_R(Word32 Rs)                                           612
vsxthw
Rdd=vsxthw(Rs)                     Word64 Q6_P_vsxthw_R(Word32 Rs)                                           612
vtrunehb
Rd=vtrunehb(Rss)                   Word32 Q6_R_vtrunehb_P(Word64 Rss)                                        615
Rdd=vtrunehb(Rss,Rtt)              Word64 Q6_P_vtrunehb_PP(Word64 Rss, Word64 Rtt)                           615
vtrunewh
Rdd=vtrunewh(Rss,Rtt)              Word64 Q6_P_vtrunewh_PP(Word64 Rss, Word64 Rtt)                           615
vtrunohb
Rd=vtrunohb(Rss)                   Word32 Q6_R_vtrunohb_P(Word64 Rss)                                        615
Rdd=vtrunohb(Rss,Rtt)              Word64 Q6_P_vtrunohb_PP(Word64 Rss, Word64 Rtt)                           615
vtrunowh
Rdd=vtrunowh(Rss,Rtt)              Word64 Q6_P_vtrunowh_PP(Word64 Rss, Word64 Rtt)                           615
vxaddsubh
Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat Word64 Q6_P_vxaddsubh_PP_rnd_rs1_sat(Word64 Rss, Word64 Rtt)              483
Rdd=vxaddsubh(Rss,Rtt):sat         Word64 Q6_P_vxaddsubh_PP_sat(Word64 Rss, Word64 Rtt)                      483
vxaddsubw
Rdd=vxaddsubw(Rss,Rtt):sat         Word64 Q6_P_vxaddsubw_PP_sat(Word64 Rss, Word64 Rtt)                      485
vxsubaddh
Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat Word64 Q6_P_vxsubaddh_PP_rnd_rs1_sat(Word64 Rss, Word64 Rtt)              483
Rdd=vxsubaddh(Rss,Rtt):sat         Word64 Q6_P_vxsubaddh_PP_sat(Word64 Rss, Word64 Rtt)                      483
vxsubaddw
Rdd=vxsubaddw(Rss,Rtt):sat         Word64 Q6_P_vxsubaddw_PP_sat(Word64 Rss, Word64 Rtt)                      485
vzxtbh
Rdd=vzxtbh(Rs)                     Word64 Q6_P_vzxtbh_R(Word32 Rs)                                           616
vzxthw
Rdd=vzxthw(Rs)                     Word64 Q6_P_vzxthw_R(Word32 Rs)                                           616
X
xor
Pd=xor(Ps,Pt)                      Byte Q6_p_xor_pp(Byte Ps, Byte Pt)                                        219
Rd=xor(Rs,Rt)                      Word32 Q6_R_xor_RR(Word32 Rs, Word32 Rt)                                  171
Rdd=xor(Rss,Rtt)                   Word64 Q6_P_xor_PP(Word64 Rss, Word64 Rtt)                                396
80-N2040-45 Rev. B                                                                                           721
Hexagon V67 Programmer’s Reference Manual                                                 Intrinsics Index
Rx^=xor(Rs,Rt)                 Word32 Q6_R_xorxacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)                 399
Rx&=xor(Rs,Rt)                 Word32 Q6_R_xorand_RR(Word32 Rx, Word32 Rs, Word32 Rt)                  399
Rx|=xor(Rs,Rt)                 Word32 Q6_R_xoror_RR(Word32 Rx, Word32 Rs, Word32 Rt)                   400
Rxx^=xor(Rss,Rtt)              Word64 Q6_P_xorxacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)              398
Z
zxtb
Rd=zxtb(Rs)                    Word32 Q6_R_zxtb_R(Word32 Rs)                                           185
zxth
Rd=zxth(Rs)                    Word32 Q6_R_zxth_R(Word32 Rs)                                           185
80-N2040-45 Rev. B                                                                                     722
Qualcomm Hexagon V66 HVX
Programmer’s Reference Manual
80-N2040-44 Rev. B
October 15, 2018
All Qualcomm products mentioned herein are products of Qualcomm Technologies, Inc. and/or its subsidiaries.
Qualcomm and Hexagon are trademarks of Qualcomm Incorporated, registered in the United States and other countries. Other
product and brand names may be trademarks or registered trademarks of their respective owners.
This technical data may be subject to U.S. and international export, re-export, or transfer (“export”) laws. Diversion contrary to U.S.
and international law is strictly prohibited.
                                                   Qualcomm Technologies, Inc.
                                                      5775 Morehouse Drive
                                                       San Diego, CA 92121
                                                               U.S.A.
                            © 2018 Qualcomm Technologies, Inc. and/or its subsidiaries. All rights reserved.
Contents
                  1 Introduction........................................................................................... 8
                  1.1 SIMD coprocessor ........................................................................................................ 8
                  1.2 HVX features................................................................................................................ 9
                      1.2.1 Vector length ....................................................................................................... 9
                      1.2.2 Vector contexts.................................................................................................... 9
                      1.2.3 Memory access.................................................................................................. 10
                      1.2.4 Vector registers.................................................................................................. 11
                      1.2.5 Vector compute instructions.............................................................................. 12
                  1.3 Changes in V66 HVX................................................................................................. 12
                  1.4 Technical assistance.................................................................................................... 13
                  2 Registers ............................................................................................. 14
                  2.1 Vector data registers ................................................................................................... 14
                      2.1.1 VRF-GRF transfers........................................................................................... 15
                  2.2 Vector predicate registers ........................................................................................... 15
                  3 Memory................................................................................................ 16
                  3.1 Alignment ................................................................................................................... 16
                  3.2 HVX local memory: VTCM....................................................................................... 16
                  3.3 Scatter and gather ....................................................................................................... 17
                  3.4 Memory-type .............................................................................................................. 18
                  3.5 Non-temporal.............................................................................................................. 18
                  3.6 Permissions................................................................................................................. 19
                  3.7 Ordering...................................................................................................................... 19
                  3.8 Atomicity.................................................................................................................... 20
                  3.9 Performance considerations........................................................................................ 21
                      3.9.1 Minimize VMEM access .................................................................................. 21
                      3.9.2 Use aligned data................................................................................................ 21
                      3.9.3 Avoid store to load stalls................................................................................... 21
                      3.9.4 L2FETCH ......................................................................................................... 21
                      3.9.5 Access data contiguously.................................................................................. 22
                      3.9.6 Use non-temporal for final data ........................................................................ 22
                      3.9.7 Scalar processing of vector data ....................................................................... 22
                      3.9.8 Avoid scatter/gather stalls ................................................................................. 23
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                              2
Hexagon V66 HVX Programmer’s Reference Manual                                                                                              Contents
                  4 Vector Instructions ............................................................................. 24
                  4.1 VLIW packing rules ................................................................................................... 24
                      4.1.1 Double vector instructions ................................................................................ 24
                      4.1.2 Vector instruction resource usage ..................................................................... 25
                      4.1.3 Vector instruction .............................................................................................. 25
                  4.2 Vector load/store......................................................................................................... 26
                  4.3 Scatter and gather ....................................................................................................... 27
                  4.4 Memory instruction slot combinations....................................................................... 28
                  4.5 Special instructions..................................................................................................... 29
                      4.5.1 Histogram.......................................................................................................... 29
                  4.6 Instruction latency ...................................................................................................... 29
                  4.7 Slot/resource/latency summary .................................................................................. 30
                  5 Instruction Set .................................................................................... 31
                  5.1 HVX/ALL-COMPUTE-RESOURCE ........................................................................ 32
                             Histogram 32
                             Weighted histogram ......................................................................................... 35
                  5.2 HVX/ALU-DOUBLE-RESOURCE .......................................................................... 40
                             Predicate operations 40
                             Combine ........................................................................................................... 42
                             In-lane shuffle................................................................................................... 44
                             Swap ................................................................................................................. 46
                             Sign/Zero extension.......................................................................................... 48
                             Arithmetic......................................................................................................... 51
                  5.3 HVX/ALU-RESOURCE............................................................................................ 55
                             Predicate operations 55
                             Byte-conditional vector assign ......................................................................... 56
                             Min/max ........................................................................................................... 57
                             Absolute value ................................................................................................. 59
                             Arithmetic......................................................................................................... 61
                             Add and subtract with carry ............................................................................. 64
                             Logical operations ............................................................................................ 66
                             Copy ................................................................................................................. 68
                             Average ............................................................................................................ 69
                             Compare vectors............................................................................................... 73
                             Conditional accumulate .................................................................................... 80
                             Mux select ........................................................................................................ 83
                             Saturation.......................................................................................................... 85
                             In-lane shuffle................................................................................................... 87
                  5.4 HVX/DEBUG............................................................................................................. 90
                             Extract vector element 90
                  5.5 HVX/GATHER-DOUBLE-RESOURCE................................................................... 92
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                             3
Hexagon V66 HVX Programmer’s Reference Manual                                                                                              Contents
                            Vector gather 92
                  5.6 HVX/GATHER........................................................................................................... 95
                            Vector gather 95
                  5.7 HVX/LOAD ............................................................................................................... 98
                            Load - aligned 98
                            Load - immediate use ..................................................................................... 101
                            Load - temporary immediate use ................................................................... 104
                            Load - unaligned............................................................................................. 107
                  5.8 HVX/MPY-DOUBLE-RESOURCE ........................................................................ 109
                            Arithmetic widening 109
                            Multiply with 2-wide reduction...................................................................... 112
                            Lookup table for piecewise from 64-bit scalar............................................... 118
                            Multiply with piecewise add/sub from 64-bit scalar ...................................... 119
                            Multiply - add ................................................................................................ 121
                            Multiply - vector by scalar ............................................................................. 127
                            Multiply - vector by vector............................................................................. 132
                            Integer multiply - vector by vector................................................................. 136
                            Integer Multiply (32x16) ................................................................................ 138
                            Integer multiply accumulate even/odd .......................................................... 140
                            Multiply (32x16) ............................................................................................ 142
                            Multiply bytes with 4-wide reduction - vector by scalar................................ 145
                            Multiply by byte with accumulate and 4-wide reduction - vector by vector . 149
                            Multiply with 3-wide reduction...................................................................... 151
                            Sum of reduction of absolute differences halfwords ..................................... 155
                            Sum of absolute differences byte ................................................................... 159
                  5.9 HVX/MPY-RESOURCE.......................................................................................... 162
                            Multiply by byte with 2-wide reduction 162
                            Multiply half of the elements (16x16)............................................................ 164
                            Integer multiply by byte ................................................................................. 165
                            Multiply half of the elements with scalar (16 x 16) ....................................... 167
                            Multiply bytes with 4-wide reduction - vector by scalar................................ 168
                            Multiply by byte with 4-wide reduction - vector by vector ........................... 171
                            Splat from scalar............................................................................................. 173
                            Vector to predicate transfer ............................................................................ 175
                            Predicate to vector transfer............................................................................. 176
                            Absolute value of difference .......................................................................... 178
                            Insert element ................................................................................................. 180
                  5.10 HVX/PERMUTE-RESOURCE ............................................................................. 181
                            Byte alignment 181
                            General permute network ............................................................................... 184
                            Shuffle - deal .................................................................................................. 188
                            Pack ................................................................................................................ 191
                            Set predicate ................................................................................................... 194
80-N2040-44 Rev. B     MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                             4
Hexagon V66 HVX Programmer’s Reference Manual                                                                                               Contents
                            Vector in-lane lookup table ............................................................................ 195
                  5.11 HVX/PERMUTE-SHIFT-RESOURCE ................................................................. 202
                            Vector ASR overlay 202
                            Vector shuffle and deal cross-lane ................................................................. 204
                            Vector in-lane lookup table ............................................................................ 211
                            Unpack............................................................................................................ 220
                  5.12 HVX/SCATTER-DOUBLE-RESOURCE ............................................................. 223
                            Vector scatter 223
                  5.13 HVX/SCATTER ..................................................................................................... 226
                            Vector scatter 226
                  5.14 HVX/SHIFT-RESOURCE ..................................................................................... 229
                            Narrowing shift 229
                            Compute contiguous offsets for valid positions ............................................. 233
                            Shift and add................................................................................................... 235
                            Shift ................................................................................................................ 238
                            Round to next smaller element size................................................................ 244
                            Vector rotate right word ................................................................................. 247
                            Bit counting ................................................................................................... 248
                  5.15 HVX/STORE.......................................................................................................... 250
                            Store - byte-enabled aligned 250
                            Store - new...................................................................................................... 253
                            Store - aligned ................................................................................................ 256
                            Store - unaligned ............................................................................................ 259
                            Scatter release ................................................................................................ 262
80-N2040-44 Rev. B     MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                              5
Hexagon V66 HVX Programmer’s Reference Manual                                                                                         Figures
                  Figures
                    Figure 1-1    Hexagon core with attached SIMD coprocessor.................................... 8
                    Figure 1-2    Registers using 128B with a vector length of 1024 bits ........................ 9
                    Figure 1-3    Four hardware threads (two HVX-enabled threads and two scalar-only
                               threads) .................................................................................................... 10
                    Figure 1-4    1024-bit SIMD register ........................................................................ 11
80-N2040-44 Rev. B   MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                         6
Hexagon V66 HVX Programmer’s Reference Manual                                                                         Tables
                  Tables
                    Table 2-1     VRF-GRF transfer instructions............................................................ 15
                    Table 3-1     Ordered operations within a thread...................................................... 19
                    Table 3-2     Unordered operations in a thread and barriers to order ....................... 19
                    Table 3-3     Atomicity of types of memory accesses .............................................. 20
                    Table 3-4     Peak scatter/gather performance for v66 ............................................. 23
                    Table 4-1     HVX execution resource usage............................................................ 25
                    Table 4-2     HVX instruction to Hexagon slots mapping ........................................ 25
                    Table 4-3     Sources used for non-contiguous accesses: (Rt, Mu, Vv) ................... 27
                    Table 4-4     Basic scatter and gather instructions.................................................... 28
                    Table 4-5     Valid VMEM load/store and scatter/gather combinations ................... 28
                    Table 4-6     HVX slot/resource/latency summary ................................................... 30
80-N2040-44 Rev. B   MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                        7
          1 Introduction
                  This document describes the Qualcomm® HexagonTM Vector eXtensions (HVX)
                  instruction set architecture. These extensions are implemented in an optional coprocessor.
                  This document assumes the reader is familiar with the Hexagon architecture. For a full
                  description of the architecture, refer to the Qualcomm Hexagon Programmer’s Reference
                  Manual.
       1.1        SIMD coprocessor
                  HVX instructions are primarily implemented in a Single Instruction Multiple Data
                  (SIMD) coprocessor block that includes vector registers, vector compute elements, and
                  dedicated memory. This extends the baseline Hexagon architecture to enable high-
                  performance computer vision, image processing, or other workloads that can be mapped to
                  SIMD parallel processing.
                              Hexagon core
                                    I$
                                 R0-R31
                                  P0-P3
                          S3    S2     S1     S0                                          SIMD coprocessor
                                          D$                     V0-V31
                                                                  Q0-Q3
                                                                                 mem             VTCM
                                                          mpy mpy shift xlane           scat
                                                          ALU ALU ALU ALU               gath
                                                           L2/TCM
                  Figure 1-1    Hexagon core with attached SIMD coprocessor
                  The Hexagon instruction set architecture (ISA) is extended with HVX instructions. These
                  instructions use HVX compute resources and can be freely mixed with normal Hexagon
                  instructions in a VLIW packet. HVX instructions can also use scalar source operands from
                  the core.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   8
Hexagon V66 HVX Programmer’s Reference Manual                                                         Introduction
       1.2        HVX features
                  HVX adds very wide SIMD capability to the Hexagon ISA. SIMD operations execute on
                  vector registers (currently up to 1024 bits each), and multiple SIMD instructions can be
                  executed in parallel.
                  The main features of HVX are described in the following subsections.
     1.2.1        Vector length
                  HVX supports 1024-bit vectors (128B). Additional vector sizes may be supported in the
                  future. To minimize porting effort, software should strive to treat vector length as an
                  arbitrary constant power of two.
                  .
                                                             Vector Context
                                                     V0     1024bit       Q0 128bit
                                                                               ...
                                                              ...         Q3 128bit
                                                    V31     1024bit
                  Figure 1-2 Registers using 128B with a vector length of 1024 bits
     1.2.2        Vector contexts
                  A vector context consists of a vector register file, vector predicate file, and the ability to
                  execute instructions using this state.
                  Hexagon hardware threads can be dynamically attached to a vector context. This enables
                  the thread to execute HVX instructions. Multiple hardware threads can execute in parallel,
                  each with a different vector context. The number of supported vector contexts is
                  implementation-defined.
                  The Hexagon scalar core can contain any number of hardware threads greater or equal to
                  the number of vector contexts. The scalar hardware thread is assignable to a vector context
                  through per-thread SSR:XA programming, as follows:
                          SSR:XA=4: HVX instructions use vector context 0.
                          SSR:XA=5: HVX instructions use vector context 1, if it is available.
                          SSR:XA=6: HVX instructions use vector context 2, if it is available.
                          SSR:XA=7: HVX instructions use vector context 3, if it is available.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        9
Hexagon V66 HVX Programmer’s Reference Manual                                                         Introduction
                  Figure 1-3 shows a vector context configuration with four hardware threads, but with two
                  of the threads configured to use 128B vectors. In this configuration, two of the threads can
                  execute 128 vector instructions, while the other two threads can execute scalar-only
                  instructions.
                                                Hexagon
                                                                           D$
                             GRF              GRF
                           Thread0        Thread2
                                                                           I$
                             GRF              GRF
                           Thread1        Thread3
                                  Coprocessor                                                   L2$/
                                Instruction Port                                               L2-TCM
                                       SIMD Coprocessor
                                              Vector Context #0
                                              Vector Context #0
                             V0          1024 bit                Q0 128bit
                                                                      ...
                                            ...
                                                                 Q3 128bit
                            V31          1024bit
                                               Vector Context #1
                             V0          1024 bit                Q0 128bit
                                                                      ...
                                            ...                  Q3 128bit
                            V31          1024bit
                  Figure 1-3 Four hardware threads (two HVX-enabled threads and two scalar-only
                                  threads)
     1.2.3        Memory access
                  The HVX memory instructions (referred to as VMEM instructions) use the Hexagon
                  general registers (R0-R31) to form addresses that access memory. The memory access size
                  of these instructions is the vector length or the size of a vector register.
                  VMEM loads and stores share a 32-bit virtual address space as normal scalar load/stores.
                  VMEM load/stores are coherent with scalar load/stores and hardware maintains
                  coherency.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        10
Hexagon V66 HVX Programmer’s Reference Manual                                                        Introduction
     1.2.4        Vector registers
                  HVX has two sets of registers:
                         Data registers consist of 32 vector length registers. Certain operations can access a
                          pair of registers to effectively double the vector length for the operand.
                         Predicate registers consist of 4 registers each with 1 bit per byte of vector length.
                          These registers provide operands to various compare, mux, and other special
                          instructions.
                  The vector registers are partitioned into lanes that operate in SIMD fashion. For example,
                  with 1024-bit (128B) vector length, each vector register can contain any of following
                  items:
                         32 words (32-bit elements)
                         64 half-words (16-bit elements)
                         128 bytes (8-bit elements)
                  Element ordering is little-endian with the lowest byte in the least-significant position, as
                  shown in Figure 1-4.
                      127 126 125 124                   7    6    5    4   3     2    1    0   Byte
                         63         62                    3         2         1          0     Half-word
                               31                              1                   0           Word
                  Figure 1-4 1024-bit SIMD register
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       11
Hexagon V66 HVX Programmer’s Reference Manual                                                      Introduction
     1.2.5        Vector compute instructions
                  Vector instructions process vector register data in SIMD fashion. The operation is
                  performed on each vector lane in parallel. For example, the following instruction performs
                  a signed ADD operation over each halfword:
                       V2.h = VADD(V3.h,V4.h)
                  In this instruction, the halfwords in V3 are summed with the corresponding halfwords in
                  V4, and the results stored in V2.
                  When vectors are specified in instructions, the element type is also usually specified:
                          .b for signed byte
                          .ub for unsigned byte
                          .h for signed halfword
                          .uh for unsigned halfword
                          .w for signed word
                          .uw for unsigned word
                  For example:
                       v0.b =   vadd(v1.b,v2.b)                      //  Add vectors of bytes
                       v1:0.b   = vadd(v3:2.b, v5:4.b)               //  Add vector pairs of bytes
                       v1:0.h   = vadd(v3:2.h, v5:4.h)               //  Add vector pairs of halfwords
                       v5:4.w   = vmpy(v0.h,v1.h)                    //  Widening vector 16x16 to 32
                                                                     //  multiplies: halfword inputs,
                                                                     //  word outputs
                  For operations with mixed element sizes, each operand with the smaller element size uses
                  a single vector register and each operand with the larger element size (double the smaller)
                  uses a vector register pair. One vector in a pair contains even elements and the other odd
                  elements.
       1.3        Changes in V66 HVX
                  The following are updates for V66 HVX:
                          Removed support for 512-bit vectors. Only 1024-bit vectors are supported.
                          Improved support for 64-bit arithmetic, including vsatdw (see Saturation),
                           vadd/sub with carry (see Add and subtract with carry), and vasrinto (see Vector
                           ASR overlay) instructions.
                          Added a vector rotate instruction (seeVector rotate right word).
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    12
Hexagon V66 HVX Programmer’s Reference Manual                                                      Introduction
       1.4        Technical assistance
                  For assistance or clarification on information in this document, submit a case to
                  Qualcomm Technologies, Inc. (QTI) at https://createpoint.qti.qualcomm.com/.
                  If you do not have access to the CDMATech Support website, register for access or send
                  email to support.cdmatech@qti.qualcomm.com.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     13
          2 Registers
                  HVX is a load-store architecture where compute operands originate from registers and
                  load/store instructions move data between memory and registers.
                  The vector registers are not used for addressing or control information, but rather hold
                  intermediate vector computation results. They are only accessible using HVX compute or
                  load/store instructions.
                  The vector predicate registers contain the decision bits for each 8-bit quantity of the vector
                  data registers.
       2.1        Vector data registers
                  The HVX coprocessor contains 32 vector registers (named V0 through V31). These
                  registers store operand data for all of the vector instructions.
                  For example:
                           V1 = vmem(R0)                        // load a vector of data
                                                                // from address R0
                           V4.w = vadd(V2.w, V3.w)              // add each word in V2
                                                               // to corresponding word in V3
                  The vector data registers can be specified as register pairs representing a double-vector of
                  data. For example:
                      V5:4.w = vadd(V3:2.w, V1:0.w) // add each word in V1:0 to
                                                                // corresponding word in V3:2
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      14
Hexagon V66 HVX Programmer’s Reference Manual                                                                Registers
     2.1.1        VRF-GRF transfers
                  Table 2-1 lists the Hexagon instructions used to transfer values between the vector register
                  file (VRF) and the general register file (GRF).
                  A packet can contain up to two insert instructions or one extract instruction. The extract
                  instruction incurs a long-latency stall and is primarily meant for debug purposes.
Table 2-1     VRF-GRF transfer instructions
                                Syntax                        Behavior                       Description
                      Rd.w=extractw(Vu,Rs)           Rd = Vu.uw[Rs&0xF];         Extract word from a vector into Rd
                                                                                 with location specified by Rs.
                                                                                 Primarily meant for debug.
                      Vx.w=insertw(Rss)              Vx.uw[Rss.w[1]&0xF] =       Insert word into vector at specified
                                                     Rss.w[0];                   location. The low word in Rss
                                                                                 specifies the data to insert, and the
                                                                                 upper word specifies the location.
       2.2        Vector predicate registers
                  Vector predicate registers hold the result of vector compare instructions, for example:
                       Q3 = vcmp.eq(V2.w, V5.w)
                  In this case, each 32-bit field of V2 and V5 are compared and the corresponding 4-bit field
                  is set in the corresponding predicate register Q3. For half-word operations, two bits are set
                  per half-word. For byte operations, one bit is set per byte.
                  The vector predicate instruction is used frequently by the vmux instruction. This takes
                  each bit in the predicate register and selects the first or second byte in each source, and
                  places it in the corresponding destination output field.
                            V4 = vmux(Q2, V5, V6)
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                            15
          3 Memory
                  The Hexagon unified byte addressable memory has a single 32-bit virtual address space
                  with little-endian format. All addresses, whether used by a scalar or vector operation go
                  through the MMU for address translation and protection.
       3.1        Alignment
                  Unlike on the scalar processor an unaligned pointer (i.e., one that is not a multiple of the
                  vector size) does not cause a memory fault or exception. When using a general VMEM
                  load or store, the least-significant bits of the address are ignored.
                            VMEM(R0) = V1 // Store to R0 & ~(0x3F)
                  The intra-vector addressing bits are ignored.
                  Unaligned loads and stores are also explicitly supported through the VMEMU instruction.
                            V0 = VMEMU(R0) // Load a vector from R0 regardless of alignment
       3.2        HVX local memory: VTCM
                  HVX also supports a local memory called VTCM, which is used for scratch buffers and
                  scatter/gather operations. The size of the memory is implementation defined. The size is
                  discoverable from the configuration table defined in the V66 system architecture
                  specification. VTCM needs normal virtual to physical translation just like other memory.
                  This memory has higher performance and lower power.
                  Use VTCM for intermediate vector data, or as a temporary buffer. It serves as the input or
                  output of the scatter/gather instructions. The following are advantages of using VTCM as
                  the intermediate buffer:
                           Guarantees no eviction (vs. L2 if the set is full)
                           Faster than L2$ (does not have the overhead of cache management, like
                            association)
                           Reduces L2$ pressure
                           Lower power than L2$
                           Supports continuous read and write for every packet without contention
                  In addition to HVX VMEM access, normal Hexagon memory access instructions can
                  access this memory.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      16
Hexagon V66 HVX Programmer’s Reference Manual                                                           Memory
                  The following conditions are invalid for VTCM access:
                          Using a page size larger than the VTCM size.
                          Attempting to execute instructions from VTCM. This includes speculative access.
                          Scalar VTCM access when the HVX fuse is blown (disabled).
                          Load-locked or store-conditional to VTCM.
                          memw_phys load from VTCM while more than one thread is active.
                          Accessing VTCM while HVX is not fully powered up or any VTCM banks are
                           asleep.
                          Unaligned access crossing between VTCM and non-VTCM pages.
       3.3        Scatter and gather
                  Scatter and gather instructions allow for per-element random access of VTCM memory.
                  Each element may specify an independent address that should be read (gather) or written
                  (scatter). Gather for HVX is a vector copy from non-contiguous addresses to an aligned
                  contiguous vector location. Gather operations use slot 0 + slot 1 on the scalar side, and
                  HVX load + store resources.
                  Gather is formed by two instructions, one for reading from VTCM and one for storing to
                  VTCM:
                       { Vtmp.h = vgather(Rt,Mu,Vv.h)
                       vmem(Rs+#1) = Vtmp.new
                       }
                  If the input data of gather is in DDR, it must first be copied to VTCM and then gathered
                  from there. Gather cannot be done directly on DDR or L2$ contents.
                  Vector gather (vgather) operations transfer elemental copies from a large region in VTCM
                  to a smaller vector-sized region in VTCM. Each instruction can gather up to 64 elements.
                  Gather supports halfword and word granularity. Byte gather can be emulated through
                  vector predicate instructions using two packets.
                  Gather can be used for large lookup tables (up to VTCM size).
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   17
Hexagon V66 HVX Programmer’s Reference Manual                                                           Memory
                  Typically, these instructions are not ordered with following operations. Even accesses
                  from elements of the same scatter or gather instruction are not ordered. The primary
                  ordered case is loading from a gather result. To help with this ordering, a scatter store
                  release instruction is provided, which is not performed until prior scatters and gathers are
                  complete. A load consuming from the scatter store release stalls until those prior scatters
                  and gathers are done.
                  The following example demonstrates proper use of a scatter release for synchronization:
                       vscatter(r0, m0, v1.h = v4.h; //Issue a scatter operation
                       ...
                       vscatter(r0, m0,v2.h) = v5.h; //Issue another scatter operation
                       ...
                       vmem(r10):scatter_release; //Scatter release to address in VTCM
                                                              //pointed to by r10
                       ...
                       v31 = vmem(r10); //Load from VTCM address in r10, when this load
                                                 //completes all prior scatters and gathers for the
                                                 //current context have completed
                  See the Scatter release instruction for details.
                  Operations that can be done via scatter or gather usually perform better via scatter.
                  The following conditions are invalid for scatter or gather access:
                           The scatter (write) or gather (read) region covers more than one page or the M
                            source (length-1) is negative. An exception is generated otherwise.
                           Any of the accesses are not within VTCM. This includes the gather target
                            addresses as well. An exception is generated otherwise.
                           Both a gather region instruction and a scatter instruction in the same packet.
       3.4        Memory-type
                  It is illegal for HVX memory instructions (VMEM or scatter/gather) to target device-type
                  memory. If this is done, a VMEM address error exception is raised. It is also illegal to use
                  HVX memory instructions while the MMU is off.
                      NOTE       HVX is designed to work with L2 cache, L2TCM, or VTCM. Memory should
                                 be marked as L2-cacheable for L2 cache data and uncached for data that
                                 resides in L2TCM or VTCM.
       3.5        Non-temporal
                  A VMEM instruction can have an optional non-temporal attribute. This is specified in
                  assembly with a “:nt” appendix. Marking an instruction non-temporal indicates to the
                  micro-architecture that the data is no longer needed after the instruction. The cache
                  memory system uses this information to inform replacement and allocation decisions.
80-N2040-44 Rev. B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   18
Hexagon V66 HVX Programmer’s Reference Manual                                                                   Memory
       3.6        Permissions
                  Unaligned VMEMU instructions that happen to be naturally aligned only require MMU
                  permissions for the accessed line. The hardware suppresses generating an access to the
                  unused portion.
                  The byte-enabled conditional VMEM store instruction requires MMU permissions
                  regardless of whether any bytes are performed or not. In other words, the state of the Q
                  register is not considered when checking permissions.
       3.7        Ordering
                  To improve performance and reduce hardware overhead, only a subset of memory
                  operations within a thread are ordered. The following pairs of operations are ordered:
                  Table 3-1      Ordered operations within a thread
                                       Older                                               Newer
                   Any store                                         Any load (same address)
                   Scalar load/store                                 Any store
                   Vector load/store                                 Any store (same memory type)
                   Scalar load/store                                 Scalar load/store (inter-packet)
                   Vector load                                       Vector load/store (same memory type)
                   Vector store                                      Scalar load/store (same memory type)
                   Gather write                                      Any load (same address)
                   Scatter release                                   Any load (same address)
                   Any load/store                                    Scatter/gather
                   Anything                                          Scatter release
                  Table 3-2 lists pairs of operations within a thread that are not ordered. The barriers listed
                  can be put between the operations to achieve ordering between them.
                  Table 3-2      Unordered operations in a thread and barriers to order
                                Older                           Newer                          Minimal barrier
                   Scalar load                     Scalar load                        Separate into different packets
                                                   (intra-packet, in data cache)
                   Scalar store                    Scalar load                        Separate into different packets
                                                   (intra-packet, in data cache,
                                                   different address)
                   Vector load                     Scalar load                        Invalidate scalar in data cache
                                                   (with external observer - bus)
                   Vector store                    Vector load                        Load (overlap with store)
                   (VTCM)                          (VTCM, different address)
                   Vector load/store               Load or store                      Scalar load/store (VTCM)
                   (VTCM)                          (non-VTCM)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                             19
Hexagon V66 HVX Programmer’s Reference Manual                                                                Memory
                  Table 3-2      Unordered operations in a thread and barriers to order
                                Older                            Newer                       Minimal barrier
                   Store or vector load             Vector load                     Scalar load/store (VTCM)
                   (non-VTCM)                       (VTCM)
                   Scatter                          Scalar load/store               Invalidate in data cache
                                                    (same address)                  Scatter release -> load
                   Scatter                          Scatter/gather                  Scatter release -> load
                                                    Vector load/store
                                                    Scalar load/store
                   Gather read                      Scatter/gather                  Scatter release -> load
                                                    Load/store
                   Gather write                     Scatter/gather                  Scatter release -> load
                   Scatter release                  Vector store
                   Gather write                     Vector load                     Scatter release -> load
                   Scatter release                  Scalar load/store
                                                    (different address)
                   Unknown (non-VTCM)               Unknown (non-VTCM)              SynchT
                                                                                    or invalidate data cache
                   Unknown                          Unknown                         Invalidate data cache
                                                                                    Scatter release -> load
                  Scatter and gather operations apply to an element at a time in the table above (i.e., no
                  ordering between elements of a scatter/gather instruction).
                  Ordering is also ensured between two memory operations when the newer operation
                  deterministically depends on the older operation. For example, when a memory write
                  needs the data from a prior memory read, the write is ordered after the read. This applies to
                  the read followed by write operations per element of gathers and scatter accumulates.
       3.8        Atomicity
                  Table 3-3 describes the size or alignment of decomposed atomic operations for different
                  types of memory accesses. When an access is not fully atomic, an observer can see atomic
                  components of the access.
                  Table 3-3      Atomicity of types of memory accesses
                             Access type                       Atomic size
                   Scalar                           Access size
                   A mem-op is 2 accesses
                   Aligned vector                   Base vector size
                   Unaligned vector                 1B
                   Scatter                          1B
                   Scatter-accumulate               1B
                   (read-modify-write)              A larger read-modify-write may
                                                    be decomposed into multiple
                                                    equivalent smaller read-modify-
                                                    writes.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        20
Hexagon V66 HVX Programmer’s Reference Manual                                                          Memory
                  Table 3-3     Atomicity of types of memory accesses
                            Access type                      Atomic size
                   Gather read                      1B
                   Gather write                     1B
                  Individual scatter and gather accesses are only guaranteed to be atomic with other scatter
                  or gather accesses.
       3.9        Performance considerations
                  This section describes best-practices for maximizing performance of the vector memory
                  system.
                  The HVX vector processor is attached directly to the L2 cache. VMEM loads/stores move
                  data to/from L2 and do not use L1 data cache. To ensure coherency with L1, VMEM
                  stores check L1 and invalidate on hit.
     3.9.1        Minimize VMEM access
                  Accessing data from vector register file (VRF) is far cheaper in cycles and power than
                  accessing data from memory. The simplest way to improve memory system performance
                  is to reduce the number of VMEM instructions. Avoid moving data to/from memory when
                  it could be hosted in VRF instead.
     3.9.2        Use aligned data
                  VMEMU instruction access multiple L2 cache lines and are expensive in bandwidth and
                  power. Where possible, data structures should be aligned to vector boundaries. Padding
                  the image is often the most effective technique to provide aligned data.
     3.9.3        Avoid store to load stalls
                  A VMEM load instruction that follows a VMEM store to the same address incurs a store-
                  to-load penalty. The store must fully reach L2 before the load starts, thus the penalty can
                  be quite large. To avoid store-to-load stalls, there should be approximately 15 packets of
                  intervening work.
     3.9.4        L2FETCH
                  The L2FETCH instruction should be used to pre-populate the L2 with data prior to using
                  VMEM loads.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    21
Hexagon V66 HVX Programmer’s Reference Manual                                                            Memory
                  L2FETCH is best performed in sizes less than 8 KB and should be issued at least several
                  hundred cycles prior to using the data. If the L2FETCH is issued too early, it is possible
                  the data can be evicted before it can be used. In general, prefetching and processing on
                  image rows or tiles works best.
                  All L2 cacheable data that is used by VMEM should be prefetched, even if it is not used in
                  the computation. Software pipelined loops often overload data that will not be used. Even
                  though the pad data is not used in computation, the VMEM stalls if it has not been
                  prefetched into L2.
     3.9.5        Access data contiguously
                  Whenever possible, data in memory should be arranged so that it is accessed contiguously.
                  For example, instead of repeatedly striding through memory, data might be first tiled,
                  striped, or decimated so that it can be accessed contiguously.
                  The following techniques achieve better spatial locality in memory to help avoid various
                  performance hazards:
                          Bank conflicts - Lower address bits are typically used for parallel banks of
                           memory. Accessing data contiguously achieves a good distribution of these
                           address bits. If address bits [7:1] are unique across elements within a vector, the
                           operation is conflict-free. Use a vector predicate to mask out any “don’t care”
                           values.
                          Set aliasing. Caches hold a number of sets identified by lower address bits. Each
                           set has a small number of methods (typically 4 to 8) to help manage aliasing and
                           multi-threading.
                          Micro-TLB misses. A limited number of pages are remembered for fast
                           translation. Containing data to a smaller number of pages helps translation
                           performance.
     3.9.6        Use non-temporal for final data
                  On the last use of data, use the “:nt” attribute. The cache uses this hint to optimize the
                  replacement algorithm.
     3.9.7        Scalar processing of vector data
                  When a VMEM store instruction produces data, that data is placed into L2 cache and L1
                  does not contain a valid copy. Thus, if scalar loads must access the data, it first must be
                  fetched into L1.
                  It is common for algorithms to use the vector engine to produce some results that must be
                  further processed on the scalar core. The best practice is to use VMEM stores to get the
                  data into L2, then use DCFETCH to get the data in L1, followed by scalar load
                  instructions. The DCFETCH can be executed anytime after the VMEM store, however,
                  software should budget at least 30 cycles before issuing the scalar load instruction.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      22
Hexagon V66 HVX Programmer’s Reference Manual                                                               Memory
     3.9.8        Avoid scatter/gather stalls
                  Scatter and gather operations compete for memory and the resulting latency can be long,
                  therefore extra care is required to avoid stalls. The following techniques should improve
                  performance around scatter and gather:
                          Distribute accesses across the intra-vector address range (lower address bits).
                           Even distribution across the least significant inter-vector address bits can also be
                           beneficial. For V66, address bits [7:1] are important to avoid conflicts. Ideally this
                           would apply per vector instruction, but distributing these accesses out between
                           vector instructions can help absorb conflicts within a vector instruction.
                          Minimize the density of scatter and gather instructions. Spread out these
                           instructions in a larger loop rather than concentrating them in a tight loop. The
                           hardware can process a small number of these instructions in parallel. If it is
                           difficult to spread these instructions out, limit bursts to four for a given thread (for
                           V66).
                          Defer loading from a gather result or a scatter store release. If the in-flight scatters
                           and gathers (including from other threads) avoid conflicts, a distance of 12 or
                           more packets should be sufficient. Double that distance is needed if the addresses
                           of in-flight accesses are not correlated.
                  Table 3-4      Peak scatter/gather performance for v66
                                                                     Vector Bandwidth               Latency
                         Operation               Addressing
                                                                         (per packet)              (packets)
                          Scatter                Conflict-free                2/3                       8
                           Gather                Conflict-free                1/2                      12
                          Scatter                  Random                     1/3                      16
                           Gather                  Random                     1/6                      32
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         23
          4 Vector Instructions
                  This chapter provides an overview of the HVX load/store instructions, compute
                  instructions, VLIW packet rules, dependency, and scheduling rules.
                  Section 4.7 gives a summary of all hexagon slot, HVX resource, and instruction latency
                  for all instruction categories.
       4.1        VLIW packing rules
                  HVX provides six resources for vector instruction execution:
                           load
                           store
                           shift
                           permute
                           two multiply
                  Each HVX instruction consumes some combination of these resources, as defined in
                  section 4.1.2. VLIW packets cannot oversubscribe resources.
                  An instruction packet can contain up to four instructions, plus an endloop. The instructions
                  inside the packet must obey the packet grouping rules described in section 4.1.3.
                      NOTE       Invalid packet combinations should be checked and flagged by the assembler.
                                 In the case that an invalid packet is executed, the behavior is undefined.
     4.1.1        Double vector instructions
                  Certain instructions consume a pair of resources, either both the shift and permute as a pair
                  or both multiply resources as another pair. Such instructions are referred to as double
                  vector instructions because they use two vector compute resources.
                  Halfword by halfword multiplies are double vector instructions, because they consume
                  both the multiply resources.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    24
Hexagon V66 HVX Programmer’s Reference Manual                                                      Vector Instructions
     4.1.2        Vector instruction resource usage
                  The following table summarizes the resources that an HVX instruction uses during
                  execution. It also specifies the order in which the Hexagon assembler tries to build an
                  instruction packet from the most to least stringent.
                  Table 4-1       HVX execution resource usage
                                    Instruction                                 Used Resources
                   Histogram                                   All
                   Unaligned memory access                     Load, store, and permute
                   Double vector cross-lane permute            Permute and shift
                   Cross-lane permute                          Permute
                   Shift                                       Shift
                   Double vector & halfword multiplies         Both multiply
                   Single vector                               Either multiply
                   Double vector ALU operation                 Either shift and permute or both multiply
                   Single vector ALU operation                 Any one of shift, permute, or multiply
                   Aligned memory                              Any one of shift, permute, or multiply and one of
                                                               load or store
                   Aligned memory (.tmp/.new)                  Load or store only
                   Scatter (single vector indexing)            Store and any one of shift, permute, or multiply
                   Scatter (double vector indexing)            Store and either shift and permute or both multiply
                   Gather (single vector indexing)             Load and any one of shift, permute, or multiply
                   Gather (double vector indexing)             Load and either shift and permute or both multiply
     4.1.3        Vector instruction
                  In addition to vector resource assignment, vector instructions also map to certain Hexagon
                  slots. A special subset of ALU instructions that require either the full 32 bits of the scalar
                  Rt register (or 64 bits of Rtt) are mapped to slots 2 and 3. These include lookup table,
                  splat, insert, and add/sub with Rt.
                  Table 4-2       HVX instruction to Hexagon slots mapping
                              Instruction                Used Hexagon Slots              Additional Restriction
                   Aligned memory load                          0 or 1
                   Aligned memory store                            0
                   Unaligned memory load/store                     0                      Slot 1 must be empty.
                                                                                        Maximum of 3 instructions
                                                                                          allowed in the packet.
                   Scatter                                         0
                   Gather                                          1                        .new store in slot 0
                   Vextract                                        -                    Only instruction in packet
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           25
Hexagon V66 HVX Programmer’s Reference Manual                                                   Vector Instructions
                  Table 4-2       HVX instruction to Hexagon slots mapping
                              Instruction                Used Hexagon Slots           Additional Restriction
                   Histogram                                  0, 1, 2, or 3          .tmp load in same packet
                   Multiplies                                    2 or 3
                   Using full 32-64 bit R                        2 or 3
                   Simple ALU, permute, shift                 0, 1, 2, or 3
       4.2        Vector load/store
                  VMEM instructions move data between VRF and memory. VMEM instructions support
                  the following addressing modes.
                           Indirect
                           Indirect with offset
                           Indirect with auto-increment (immediate and register/modifier register)
                  For example:
                  V2 = vmem(R1+#4)           // address R1 + 4 * (vector-size) bytes
                  V2 = vmem(R1++M1)          // address R1, post-modify by the value of M1
                  The immediate increment and post increments values are vector counts. So the byte offset
                  is in multiples of the vector length.
                  To facilitate unaligned memory access, unaligned load and stores are available. The
                  VMEMU instructions generate multiple accesses to the L2 cache and use the permute
                  network to align the data.
                  The “load-temp” and “load-current” forms allow immediate use of load data within the
                  same packet. A “load-temp” instruction does not write the load data into the register file
                  (A register must be specified, but it will not be overwritten). Since the “load-temp”
                  instruction does not write to the register file, it does not consume a vector ALU resource.
                       {    V2.tmp = vmem(R1+#1)                     // Data loaded into a tmp
                            V5:4.ub = vadd(V3.ub, V2.ub) // Use loaded data as V2 source
                            V7:6.uw = vrmpy(V5:4.ub, R5.ub, #0)
                       }
                  “Load-current” is similar to “load-temp”, but consumes a vector ALU resource as the
                  loaded data is written to the register file
                       {    V2.cur = vmem(R1+#1)               // Data loaded into a V2
                            V3 = valign(V1,V2, R4)             // load data used immediately
                            V7:6.ub = vrmpy(V5:4.ub, R5.ub,#0)
                       }
                  VMEM store instructions can store a newly generated value. They do not consume a
                  vector ALU resource as they do not read nor write the register file.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        26
Hexagon V66 HVX Programmer’s Reference Manual                                                        Vector Instructions
                       vmem(R1+#1)= V20.new // Store V20 that was generate in the current
                       packet
                  An entire VMEM write can also be suppressed by a scalar predicate
                       if P0 vmem(R1++M1) = V20 // Store V20 if P0 is true
                  A partial byte-enabled store can be issued and controlled with a vector predicate register
                       if Q0 vmem(R1++M1) = V20 // Store bytes of V20 where Q0 is true
       4.3        Scatter and gather
                  Unlike vector loads and stores that access contiguous vectors in memory, scatter and
                  gather allow for non-contiguous memory access of vector data. With scatter and gather,
                  each element can independently index into a region of memory. This allows for
                  applications that would not otherwise map well to the SIMD parallelism that HVX
                  provides.
                  A scatter transfers data from a contiguous vector to non-contiguous memory locations.
                  Similarly, gather transfers data from non-contiguous memory locations to a contiguous
                  vector. In HVX, scatter is a vector register to non-contiguous memory transfer and gather
                  is a non-contiguous memory to contiguous memory transfer. Additionally, HVX supports
                  scatter-accumulate instructions that atomically add.
                  To maximize performance and efficiency, the scatter and gather instructions define a
                  bounded region that all non-contiguous accesses must be in. This region must be within
                  VTCM (scatter/gather capable) and be within one translatable page. A vector specifies
                  offsets from the base of the region for each element access. The following table describes
                  the three sources that specify the non-contiguous accesses of a scatter or gather:
                  Table 4-3     Sources used for non-contiguous accesses: (Rt, Mu, Vv)
                                       Source                                            Meaning
                   Rt                                              Base address of the region
                   Mu                                              Byte offset of last valid byte of the region
                                                                   (i.e., region size - 1)
                   Vv or Vvv                                       Vector of byte offsets for the accesses.
                                                                   Double-vector is used when the offset width is
                                                                   double the data width
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                             27
Hexagon V66 HVX Programmer’s Reference Manual                                                     Vector Instructions
                  To form an HVX gather (memory to memory), vgather is paired with a vector store to
                  specify the destination address. A scatter is specified with a single instruction. Ignoring
                  element sizes, the following table describes the basic forms of scatter and gather
                  instructions:
                  Table 4-4       Basic scatter and gather instructions
                                      Instruction                                       Behavior
                   vscatter(Rt,Mu,Vv)=Vw                            Write data in Vw to non-contiguous addresses
                                                                    specified by (Rt,Mu,Vv)
                   vscatter(Rt,Mu,Vv)+=Vw                           Atomically add data in Vw to non-contiguous
                                                                    addresses specified by (Rt,Mu,Vv)
                   {                                                Read data from non-contiguous addresses
                   vtmp=vgather(Rt,Mu,Vv);                          specified by (Rt,Mu,Vv) and write the data
                   vmem(Addr)=vtmp.new                              contiguously to the aligned Addr
                   }
       4.4        Memory instruction slot combinations
                  VMEM load/store instructions and scatter/gather instructions can be grouped with normal
                  scalar load/store instructions.
                  Table 4-5 provides the valid grouping combinations for HVX memory instructions. A
                  combination that is not present in the table is invalid, and should be rejected by the
                  assembler. The hardware generates an invalid packet error exception.
                  Table 4-5       Valid VMEM load/store and scatter/gather combinations
                          Slot 0 Instruction              Slot 1 Instruction
                   VMEM Ld                                   Non-memory
                   VMEM St                                   Non-memory
                   VMEM Ld                                    Scalar Ld
                   Scalar St                                  VMEM Ld
                   VMEM St                                     Scalar St
                   VMEM St                                    Scalar Ld
                   VMEM St                                    VMEM Ld
                   VMEMU Ld                                     Empty
                   VMEMU St                                     Empty
                   .new VMEM St                                 Gather
                   Scatter                                   Non-memory
                   Scatter                                     Scalar St
                   Scatter                                    Scalar Ld
                   Scatter                                    VMEM Ld
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          28
Hexagon V66 HVX Programmer’s Reference Manual                                                   Vector Instructions
       4.5        Special instructions
     4.5.1        Histogram
                  HVX contains a specialized histogram instruction. The vector register file is divided into
                  four histogram tables each of 256 entries (32 registers by 8 halfwords). A line is fetched
                  from memory via a temporary VMEM load instruction. The top five bits of each byte
                  provide a register select, and the bottom bits provide an element index. The value of the
                  element in the register file is incremented. All the registers must be cleared before use by
                  the programmer.
                  Example:
                  {    V31.tmp = VMEM(R2) // load a vector of data from memory
                       VHIST();// Perform histogram using counters in VRF and indexes from temp load
                  }
       4.6        Instruction latency
                  Latencies are implementation defined and can change with future versions.
                  HVX packets execute over multiple clock cycles, but typically in a pipelined manner so
                  that a packet can be issued and completed on every context cycle. The contexts are time
                  interleaved to share the hardware such that using all contexts may be required to reach
                  peak compute bandwidth.
                  With a few exceptions (i.e., histogram and extract), all results of all packets are generated
                  within a fixed time after execution starts. But, when the sources are required varies.
                  Instructions that need more pipelining require early sources. Only HVX registers are Early
                  Source registers. Early source operands include:
                          Input to the multiplier. For example “V3.h = vmpyh(V2.h, V4.h)”. V2 and V4 are
                           multiplier inputs. For multiply instructions with accumulation, the accumulator is
                           not considered an early source multiplier input.
                          Input to shift/bit count instructions. Only the register that is being shifted or
                           counted is considered early source. Accumulators are not early sources.
                          Input to permute instructions. Only registers that are being permuted are
                           considered early source (not an acccumulator).
                          Unaligned store data is an early source.
                  If an early source register is produced in the previous vector packet, an interlock stall can
                  be incurred. Software should strive to schedule an intervening packet between the
                  producer and an early source consumer.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        29
Hexagon V66 HVX Programmer’s Reference Manual                                               Vector Instructions
                  The following example shows various interlock cases:
                      V8 =   VADD(V0,V0)
                      V0 =   VADD(V8,V9)         //  NO STALL
                      V1 =   VMPY(V0,R0)         //  STALL due to V0
                      V2 =   VSUB(V2,V1)         //  NO STALL on V1
                      V5:4   = VUNPACK(V2)       //  STALL due to V2
                      V2 =   VADD(V0,V4)         //  NO STALL on V4
       4.7        Slot/resource/latency summary
                  Table 4-6 summarizes the Hexagon slot, HVX resource, and latency requirements for all
                  HVX instruction types.
                  Table 4-6     HVX slot/resource/latency summary
                                                       Core slots       Vector resources       Input
                      Category       Variation        3 2 1 0      ld mpy mpy shift xlane st  latency
                                     1 vec                any                  any                   1
                      ALU            2 vec                any              either pair               1
                                     Rt              either             either                       1
                                     1 vec           either             either                       2
                      Abs-diff
                                     2 vec           either                                          2
                                     by 8b; 1 vec    either             either                       2
                      Multiply       by 8b; 2 vec    either                                          2
                                     by 16b          either                                          2
                                     1 vec                any                                        2
                      Cross-lane
                                     2 vec                any                                        2
                      Shift or count 1 vec                any                                        2
                                     aligned                either             any                   -
                                     aligned; .tmp          either                                   -
                      load
                                     aligned; .cur          either             any                   -
                                     unaligned                                                       -
                                     aligned                                   any                   1
                      store          aligned; .new                                                   0
                                     unaligned                                                       2
                      gather (needs 1 vec                                      any                   1
                      .new store)    2 vec                                 either pair               1
                                     1 vec                                     any                   1
                      scatter
                                     2 vec                                 either pair               1
                      histogram (needs .tmp load)         any                                        2
                      extract                                                                        1
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     30
          5 Instruction Set
                  This chapter describes the instruction set for version 6 of the Hexagon processor.
                  The instructions are listed alphabetically within instruction categories. The following
                  information is provided for each instruction:
                       ■  Instruction name
                       ■  A brief description of the instruction
                       ■  A high-level functional description (syntax and behavior) with all possible
                          operand types
                       ■  Instruction class and slot information for grouping instructions in packets
                       ■  Notes on miscellaneous issues
                       ■  Any C intrinsic functions that provide access to the instruction
                       ■  Instruction encoding
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  31
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
       5.1        HVX/ALL-COMPUTE-RESOURCE
                  The HVX/ALL-COMPUTE-RESOURCE instruction subclass includes ALU instructions
                  that use a pair of HVX resources.
        Histogram
                  The vhist instructions use all of the HVX core resources: the register file, V0-V31, and all
                  four instruction pipes. The instruction also takes our execution packets to complete. The
                  basic unit of the histogram instruction is a 128-bit wide slice - there can be 4 or 8 slices,
                  depending on the particular configuration. The 32 vector registers are configured as
                  multiple 256-entry histograms, where each histogram bin has a width of 16 bits. This
                  allows up to 65535 8-bit elements of the same value to be accumulated. Each histogram is
                  128 bits wide and 32 elements deep, giving a total of 256 histogram bins. A vector is read
                  from memory and stored in a temporary location, outside of the register file. The data read
                  is then divided equally between the histograms. For example:
                  Bytes 0 to 15 are profiled into bits 0 to 127 of all 32 vector registers, histogram 0.
                  Bytes 16 to 31 are profiled into bits 128 to 255 of all 32 vector registers, histogram 1.
                  ... and so on.
                  The bytes are processed over multiple cycles to update the histogram bins. For each of the
                  histogram slices, the lower 3 bits of each byte element in the 128-bit slice is used to select
                  the 16-bit position, while the upper 5 bits select which vector register. The register file
                  entry is then incremented by one.
                  vhist is the only instruction that occupies all pipes and resources.
                  Before use, the vector register file must be cleared if a new histogram is to begin,
                  otherwise the current state will be added to the histograms of the next data.
                  vhist supports the same addressing modes as standard loads. In addition, a byte-enabled
                  version is available which enables the selection of the elements used in the accumulation.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        32
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                  Instruction Set
                  The following diagram shows a single 8-bit element in position 2 of the source data.
                                           vhist(Qv4)
                                                                                                              b[2]                Line from
                                                            b[31:16]      b[15]            b[14:3]                   b[1]    b[0]
                                                                                                              =124                 Memory
                                                                                                       & 0x7  >>3
                                                           Histogram           Histogram
                        Multiple Datapath Slices           Datapath 1         Datapath 0
                                                                                         Element Select           Register Select
                                                                                                                                    V31
                                                                            Increment Element    +
                                                            h[15:8]       h[7]    h[6]   h[5]   h[4]   h[3]   h[2]   h[1]    h[0]  V15
                          Vector Register File
                                 V0-V31
                                                                                                                                        V1-V30
                                                      Histogram 1 Storage                 Histogram 0 Storage
                                                                                                                                    V0
                  The value is 124, the register number assigned to this is 124 >> 3 = V15, and the element
                  number in the register is 124 & 7 = 4. The byte position in the example is 2, which is in the
                  first 16 bytes of the input line from memory, so the data affects the first 128-bit wide slice
                  of the register file. The 16-bit histogram bin location is then incremented by 1. Each 64-bit
                  input group of bytes affects the respective 128-bit histogram slice.
                  For a 64-byte vector size there can be a peak total consumption of 64(bytes per
                  vector)/4(packets per operation) * 4(threads) = 64 bytes per clock cycle per core,
                  assuming all threads are performing histogramming.
                   Syntax                                                    Behavior
                   vhist                                                      inputVec=Data from .tmp load;
                                                                              ;
                                                                              for (lane = 0; lane < VELEM(128); lane++) {
                                                                                       for (i=0; i<128/8; ++i) {
                                                                                              unsigned char value =
                                                                              inputVec.ub[(128/8)*lane+i];
                                                                                              unsigned char regno = value>>3;
                                                                                              unsigned char element = value & 7;
                                                                                              READ_EXT_VREG(regno,tmp);
                                                                                              tmp.uh[(128/16)*lane+(element)]++;
                                                                                              WRITE_EXT_VREG(regno,tmp,EXT_NEW);
                                                                                       }
                                                                              }
                                                                              ;
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                   33
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                   Syntax                                   Behavior
                   vhist(Qv4)                               inputVec=Data from .tmp load;
                                                            ;
                                                            for (lane = 0; lane < VELEM(128); lane++) {
                                                                 for (i=0; i<128/8; ++i) {
                                                                     unsigned char value =
                                                            inputVec.ub[(128/8)*lane+i];
                                                                     unsigned char regno = value>>3;
                                                                     unsigned char element = value & 7;
                                                                     READ_EXT_VREG(regno,tmp);
                                                                     if (QvV[128/8*lane+i])
                                                            tmp.uh[(128/16)*lane+(element)]++;
                                                                     WRITE_EXT_VREG(regno,tmp,EXT_NEW);
                                                                 }
                                                            }
                                                            ;
                  Class: COPROC_VX (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS                                        Parse
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  0  0  P   P 1  -   0 0  0  - 1 0  0  - -  - -  - vhist
 0  0  0  1 1  1   1 0   v  v 0   -  -  -  1  0  P   P 1  -   - 0  0  - 1 0  0  - -  - -  - vhist(Qv4)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  v2                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          34
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
        Weighted histogram
                  The vwhist instructions use all of the HVX core resources: the register file, V0-V31, and
                  all four instruction pipes. The instruction also takes four execution packets to complete.
                  The basic unit of the histogram instruction is a 128-bit wide slice - there can be 4 or 8
                  slices, depending on the particular configuration
                  The 32 vector registers are configured as multiple 256-entry histograms for vwhist256,
                  where each histogram bin has a width of 16 bits. Each histogram is 128 bits wide and 32
                  elements deep, giving a total of 256 histogram bins.
                  For vwhist128, the 32 vector registers are configured as multiple 128-entry histograms,
                  where each histogram bin has a width of 32 bits. Each histogram is 128 bits wide and 16
                  elements deep, giving a total of 128 histogram bins.
                  A vector is read from memory and stored in a temporary location, outside of the register
                  file. The vector carries both the data, which is used for the index into the histogram and the
                  weight. The data occupies the even byte of each halfword and the weight the odd byte of
                  each halfword. The data read is then divided equally between the histograms. For
                  example:
                  Even bytes 0 to 15 are profiled into bits 0 to 127 of all 32 vector registers, histogram 0.
                  Even bytes 16 to 31 are profiled into bits 128 to 255 of all 32 vector registers, histogram 1.
                  ... and so on.
                  The bytes are processed over multiple cycles to update the histogram bins. For each of the
                  histogram slices in vwhist256, the lower three bits of each even byte element in the 128-
                  bit slice is used to select the 16-bit position, while the upper five bits select which vector
                  register.
                  For each of the histogram slices in vwhist128, bits 2:1 of each even byte element in the
                  128-bit slice are used to select the 32-bit position, while the upper 5 bits select which
                  vector register. The LSB of the bye is ignored.
                  The register file entry is then incremented by corresponding weight from the odd byte.
                  Like vhist, vwhist occupies all pipes and resources.
                  Before use, the vector register file must be cleared if a new histogram is to begin,
                  otherwise the current state is added to the histograms of the next data.
                  vwhist supports the same addressing modes as standard loads. In addition, a byte-enabled
                  version is available that enables the selection of the elements used in the accumulation.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         35
Hexagon V66 HVX Programmer’s Reference Manual                                                                                              Instruction Set
                  The following diagram shows a single 8-bit element in byte position 2 of the source data
                  with corresponding weight in byte position 3.
                                               VWHIST128(Rt/Rx+#I)
                                                                                                   b3=    b2 =                Line From
                                                      b31 down to b16    b15   b14 down to b3                     b1      b0
                                                                                                     6    124                  Memory
                                                                                                   & 0x7  >>3
                                                          Histogram
                        Multiple Datapath Slices          Datapath 1
                                                                                  Element Select
                                                        Histogram                                             Register Select
                                                        Datapath 0
                                                                                                                                V31
                                                                                Increment
                                                                               element by
                                                                                  weight
                                                                                             +
                                                       h15 down to h8    h[7] h[6]   h[5]   h[4]   h[3]   h[2]   h[1]    h[0]   V15
                          Vector Register File
                                 V0-V31
                                                                                                                                    V1-V30
                                                     Histogram 1 Storage              Histogram 0 Storage
                                                                                                                                 V0
                  The value is 124, the register number assigned to this is 124 >> 3 = V15, and the element
                  number in the register is 124 & 7 = 4. The byte position in the example is 2, which is in the
                  first 16 bytes of the input line from memory, so the data affects the first 128-bit wide slice
                  of the register file. The 16-bit histogram bin location is then incremented by the weight
                  from byte position 3. Each 64-bit input group of bytes affects the respective 128-bit
                  histogram slice.
                  For a 64-byte vector size, there can be a peak total consumption of 64(bytes per
                  vector)/4(packets per operation) * 4(threads) = 64 bytes per clock cycle per core,
                  assuming all threads are performing histogramming.
                   Syntax                                          Behavior
                   vwhist128                                       input = Data from .tmp load;
                                                                   {
                                                                         for (i = 0; i < VELEM(16); i++) {
                                                                              bucket = input.h[i].ub[0];
                                                                              weight = input.h[i].ub[1];
                                                                              vindex = (bucket >> 3) & 0x1F;
                                                                              elindex = ((i>>1) & (~3)) | ((bucket>>1) & 3);
                                                                              READ_EXT_VREG(vindex,tmp);
                                                                              tmp.uw[elindex] = (tmp.uw[elindex] + weight);
                                                                              WRITE_EXT_VREG(vindex,tmp,EXT_NEW);
                                                                   ;
                                                                   ;
                                                                         }
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                               36
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                         Behavior
                   vwhist128(#u1)                 input = Data from .tmp load;
                                                  {
                                                       for (i = 0; i < VELEM(16); i++) {
                                                            bucket = input.h[i].ub[0];
                                                            weight = input.h[i].ub[1];
                                                            vindex = (bucket >> 3) & 0x1F;
                                                            elindex = ((i>>1) & (~3)) | ((bucket>>1) & 3);
                                                            READ_EXT_VREG(vindex,tmp);
                                                            if ((bucket & 1) == #u) tmp.uw[elindex] =
                                                  (tmp.uw[elindex] + weight);
                                                            WRITE_EXT_VREG(vindex,tmp,EXT_NEW);
                                                  ;
                                                  ;
                                                       }
                   vwhist128(Qv4)                 input = Data from .tmp load;
                                                  {
                                                       for (i = 0; i < VELEM(16); i++) {
                                                            bucket = input.h[i].ub[0];
                                                            weight = input.h[i].ub[1];
                                                            vindex = (bucket >> 3) & 0x1F;
                                                            elindex = ((i>>1) & (~3)) | ((bucket>>1) & 3);
                                                            READ_EXT_VREG(vindex,tmp);
                                                            if (QvV[2*i]) tmp.uw[elindex] =
                                                  (tmp.uw[elindex] + weight);
                                                            WRITE_EXT_VREG(vindex,tmp,EXT_NEW);
                                                  ;
                                                  ;
                                                       }
                   vwhist128(Qv4,#u1)             input = Data from .tmp load;
                                                  {
                                                       for (i = 0; i < VELEM(16); i++) {
                                                            bucket = input.h[i].ub[0];
                                                            weight = input.h[i].ub[1];
                                                            vindex = (bucket >> 3) & 0x1F;
                                                            elindex = ((i>>1) & (~3)) | ((bucket>>1) & 3);
                                                            READ_EXT_VREG(vindex,tmp);
                                                            if (((bucket & 1) == #u) && QvV[2*i])
                                                  tmp.uw[elindex] = (tmp.uw[elindex] + weight);
                                                            WRITE_EXT_VREG(vindex,tmp,EXT_NEW);
                                                  ;
                                                  ;
                                                       }
                   vwhist256                      input = Data from .tmp load;
                                                  {
                                                       for (i = 0; i < VELEM(16); i++) {
                                                            bucket = input.h[i].ub[0];
                                                            weight = input.h[i].ub[1];
                                                            vindex = (bucket >> 3) & 0x1F;
                                                            elindex = ((i>>0) & (~7)) | ((bucket>>0) & 7);
                                                            READ_EXT_VREG(vindex,tmp);
                                                            tmp.uh[elindex] = (tmp.uh[elindex] + weight);
                                                            WRITE_EXT_VREG(vindex,tmp,EXT_NEW);
                                                  ;
                                                  ;
                                                       }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    37
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                   Syntax                          Behavior
                   vwhist256(Qv4)                   input = Data from .tmp load;
                                                    {
                                                        for (i = 0; i < VELEM(16); i++) {
                                                              bucket = input.h[i].ub[0];
                                                              weight = input.h[i].ub[1];
                                                              vindex = (bucket >> 3) & 0x1F;
                                                              elindex = ((i>>0) & (~7)) | ((bucket>>0) & 7);
                                                              READ_EXT_VREG(vindex,tmp);
                                                              if (QvV[2*i]) tmp.uh[elindex] =
                                                    (tmp.uh[elindex] + weight);
                                                              WRITE_EXT_VREG(vindex,tmp,EXT_NEW);
                                                    ;
                                                    ;
                                                        }
                   vwhist256(Qv4):sat               input = Data from .tmp load;
                                                    {
                                                        for (i = 0; i < VELEM(16); i++) {
                                                              bucket = input.h[i].ub[0];
                                                              weight = input.h[i].ub[1];
                                                              vindex = (bucket >> 3) & 0x1F;
                                                              elindex = ((i>>0) & (~7)) | ((bucket>>0) & 7);
                                                              READ_EXT_VREG(vindex,tmp);
                                                              if (QvV[2*i]) tmp.uh[elindex] =
                                                    usat16(tmp.uh[elindex] + weight);
                                                              WRITE_EXT_VREG(vindex,tmp,EXT_NEW);
                                                    ;
                                                    ;
                                                        }
                   vwhist256:sat                    input = Data from .tmp load;
                                                    {
                                                        for (i = 0; i < VELEM(16); i++) {
                                                              bucket = input.h[i].ub[0];
                                                              weight = input.h[i].ub[1];
                                                              vindex = (bucket >> 3) & 0x1F;
                                                              elindex = ((i>>0) & (~7)) | ((bucket>>0) & 7);
                                                              READ_EXT_VREG(vindex,tmp);
                                                              tmp.uh[elindex] = usat16(tmp.uh[elindex] +
                                                    weight);
                                                              WRITE_EXT_VREG(vindex,tmp,EXT_NEW);
                                                    ;
                                                    ;
                                                        }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1  0
   ICLASS                                       Parse
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 1   - 0   0 1  0 1 0  0  - -  - -  - vwhist256
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 1   - 0   0 1  1 1 0  0  - -  - -  - vwhist256:sat
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 1   - 0   1 0  - 1 0  0  - -  - -  - vwhist128
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         38
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
 0  0 0  1  1  1   1 0   -  - 0   -  -  -  0  0  P  P 1   -  0 1  1 i 1 0 0   - -  - -  - vwhist128(#u1)
 0  0 0  1  1  1   1 0   v  v 0   -  -  -  1  0  P  P 1   -  - 0  1 0 1 0 0   - -  - -  - vwhist256(Qv4)
 0  0 0  1  1  1   1 0   v  v 0   -  -  -  1  0  P  P 1   -  - 0  1 1 1 0 0   - -  - -  - vwhist256(Qv4):sat
 0  0 0  1  1  1   1 0   v  v 0   -  -  -  1  0  P  P 1   -  - 1  0 - 1 0 0   - -  - -  - vwhist128(Qv4)
 0  0 0  1  1  1   1 0   v  v 0   -  -  -  1  0  P  P 1   -  - 1  1 i 1 0 0   - -  - -  - vwhist128(Qv4,#u1)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  v2                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        39
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
       5.2        HVX/ALU-DOUBLE-RESOURCE
                  The HVX/ALU-DOUBLE-RESOURCE instruction subclass includes ALU instructions
                  that use a pair of HVX resources.
        Predicate operations
                  Perform bitwise logical operations between two vector predicate registers Qs and Qt, and
                  place the result in Qd. The operations are element-size agnostic.
                  The following combinations are implemented: Qs & Qt, Qs & !Qt, Qs | Qt, Qs | !Qt, Qs ^
                  Qt. Interleave predicate bits from two vectors to match a shuffling operation like vsat or
                  vround. Forms that match word-to-halfword and halfword-to-byte shuffling are available.
                   Syntax                               Behavior
                   Qd4.b=vshuffe(Qs4.h,Qt4.h)            for (i = 0; i < VELEM(8); i++) {
                                                              QdV[i]=(i & 1) ? QsV[i-1] : QtV[i] ;
                                                         }
                   Qd4.h=vshuffe(Qs4.w,Qt4.w)            for (i = 0; i < VELEM(8); i++) {
                                                              QdV[i]=(i & 2) ? QsV[i-2] : QtV[i] ;
                                                         }
                   Qd4=and(Qs4,[!]Qt4)                   for (i = 0; i < VELEM(8); i++) {
                                                              QdV[i]=QsV[i] && [!]QtV[i] ;
                                                         }
                   Qd4=or(Qs4,[!]Qt4)                    for (i = 0; i < VELEM(8); i++) {
                                                              QdV[i]=QsV[i] || [!]QtV[i] ;
                                                         }
                   Qd4=xor(Qs4,Qt4)                      for (i = 0; i < VELEM(8); i++) {
                                                              QdV[i]=QsV[i] ^ QtV[i] ;
                                                         }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses any pair of the HVX resources (both multiply or
                           shift/permute).
                  Intrinsics
                   Qd4.b=vshuffe(Qs4.h,Qt4.h)            HVX_VectorPred Q6_Qb_vshuffe_QhQh(HVX_VectorPred
                                                         Qs, HVX_VectorPred Qt)
                   Qd4.h=vshuffe(Qs4.w,Qt4.w)            HVX_VectorPred Q6_Qh_vshuffe_QwQw(HVX_VectorPred
                                                         Qs, HVX_VectorPred Qt)
                   Qd4=and(Qs4,!Qt4)                     HVX_VectorPred Q6_Q_and_QQn(HVX_VectorPred Qs,
                                                         HVX_VectorPred Qt)
                   Qd4=and(Qs4,Qt4)                      HVX_VectorPred Q6_Q_and_QQ(HVX_VectorPred Qs,
                                                         HVX_VectorPred Qt)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     40
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                   Qd4=or(Qs4,!Qt4)                         HVX_VectorPred Q6_Q_or_QQn(HVX_VectorPred Qs,
                                                            HVX_VectorPred Qt)
                   Qd4=or(Qs4,Qt4)                          HVX_VectorPred Q6_Q_or_QQ(HVX_VectorPred Qs,
                                                            HVX_VectorPred Qt)
                   Qd4=xor(Qs4,Qt4)                         HVX_VectorPred Q6_Q_xor_QQ(HVX_VectorPred Qs,
                                                            HVX_VectorPred Qt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8 7 6 5 4 3 2 1   0
   ICLASS                  t2                    Parse               s2                 d2
 0  0  0  1 1  1   1 0   t    t 0 -  -  -  1  1  P   P 0  -   - -  s    s 0 0 0 0 0 0 d   d Qd4=and(Qs4,Qt4)
 0  0  0  1 1  1   1 0   t    t 0 -  -  -  1  1  P   P 0  -   - -  s    s 0 0 0 0 0 1 d   d Qd4=or(Qs4,Qt4)
 0  0  0  1 1  1   1 0   t    t 0 -  -  -  1  1  P   P 0  -   - -  s    s 0 0 0 0 1 1 d   d Qd4=xor(Qs4,Qt4)
 0  0  0  1 1  1   1 0   t    t 0 -  -  -  1  1  P   P 0  -   - -  s    s 0 0 0 1 0 0 d   d Qd4=or(Qs4,!Qt4)
 0  0  0  1 1  1   1 0   t    t 0 -  -  -  1  1  P   P 0  -   - -  s    s 0 0 0 1 0 1 d   d Qd4=and(Qs4,!Qt4)
 0  0  0  1 1  1   1 0   t    t 0 -  -  -  1  1  P   P 0  -   - -  s    s 0 0 0 1 1 0 d   d Qd4.b=vshuffe(Qs4.h,Qt4.h
                                                                                            )
 0  0  0  1 1  1   1 0   t    t 0 -  -  -  1  1  P   P 0  -   - -  s    s 0 0 0 1 1 1 d   d Qd4.h=vshuffe(Qs4.w,Qt4.
                                                                                            w)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s2                Field to encode register s
                  t2                Field to encode register t
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           41
Hexagon V66 HVX Programmer’s Reference Manual                                                          Instruction Set
          Combine
                  Combine two input vector registers into a single destination vector register pair.
                  Using a scalar predicate, conditionally copy a single vector register to a destination vector
                  register, or conditionally combine two input vectors into a destination vector register pair.
                  A scalar predicate guards the entire operation. If the scalar predicate is true, the operation
                  is performed. Otherwise the instruction is treated as a NOP.
                   Syntax                                  Behavior
                   Vdd=vcombine(Vu,Vv)                      for (i = 0; i < VELEM(8); i++) {
                                                                 Vdd.v[0].ub[i] = Vv.ub[i];
                                                                 Vdd.v[1].ub[i] = Vu.ub[i] ;
                                                            }
                   if ([!]Ps) Vdd=vcombine(Vu,Vv)           if ([!]Ps[0]) {
                                                                 for (i = 0; i < VELEM(8); i++) {
                                                                      Vdd.v[0].ub[i] = Vv.ub[i];
                                                                      Vdd.v[1].ub[i] = Vu.ub[i];
                                                                 }
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                        ■  This instruction uses any pair of the HVX resources (both multiply or
                           shift/permute).
                  Intrinsics
                   Vdd=vcombine(Vu,Vv)                     HVX_VectorPair Q6_W_vcombine_VV(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6    5 4 3 2  1 0
   ICLASS                                        Parse          u5            s2       d5
                                                                                            d ifVdd=vcombine(Vu,Vv)
                                                                                                 (!Ps)
 0  0  0  1 1  0   1  0  0  1  0  v  v  v  v  v  P   P -  u   u u  u   u -  s    s d d d  d
                                                                                            d ifVdd=vcombine(Vu,Vv)
                                                                                                 (Ps)
 0  0  0  1 1  0   1  0  0  1  1  v  v  v  v  v  P   P -  u   u u  u   u -  s    s d d d  d
   ICLASS                                        Parse          u5                     d5
 0  0  0  1 1  1   1  1  0  1  0  v  v  v  v  v  P   P 0  u   u u  u   u 1 1    1  d d d  d d Vdd=vcombine(Vu,Vv)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           42
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  s2              Field to encode register s
                  u5              Field to encode register u
                  v5              Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION              43
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
        In-lane shuffle
                  vshuffoe performs both the vshuffo and vshuffe operation at the same time, with even
                  elements placed into the even vector register of Vdd, and odd elements placed in the odd
                  vector register of the destination vector pair.
               Vdd.b=vshuffoe(Vu.b,Vv.b)
               b[3]     b[2]     b[1]     b[0]     Vu              b[3]    b[2]    b[1]    b[0]     Vv
               b[3]     b[2]     b[1]     b[0]    Vdd.V[1]         b[3]    b[2]    b[1]    b[0]   Vdd.V[0]
              Vdd.h=vshuffoe(Vu.h,Vv.h)
                    h[1]              h[0]         Vu                  h[1]             h[0]        Vv
                    h[1]              h[0]        Vdd.V[1]             h[1]             h[0]      Vdd.V[0]
                                         Repeated for each 32bit lane
                  This group of shuffles is limited to bytes and halfwords.
                   Syntax                               Behavior
                   Vdd.b=vshuffoe(Vu.b,Vv.b)             for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].uh[i].b[0]=Vv.uh[i].ub[0];
                                                              Vdd.v[0].uh[i].b[1]=Vu.uh[i].ub[0];
                                                              Vdd.v[1].uh[i].b[0]=Vv.uh[i].ub[1];
                                                              Vdd.v[1].uh[i].b[1]=Vu.uh[i].ub[1] ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     44
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
                   Syntax                                  Behavior
                   Vdd.h=vshuffoe(Vu.h,Vv.h)                for (i = 0; i < VELEM(32); i++) {
                                                                 Vdd.v[0].uw[i].h[0]=Vv.uw[i].uh[0];
                                                                 Vdd.v[0].uw[i].h[1]=Vu.uw[i].uh[0];
                                                                 Vdd.v[1].uw[i].h[0]=Vv.uw[i].uh[1];
                                                                 Vdd.v[1].uw[i].h[1]=Vu.uw[i].uh[1] ;
                                                            }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses any pair of the HVX resources (both multiply or
                           shift/permute).
                  Intrinsics
                   Vdd.b=vshuffoe(Vu.b,Vv.b)               HVX_VectorPair Q6_Wb_vshuffoe_VbVb(HVX_Vector
                                                           Vu, HVX_Vector Vv)
                   Vdd.h=vshuffoe(Vu.h,Vv.h)               HVX_VectorPair Q6_Wh_vshuffoe_VhVh(HVX_Vector
                                                           Vu, HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS                                        Parse          u5                  d5
 0  0  0  1 1  1   1 1  0  1  0   v  v  v  v  v  P   P 0  u   u u  u  u 1 0  1 d  d d  d d Vdd.h=vshuffoe(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  0  1  0   v  v  v  v  v  P   P 0  u   u u  u  u 1 1  0 d  d d  d d Vdd.b=vshuffoe(Vu.b,Vv.b)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           45
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                         Instruction Set
        Swap
                 Based on a predicate bit in a vector predicate register, if the bit is set the corresponding
                 byte from vector register Vu is placed in the even destination vector register of Vdd, and
                 the byte from Vv is placed in the even destination vector register of Vdd. Otherwise, the
                 corresponding byte from Vv is written to the even register, and Vu to the odd register. The
                 operation works on bytes so it can handle all data sizes. It is similar to the vmux operation,
                 but places the opposite case output into the odd vector register of the destination vector
                 register pair.
                                                             Vdd=vswap(Qt4,Vu,Vv)
                                                              b[N-1]                       b[3]          b[2]          b[1]          b[0]      Vu
                                                          b[N-1]                    b[3]          b[2]          b[1]          b[0]              Vv
                                                                                                                                            1 – pass 0 - swap
                      N is number of slices implemented
                                                                                                                                                      Qt.b[0]
                                                                                                                                                      Qt.b[1]
                                                                                                                                                      Qt.b[2]
                                                                                                                                                      Qt.b[3]
                                                                                                                                                        ...
                                                                                                                                                      Qt.b[N-1]
                                                              b[N-1]                       b[3]          b[2]          b[1]          b[0]    Vdd[0]
                                                              b[N-1]                       b[3]          b[2]          b[1]          b[0]    Vdd[1]
                     Syntax                                                                Behavior
                     Vdd=vswap(Qt4,Vu,Vv)                                                   for (i = 0; i < VELEM(8); i++) {
                                                                                                Vdd.v[0].ub[i] = QtV[i] ? Vu.ub[i] :
                                                                                            Vv.ub[i];
                                                                                                Vdd.v[1].ub[i] = !QtV[i] ? Vu.ub[i] :
                                                                                            Vv.ub[i] ;
                                                                                            }
80-N2040-44 Rev. B                                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                        46
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses any pair of the HVX resources (both multiply or
                           shift/permute).
                  Intrinsics
                   Vdd=vswap(Qt4,Vu,Vv)                    HVX_VectorPair Q6_W_vswap_QVV(HVX_VectorPred Qt,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6    5 4 3 2  1 0
   ICLASS                                        Parse         u5          t2       d5
 0  0  0  1 1  1   1 0  1  0  1   v  v  v  v  v  P   P 1  u  u  u u u  - t    t d d d  d d Vdd=vswap(Qt4,Vu,Vv)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t2                Field to encode register t
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        47
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
        Sign/Zero extension
                  Perform sign extension on each even element in Vu, and place it in the even destination
                  vector register Vdd[0]. Odd elements are sign-extended and placed in the odd destination
                  vector register Vdd[1]. Bytes are converted to halfwords, and halfwords are converted to
                  words.
                  Sign extension of words is a cross-lane operation, and can only execute on the permute
                  slot.
                                                   Vdd.h=vsxt(Vu.b)
                            [N*-1] [N*-2]            ...         [3]     [2]       [1]     [0]    Vu
                       sign                                sign              sign
                                [N-1]           ...                  [3]               [1]    Vdd.V[1]
                        fill                                fill              fill
                       sign                                sign              sign
                                [N-2]           ...                  [2]               [0]    Vdd.V[0]
                        fill                                fill              fill
                     *
                       N is number of operations in vector
                  Perform zero extension on each even element in Vu, and place it in the even destination
                  vector register Vdd[0]. Odd elements are zero-extended and placed in the odd destination
                  vector register Vdd[1]. Bytes are converted to halfwords, and halfwords are converted to
                  words.
80-N2040-44 Rev. B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        48
Hexagon V66 HVX Programmer’s Reference Manual                                                    Instruction Set
                  Zero extension of words is a cross-lane operation, and can only execute on the permute
                  slot.
                                               Vdd.uh=vzxt(Vu.ub)
                           [N*-1] [N*-2]           ...         [3]     [2]     [1]     [0]    Vu
                       0x0     [N-1]           ...         0x0     [3]     0x0     [1]    Vdd.V[1]
                       0x0     [N-2]           ...         0x0     [2]     0x0     [0]    Vdd.V[0]
                     *
                       N is number of operations in vector
                   Syntax                                 Behavior
                   Vdd.h=vsxt(Vu.b)                        for (i = 0; i < VELEM(16); i++) {
                                                               Vdd.v[0].h[i] = Vu.h[i].b[0];
                                                               Vdd.v[1].h[i] = Vu.h[i].b[1] ;
                                                           }
                   Vdd.uh=vzxt(Vu.ub)                      for (i = 0; i < VELEM(16); i++) {
                                                               Vdd.v[0].uh[i] = Vu.uh[i].ub[0];
                                                               Vdd.v[1].uh[i] = Vu.uh[i].ub[1] ;
                                                           }
                   Vdd.uw=vzxt(Vu.uh)                      for (i = 0; i < VELEM(32); i++) {
                                                               Vdd.v[0].uw[i] = Vu.uw[i].uh[0];
                                                               Vdd.v[1].uw[i] = Vu.uw[i].uh[1] ;
                                                           }
                   Vdd.w=vsxt(Vu.h)                        for (i = 0; i < VELEM(32); i++) {
                                                               Vdd.v[0].w[i] = Vu.w[i].h[0];
                                                               Vdd.v[1].w[i] = Vu.w[i].h[1] ;
                                                           }
                   Vdd=vsxtb(Vu)                           Assembler mapped to: "Vdd.h=vsxt(Vu.b)"
                   Vdd=vsxth(Vu)                           Assembler mapped to: "Vdd.w=vsxt(Vu.h)"
                   Vdd=vzxtb(Vu)                           Assembler mapped to: "Vdd.uh=vzxt(Vu.ub)"
                   Vdd=vzxth(Vu)                           Assembler mapped to: "Vdd.uw=vzxt(Vu.uh)"
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     49
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses any pair of the HVX resources (both multiply or
                           shift/permute).
                  Intrinsics
                   Vdd.h=vsxt(Vu.b)                        HVX_VectorPair Q6_Wh_vsxt_Vb(HVX_Vector Vu)
                   Vdd.uh=vzxt(Vu.ub)                      HVX_VectorPair Q6_Wuh_vzxt_Vub(HVX_Vector Vu)
                   Vdd.uw=vzxt(Vu.uh)                      HVX_VectorPair Q6_Wuw_vzxt_Vuh(HVX_Vector Vu)
                   Vdd.w=vsxt(Vu.h)                        HVX_VectorPair Q6_Ww_vsxt_Vh(HVX_Vector Vu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  1  0  P   P 0  u  u  u u u 0  0 1  d d  d d  d Vdd.uh=vzxt(Vu.ub)
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  1  0  P   P 0  u  u  u u u 0  1 0  d d  d d  d Vdd.uw=vzxt(Vu.uh)
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  1  0  P   P 0  u  u  u u u 0  1 1  d d  d d  d Vdd.h=vsxt(Vu.b)
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  1  0  P   P 0  u  u  u u u 1  0 0  d d  d d  d Vdd.w=vsxt(Vu.h)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       50
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
        Arithmetic
                  Perform simple arithmetic operations, add and subtract, between the elements of the two
                  vectors Vu and Vv. Supports word, halfword (signed and unsigned), and byte (signed and
                  unsigned).
                  Optionally saturate for word and halfword. Always saturate for unsigned types.
                   Syntax                               Behavior
                   Vdd.b=vadd(Vuu.b,Vvv.b)[:sat]         for (i = 0; i < VELEM(8); i++) {
                                                              Vdd.v[0].b[i] =
                                                         [sat8](Vuu.v[0].b[i]+Vvv.v[0].b[i]);
                                                              Vdd.v[1].b[i] =
                                                         [sat8](Vuu.v[1].b[i]+Vvv.v[1].b[i]) ;
                                                         }
                   Vdd.b=vsub(Vuu.b,Vvv.b)[:sat]         for (i = 0; i < VELEM(8); i++) {
                                                              Vdd.v[0].b[i] = [sat8](Vuu.v[0].b[i]-
                                                         Vvv.v[0].b[i]);
                                                              Vdd.v[1].b[i] = [sat8](Vuu.v[1].b[i]-
                                                         Vvv.v[1].b[i]) ;
                                                         }
                   Vdd.h=vadd(Vuu.h,Vvv.h)[:sat]         for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] =
                                                         [sat16](Vuu.v[0].h[i]+Vvv.v[0].h[i]);
                                                              Vdd.v[1].h[i] =
                                                         [sat16](Vuu.v[1].h[i]+Vvv.v[1].h[i]) ;
                                                         }
                   Vdd.h=vsub(Vuu.h,Vvv.h)[:sat]         for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] = [sat16](Vuu.v[0].h[i]-
                                                         Vvv.v[0].h[i]);
                                                              Vdd.v[1].h[i] = [sat16](Vuu.v[1].h[i]-
                                                         Vvv.v[1].h[i]) ;
                                                         }
                   Vdd.ub=vadd(Vuu.ub,Vvv.ub):sat        for (i = 0; i < VELEM(8); i++) {
                                                              Vdd.v[0].ub[i] =
                                                         usat8(Vuu.v[0].ub[i]+Vvv.v[0].ub[i]);
                                                              Vdd.v[1].ub[i] =
                                                         usat8(Vuu.v[1].ub[i]+Vvv.v[1].ub[i]) ;
                                                         }
                   Vdd.ub=vsub(Vuu.ub,Vvv.ub):sat        for (i = 0; i < VELEM(8); i++) {
                                                              Vdd.v[0].ub[i] = usat8(Vuu.v[0].ub[i]-
                                                         Vvv.v[0].ub[i]);
                                                              Vdd.v[1].ub[i] = usat8(Vuu.v[1].ub[i]-
                                                         Vvv.v[1].ub[i]) ;
                                                         }
                   Vdd.uh=vadd(Vuu.uh,Vvv.uh):sat        for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].uh[i] =
                                                         usat16(Vuu.v[0].uh[i]+Vvv.v[0].uh[i]);
                                                              Vdd.v[1].uh[i] =
                                                         usat16(Vuu.v[1].uh[i]+Vvv.v[1].uh[i]) ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    51
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vdd.uh=vsub(Vuu.uh,Vvv.uh):sat        for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].uh[i] = usat16(Vuu.v[0].uh[i]-
                                                         Vvv.v[0].uh[i]);
                                                              Vdd.v[1].uh[i] = usat16(Vuu.v[1].uh[i]-
                                                         Vvv.v[1].uh[i]) ;
                                                         }
                   Vdd.uw=vadd(Vuu.uw,Vvv.uw):sat        for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].uw[i] =
                                                         usat32(Vuu.v[0].uw[i]+Vvv.v[0].uw[i]);
                                                              Vdd.v[1].uw[i] =
                                                         usat32(Vuu.v[1].uw[i]+Vvv.v[1].uw[i]) ;
                                                         }
                   Vdd.uw=vsub(Vuu.uw,Vvv.uw):sat        for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].uw[i] = usat32(Vuu.v[0].uw[i]-
                                                         Vvv.v[0].uw[i]);
                                                              Vdd.v[1].uw[i] = usat32(Vuu.v[1].uw[i]-
                                                         Vvv.v[1].uw[i]) ;
                                                         }
                   Vdd.w=vadd(Vuu.w,Vvv.w)[:sat]         for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] =
                                                         [sat32](Vuu.v[0].w[i]+Vvv.v[0].w[i]);
                                                              Vdd.v[1].w[i] =
                                                         [sat32](Vuu.v[1].w[i]+Vvv.v[1].w[i]) ;
                                                         }
                   Vdd.w=vsub(Vuu.w,Vvv.w)[:sat]         for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = [sat32](Vuu.v[0].w[i]-
                                                         Vvv.v[0].w[i]);
                                                              Vdd.v[1].w[i] = [sat32](Vuu.v[1].w[i]-
                                                         Vvv.v[1].w[i]) ;
                                                         }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction uses any pair of the HVX resources (both multiply or
                          shift/permute).
                  Intrinsics
                   Vdd.b=vadd(Vuu.b,Vvv.b)               HVX_VectorPair Q6_Wb_vadd_WbWb(HVX_VectorPair
                                                         Vuu, HVX_VectorPair Vvv)
                   Vdd.b=vadd(Vuu.b,Vvv.b):sat           HVX_VectorPair
                                                         Q6_Wb_vadd_WbWb_sat(HVX_VectorPair Vuu,
                                                         HVX_VectorPair Vvv)
                   Vdd.b=vsub(Vuu.b,Vvv.b)               HVX_VectorPair Q6_Wb_vsub_WbWb(HVX_VectorPair
                                                         Vuu, HVX_VectorPair Vvv)
                   Vdd.b=vsub(Vuu.b,Vvv.b):sat           HVX_VectorPair
                                                         Q6_Wb_vsub_WbWb_sat(HVX_VectorPair Vuu,
                                                         HVX_VectorPair Vvv)
                   Vdd.h=vadd(Vuu.h,Vvv.h)               HVX_VectorPair Q6_Wh_vadd_WhWh(HVX_VectorPair
                                                         Vuu, HVX_VectorPair Vvv)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    52
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                   Vdd.h=vadd(Vuu.h,Vvv.h):sat             HVX_VectorPair
                                                           Q6_Wh_vadd_WhWh_sat(HVX_VectorPair Vuu,
                                                           HVX_VectorPair Vvv)
                   Vdd.h=vsub(Vuu.h,Vvv.h)                 HVX_VectorPair Q6_Wh_vsub_WhWh(HVX_VectorPair
                                                           Vuu, HVX_VectorPair Vvv)
                   Vdd.h=vsub(Vuu.h,Vvv.h):sat             HVX_VectorPair
                                                           Q6_Wh_vsub_WhWh_sat(HVX_VectorPair Vuu,
                                                           HVX_VectorPair Vvv)
                   Vdd.ub=vadd(Vuu.ub,Vvv.ub):sat          HVX_VectorPair
                                                           Q6_Wub_vadd_WubWub_sat(HVX_VectorPair Vuu,
                                                           HVX_VectorPair Vvv)
                   Vdd.ub=vsub(Vuu.ub,Vvv.ub):sat          HVX_VectorPair
                                                           Q6_Wub_vsub_WubWub_sat(HVX_VectorPair Vuu,
                                                           HVX_VectorPair Vvv)
                   Vdd.uh=vadd(Vuu.uh,Vvv.uh):sat          HVX_VectorPair
                                                           Q6_Wuh_vadd_WuhWuh_sat(HVX_VectorPair Vuu,
                                                           HVX_VectorPair Vvv)
                   Vdd.uh=vsub(Vuu.uh,Vvv.uh):sat          HVX_VectorPair
                                                           Q6_Wuh_vsub_WuhWuh_sat(HVX_VectorPair Vuu,
                                                           HVX_VectorPair Vvv)
                   Vdd.uw=vadd(Vuu.uw,Vvv.uw):sat          HVX_VectorPair
                                                           Q6_Wuw_vadd_WuwWuw_sat(HVX_VectorPair Vuu,
                                                           HVX_VectorPair Vvv)
                   Vdd.uw=vsub(Vuu.uw,Vvv.uw):sat          HVX_VectorPair
                                                           Q6_Wuw_vsub_WuwWuw_sat(HVX_VectorPair Vuu,
                                                           HVX_VectorPair Vvv)
                   Vdd.w=vadd(Vuu.w,Vvv.w)                 HVX_VectorPair Q6_Ww_vadd_WwWw(HVX_VectorPair
                                                           Vuu, HVX_VectorPair Vvv)
                   Vdd.w=vadd(Vuu.w,Vvv.w):sat             HVX_VectorPair
                                                           Q6_Ww_vadd_WwWw_sat(HVX_VectorPair Vuu,
                                                           HVX_VectorPair Vvv)
                   Vdd.w=vsub(Vuu.w,Vvv.w)                 HVX_VectorPair Q6_Ww_vsub_WwWw(HVX_VectorPair
                                                           Vuu, HVX_VectorPair Vvv)
                   Vdd.w=vsub(Vuu.w,Vvv.w):sat             HVX_VectorPair
                                                           Q6_Ww_vsub_WwWw_sat(HVX_VectorPair Vuu,
                                                           HVX_VectorPair Vvv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                                       Parse          u5                 d5
 0  0  0  1 1  1   0 0  0  1  1   v  v  v  v  v P   P 0  u   u  u u u 1  0 0  d d  d d  d Vdd.b=vadd(Vuu.b,Vvv.b)
 0  0  0  1 1  1   0 0  0  1  1   v  v  v  v  v P   P 0  u   u  u u u 1  0 1  d d  d d  d Vdd.h=vadd(Vuu.h,Vvv.h)
 0  0  0  1 1  1   0 0  0  1  1   v  v  v  v  v P   P 0  u   u  u u u 1  1 0  d d  d d  d Vdd.w=vadd(Vuu.w,Vvv.w)
                                                                                          Vdd.ub=vadd(Vuu.ub,Vvv.u
 0  0  0  1 1  1   0 0  0  1  1   v  v  v  v  v P   P 0  u   u  u u u 1  1 1  d d  d d  d b):sat
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 0  u   u  u u u 0  0 0  d d  d d  d Vdd.uh=vadd(Vuu.uh,Vvv.u
                                                                                          h):sat
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 0  u   u  u u u 0  0 1  d d  d d  d Vdd.h=vadd(Vuu.h,Vvv.h):s
                                                                                          at
                                                                                          Vdd.w=vadd(Vuu.w,Vvv.w):
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 0  u   u  u u u 0  1 0  d d  d d  d sat
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 0  u   u  u u u 0  1 1  d d  d d  d Vdd.b=vsub(Vuu.b,Vvv.b)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          53
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
 0  0 0  1  1  1   0 0  1  0  0   v  v  v  v  v  P  P 0   u  u  u u u 1 0 0  d  d d  d  d Vdd.h=vsub(Vuu.h,Vvv.h)
 0  0 0  1  1  1   0 0  1  0  0   v  v  v  v  v  P  P 0   u  u  u u u 1 0 1  d  d d  d  d Vdd.w=vsub(Vuu.w,Vvv.w)
                                                                                          Vdd.ub=vsub(Vuu.ub,Vvv.u
 0  0 0  1  1  1   0 0  1  0  0   v  v  v  v  v  P  P 0   u  u  u u u 1 1 0  d  d d  d  d
                                                                                          b):sat
                                                                                          Vdd.uh=vsub(Vuu.uh,Vvv.u
 0  0 0  1  1  1   0 0  1  0  0   v  v  v  v  v  P  P 0   u  u  u u u 1 1 1  d  d d  d  d h):sat
                                                                                          Vdd.h=vsub(Vuu.h,Vvv.h):s
 0  0 0  1  1  1   0 0  1  0  1   v  v  v  v  v  P  P 0   u  u  u u u 0 0 0  d  d d  d  d
                                                                                          at
                                                                                          Vdd.w=vsub(Vuu.w,Vvv.w):
 0  0 0  1  1  1   0 0  1  0  1   v  v  v  v  v  P  P 0   u  u  u u u 0 0 1  d  d d  d  d
                                                                                          sat
                                                                                          Vdd.b=vadd(Vuu.b,Vvv.b):s
 0  0 0  1  1  1   1 0  1  0  1   v  v  v  v  v  P  P 0   u  u  u u u 0 0 0  d  d d  d  d
                                                                                          at
                                                                                          Vdd.b=vsub(Vuu.b,Vvv.b):s
 0  0 0  1  1  1   1 0  1  0  1   v  v  v  v  v  P  P 0   u  u  u u u 0 0 1  d  d d  d  d
                                                                                          at
                                                                                          Vdd.uw=vadd(Vuu.uw,Vvv.
 0  0 0  1  1  1   1 0  1  0  1   v  v  v  v  v  P  P 0   u  u  u u u 0 1 0  d  d d  d  d
                                                                                          uw):sat
 0  0 0  1  1  1   1 0  1  0  1   v  v  v  v  v  P  P 0   u  u  u u u 0 1 1  d  d d  d  d Vdd.uw=vsub(Vuu.uw,Vvv.u
                                                                                          w):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          54
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
         5.3      HVX/ALU-RESOURCE
                  The HVX/ALU-RESOURCE instruction subclass includes ALU instructions that use a
                  single HVX resource.
          Predicate operations
                  Perform bitwise logical operation on a vector predicate register Qs, and place the result in
                  Qd. This operation works on vectors with any element size.
                  The following combinations are implemented: !Qs.
                   Syntax                                   Behavior
                   Qd4=not(Qs4)                             for (i = 0; i < VELEM(8); i++) {
                                                                QdV[i]=!QsV[i] ;
                                                            }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction can use any HVX resource.
                  Intrinsics
                   Qd4=not(Qs4)                             HVX_VectorPred Q6_Q_not_Q(HVX_VectorPred Qs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9     8 7 6 5 4 3 2 1   0
   ICLASS                                        Parse               s2                 d2
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  1  1  P   P 0  -   - -  s    s 0 0 0 0 1 0 d   d Qd4=not(Qs4)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  s2                Field to encode register s
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         55
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
          Byte-conditional vector assign
                  If the bit in Qv is set, copy the byte. Otherwise, set the byte in the destination to zero.
                   Syntax                                  Behavior
                   Vd=vand([!]Qv4,Vu)                       for (i = 0; i < VELEM(8); i++) {
                                                                 Vd.b[i] = [!]QvV[i] ? Vu.b[i] : 0 ;
                                                            }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                        ■  This instruction can use any HVX resource.
                  Intrinsics
                   Vd=vand(!Qv4,Vu)                        HVX_Vector Q6_V_vand_QnV(HVX_VectorPred Qv,
                                                           HVX_Vector Vu)
                   Vd=vand(Qv4,Vu)                         HVX_Vector Q6_V_vand_QV(HVX_VectorPred Qv,
                                                           HVX_Vector Vu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1  0
   ICLASS                                        Parse          u5                  d5
 0  0  0  1 1  1   1  0  v  v  0  -  -  -  1  1  P   P 1  u   u u  u  u 0 0  0 d  d d  d  d Vd=vand(Qv4,Vu)
 0  0  0  1 1  1   1  0  v  v  0  -  -  -  1  1  P   P 1  u   u u  u  u 0 0  1 d  d d  d  d Vd=vand(!Qv4,Vu)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v2                Field to encode register v
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        56
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
        Min/max
                  Compare the respective elements of Vu and Vv, and return the maximum or minimum.
                  The result is placed in the same position as the inputs.
                  Supports unsigned byte, signed and unsigned halfword, and signed word.
                   Syntax                               Behavior
                   Vd.b=vmax(Vu.b,Vv.b)                  for (i = 0; i < VELEM(8); i++) {
                                                              Vd.b[i] = (Vu.b[i] > Vv.b[i]) ? Vu.b[i] :
                                                         Vv.b[i] ;
                                                         }
                   Vd.b=vmin(Vu.b,Vv.b)                  for (i = 0; i < VELEM(8); i++) {
                                                              Vd.b[i] = (Vu.b[i] < Vv.b[i]) ? Vu.b[i] :
                                                         Vv.b[i] ;
                                                         }
                   Vd.h=vmax(Vu.h,Vv.h)                  for (i = 0; i < VELEM(16); i++) {
                                                              Vd.h[i] = (Vu.h[i] > Vv.h[i]) ? Vu.h[i] :
                                                         Vv.h[i] ;
                                                         }
                   Vd.h=vmin(Vu.h,Vv.h)                  for (i = 0; i < VELEM(16); i++) {
                                                              Vd.h[i] = (Vu.h[i] < Vv.h[i]) ? Vu.h[i] :
                                                         Vv.h[i] ;
                                                         }
                   Vd.ub=vmax(Vu.ub,Vv.ub)               for (i = 0; i < VELEM(8); i++) {
                                                              Vd.ub[i] = (Vu.ub[i] > Vv.ub[i]) ? Vu.ub[i]
                                                         : Vv.ub[i] ;
                                                         }
                   Vd.ub=vmin(Vu.ub,Vv.ub)               for (i = 0; i < VELEM(8); i++) {
                                                              Vd.ub[i] = (Vu.ub[i] < Vv.ub[i]) ? Vu.ub[i]
                                                         : Vv.ub[i] ;
                                                         }
                   Vd.uh=vmax(Vu.uh,Vv.uh)               for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i] = (Vu.uh[i] > Vv.uh[i]) ? Vu.uh[i]
                                                         : Vv.uh[i] ;
                                                         }
                   Vd.uh=vmin(Vu.uh,Vv.uh)               for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i] = (Vu.uh[i] < Vv.uh[i]) ? Vu.uh[i]
                                                         : Vv.uh[i] ;
                                                         }
                   Vd.w=vmax(Vu.w,Vv.w)                  for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = (Vu.w[i] > Vv.w[i]) ? Vu.w[i] :
                                                         Vv.w[i] ;
                                                         }
                   Vd.w=vmin(Vu.w,Vv.w)                  for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = (Vu.w[i] < Vv.w[i]) ? Vu.w[i] :
                                                         Vv.w[i] ;
                                                         }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction can use any HVX resource.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    57
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Intrinsics
                   Vd.b=vmax(Vu.b,Vv.b)                    HVX_Vector Q6_Vb_vmax_VbVb(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.b=vmin(Vu.b,Vv.b)                    HVX_Vector Q6_Vb_vmin_VbVb(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.h=vmax(Vu.h,Vv.h)                    HVX_Vector Q6_Vh_vmax_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.h=vmin(Vu.h,Vv.h)                    HVX_Vector Q6_Vh_vmin_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.ub=vmax(Vu.ub,Vv.ub)                 HVX_Vector Q6_Vub_vmax_VubVub(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.ub=vmin(Vu.ub,Vv.ub)                 HVX_Vector Q6_Vub_vmin_VubVub(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.uh=vmax(Vu.uh,Vv.uh)                 HVX_Vector Q6_Vuh_vmax_VuhVuh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.uh=vmin(Vu.uh,Vv.uh)                 HVX_Vector Q6_Vuh_vmin_VuhVuh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.w=vmax(Vu.w,Vv.w)                    HVX_Vector Q6_Vw_vmax_VwVw(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.w=vmin(Vu.w,Vv.w)                    HVX_Vector Q6_Vw_vmin_VwVw(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 0  u  u  u u u 0  0 1  d d  d d  d Vd.ub=vmin(Vu.ub,Vv.ub)
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 0  u  u  u u u 0  1 0  d d  d d  d Vd.uh=vmin(Vu.uh,Vv.uh)
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 0  u  u  u u u 0  1 1  d d  d d  d Vd.h=vmin(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 0  u  u  u u u 1  0 0  d d  d d  d Vd.w=vmin(Vu.w,Vv.w)
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 0  u  u  u u u 1  0 1  d d  d d  d Vd.ub=vmax(Vu.ub,Vv.ub)
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 0  u  u  u u u 1  1 0  d d  d d  d Vd.uh=vmax(Vu.uh,Vv.uh)
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 0  u  u  u u u 1  1 1  d d  d d  d Vd.h=vmax(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  0  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0  0 0  d d  d d  d Vd.w=vmax(Vu.w,Vv.w)
 0  0  0  1 1  1   1 1  0  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1  0 0  d d  d d  d Vd.b=vmin(Vu.b,Vv.b)
 0  0  0  1 1  1   1 1  0  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1  0 1  d d  d d  d Vd.b=vmax(Vu.b,Vv.b)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         58
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
          Absolute value
                  Take the absolute value of the vector register elements. Supports signed halfword and
                  word. Optionally saturate to deal with the maximum negative value overflow case.
                   Syntax                                 Behavior
                   Vd.b=vabs(Vu.b)[:sat]                   for (i = 0; i < VELEM(8); i++) {
                                                                Vd.b[i] = [sat8](ABS(Vu.b[i])) ;
                                                           }
                   Vd.h=vabs(Vu.h)[:sat]                   for (i = 0; i < VELEM(16); i++) {
                                                                Vd.h[i] = [sat16](ABS(Vu.h[i])) ;
                                                           }
                   Vd.ub=vabs(Vu.b)                        Assembler mapped to: "Vd.b=vabs(Vu.b)"
                   Vd.uh=vabs(Vu.h)                        Assembler mapped to: "Vd.h=vabs(Vu.h)"
                   Vd.uw=vabs(Vu.w)                        Assembler mapped to: "Vd.w=vabs(Vu.w)"
                   Vd.w=vabs(Vu.w)[:sat]                   for (i = 0; i < VELEM(32); i++) {
                                                                Vd.w[i] = [sat32](ABS(Vu.w[i])) ;
                                                           }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction can use any HVX resource.
                       ■   This may not work correctly in Napali V1.
                  Intrinsics
                   Vd.b=vabs(Vu.b)                         HVX_Vector Q6_Vb_vabs_Vb(HVX_Vector Vu)
                   Vd.b=vabs(Vu.b):sat                     HVX_Vector Q6_Vb_vabs_Vb_sat(HVX_Vector Vu)
                   Vd.h=vabs(Vu.h)                         HVX_Vector Q6_Vh_vabs_Vh(HVX_Vector Vu)
                   Vd.h=vabs(Vu.h):sat                     HVX_Vector Q6_Vh_vabs_Vh_sat(HVX_Vector Vu)
                   Vd.w=vabs(Vu.w)                         HVX_Vector Q6_Vw_vabs_Vw(HVX_Vector Vu)
                   Vd.w=vabs(Vu.w):sat                     HVX_Vector Q6_Vw_vabs_Vw_sat(HVX_Vector Vu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS                                       Parse          u5                  d5
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 0  u   u  u u  u 0 0  0  d d  d d  d Vd.h=vabs(Vu.h)
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 0  u   u  u u  u 0 0  1  d d  d d  d Vd.h=vabs(Vu.h):sat
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 0  u   u  u u  u 0 1  0  d d  d d  d Vd.w=vabs(Vu.w)
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 0  u   u  u u  u 0 1  1  d d  d d  d Vd.w=vabs(Vu.w):sat
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  1  P   P 0  u   u  u u  u 1 0  0  d d  d d  d Vd.b=vabs(Vu.b)
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  1  P   P 0  u   u  u u  u 1 0  1  d d  d d  d Vd.b=vabs(Vu.b):sat
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        59
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Parse           Packet/Loop parse bits
                  d5              Field to encode register d
                  u5              Field to encode register u
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION              60
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
        Arithmetic
                  Perform simple arithmetic operations, add and subtract, between the elements of the two
                  vectors Vu and Vv. Supports unsigned and signed byte and halfword.
                  Optionally saturate for word and signed halfword. Always saturate for unsigned types
                  except byte.
                   Syntax                               Behavior
                   Vd.b=vadd(Vu.b,Vv.b)[:sat]            for (i = 0; i < VELEM(8); i++) {
                                                              Vd.b[i] = [sat8](Vu.b[i]+Vv.b[i]) ;
                                                         }
                   Vd.b=vsub(Vu.b,Vv.b)[:sat]            for (i = 0; i < VELEM(8); i++) {
                                                              Vd.b[i] = [sat8](Vu.b[i]-Vv.b[i]) ;
                                                         }
                   Vd.h=vadd(Vu.h,Vv.h)[:sat]            for (i = 0; i < VELEM(16); i++) {
                                                              Vd.h[i] = [sat16](Vu.h[i]+Vv.h[i]) ;
                                                         }
                   Vd.h=vsub(Vu.h,Vv.h)[:sat]            for (i = 0; i < VELEM(16); i++) {
                                                              Vd.h[i] = [sat16](Vu.h[i]-Vv.h[i]) ;
                                                         }
                   Vd.ub=vadd(Vu.ub,Vv.b):sat            for (i = 0; i < VELEM(8); i++) {
                                                              Vd.ub[i] = usat8(Vu.ub[i] + Vv.b[i]) ;
                                                         }
                   Vd.ub=vadd(Vu.ub,Vv.ub):sat           for (i = 0; i < VELEM(8); i++) {
                                                              Vd.ub[i] = usat8(Vu.ub[i]+Vv.ub[i]) ;
                                                         }
                   Vd.ub=vsub(Vu.ub,Vv.b):sat            for (i = 0; i < VELEM(8); i++) {
                                                              Vd.ub[i] = usat8(Vu.ub[i] - Vv.b[i]) ;
                                                         }
                   Vd.ub=vsub(Vu.ub,Vv.ub):sat           for (i = 0; i < VELEM(8); i++) {
                                                              Vd.ub[i] = usat8(Vu.ub[i]-Vv.ub[i]) ;
                                                         }
                   Vd.uh=vadd(Vu.uh,Vv.uh):sat           for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i] = usat16(Vu.uh[i]+Vv.uh[i]) ;
                                                         }
                   Vd.uh=vsub(Vu.uh,Vv.uh):sat           for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i] = usat16(Vu.uh[i]-Vv.uh[i]) ;
                                                         }
                   Vd.uw=vadd(Vu.uw,Vv.uw):sat           for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uw[i] = usat32(Vu.uw[i]+Vv.uw[i]) ;
                                                         }
                   Vd.uw=vsub(Vu.uw,Vv.uw):sat           for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uw[i] = usat32(Vu.uw[i]-Vv.uw[i]) ;
                                                         }
                   Vd.w=vadd(Vu.w,Vv.w)[:sat]            for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = [sat32](Vu.w[i]+Vv.w[i]) ;
                                                         }
                   Vd.w=vsub(Vu.w,Vv.w)[:sat]            for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = [sat32](Vu.w[i]-Vv.w[i]) ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    61
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction can use any HVX resource.
                  Intrinsics
                   Vd.b=vadd(Vu.b,Vv.b)                  HVX_Vector Q6_Vb_vadd_VbVb(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.b=vadd(Vu.b,Vv.b):sat              HVX_Vector Q6_Vb_vadd_VbVb_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.b=vsub(Vu.b,Vv.b)                  HVX_Vector Q6_Vb_vsub_VbVb(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.b=vsub(Vu.b,Vv.b):sat              HVX_Vector Q6_Vb_vsub_VbVb_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vadd(Vu.h,Vv.h)                  HVX_Vector Q6_Vh_vadd_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vadd(Vu.h,Vv.h):sat              HVX_Vector Q6_Vh_vadd_VhVh_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vsub(Vu.h,Vv.h)                  HVX_Vector Q6_Vh_vsub_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vsub(Vu.h,Vv.h):sat              HVX_Vector Q6_Vh_vsub_VhVh_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.ub=vadd(Vu.ub,Vv.b):sat            HVX_Vector Q6_Vub_vadd_VubVb_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.ub=vadd(Vu.ub,Vv.ub):sat           HVX_Vector Q6_Vub_vadd_VubVub_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.ub=vsub(Vu.ub,Vv.b):sat            HVX_Vector Q6_Vub_vsub_VubVb_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.ub=vsub(Vu.ub,Vv.ub):sat           HVX_Vector Q6_Vub_vsub_VubVub_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.uh=vadd(Vu.uh,Vv.uh):sat           HVX_Vector Q6_Vuh_vadd_VuhVuh_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.uh=vsub(Vu.uh,Vv.uh):sat           HVX_Vector Q6_Vuh_vsub_VuhVuh_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.uw=vadd(Vu.uw,Vv.uw):sat           HVX_Vector Q6_Vuw_vadd_VuwVuw_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.uw=vsub(Vu.uw,Vv.uw):sat           HVX_Vector Q6_Vuw_vsub_VuwVuw_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.w=vadd(Vu.w,Vv.w)                  HVX_Vector Q6_Vw_vadd_VwVw(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.w=vadd(Vu.w,Vv.w):sat              HVX_Vector Q6_Vw_vadd_VwVw_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.w=vsub(Vu.w,Vv.w)                  HVX_Vector Q6_Vw_vsub_VwVw(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.w=vsub(Vu.w,Vv.w):sat              HVX_Vector Q6_Vw_vsub_VwVw_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   62
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   0 0  0  1  0   v  v  v  v  v  P   P 0  u  u  u u u 0 0 0  d  d d  d  d Vd.w=vadd(Vu.w,Vv.w)
 0  0  0  1 1  1   0 0  0  1  0   v  v  v  v  v  P   P 0  u  u  u u u 0 0 1  d  d d  d  d Vd.ub=vadd(Vu.ub,Vv.ub):s
                                                                                          at
                                                                                          Vd.uh=vadd(Vu.uh,Vv.uh):s
 0  0  0  1 1  1   0 0  0  1  0   v  v  v  v  v  P   P 0  u  u  u u u 0 1 0  d  d d  d  d
                                                                                          at
 0  0  0  1 1  1   0 0  0  1  0   v  v  v  v  v  P   P 0  u  u  u u u 0 1 1  d  d d  d  d Vd.h=vadd(Vu.h,Vv.h):sat
 0  0  0  1 1  1   0 0  0  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1 0 0  d  d d  d  d Vd.w=vadd(Vu.w,Vv.w):sat
 0  0  0  1 1  1   0 0  0  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1 0 1  d  d d  d  d Vd.b=vsub(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  0  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1 1 0  d  d d  d  d Vd.h=vsub(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  0  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1 1 1  d  d d  d  d Vd.w=vsub(Vu.w,Vv.w)
 0  0  0  1 1  1   0 0  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 0 0  d  d d  d  d Vd.ub=vsub(Vu.ub,Vv.ub):s
                                                                                          at
                                                                                          Vd.uh=vsub(Vu.uh,Vv.uh):s
 0  0  0  1 1  1   0 0  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 0 1  d  d d  d  d at
 0  0  0  1 1  1   0 0  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 1 0  d  d d  d  d Vd.h=vsub(Vu.h,Vv.h):sat
 0  0  0  1 1  1   0 0  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 1 1  d  d d  d  d Vd.w=vsub(Vu.w,Vv.w):sat
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   1 0  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1 0 0  d  d d  d  d Vd.ub=vadd(Vu.ub,Vv.b):sa
                                                                                          t
 0  0  0  1 1  1   1 0  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1 0 1  d  d d  d  d Vd.ub=vsub(Vu.ub,Vv.b):sa
                                                                                          t
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 0  u  u  u u u 0 0 0  d  d d  d  d Vd.b=vadd(Vu.b,Vv.b):sat
 0  0  0  1 1  1   1 1  0  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0 1 0  d  d d  d  d Vd.b=vsub(Vu.b,Vv.b):sat
 0  0  0  1 1  1   1 1  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 0 1  d  d d  d  d Vd.uw=vadd(Vu.uw,Vv.uw):
                                                                                          sat
 0  0  0  1 1  1   1 1  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1 1 0  d  d d  d  d Vd.b=vadd(Vu.b,Vv.b)
 0  0  0  1 1  1   1 1  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1 1 1  d  d d  d  d Vd.h=vadd(Vu.h,Vv.h)
                                                                                          Vd.uw=vsub(Vu.uw,Vv.uw):
 0  0  0  1 1  1   1 1  1  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1 0 0  d  d d  d  d sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  e2                Field to encode register e
                  s2                Field to encode register s
                  u5                Field to encode register u
                  v5                Field to encode register v
                  x2                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           63
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
        Add and subtract with carry
                  Perform add and subtract with carry operations between the elements of the two vectors
                  Vu and Vv. These instructions support unsigned and signed byte and halfword.
                  Optionally saturate for word and signed halfword. Always saturate for unsigned types
                  except byte.
                   Syntax                               Behavior
                   Vd.w,Qe4=vadd(Vu.w,Vv.w):carry        for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = Vu.w[i]+Vv.w[i];
                                                              QeV[4*i+4-1:4*i] = -
                                                         carry_from(Vu.w[i],Vv.w[i],0) ;
                                                         }
                   Vd.w,Qe4=vsub(Vu.w,Vv.w):carry        for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = Vu.w[i]+~Vv.w[i]+1;
                                                              QeV[4*i+4-1:4*i] = -
                                                         carry_from(Vu.w[i],~Vv.w[i],1) ;
                                                         }
                   Vd.w=vadd(Vu.w,Vv.w,Qs4):carry:       for (i = 0; i < VELEM(32); i++) {
                   sat                                        Vd.w[i] = sat32(Vu.w[i]+Vv.w[i]+QsV[i*4]) ;
                                                         }
                   Vd.w=vadd(Vu.w,Vv.w,Qx4):carry        for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = Vu.w[i]+Vv.w[i]+QxV[i*4];
                                                              QxV[4*i+4-1:4*i] = -
                                                         carry_from(Vu.w[i],Vv.w[i],QxV[i*4]) ;
                                                         }
                   Vd.w=vsub(Vu.w,Vv.w,Qx4):carry        for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = Vu.w[i]+~Vv.w[i]+QxV[i*4];
                                                              QxV[4*i+4-1:4*i] = -
                                                         carry_from(Vu.w[i],~Vv.w[i],QxV[i*4]) ;
                                                         }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction can use any HVX resource.
                  Intrinsics
                   Vd.w=vadd(Vu.w,Vv.w,Qs4):carry:       HVX_Vector Q6_Vw_vadd_VwVwQ_carry_sat(HVX_Vector
                   sat                                   Vu, HVX_Vector Vv, HVX_VectorPred Qs)
                   Vd.w=vadd(Vu.w,Vv.w,Qx4):carry        HVX_Vector Q6_Vw_vadd_VwVwQ_carry(HVX_Vector Vu,
                                                         HVX_Vector Vv, HVX_VectorPred* Qp)
                   Vd.w=vsub(Vu.w,Vv.w,Qx4):carry        HVX_Vector Q6_Vw_vsub_VwVwQ_carry(HVX_Vector Vu,
                                                         HVX_Vector Vv, HVX_VectorPred* Qp)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    64
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6    5 4 3 2  1 0
   ICLASS                                        Parse         u5         x2       d5
                                                                                          Vd.w=vadd(Vu.w,Vv.w,Qx4)
 0  0  0  1 1  1   0 0  1  0  1   v  v  v  v  v  P   P 1  u  u  u u u 0 x    x d d d  d d
                                                                                          :carry
 0  0  0  1 1  1   0 0  1  0  1   v  v  v  v  v  P   P 1  u  u  u u u 1 x    x d d d  d d Vd.w=vsub(Vu.w,Vv.w,Qx4)
                                                                                          :carry
   ICLASS                                        Parse         u5         s2       d5
                                                                                          Vd.w=vadd(Vu.w,Vv.w,Qs4)
 0  0  0  1 1  1   0 1  1  0  0   v  v  v  v  v  P   P 1  u  u  u u u 0 s    s d d d  d d
                                                                                          :carry:sat
   ICLASS                                        Parse         u5         e2       d5
                                                                                          Vd.w,Qe4=vadd(Vu.w,Vv.w)
 0  0  0  1 1  1   0 1  1  0  1   v  v  v  v  v  P   P 1  u  u  u u u 0 e    e d d d  d d
                                                                                          :carry
                                                                                          Vd.w,Qe4=vsub(Vu.w,Vv.w)
 0  0  0  1 1  1   0 1  1  0  1   v  v  v  v  v  P   P 1  u  u  u u u 1 e    e d d d  d d
                                                                                          :carry
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  e2                Field to encode register e
                  s2                Field to encode register s
                  u5                Field to encode register u
                  v5                Field to encode register v
                  x2                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          65
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
          Logical operations
                  Perform bitwise logical operations (AND, OR, XOR) between the two vector registers. In
                  the case of vnot, invert the input register.
                   Syntax                                 Behavior
                   Vd=vand(Vu,Vv)                          for (i = 0; i < VELEM(16); i++) {
                                                                Vd.uh[i] = Vu.uh[i] & Vv.h[i] ;
                                                           }
                   Vd=vnot(Vu)                             for (i = 0; i < VELEM(16); i++) {
                                                                Vd.uh[i] = ~Vu.uh[i] ;
                                                           }
                   Vd=vor(Vu,Vv)                           for (i = 0; i < VELEM(16); i++) {
                                                                Vd.uh[i] = Vu.uh[i] | Vv.h[i] ;
                                                           }
                   Vd=vxor(Vu,Vv)                          for (i = 0; i < VELEM(16); i++) {
                                                                Vd.uh[i] = Vu.uh[i] ^ Vv.h[i] ;
                                                           }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction can use any HVX resource.
                  Intrinsics
                   Vd=vand(Vu,Vv)                          HVX_Vector Q6_V_vand_VV(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd=vnot(Vu)                             HVX_Vector Q6_V_vnot_V(HVX_Vector Vu)
                   Vd=vor(Vu,Vv)                           HVX_Vector Q6_V_vor_VV(HVX_Vector Vu, HVX_Vector
                                                           Vv)
                   Vd=vxor(Vu,Vv)                          HVX_Vector Q6_V_vxor_VV(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS                                       Parse          u5                  d5
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v P   P 0  u   u  u u  u 1 0  1 d  d d  d d Vd=vand(Vu,Vv)
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v P   P 0  u   u  u u  u 1 1  0 d  d d  d d Vd=vor(Vu,Vv)
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v P   P 0  u   u  u u  u 1 1  1 d  d d  d d Vd=vxor(Vu,Vv)
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 0  u   u  u u  u 1 0  0 d  d d  d d Vd=vnot(Vu)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       66
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Parse           Packet/Loop parse bits
                  d5              Field to encode register d
                  u5              Field to encode register u
                  v5              Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION              67
Hexagon V66 HVX Programmer’s Reference Manual                                                            Instruction Set
          Copy
                  Copy a single input vector register to a new output vector register.
                  Using a scalar predicate, conditionally copy a single vector register to a destination vector
                  register, or conditionally combine two input vectors into a destination vector register pair.
                  A scalar predicate guards the entire operation. If the scalar predicate is true, the operation
                  is performed. Otherwise the instruction is treated as a NOP.
                   Syntax                                  Behavior
                   Vd=Vu                                    for (i = 0; i < VELEM(32); i++) {
                                                                 Vd.w[i]=Vu.w[i] ;
                                                            }
                   if ([!]Ps) Vd=Vu                         if ([!]Ps[0]) {
                                                                 for (i = 0; i < VELEM(8); i++) {
                                                                      Vd.ub[i] = Vu.ub[i];
                                                                 }
                                                            } else {
                                                                 NOP;
                                                            }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                        ■   This instruction can use any HVX resource.
                  Intrinsics
                   Vd=Vu                                   HVX_Vector Q6_V_equals_V(HVX_Vector Vu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8 7  6    5 4 3 2  1 0
   ICLASS                                        Parse          u5            s2       d5
 0  0  0  1 1  0   1  0  0  0  0  -  -  -   -  - P   P -  u   u u  u   u -  s    s d d d  d d if (Ps) Vd=Vu
 0  0  0  1 1  0   1  0  0  0  1  -  -  -   -  - P   P -  u   u u  u   u -  s    s d d d  d d if (!Ps) Vd=Vu
   ICLASS                                        Parse          u5                     d5
 0  0  0  1 1  1   1  0   - -  0  -  -  -  1  1  P   P 1  u   u u  u   u 1 1    1  d d d  d d Vd=Vu
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  s2                Field to encode register s
                  u5                Field to encode register u
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                             68
Hexagon V66 HVX Programmer’s Reference Manual                                                         Instruction Set
        Average
                 Add the elements of Vu to the respective elements of Vv, and shift the results right by 1
                 bit. The intermediate precision of the sum is larger than the input data precision.
                 Optionally, a rounding constant 0x1 is added before shifting.
                 Supports unsigned byte, signed and unsigned halfword, and signed word. The operation is
                 replicated to fill the implemented datapath width.
                                            Vd.w=vavg(Vu.w,Vv.w)[:rnd]
                                                           [1]            [0]         Vu
                                                           [1]            [0]         Vv
                     Other datapath lanes
                                                            +             +
                                                           +1             +1       Optional Round
                                                           >>1           >>1
                                                           [1]            [0]         Vd
                 Subtract the elements of Vu from the respective elements of Vv, and shift the results right
                 by 1 bit. The intermediate precision of the sum is larger than the input data precision.
                 Saturate the data to the required precision.
80-N2040-44 Rev. B                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION               69
Hexagon V66 HVX Programmer’s Reference Manual                                                             Instruction Set
                 Supports unsigned byte, halfword, and word. The operation is replicated to fill the
                 implemented datapath width.
                               Vd.w=vnavg(Vu.w,Vv.w)
                                                           [1]              [0]         Vu
                                                           [1]              [0]         Vv
                       Other datapath lanes
                                                            -                -
                                                          >>1              >>1
                                                           [1]              [0]         Vd
                     Syntax                                         Behavior
                     Vd.b=vavg(Vu.b,Vv.b)[:rnd]                     for (i = 0; i < VELEM(8); i++) {
                                                                        Vd.b[i] = (Vu.b[i]+Vv.b[i]+1)/2 ;
                                                                    }
                     Vd.b=vnavg(Vu.b,Vv.b)                          for (i = 0; i < VELEM(8); i++) {
                                                                        Vd.b[i] = (Vu.b[i]-Vv.b[i])/2 ;
                                                                    }
                     Vd.b=vnavg(Vu.ub,Vv.ub)                        for (i = 0; i < VELEM(8); i++) {
                                                                        Vd.b[i] = (Vu.ub[i]-Vv.ub[i])/2 ;
                                                                    }
                     Vd.h=vavg(Vu.h,Vv.h)[:rnd]                     for (i = 0; i < VELEM(16); i++) {
                                                                        Vd.h[i] = (Vu.h[i]+Vv.h[i]+1)/2 ;
                                                                    }
                     Vd.h=vnavg(Vu.h,Vv.h)                          for (i = 0; i < VELEM(16); i++) {
                                                                        Vd.h[i] = (Vu.h[i]-Vv.h[i])/2 ;
                                                                    }
                     Vd.ub=vavg(Vu.ub,Vv.ub)[:rnd]                  for (i = 0; i < VELEM(8); i++) {
                                                                        Vd.ub[i] = (Vu.ub[i]+Vv.ub[i]+1)/2 ;
                                                                    }
80-N2040-44 Rev. B                   MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                 70
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vd.uh=vavg(Vu.uh,Vv.uh)[:rnd]         for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i] = (Vu.uh[i]+Vv.uh[i]+1)/2 ;
                                                         }
                   Vd.uw=vavg(Vu.uw,Vv.uw)[:rnd]         for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uw[i] = (Vu.uw[i]+Vv.uw[i]+1)/2 ;
                                                         }
                   Vd.w=vavg(Vu.w,Vv.w)[:rnd]            for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = (Vu.w[i]+Vv.w[i]+1)/2 ;
                                                         }
                   Vd.w=vnavg(Vu.w,Vv.w)                 for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = (Vu.w[i]-Vv.w[i])/2 ;
                                                         }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction can use any HVX resource.
                       ■  This may not work correctly in Napali V1.
                  Intrinsics
                   Vd.b=vavg(Vu.b,Vv.b)                  HVX_Vector Q6_Vb_vavg_VbVb(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.b=vavg(Vu.b,Vv.b):rnd              HVX_Vector Q6_Vb_vavg_VbVb_rnd(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.b=vnavg(Vu.b,Vv.b)                 HVX_Vector Q6_Vb_vnavg_VbVb(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.b=vnavg(Vu.ub,Vv.ub)               HVX_Vector Q6_Vb_vnavg_VubVub(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vavg(Vu.h,Vv.h)                  HVX_Vector Q6_Vh_vavg_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vavg(Vu.h,Vv.h):rnd              HVX_Vector Q6_Vh_vavg_VhVh_rnd(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vnavg(Vu.h,Vv.h)                 HVX_Vector Q6_Vh_vnavg_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.ub=vavg(Vu.ub,Vv.ub)               HVX_Vector Q6_Vub_vavg_VubVub(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.ub=vavg(Vu.ub,Vv.ub):rnd           HVX_Vector Q6_Vub_vavg_VubVub_rnd(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.uh=vavg(Vu.uh,Vv.uh)               HVX_Vector Q6_Vuh_vavg_VuhVuh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.uh=vavg(Vu.uh,Vv.uh):rnd           HVX_Vector Q6_Vuh_vavg_VuhVuh_rnd(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.uw=vavg(Vu.uw,Vv.uw)               HVX_Vector Q6_Vuw_vavg_VuwVuw(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.uw=vavg(Vu.uw,Vv.uw):rnd           HVX_Vector Q6_Vuw_vavg_VuwVuw_rnd(HVX_Vector Vu,
                                                         HVX_Vector Vv)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    71
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                   Vd.w=vavg(Vu.w,Vv.w)                    HVX_Vector Q6_Vw_vavg_VwVw(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.w=vavg(Vu.w,Vv.w):rnd                HVX_Vector Q6_Vw_vavg_VwVw_rnd(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.w=vnavg(Vu.w,Vv.w)                   HVX_Vector Q6_Vw_vnavg_VwVw(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   0 0  1  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1  0 0  d d  d d  d Vd.ub=vavg(Vu.ub,Vv.ub)
 0  0  0  1 1  1   0 0  1  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1  0 1  d d  d d  d Vd.uh=vavg(Vu.uh,Vv.uh)
 0  0  0  1 1  1   0 0  1  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1  1 0  d d  d d  d Vd.h=vavg(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  1  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1  1 1  d d  d d  d Vd.w=vavg(Vu.w,Vv.w)
 0  0  0  1 1  1   0 0  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0  0 0  d d  d d  d Vd.b=vnavg(Vu.ub,Vv.ub)
 0  0  0  1 1  1   0 0  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0  0 1  d d  d d  d Vd.h=vnavg(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0  1 0  d d  d d  d Vd.w=vnavg(Vu.w,Vv.w)
 0  0  0  1 1  1   0 0  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0  1 1  d d  d d  d Vd.ub=vavg(Vu.ub,Vv.ub):r
                                                                                          nd
                                                                                          Vd.uh=vavg(Vu.uh,Vv.uh):r
 0  0  0  1 1  1   0 0  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 1  0 0  d d  d d  d nd
 0  0  0  1 1  1   0 0  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 1  0 1  d d  d d  d Vd.h=vavg(Vu.h,Vv.h):rnd
 0  0  0  1 1  1   0 0  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 1  1 0  d d  d d  d Vd.w=vavg(Vu.w,Vv.w):rnd
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 1  u  u  u u u 0  1 0  d d  d d  d Vd.uw=vavg(Vu.uw,Vv.uw)
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 1  u  u  u u u 0  1 1  d d  d d  d Vd.uw=vavg(Vu.uw,Vv.uw):
                                                                                          rnd
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 1  u  u  u u u 1  0 0  d d  d d  d Vd.b=vavg(Vu.b,Vv.b)
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 1  u  u  u u u 1  0 1  d d  d d  d Vd.b=vavg(Vu.b,Vv.b):rnd
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 1  u  u  u u u 1  1 0  d d  d d  d Vd.b=vnavg(Vu.b,Vv.b)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          72
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
        Compare vectors
                  Perform compares between the two vector register inputs Vu and Vv. Depending on the
                  element size, an appropriate number of bits are written into the vector predicate register
                  Qd for each pair of elements.
                  Two types of compare are supported: equal (.eq) and greater than (.gt)
                  Supports comparison of word, signed and unsigned halfword, signed and unsigned byte.
                  For each element comparison, the respective number of bits in the destination register are:
                  bytes 1 bit, halfwords 2 bits, and words 4 bits.
                  Optionally supports XOR (^) with the destination, AND (&) with the destination, and OR
                  (|) with the destination.
                   Syntax                                Behavior
                   Qd4=vcmp.eq(Vu.b,Vv.b)                 for( i = 0; i < VWIDTH; i += 1) {
                                                               QdV[i+1-1:i] = ((Vu.b[i/1] == Vv.b[i/1]) ?
                                                          0x1 : 0);
                                                          }
                   Qd4=vcmp.eq(Vu.h,Vv.h)                 for( i = 0; i < VWIDTH; i += 2) {
                                                               QdV[i+2-1:i] = ((Vu.h[i/2] == Vv.h[i/2]) ?
                                                          0x3 : 0);
                                                          }
                   Qd4=vcmp.eq(Vu.ub,Vv.ub)               Assembler mapped to: "Qd4=vcmp.eq(Vu." "b"
                                                          ",Vv." "b" ")"
                   Qd4=vcmp.eq(Vu.uh,Vv.uh)               Assembler mapped to: "Qd4=vcmp.eq(Vu." "h"
                                                          ",Vv." "h" ")"
                   Qd4=vcmp.eq(Vu.uw,Vv.uw)               Assembler mapped to: "Qd4=vcmp.eq(Vu." "w"
                                                          ",Vv." "w" ")"
                   Qd4=vcmp.eq(Vu.w,Vv.w)                 for( i = 0; i < VWIDTH; i += 4) {
                                                               QdV[i+4-1:i] = ((Vu.w[i/4] == Vv.w[i/4]) ?
                                                          0xF : 0);
                                                          }
                   Qd4=vcmp.gt(Vu.b,Vv.b)                 for( i = 0; i < VWIDTH; i += 1) {
                                                               QdV[i+1-1:i] = ((Vu.b[i/1] > Vv.b[i/1]) ?
                                                          0x1 : 0);
                                                          }
                   Qd4=vcmp.gt(Vu.h,Vv.h)                 for( i = 0; i < VWIDTH; i += 2) {
                                                               QdV[i+2-1:i] = ((Vu.h[i/2] > Vv.h[i/2]) ?
                                                          0x3 : 0);
                                                          }
                   Qd4=vcmp.gt(Vu.ub,Vv.ub)               for( i = 0; i < VWIDTH; i += 1) {
                                                               QdV[i+1-1:i] = ((Vu.ub[i/1] > Vv.ub[i/1]) ?
                                                          0x1 : 0);
                                                          }
                   Qd4=vcmp.gt(Vu.uh,Vv.uh)               for( i = 0; i < VWIDTH; i += 2) {
                                                               QdV[i+2-1:i] = ((Vu.uh[i/2] > Vv.uh[i/2]) ?
                                                          0x3 : 0);
                                                          }
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    73
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Qd4=vcmp.gt(Vu.uw,Vv.uw)              for( i = 0; i < VWIDTH; i += 4) {
                                                              QdV[i+4-1:i] = ((Vu.uw[i/4] > Vv.uw[i/4]) ?
                                                         0xF : 0);
                                                         }
                   Qd4=vcmp.gt(Vu.w,Vv.w)                for( i = 0; i < VWIDTH; i += 4) {
                                                              QdV[i+4-1:i] = ((Vu.w[i/4] > Vv.w[i/4]) ?
                                                         0xF : 0);
                                                         }
                   Qx4[&|]=vcmp.eq(Vu.b,Vv.b)            for( i = 0; i < VWIDTH; i += 1) {
                                                              QxV[i+1-1:i] = QxV[i+1-1:i] [|&] ((Vu.b[i/1]
                                                         == Vv.b[i/1]) ? 0x1 : 0);
                                                         }
                   Qx4[&|]=vcmp.eq(Vu.h,Vv.h)            for( i = 0; i < VWIDTH; i += 2) {
                                                              QxV[i+2-1:i] = QxV[i+2-1:i] [|&] ((Vu.h[i/2]
                                                         == Vv.h[i/2]) ? 0x3 : 0);
                                                         }
                   Qx4[&|]=vcmp.eq(Vu.ub,Vv.ub)          Assembler mapped to: "Qx4[|&]=vcmp.eq(Vu." "b"
                                                         ",Vv." "b" ")"
                   Qx4[&|]=vcmp.eq(Vu.uh,Vv.uh)          Assembler mapped to: "Qx4[|&]=vcmp.eq(Vu." "h"
                                                         ",Vv." "h" ")"
                   Qx4[&|]=vcmp.eq(Vu.uw,Vv.uw)          Assembler mapped to: "Qx4[|&]=vcmp.eq(Vu." "w"
                                                         ",Vv." "w" ")"
                   Qx4[&|]=vcmp.eq(Vu.w,Vv.w)            for( i = 0; i < VWIDTH; i += 4) {
                                                              QxV[i+4-1:i] = QxV[i+4-1:i] [|&] ((Vu.w[i/4]
                                                         == Vv.w[i/4]) ? 0xF : 0);
                                                         }
                   Qx4[&|]=vcmp.gt(Vu.b,Vv.b)            for( i = 0; i < VWIDTH; i += 1) {
                                                              QxV[i+1-1:i] = QxV[i+1-1:i] [|&] ((Vu.b[i/1]
                                                         > Vv.b[i/1]) ? 0x1 : 0);
                                                         }
                   Qx4[&|]=vcmp.gt(Vu.h,Vv.h)            for( i = 0; i < VWIDTH; i += 2) {
                                                              QxV[i+2-1:i] = QxV[i+2-1:i] [|&] ((Vu.h[i/2]
                                                         > Vv.h[i/2]) ? 0x3 : 0);
                                                         }
                   Qx4[&|]=vcmp.gt(Vu.ub,Vv.ub)          for( i = 0; i < VWIDTH; i += 1) {
                                                              QxV[i+1-1:i] = QxV[i+1-1:i] [|&]
                                                         ((Vu.ub[i/1] > Vv.ub[i/1]) ? 0x1 : 0);
                                                         }
                   Qx4[&|]=vcmp.gt(Vu.uh,Vv.uh)          for( i = 0; i < VWIDTH; i += 2) {
                                                              QxV[i+2-1:i] = QxV[i+2-1:i] [|&]
                                                         ((Vu.uh[i/2] > Vv.uh[i/2]) ? 0x3 : 0);
                                                         }
                   Qx4[&|]=vcmp.gt(Vu.uw,Vv.uw)          for( i = 0; i < VWIDTH; i += 4) {
                                                              QxV[i+4-1:i] = QxV[i+4-1:i] [|&]
                                                         ((Vu.uw[i/4] > Vv.uw[i/4]) ? 0xF : 0);
                                                         }
                   Qx4[&|]=vcmp.gt(Vu.w,Vv.w)            for( i = 0; i < VWIDTH; i += 4) {
                                                              QxV[i+4-1:i] = QxV[i+4-1:i] [|&] ((Vu.w[i/4]
                                                         > Vv.w[i/4]) ? 0xF : 0);
                                                         }
                   Qx4^=vcmp.eq(Vu.b,Vv.b)               for( i = 0; i < VWIDTH; i += 1) {
                                                              QxV[i+1-1:i] = QxV[i+1-1:i] ^ ((Vu.b[i/1] ==
                                                         Vv.b[i/1]) ? 0x1 : 0);
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    74
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Qx4^=vcmp.eq(Vu.h,Vv.h)               for( i = 0; i < VWIDTH; i += 2) {
                                                              QxV[i+2-1:i] = QxV[i+2-1:i] ^ ((Vu.h[i/2] ==
                                                         Vv.h[i/2]) ? 0x3 : 0);
                                                         }
                   Qx4^=vcmp.eq(Vu.ub,Vv.ub)             Assembler mapped to: "Qx4^=vcmp.eq(Vu." "b"
                                                         ",Vv." "b" ")"
                   Qx4^=vcmp.eq(Vu.uh,Vv.uh)             Assembler mapped to: "Qx4^=vcmp.eq(Vu." "h"
                                                         ",Vv." "h" ")"
                   Qx4^=vcmp.eq(Vu.uw,Vv.uw)             Assembler mapped to: "Qx4^=vcmp.eq(Vu." "w"
                                                         ",Vv." "w" ")"
                   Qx4^=vcmp.eq(Vu.w,Vv.w)               for( i = 0; i < VWIDTH; i += 4) {
                                                              QxV[i+4-1:i] = QxV[i+4-1:i] ^ ((Vu.w[i/4] ==
                                                         Vv.w[i/4]) ? 0xF : 0);
                                                         }
                   Qx4^=vcmp.gt(Vu.b,Vv.b)               for( i = 0; i < VWIDTH; i += 1) {
                                                              QxV[i+1-1:i] = QxV[i+1-1:i] ^ ((Vu.b[i/1] >
                                                         Vv.b[i/1]) ? 0x1 : 0);
                                                         }
                   Qx4^=vcmp.gt(Vu.h,Vv.h)               for( i = 0; i < VWIDTH; i += 2) {
                                                              QxV[i+2-1:i] = QxV[i+2-1:i] ^ ((Vu.h[i/2] >
                                                         Vv.h[i/2]) ? 0x3 : 0);
                                                         }
                   Qx4^=vcmp.gt(Vu.ub,Vv.ub)             for( i = 0; i < VWIDTH; i += 1) {
                                                              QxV[i+1-1:i] = QxV[i+1-1:i] ^ ((Vu.ub[i/1] >
                                                         Vv.ub[i/1]) ? 0x1 : 0);
                                                         }
                   Qx4^=vcmp.gt(Vu.uh,Vv.uh)             for( i = 0; i < VWIDTH; i += 2) {
                                                              QxV[i+2-1:i] = QxV[i+2-1:i] ^ ((Vu.uh[i/2] >
                                                         Vv.uh[i/2]) ? 0x3 : 0);
                                                         }
                   Qx4^=vcmp.gt(Vu.uw,Vv.uw)             for( i = 0; i < VWIDTH; i += 4) {
                                                              QxV[i+4-1:i] = QxV[i+4-1:i] ^ ((Vu.uw[i/4] >
                                                         Vv.uw[i/4]) ? 0xF : 0);
                                                         }
                   Qx4^=vcmp.gt(Vu.w,Vv.w)               for( i = 0; i < VWIDTH; i += 4) {
                                                              QxV[i+4-1:i] = QxV[i+4-1:i] ^ ((Vu.w[i/4] >
                                                         Vv.w[i/4]) ? 0xF : 0);
                                                         }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction can use any HVX resource.
                  Intrinsics
                   Qd4=vcmp.eq(Vu.b,Vv.b)                HVX_VectorPred Q6_Q_vcmp_eq_VbVb(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Qd4=vcmp.eq(Vu.h,Vv.h)                HVX_VectorPred Q6_Q_vcmp_eq_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    75
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
                   Qd4=vcmp.eq(Vu.w,Vv.w)                HVX_VectorPred Q6_Q_vcmp_eq_VwVw(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Qd4=vcmp.gt(Vu.b,Vv.b)                HVX_VectorPred Q6_Q_vcmp_gt_VbVb(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Qd4=vcmp.gt(Vu.h,Vv.h)                HVX_VectorPred Q6_Q_vcmp_gt_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Qd4=vcmp.gt(Vu.ub,Vv.ub)              HVX_VectorPred Q6_Q_vcmp_gt_VubVub(HVX_Vector
                                                         Vu, HVX_Vector Vv)
                   Qd4=vcmp.gt(Vu.uh,Vv.uh)              HVX_VectorPred Q6_Q_vcmp_gt_VuhVuh(HVX_Vector
                                                         Vu, HVX_Vector Vv)
                   Qd4=vcmp.gt(Vu.uw,Vv.uw)              HVX_VectorPred Q6_Q_vcmp_gt_VuwVuw(HVX_Vector
                                                         Vu, HVX_Vector Vv)
                   Qd4=vcmp.gt(Vu.w,Vv.w)                HVX_VectorPred Q6_Q_vcmp_gt_VwVw(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Qx4&=vcmp.eq(Vu.b,Vv.b)               HVX_VectorPred
                                                         Q6_Q_vcmp_eqand_QVbVb(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4&=vcmp.eq(Vu.h,Vv.h)               HVX_VectorPred
                                                         Q6_Q_vcmp_eqand_QVhVh(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4&=vcmp.eq(Vu.w,Vv.w)               HVX_VectorPred
                                                         Q6_Q_vcmp_eqand_QVwVw(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4&=vcmp.gt(Vu.b,Vv.b)               HVX_VectorPred
                                                         Q6_Q_vcmp_gtand_QVbVb(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4&=vcmp.gt(Vu.h,Vv.h)               HVX_VectorPred
                                                         Q6_Q_vcmp_gtand_QVhVh(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4&=vcmp.gt(Vu.ub,Vv.ub)             HVX_VectorPred
                                                         Q6_Q_vcmp_gtand_QVubVub(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4&=vcmp.gt(Vu.uh,Vv.uh)             HVX_VectorPred
                                                         Q6_Q_vcmp_gtand_QVuhVuh(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4&=vcmp.gt(Vu.uw,Vv.uw)             HVX_VectorPred
                                                         Q6_Q_vcmp_gtand_QVuwVuw(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4&=vcmp.gt(Vu.w,Vv.w)               HVX_VectorPred
                                                         Q6_Q_vcmp_gtand_QVwVw(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4^=vcmp.eq(Vu.b,Vv.b)               HVX_VectorPred
                                                         Q6_Q_vcmp_eqxacc_QVbVb(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4^=vcmp.eq(Vu.h,Vv.h)               HVX_VectorPred
                                                         Q6_Q_vcmp_eqxacc_QVhVh(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4^=vcmp.eq(Vu.w,Vv.w)               HVX_VectorPred
                                                         Q6_Q_vcmp_eqxacc_QVwVw(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   76
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
                   Qx4^=vcmp.gt(Vu.b,Vv.b)               HVX_VectorPred
                                                         Q6_Q_vcmp_gtxacc_QVbVb(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4^=vcmp.gt(Vu.h,Vv.h)               HVX_VectorPred
                                                         Q6_Q_vcmp_gtxacc_QVhVh(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4^=vcmp.gt(Vu.ub,Vv.ub)             HVX_VectorPred
                                                         Q6_Q_vcmp_gtxacc_QVubVub(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4^=vcmp.gt(Vu.uh,Vv.uh)             HVX_VectorPred
                                                         Q6_Q_vcmp_gtxacc_QVuhVuh(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4^=vcmp.gt(Vu.uw,Vv.uw)             HVX_VectorPred
                                                         Q6_Q_vcmp_gtxacc_QVuwVuw(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4^=vcmp.gt(Vu.w,Vv.w)               HVX_VectorPred
                                                         Q6_Q_vcmp_gtxacc_QVwVw(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4|=vcmp.eq(Vu.b,Vv.b)               HVX_VectorPred
                                                         Q6_Q_vcmp_eqor_QVbVb(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4|=vcmp.eq(Vu.h,Vv.h)               HVX_VectorPred
                                                         Q6_Q_vcmp_eqor_QVhVh(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4|=vcmp.eq(Vu.w,Vv.w)               HVX_VectorPred
                                                         Q6_Q_vcmp_eqor_QVwVw(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4|=vcmp.gt(Vu.b,Vv.b)               HVX_VectorPred
                                                         Q6_Q_vcmp_gtor_QVbVb(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4|=vcmp.gt(Vu.h,Vv.h)               HVX_VectorPred
                                                         Q6_Q_vcmp_gtor_QVhVh(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4|=vcmp.gt(Vu.ub,Vv.ub)             HVX_VectorPred
                                                         Q6_Q_vcmp_gtor_QVubVub(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4|=vcmp.gt(Vu.uh,Vv.uh)             HVX_VectorPred
                                                         Q6_Q_vcmp_gtor_QVuhVuh(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4|=vcmp.gt(Vu.uw,Vv.uw)             HVX_VectorPred
                                                         Q6_Q_vcmp_gtor_QVuwVuw(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
                   Qx4|=vcmp.gt(Vu.w,Vv.w)               HVX_VectorPred
                                                         Q6_Q_vcmp_gtor_QVwVw(HVX_VectorPred Qx,
                                                         HVX_Vector Vu, HVX_Vector Vv)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   77
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1    0
   ICLASS                                       Parse          u5                      x2
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 0 0  0  0 0  x    x Qx4&=vcmp.eq(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 0 0  0  0 1  x    x Qx4&=vcmp.eq(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 0 0  0  1 0  x    x Qx4&=vcmp.eq(Vu.w,Vv.w)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 0 0  1  0 0  x    x Qx4&=vcmp.gt(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 0 0  1  0 1  x    x Qx4&=vcmp.gt(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 0 0  1  1 0  x    x Qx4&=vcmp.gt(Vu.w,Vv.w)
                                                                                            Qx4&=vcmp.gt(Vu.ub,Vv.ub
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 0 1  0  0 0  x    x
                                                                                            )
                                                                                            Qx4&=vcmp.gt(Vu.uh,Vv.uh
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 0 1  0  0 1  x    x
                                                                                            )
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 0 1  0  1 0  x    x Qx4&=vcmp.gt(Vu.uw,Vv.u
                                                                                            w)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 1 0  0  0 0  x    x Qx4|=vcmp.eq(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 1 0  0  0 1  x    x Qx4|=vcmp.eq(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 1 0  0  1 0  x    x Qx4|=vcmp.eq(Vu.w,Vv.w)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 1 0  1  0 0  x    x Qx4|=vcmp.gt(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 1 0  1  0 1  x    x Qx4|=vcmp.gt(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 1 0  1  1 0  x    x Qx4|=vcmp.gt(Vu.w,Vv.w)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 1 1  0  0 0  x    x Qx4|=vcmp.gt(Vu.ub,Vv.ub)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 1 1  0  0 1  x    x Qx4|=vcmp.gt(Vu.uh,Vv.uh)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 0 1 1  0  1 0  x    x Qx4|=vcmp.gt(Vu.uw,Vv.uw
                                                                                            )
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 1 0 0  0  0 0  x    x Qx4^=vcmp.eq(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 1 0 0  0  0 1  x    x Qx4^=vcmp.eq(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 1 0 0  0  1 0  x    x Qx4^=vcmp.eq(Vu.w,Vv.w)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 1 0 0  1  0 0  x    x Qx4^=vcmp.gt(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 1 0 0  1  0 1  x    x Qx4^=vcmp.gt(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 1 0 0  1  1 0  x    x Qx4^=vcmp.gt(Vu.w,Vv.w)
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 1 0 1  0  0 0  x    x Qx4^=vcmp.gt(Vu.ub,Vv.ub
                                                                                            )
                                                                                            Qx4^=vcmp.gt(Vu.uh,Vv.uh
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 1 0 1  0  0 1  x    x )
 0  0  0  1 1  1   0 0  1  0  0   v  v  v  v  v P   P 1  u  u   u u u 1 0 1  0  1 0  x    x Qx4^=vcmp.gt(Vu.uw,Vv.u
                                                                                            w)
   ICLASS                                       Parse          u5                      d2
 0  0  0  1 1  1   1 1  1  0  0   v  v  v  v  v P   P 0  u  u   u u u 0 0 0  0  0 0  d    d Qd4=vcmp.eq(Vu.b,Vv.b)
 0  0  0  1 1  1   1 1  1  0  0   v  v  v  v  v P   P 0  u  u   u u u 0 0 0  0  0 1  d    d Qd4=vcmp.eq(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  1  0  0   v  v  v  v  v P   P 0  u  u   u u u 0 0 0  0  1 0  d    d Qd4=vcmp.eq(Vu.w,Vv.w)
 0  0  0  1 1  1   1 1  1  0  0   v  v  v  v  v P   P 0  u  u   u u u 0 0 0  1  0 0  d    d Qd4=vcmp.gt(Vu.b,Vv.b)
 0  0  0  1 1  1   1 1  1  0  0   v  v  v  v  v P   P 0  u  u   u u u 0 0 0  1  0 1  d    d Qd4=vcmp.gt(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  1  0  0   v  v  v  v  v P   P 0  u  u   u u u 0 0 0  1  1 0  d    d Qd4=vcmp.gt(Vu.w,Vv.w)
 0  0  0  1 1  1   1 1  1  0  0   v  v  v  v  v P   P 0  u  u   u u u 0 0 1  0  0 0  d    d Qd4=vcmp.gt(Vu.ub,Vv.ub)
 0  0  0  1 1  1   1 1  1  0  0   v  v  v  v  v P   P 0  u  u   u u u 0 0 1  0  0 1  d    d Qd4=vcmp.gt(Vu.uh,Vv.uh)
 0  0  0  1 1  1   1 1  1  0  0   v  v  v  v  v P   P 0  u  u   u u u 0 0 1  0  1 0  d    d Qd4=vcmp.gt(Vu.uw,Vv.uw)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                            78
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Parse           Packet/Loop parse bits
                  d2              Field to encode register d
                  u5              Field to encode register u
                  v5              Field to encode register v
                  x2              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION              79
Hexagon V66 HVX Programmer’s Reference Manual                                                                            Instruction Set
        Conditional accumulate
                 Conditionally add or subtract a value to the destination register. If the corresponding bits
                 are set in the vector predicate register, the elements in Vu are added to or subtracted from
                 the corresponding elements in Vx. Supports byte, halfword, and word. No saturation is
                 performed on the result.
                                                                if (Qv4) Vx.b +[-]= Vu.b
                              [N-1]                                                [1]              [0]             Vu
                                         [N-1]                                                [1]             [0]         Qv
                                     0                                                    0               0
                                                 N is the number of datapath
                               +/-                                                 +/-              +/-
                                                    elements implemented
                              [N-1]                                                [1]              [0]             Vx
                     Syntax                                                    Behavior
                     if ([!]Qv4) Vx.b[+-]=Vu.b                                 for (i = 0; i < VELEM(8); i[+-][+-]) {
                                                                                   Vx.ub[i]=QvV.i ? Vx.ub[i] : Vx.ub[i][+-
                                                                               ]Vu.ub[i] ;
                                                                               }
                     if ([!]Qv4) Vx.h[+-]=Vu.h                                 for (i = 0; i < VELEM(16); i[+-][+-]) {
                                                                                   Vx.h[i]=select_bytes(QvV,i,Vx.h[i],Vx.h[i][+
                                                                               -]Vu.h[i]) ;
                                                                               }
                     if ([!]Qv4) Vx.w[+-]=Vu.w                                 for (i = 0; i < VELEM(32); i[+-][+-]) {
                                                                                   Vx.w[i]=select_bytes(QvV,i,Vx.w[i],Vx.w[i][+
                                                                               -]Vu.w[i]) ;
                                                                               }
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                            80
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction can use any HVX resource.
                  Intrinsics
                   if (!Qv4) Vx.b+=Vu.b                    HVX_Vector Q6_Vb_condacc_QnVbVb(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (!Qv4) Vx.b-=Vu.b                    HVX_Vector Q6_Vb_condnac_QnVbVb(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (!Qv4) Vx.h+=Vu.h                    HVX_Vector Q6_Vh_condacc_QnVhVh(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (!Qv4) Vx.h-=Vu.h                    HVX_Vector Q6_Vh_condnac_QnVhVh(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (!Qv4) Vx.w+=Vu.w                    HVX_Vector Q6_Vw_condacc_QnVwVw(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (!Qv4) Vx.w-=Vu.w                    HVX_Vector Q6_Vw_condnac_QnVwVw(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (Qv4) Vx.b+=Vu.b                     HVX_Vector Q6_Vb_condacc_QVbVb(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (Qv4) Vx.b-=Vu.b                     HVX_Vector Q6_Vb_condnac_QVbVb(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (Qv4) Vx.h+=Vu.h                     HVX_Vector Q6_Vh_condacc_QVhVh(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (Qv4) Vx.h-=Vu.h                     HVX_Vector Q6_Vh_condnac_QVhVh(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (Qv4) Vx.w+=Vu.w                     HVX_Vector Q6_Vw_condacc_QVwVw(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                   if (Qv4) Vx.w-=Vu.w                     HVX_Vector Q6_Vw_condnac_QVwVw(HVX_VectorPred
                                                           Qv, HVX_Vector Vx, HVX_Vector Vu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                                       Parse          u5                 x5
 0  0  0  1 1  1   1 0   v  v 0   -  -  - 0  1  P   P 1  u   u  u u u 0  0 0  x x  x x  x if (Qv4) Vx.b+=Vu.b
 0  0  0  1 1  1   1 0   v  v 0   -  -  - 0  1  P   P 1  u   u  u u u 0  0 1  x x  x x  x if (Qv4) Vx.h+=Vu.h
 0  0  0  1 1  1   1 0   v  v 0   -  -  - 0  1  P   P 1  u   u  u u u 0  1 0  x x  x x  x if (Qv4) Vx.w+=Vu.w
 0  0  0  1 1  1   1 0   v  v 0   -  -  - 0  1  P   P 1  u   u  u u u 0  1 1  x x  x x  x if (!Qv4) Vx.b+=Vu.b
 0  0  0  1 1  1   1 0   v  v 0   -  -  - 0  1  P   P 1  u   u  u u u 1  0 0  x x  x x  x if (!Qv4) Vx.h+=Vu.h
 0  0  0  1 1  1   1 0   v  v 0   -  -  - 0  1  P   P 1  u   u  u u u 1  0 1  x x  x x  x if (!Qv4) Vx.w+=Vu.w
 0  0  0  1 1  1   1 0   v  v 0   -  -  - 0  1  P   P 1  u   u  u u u 1  1 0  x x  x x  x if (Qv4) Vx.b-=Vu.b
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          81
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
 0  0 0  1  1  1   1 0   v  v 0   -  -  -  0  1  P  P 1   u  u  u u u 1 1 1  x  x x  x  x if (Qv4) Vx.h-=Vu.h
 0  0 0  1  1  1   1 0   v  v 0   -  -  -  1  0  P  P 1   u  u  u u u 0 0 0  x  x x  x  x if (Qv4) Vx.w-=Vu.w
 0  0 0  1  1  1   1 0   v  v 0   -  -  -  1  0  P  P 1   u  u  u u u 0 0 1  x  x x  x  x if (!Qv4) Vx.b-=Vu.b
 0  0 0  1  1  1   1 0   v  v 0   -  -  -  1  0  P  P 1   u  u  u u u 0 1 0  x  x x  x  x if (!Qv4) Vx.h-=Vu.h
 0  0 0  1  1  1   1 0   v  v 0   -  -  -  1  0  P  P 1   u  u  u u u 0 1 1  x  x x  x  x if (!Qv4) Vx.w-=Vu.w
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  u5                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          82
Hexagon V66 HVX Programmer’s Reference Manual                                                                                           Instruction Set
        Mux select
                 Perform a parallel if-then-else operation. Based on a predicate bit in a vector predicate
                 register, if the bit is set, the corresponding byte from vector register Vu is placed in the
                 destination vector register Vd. Otherwise, the corresponding byte from Vv is written. The
                 operation works on bytes so it can handle all data sizes.
                                                               Vd=vmux(Qt4,Vu,Vv)
                                                               b[N-1]                      b[3]       b[2]      b[1]       b[0]    Vu
                                                          b[N-1]                    b[3]       b[2]      b[1]       b[0]           Vv
                      N is number of slices implemented
                                                                                                                                        Qt.b[0]
                                                                                                                                        Qt.b[1]
                                                                                                                                        Qt.b[2]
                                                                                                                                        Qt.b[3]
                                                                                                                                          ...
                                                                                                                                        Qt.b[N-1]
                                                              b[N-1]                    b[3]      b[2]       b[1]      b[0]       Vd
                     Syntax                                                                Behavior
                     Vd=vmux(Qt4,Vu,Vv)                                                    for (i = 0; i < VELEM(8); i++) {
                                                                                               Vd.ub[i] = QtV[i] ? Vu.ub[i] : Vv.ub[i] ;
                                                                                           }
                 Class: COPROC_VX (slots 0,1,2,3)
                 Notes
                                                    ■       This instruction can use any HVX resource.
                 Intrinsics
                     Vd=vmux(Qt4,Vu,Vv)                                                    HVX_Vector Q6_V_vmux_QVV(HVX_VectorPred Qt,
                                                                                           HVX_Vector Vu, HVX_Vector Vv)
80-N2040-44 Rev. B                                        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          83
Hexagon V66 HVX Programmer’s Reference Manual                                                    Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6    5 4 3 2  1 0
   ICLASS                                        Parse         u5         t2       d5
 0  0  0  1 1  1   1 0  1  1  1   v  v  v  v  v  P   P 1  u  u  u u u - t    t d d d  d d Vd=vmux(Qt4,Vu,Vv)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t2                Field to encode register t
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      84
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
        Saturation
                  Perform simple arithmetic operations, add and subtract, between the elements of the two
                  vectors Vu and Vv. Supports word, halfword (signed and unsigned), and byte (signed and
                  unsigned).
                  Optionally saturate for word and halfword. Always saturate for unsigned types.
                   Syntax                               Behavior
                   Vd.h=vsat(Vu.w,Vv.w)                  for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i].h[0]=sat16(Vv.w[i]);
                                                              Vd.w[i].h[1]=sat16(Vu.w[i]) ;
                                                         }
                   Vd.ub=vsat(Vu.h,Vv.h)                 for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i].b[0]=usat8(Vv.h[i]);
                                                              Vd.uh[i].b[1]=usat8(Vu.h[i]) ;
                                                         }
                   Vd.uh=vsat(Vu.uw,Vv.uw)               for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i].h[0]=usat16(Vv.uw[i]);
                                                              Vd.w[i].h[1]=usat16(Vu.uw[i]) ;
                                                         }
                   Vd.w=vsatdw(Vu.w, Vv.w)               for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = usat32(Vu.w[i]:Vv.w[i]) ;
                                                         }
                   Vd=vsathub(Vu,Vv)                     Assembler mapped to: "Vd.ub=vsat(Vu.h,Vv.h)"
                   Vd=vsatuwuh(Vu,Vv)                    Assembler mapped to: "Vd.uh=vsat(Vu.uw,Vv.uw)"
                   Vd=vsatwh(Vu,Vv)                      Assembler mapped to: "Vd.h=vsat(Vu.w,Vv.w)"
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction can use any HVX resource.
                  Intrinsics
                   Vd.h=vsat(Vu.w,Vv.w)                  HVX_Vector Q6_Vh_vsat_VwVw(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.ub=vsat(Vu.h,Vv.h)                 HVX_Vector Q6_Vub_vsat_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.uh=vsat(Vu.uw,Vv.uw)               HVX_Vector Q6_Vuh_vsat_VuwVuw(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.w=vsatdw(Vu.w, Vv.w)               HVX_Vector Q6_Vw_vsatdw_VwVw(HVX_Vector Vu,
                                                         HVX_Vector Vv)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    85
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   0 1  1  0  0   v  v  v  v  v  P   P 1  u  u  u u u 1 1 1  d  d d  d  d Vd.w=vsatdw(Vu.w, Vv.w)
 0  0  0  1 1  1   1 1  0  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1 1 0  d  d d  d  d Vd.uh=vsat(Vu.uw,Vv.uw)
 0  0  0  1 1  1   1 1  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 1 0  d  d d  d  d Vd.ub=vsat(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 1 1  d  d d  d  d Vd.h=vsat(Vu.w,Vv.w)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         86
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
        In-lane shuffle
                  Shuffle the even or odd elements respectively from two vector registers into one
                  destination vector register. Supports bytes and halfwords.
                    Vd.b=vshuffe(Vu.b,Vv.b)
                              b[N-1]   b[N-2]         ....          b[3]   b[2]     b[1]   b[0]   Vv
                     b[N-1]   b[N-2]          ....         b[3]     b[2]   b[1]     b[0]          Vu
                              b[N-1]   b[N-2]         ....          b[3]   b[2]     b[1]   b[0]   Vd
                    Vd.b=vshuffo(Vu.b,Vv.b)
                              b[N-1]   b[N-2]         ....          b[3]   b[2]     b[1]   b[0]   Vv
                     b[N-1]   b[N-2]          ....          b[3]     b[2]   b[1]     b[0]          Vu
                     b[N-1]   b[N-2]          ....         b[3]     b[2]   b[1]     b[0]          Vd
                  This group of shuffles is limited to bytes and halfwords.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    87
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                   Syntax                                 Behavior
                   Vd.b=vshuffe(Vu.b,Vv.b)                 for (i = 0; i < VELEM(16); i++) {
                                                                Vd.uh[i].b[0]=Vv.uh[i].ub[0];
                                                                Vd.uh[i].b[1]=Vu.uh[i].ub[0] ;
                                                           }
                   Vd.b=vshuffo(Vu.b,Vv.b)                 for (i = 0; i < VELEM(16); i++) {
                                                                Vd.uh[i].b[0]=Vv.uh[i].ub[1];
                                                                Vd.uh[i].b[1]=Vu.uh[i].ub[1] ;
                                                           }
                   Vd.h=vshuffe(Vu.h,Vv.h)                 for (i = 0; i < VELEM(32); i++) {
                                                                Vd.uw[i].h[0]=Vv.uw[i].uh[0];
                                                                Vd.uw[i].h[1]=Vu.uw[i].uh[0] ;
                                                           }
                   Vd.h=vshuffo(Vu.h,Vv.h)                 for (i = 0; i < VELEM(32); i++) {
                                                                Vd.uw[i].h[0]=Vv.uw[i].uh[1];
                                                                Vd.uw[i].h[1]=Vu.uw[i].uh[1] ;
                                                           }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction can use any HVX resource.
                  Intrinsics
                   Vd.b=vshuffe(Vu.b,Vv.b)                 HVX_Vector Q6_Vb_vshuffe_VbVb(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.b=vshuffo(Vu.b,Vv.b)                 HVX_Vector Q6_Vb_vshuffo_VbVb(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.h=vshuffe(Vu.h,Vv.h)                 HVX_Vector Q6_Vh_vshuffe_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.h=vshuffo(Vu.h,Vv.h)                 HVX_Vector Q6_Vh_vshuffo_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS                                        Parse         u5                  d5
 0  0  0  1 1  1   1 1  0  1  0   v  v  v  v  v  P   P 0 u   u  u u  u 0 0  1 d  d d  d d Vd.b=vshuffe(Vu.b,Vv.b)
 0  0  0  1 1  1   1 1  0  1  0   v  v  v  v  v  P   P 0 u   u  u u  u 0 1  0 d  d d  d d Vd.b=vshuffo(Vu.b,Vv.b)
 0  0  0  1 1  1   1 1  0  1  0   v  v  v  v  v  P   P 0 u   u  u u  u 0 1  1 d  d d  d d Vd.h=vshuffe(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  0  1  0   v  v  v  v  v  P   P 0 u   u  u u  u 1 0  0 d  d d  d d Vd.h=vshuffo(Vu.h,Vv.h)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          88
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  d5              Field to encode register d
                  u5              Field to encode register u
                  v5              Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION              89
Hexagon V66 HVX Programmer’s Reference Manual                                                                            Instruction Set
         5.4      HVX/DEBUG
                  The HVX/DEBUG instruction subclass includes instructions used for debugging.
          Extract vector element
                  Extract a word from the vector register Vu using bits 5:2 of Rs as the word index. The
                  result is placed in the scalar register Rd. A memory address can be used as the control
                  selection Rs after data has been read from memory using a vector load.
                  This is a very high latency instruction and should only be used in debug. A memory to
                  memory transfer is more efficient.
                     Rs              28                         >>2
                                                                                                 Rd.w=vextract(Vu,Rs)
                     Vu    w[15]  w[14] w[13]  w[12]  w[11] w[10]  w[9]   w[8]  w[7] w[6]   w[5]   w[4]  w[3] w[2] w[1] w[0]
                      Rd           w[7]
                   Syntax                                           Behavior
                   Rd.w=vextract(Vu,Rs)                              Assembler mapped to: "Rd=vextract(Vu,Rs)"
                   Rd=vextract(Vu,Rs)                                Rd = Vu.uw[ (Rs & (VWIDTH-1)) >> 2];
                  Class: LD (slots 0)
                  Notes
                        ■    This is a solo instruction. It must not be grouped with other instructions in a
                             packet.
                  Intrinsics
                   Rd=vextract(Vu,Rs)                       Word32 Q6_R_vextract_VR(HVX_Vector Vu, Word32 Rs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9                8 7    6  5   4   3  2   1 0
                                 U
   ICLASS    Amode      Type                s5          Parse              u5                           d5
                                 N
 1  0  0  1 0  0   1  0  0   0   0   s  s    s  s    s   P  P 0    u    u  u   u   u -    - 1    d   d  d   d d Rd=vextract(Vu,Rs)
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                             90
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Amode           Amode
                  Type            Type
                  UN              Unsigned
                  Parse           Packet/Loop parse bits
                  d5              Field to encode register d
                  s5              Field to encode register s
                  u5              Field to encode register u
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION              91
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
       5.5        HVX/GATHER-DOUBLE-RESOURCE
                  The HVX/GATHER-DOUBLE-RESOURCE instruction subclass includes instructions
                  that perform gather operations into the vector TCM.
        Vector gather
                  Gather operations are effectively element copies from a large region in VTCM to a smaller
                  vector-sized region. The larger region of memory is specified by two scalar registers: Rt32
                  is the base and Mu2 specified the length-1 of the region in bytes. This region must reside
                  in VTCM and cannot cross a page boundary. A vector register, Vv32, specifies byte
                  offsets to this region. Elements of either halfword or word granularity are copied from the
                  address pointed to by Rt + Vv32 for each element in the vector to the corresponding
                  element in the linear element pointed to by the accompanying store.
                  The offset vector, Vv32, can contain byte offsets specified in either halfword or word
                  sizes. The final element addresses do not have to be byte aligned. If an offset crosses the
                  end of the gather region, it is dropped. Offsets must be positive otherwise they are
                  dropped. A vector predicate register can also be specified. If a the predicate is false, that
                  byte is not copied. This can be used to emulate a byte gather.
                  The gather instruction must be paired with a VMEM .new store that uses a tmp register
                  source.
                  The following example gathers halfwords with halfword addresses and saves the results to
                  the address pointed to by R0 of the VMEM instruction.
                       { VMEM(R0+#0) = Vtmp.new;
                       Vtmp.h = vgather(R1,M0, V1:0.w);
                       }
                  If a vgather is not accompanied with a store, it is dropped.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      92
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                                                       Instruction Set
                         { vmem(Rs+#I)=Vtmp.h; vtmp.h = vgather(Rt,Mu,Vv.h) }
                         Rs – Address of gathered values in VTCM       Rt – Scalar Indicating base address in VTCM
                                                                       Mu – Scalar indicating length-1 of Region
                                                                       Vv – Vector with byte offsets from base
                                        Rt+Mu            Example of vgather (only first 4 elements shown)
                                 ...
                                        Region                                                                                                                         ...
                       ...       ...     End
                                                                                                                                                                              Scatter VTCM Region
                                                                                                                                                                       ...
                       ...       ...
                                                                                                                                                                       ...
                       ...       ...                                                                                       +
                                                                                                                     *( Rs
                                                                                                                         2)                                            ...
                                                                                                                               =
                       ...       ...
                                                                                                                                  Rt +              s+0
                                                                                                                               *(
                                                                                                                                      .         * (R
                                                                             * (R                                                  Vv               )=                 ...
                       ...       ...                                                s+ 4                                                 h[ 1
                                                                                        )= *                                                             t
                                                                                               (Rt+                                        ])         *(R
                                                                                                      Vv .
                                                                                                             h[2      Region                                       )
                                                                                                                ])                                              [0]    ...
                       ...                                                                                                                                  v .h
                                                                                                                       Base
                                                                   *(Rs+6)=
                                                                           *(Rt+Vv.                                                                       +V
                                                                                    h    [3])                                                                                   Gather
                       ...       ...                                                                                                                                   ...      Results
                                                                                                                                                                             at address Rs
                       ...
                                                                                                                                                                   VTCM
                       ...                                                                                                                                         Base
                                                                                                                        Rt
                     Syntax                                                          Behavior
                     if (Qs4)                                                         MuV = MuV | (element_size-1);
                     vtmp.h=vgather(Rt,Mu,Vvv.w).h                                    Rt = Rt & ~(element_size-1);
                                                                                      for (i = 0; i < VELEM(32); i++) {
                                                                                          for(j = 0; j < 2; j++) {
                                                                                              EA = Rt+Vvv.v[j].uw[i];
                                                                                              if ( (Rt <= EA <= Rt + MuV) & QsV)
                                                                                      TEMP.uw[i].uh[j] = *EA;
                                                                                          }
                                                                                      }
                     vtmp.h=vgather(Rt,Mu,Vvv.w).h                                    MuV = MuV | (element_size-1);
                                                                                      Rt = Rt & ~(element_size-1);
                                                                                      for (i = 0; i < VELEM(32); i++) {
                                                                                          for(j = 0; j < 2; j++) {
                                                                                              EA = Rt+Vvv.v[j].uw[i];
                                                                                              if (Rt <= EA <= Rt + MuV)
                                                                                      TEMP.uw[i].uh[j] = *EA;
                                                                                          }
                                                                                      }
                 Class: COPROC_VMEM (slots 1)
                 Notes
                             ■         This instruction can use any HVX resource.
80-N2040-44 Rev. B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                                                                   93
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                  Intrinsics
                   if (Qs4)                                 void Q6_vgather_AQRMWw(HVX_Vector* A,
                   vtmp.h=vgather(Rt,Mu,Vvv.w).h            HVX_VectorPred Qs, HVX_Vector* Rb, Word32 Mu,
                                                            HVX_VectorPair Vvv)
                   vtmp.h=vgather(Rt,Mu,Vvv.w).h            void Q6_vgather_ARMWw(HVX_Vector* A, HVX_Vector*
                                                            Rb, Word32 Mu, HVX_VectorPair Vvv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6    5 4 3 2 1 0
   ICLASS                  NT           t5       Parse u1
                                                                                           vtmp.h=vgather(Rt,Mu,Vvv.
 0  0  1  0 1  1   1 1  0  0  0   t  t   t  t  t P   P u  -   - 0 1  0  - -    - v v v v v
                                                                                           w).h
   ICLASS                  NT           t5       Parse u1                   s2
                                                                                           if (Qs4)
 0  0  1  0 1  1   1 1  0  0  0   t  t   t  t  t P   P u  -   - 1 1  0  - s    s v v v v v vtmp.h=vgather(Rt,Mu,Vvv.
                                                                                           w).h
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  s2                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          94
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
       5.6        HVX/GATHER
                  The HVX/GATHER instruction subclass includes instructions that perform gather
                  operations.
        Vector gather
                  Gather operations are effectively element copies from a large region in VTCM to a smaller
                  vector-sized region. The larger region of memory is specified by two scalar registers: Rt32
                  is the base and Mu2 specified the length-1 of the region in bytes. This region must reside
                  in VTCM and cannot cross a page boundary. A vector register, Vv32, specifies byte
                  offsets to this region. Elements of either halfword or word granularity are copied from the
                  address pointed to by Rt + Vv32 for each element in the vector to the corresponding
                  element in the linear element pointed to by the accompanying store.
                  The offset vector, Vv32, can contain byte offsets specified in either halfword or word
                  sizes. The final element addresses do not have to be byte aligned. If an offset crosses the
                  end of the gather region, it is dropped. Offsets must be positive otherwise they are
                  dropped. A vector predicate register can also be specified. If a the predicate is false, that
                  byte is not copied. This can be used to emulate a byte gather.
                  The gather instruction must be paired with a VMEM .new store that uses a tmp register
                  source. The following example gathers halfwords with halfword addresses and saves the
                  results to the address pointed to by R0 of the VMEM instruction.
                       { VMEM(R0+#0) = Vtmp.new;
                       Vtmp.h = vgather(R1,M0, V0.h);
                       }
                  If a vgather is not accompanied with a store, it is dropped.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      95
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                                                     Instruction Set
                             { vmem(Rs+#I)=Vtmp.h; vtmp.h = vgather(Rt,Mu,Vv.h) }
                         Rs – Address of gathered values in VTCM       Rt – Scalar Indicating base address in VTCM
                                                                       Mu – Scalar indicating length-1 of Region
                                                                       Vv – Vector with byte offsets from base
                                       Rt+Mu             Example of vgather (only first 4 elements shown)
                                 ...
                                       Region                                                                                                                        ...
                       ...       ...    End
                                                                                                                                                                            Scatter VTCM Region
                                                                                                                                                                     ...
                       ...       ...
                                                                                                                                                                     ...
                       ...       ...
                                                                                                                      Rs+2
                                                                                                                    *(
                                                                                                                        )=                                           ...
                       ...       ...                                                                                            Rt          *(R
                                                                                                                              *(
                                                                                                                                  v.         s+0
                                                                                * (R                                            +V                )=                 ...
                       ...       ...                                                   s+4                                           h[
                                                                                             )= *
                                                                                                                                                   *(R
                                                                                                                                     1] )
                                                                                                 (Rt +
                                                                                                      Vv.                                                        )
                                                                                                            h[2
                                                                                                                                                              [0]
                                                                                                                     Region
                                                                                                               ])                                                    ...
                       ...                                                                                            Base                                v.h
                                                                   *(Rs+6)=
                                                                              *(Rt+Vv.                                                                 t+V
                                                                                      h[3])                                                                                   Gather
                       ...       ...                                                                                                                                 ...      Results
                                                                                                                                                                           at address Rs
                       ...
                                                                                                                                                                 VTCM
                       ...                                                                                                                                       Base
                                                                                                                      Rt
                     Syntax                                                            Behavior
                     if (Qs4)                                                           MuV = MuV | (element_size-1);
                     vtmp.h=vgather(Rt,Mu,Vv.h).h                                       Rt = Rt & ~(element_size-1);
                                                                                        for (i = 0; i < VELEM(16); i++) {
                                                                                            EA = Rt+Vv.uh[i];
                                                                                            if ( (Rt <= EA <= Rt + MuV) & QsV) TEMP.uh[i]
                                                                                        = *EA;
                                                                                        }
                     if (Qs4)                                                           MuV = MuV | (element_size-1);
                     vtmp.w=vgather(Rt,Mu,Vv.w).w                                       Rt = Rt & ~(element_size-1);
                                                                                        for (i = 0; i < VELEM(32); i++) {
                                                                                            EA = Rt+Vv.uw[i];
                                                                                            if ( (Rt <= EA <= Rt + MuV) & QsV) TEMP.uw[i]
                                                                                        = *EA;
                                                                                        }
                     vtmp.h=vgather(Rt,Mu,Vv.h).h                                       MuV = MuV | (element_size-1);
                                                                                        Rt = Rt & ~(element_size-1);
                                                                                        for (i = 0; i < VELEM(16); i++) {
                                                                                            EA = Rt+Vv.uh[i];
                                                                                            if (Rt <= EA <= Rt + MuV) TEMP.uh[i] = *EA;
                                                                                        }
                     vtmp.w=vgather(Rt,Mu,Vv.w).w                                       MuV = MuV | (element_size-1);
                                                                                        Rt = Rt & ~(element_size-1);
                                                                                        for (i = 0; i < VELEM(32); i++) {
                                                                                            EA = Rt+Vv.uw[i];
                                                                                            if (Rt <= EA <= Rt + MuV) TEMP.uw[i] = *EA;
                                                                                        }
80-N2040-44 Rev. B             MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                                                               96
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                  Class: COPROC_VMEM (slots 1)
                  Notes
                       ■   This instruction can use any HVX resource.
                  Intrinsics
                   if (Qs4)                                 void Q6_vgather_AQRMVh(HVX_Vector* A,
                   vtmp.h=vgather(Rt,Mu,Vv.h).h             HVX_VectorPred Qs, HVX_Vector* Rb, Word32 Mu,
                                                            HVX_Vector Vv)
                   if (Qs4)                                 void Q6_vgather_AQRMVw(HVX_Vector* A,
                   vtmp.w=vgather(Rt,Mu,Vv.w).w             HVX_VectorPred Qs, HVX_Vector* Rb, Word32 Mu,
                                                            HVX_Vector Vv)
                   vtmp.h=vgather(Rt,Mu,Vv.h).h             void Q6_vgather_ARMVh(HVX_Vector* A, HVX_Vector*
                                                            Rb, Word32 Mu, HVX_Vector Vv)
                   vtmp.w=vgather(Rt,Mu,Vv.w).w             void Q6_vgather_ARMVw(HVX_Vector* A, HVX_Vector*
                                                            Rb, Word32 Mu, HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6     5 4 3 2 1 0
   ICLASS                  NT           t5       Parse u1
 0  0  1  0 1  1   1 1  0  0  0   t  t   t  t  t P   P u  -   - 0 0  0  -  -    - v v v v v vtmp.w=vgather(Rt,Mu,Vv.
                                                                                            w).w
                                                                                            vtmp.h=vgather(Rt,Mu,Vv.h
 0  0  1  0 1  1   1 1  0  0  0   t  t   t  t  t P   P u  -   - 0 0  1  -  -    - v v v v v ).h
   ICLASS                  NT           t5       Parse u1                    s2
                                                                                            if (Qs4)
 0  0  1  0 1  1   1 1  0  0  0   t  t   t  t  t P   P u  -   - 1 0  0  - s     s v v v v v vtmp.w=vgather(Rt,Mu,Vv.
                                                                                            w).w
                                                                                            if (Qs4)
 0  0  1  0 1  1   1 1  0  0  0   t  t   t  t  t P   P u  -   - 1 0  1  - s     s v v v v v vtmp.h=vgather(Rt,Mu,Vv.h
                                                                                            ).h
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  s2                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           97
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
       5.7        HVX/LOAD
                  The HVX/LOAD instruction subclass includes memory load instructions.
        Load - aligned
                  Read a full vector register Vd from memory, using a vector-size-aligned address. The
                  operation has three ways to generate the memory pointer address: Rt with a constant 4-bit
                  signed offset, Rx with a signed post-increment, and Rx with a modifier register Mu post-
                  increment. For the immediate forms, the value specifies the number of vectors worth of
                  data. Mu contains the actual byte offset.
                  If the pointer presented to the instruction is not aligned, the instruction simply ignores the
                  lower bits, yielding an aligned address.
                  If a scalar predicate register Pv evaluates true, load a full vector register Vs from memory,
                  using a vector-size-aligned address. Otherwise, the operation becomes a NOP.
                   Syntax                                Behavior
                   Vd=vmem(Rt)                            Assembler mapped to: "Vd=vmem(Rt+#0)"
                   Vd=vmem(Rt):nt                         Assembler mapped to: "Vd=vmem(Rt+#0):nt"
                   Vd=vmem(Rt+#s4)                        EA=Rt+#s*VBYTES;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                   Vd=vmem(Rt+#s4):nt                     EA=Rt+#s*VBYTES;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                   Vd=vmem(Rx++#s3)                       EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+#s*VBYTES;
                   Vd=vmem(Rx++#s3):nt                    EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+#s*VBYTES;
                   Vd=vmem(Rx++Mu)                        EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+MuV;
                   Vd=vmem(Rx++Mu):nt                     EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+MuV;
                   if ([!]Pv) Vd=vmem(Rt)                 Assembler mapped to: "if ([!]Pv) Vd=vmem(Rt+#0)"
                   if ([!]Pv) Vd=vmem(Rt):nt              Assembler mapped to: "if ([!]Pv)
                                                          Vd=vmem(Rt+#0):nt"
                   if ([!]Pv) Vd=vmem(Rt+#s4)             if ([!]Pv[0]) {
                                                               EA=Rt+#s*VBYTES;
                                                               Vd = *(EA&~(ALIGNMENT-1));
                                                          ;
                                                          } else {
                                                               NOP;
                                                          }
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         98
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
                   Syntax                               Behavior
                   if ([!]Pv) Vd=vmem(Rt+#s4):nt         if ([!]Pv[0]) {
                                                              EA=Rt+#s*VBYTES;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv) Vd=vmem(Rx++#s3)           if ([!]Pv[0]) {
                                                              EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+#s*VBYTES;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv) Vd=vmem(Rx++#s3):nt        if ([!]Pv[0]) {
                                                              EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+#s*VBYTES;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv) Vd=vmem(Rx++Mu)            if ([!]Pv[0]) {
                                                              EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+MuV;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv) Vd=vmem(Rx++Mu):nt         if ([!]Pv[0]) {
                                                              EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+MuV;
                                                         } else {
                                                              NOP;
                                                         }
                  Class: COPROC_VMEM (slots 0,1)
                  Notes
                       ■  This instruction can use any HVX resource.
                       ■  An optional "non-temporal" hint to the micro-architecture can be specified to
                          indicate the data has no reuse.
                       ■  Immediates used in address computation are specified in multiples of vector
                          length.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   99
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                  NT           t5       Parse                            d5
 0  0  1  0 1  0   0 0  0  0  0   t  t   t  t  t P   P  i 0  0  i i i 0 0 0  d  d d  d  d Vd=vmem(Rt+#s4)
 0  0  1  0 1  0   0 0  0  1  0   t  t   t  t  t P   P  i 0  0  i i i 0 0 0  d  d d  d  d Vd=vmem(Rt+#s4):nt
 0  0  1  0 1  0   0 0  1  0  0   t  t   t  t  t P   P  i v  v  i i i 0 1 0  d  d d  d  d if (Pv) Vd=vmem(Rt+#s4)
 0  0  1  0 1  0   0 0  1  0  0   t  t   t  t  t P   P  i v  v  i i i 0 1 1  d  d d  d  d if (!Pv) Vd=vmem(Rt+#s4)
 0  0  1  0 1  0   0 0  1  1  0   t  t   t  t  t P   P  i v  v  i i i 0 1 0  d  d d  d  d if (Pv)
                                                                                          Vd=vmem(Rt+#s4):nt
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 0  1  1  0   t  t   t  t  t P   P  i v  v  i i i 0 1 1  d  d d  d  d
                                                                                          Vd=vmem(Rt+#s4):nt
   ICLASS                  NT          x5        Parse                            d5
 0  0  1  0 1  0   0 1  0  0  0   x  x  x  x  x  P   P  - 0  0  i i i 0 0 0  d  d d  d  d Vd=vmem(Rx++#s3)
 0  0  1  0 1  0   0 1  0  1  0   x  x  x  x  x  P   P  - 0  0  i i i 0 0 0  d  d d  d  d Vd=vmem(Rx++#s3):nt
 0  0  1  0 1  0   0 1  1  0  0   x  x   x x  x  P   P  - v  v  i i i 0 1 0  d  d d  d  d if (Pv) Vd=vmem(Rx++#s3)
 0  0  1  0 1  0   0 1  1  0  0   x  x   x x  x  P   P  - v  v  i i i 0 1 1  d  d d  d  d if (!Pv) Vd=vmem(Rx++#s3)
                                                                                        d ifVd=vmem(Rx++#s3):nt
                                                                                             (Pv)
 0  0  1  0 1  0   0 1  1  1  0   x  x   x x  x  P   P  - v  v  i i i 0 1 0  d  d d  d
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 1  1  1  0   x  x   x x  x  P   P  - v  v  i i i 0 1 1  d  d d  d  d
                                                                                          Vd=vmem(Rx++#s3):nt
   ICLASS                  NT          x5        Parse u1                         d5
 0  0  1  0 1  0   1 1  0  0  0   x  x   x x  x  P   P u 0   0  - - - 0 0 0  d  d d  d  d Vd=vmem(Rx++Mu)
 0  0  1  0 1  0   1 1  0  1  0   x  x   x x  x  P   P u 0   0  - - - 0 0 0  d  d d  d  d Vd=vmem(Rx++Mu):nt
 0  0  1  0 1  0   1 1  1  0  0   x  x   x x  x  P   P u  v  v  - - - 0 1 0  d  d d  d  d if (Pv) Vd=vmem(Rx++Mu)
 0  0  1  0 1  0   1 1  1  0  0   x  x   x x  x  P   P u  v  v  - - - 0 1 1  d  d d  d  d if (!Pv) Vd=vmem(Rx++Mu)
                                                                                        d ifVd=vmem(Rx++Mu):nt
                                                                                             (Pv)
 0  0  1  0 1  0   1 1  1  1  0   x  x   x x  x  P   P u  v  v  - - - 0 1 0  d  d d  d
                                                                                          if (!Pv)
 0  0  1  0 1  0   1 1  1  1  0   x  x  x  x  x  P   P u  v  v  - - - 0 1 1  d  d d  d  d Vd=vmem(Rx++Mu):nt
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u1                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         100
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
        Load - immediate use
                  Read a full vector register Vd (and/or temporary vector register) from memory, using a
                  vector-size-aligned address. The operation has three ways to generate the memory pointer
                  address: Rt with a constant 4-bit signed offset, Rx with a signed post-increment, and Rx
                  with a modifier register Mu post-increment. For the immediate forms, the value indicates
                  the number of vectors worth of data. Mu contains the actual byte offset.
                  If the pointer presented to the instruction is not aligned, the instruction simply ignores the
                  lower bits, yielding an aligned address. The value is used immediately in the packet as a
                  source operand of any instruction.
                  "Vd.cur" writes the load value to a vector register in addition to consuming it within the
                  packet.
                  "Vd.tmp" does not write the incoming data to the vector register file. The data is only used
                  as a source in the current packet, and then immediately discarded. Note that this form does
                  not consume any vector resources, allowing it to be placed in parallel with some
                  instructions that a normal align load cannot.
                  If a scalar predicate register Pv evaluates true, load a full vector register Vs from memory,
                  using a vector-size-aligned address. Otherwise, the operation becomes a NOP.
                   Syntax                                Behavior
                   Vd.cur=vmem(Rt+#s4)                    EA=Rt+#s*VBYTES;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                   Vd.cur=vmem(Rt+#s4):nt                 EA=Rt+#s*VBYTES;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                   Vd.cur=vmem(Rx++#s3)                   EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+#s*VBYTES;
                   Vd.cur=vmem(Rx++#s3):nt                EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+#s*VBYTES;
                   Vd.cur=vmem(Rx++Mu)                    EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+MuV;
                   Vd.cur=vmem(Rx++Mu):nt                 EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+MuV;
                   if ([!]Pv) Vd.cur=vmem(Rt)             Assembler mapped to: "if ([!]Pv)
                                                          Vd.cur=vmem(Rt+#0)"
                   if ([!]Pv) Vd.cur=vmem(Rt):nt          Assembler mapped to: "if ([!]Pv)
                                                          Vd.cur=vmem(Rt+#0):nt"
                   if ([!]Pv) Vd.cur=vmem(Rt+#s4)         if ([!]Pv[0]) {
                                                               EA=Rt+#s*VBYTES;
                                                               Vd = *(EA&~(ALIGNMENT-1));
                                                          ;
                                                          } else {
                                                               NOP;
                                                          }
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        101
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
                   Syntax                               Behavior
                   if ([!]Pv)                            if ([!]Pv[0]) {
                   Vd.cur=vmem(Rt+#s4):nt                     EA=Rt+#s*VBYTES;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv) Vd.cur=vmem(Rx++#s3)       if ([!]Pv[0]) {
                                                              EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+#s*VBYTES;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv)                            if ([!]Pv[0]) {
                   Vd.cur=vmem(Rx++#s3):nt                    EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+#s*VBYTES;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv) Vd.cur=vmem(Rx++Mu)        if ([!]Pv[0]) {
                                                              EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+MuV;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv)                            if ([!]Pv[0]) {
                   Vd.cur=vmem(Rx++Mu):nt                     EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+MuV;
                                                         } else {
                                                              NOP;
                                                         }
                  Class: COPROC_VMEM (slots 0,1)
                  Notes
                       ■  This instruction can use any HVX resource.
                       ■  An optional "non-temporal" hint to the micro-architecture can be specified to
                          indicate the data has no reuse.
                       ■  Immediates used in address computation are specified in multiples of vector
                          length.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  102
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                  NT           t5       Parse                            d5
 0  0  1  0 1  0   0 0  0  0  0   t  t   t  t  t P   P  i 0  0  i i i 0 0 1  d  d d  d  d Vd.cur=vmem(Rt+#s4)
 0  0  1  0 1  0   0 0  0  1  0   t  t   t  t  t P   P  i 0  0  i i i 0 0 1  d  d d  d  d Vd.cur=vmem(Rt+#s4):nt
                                                                                          if (Pv)
 0  0  1  0 1  0   0 0  1  0  0   t  t   t  t  t P   P  i v  v  i i i 1 0 0  d  d d  d  d
                                                                                          Vd.cur=vmem(Rt+#s4)
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 0  1  0  0   t  t   t  t  t P   P  i v  v  i i i 1 0 1  d  d d  d  d Vd.cur=vmem(Rt+#s4)
                                                                                          if (Pv)
 0  0  1  0 1  0   0 0  1  1  0   t  t   t  t  t P   P  i v  v  i i i 1 0 0  d  d d  d  d
                                                                                          Vd.cur=vmem(Rt+#s4):nt
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 0  1  1  0   t  t   t  t  t P   P  i v  v  i i i 1 0 1  d  d d  d  d Vd.cur=vmem(Rt+#s4):nt
   ICLASS                  NT          x5        Parse                            d5
 0  0  1  0 1  0   0 1  0  0  0   x  x  x  x  x  P   P  - 0  0  i i i 0 0 1  d  d d  d  d Vd.cur=vmem(Rx++#s3)
 0  0  1  0 1  0   0 1  0  1  0   x  x  x  x  x  P   P  - 0  0  i i i 0 0 1  d  d d  d  d Vd.cur=vmem(Rx++#s3):nt
                                                                                        d ifVd.cur=vmem(Rx++#s3)
                                                                                             (Pv)
 0  0  1  0 1  0   0 1  1  0  0   x  x   x x  x  P   P  - v  v  i i i 1 0 0  d  d d  d
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 1  1  0  0   x  x   x x  x  P   P  - v  v  i i i 1 0 1  d  d d  d  d Vd.cur=vmem(Rx++#s3)
                                                                                        d ifVd.cur=vmem(Rx++#s3):nt
                                                                                             (Pv)
 0  0  1  0 1  0   0 1  1  1  0   x  x   x x  x  P   P  - v  v  i i i 1 0 0  d  d d  d
                                                                                        d ifVd.cur=vmem(Rx++#s3):nt
                                                                                             (!Pv)
 0  0  1  0 1  0   0 1  1  1  0   x  x   x x  x  P   P  - v  v  i i i 1 0 1  d  d d  d
   ICLASS                  NT          x5        Parse u1                         d5
 0  0  1  0 1  0   1 1  0  0  0   x  x   x x  x  P   P u 0   0  - - - 0 0 1  d  d d  d  d Vd.cur=vmem(Rx++Mu)
 0  0  1  0 1  0   1 1  0  1  0   x  x   x x  x  P   P u 0   0  - - - 0 0 1  d  d d  d  d Vd.cur=vmem(Rx++Mu):nt
                                                                                          if (Pv)
 0  0  1  0 1  0   1 1  1  0  0   x  x   x x  x  P   P u  v  v  - - - 1 0 0  d  d d  d  d Vd.cur=vmem(Rx++Mu)
                                                                                        d ifVd.cur=vmem(Rx++Mu)
                                                                                             (!Pv)
 0  0  1  0 1  0   1 1  1  0  0   x  x   x x  x  P   P u  v  v  - - - 1 0 1  d  d d  d
 0  0  1  0 1  0   1 1  1  1  0   x  x  x  x  x  P   P u  v  v  - - - 1 0 0  d  d d  d  d ifVd.cur=vmem(Rx++Mu):nt
                                                                                             (Pv)
                                                                                          if (!Pv)
 0  0  1  0 1  0   1 1  1  1  0   x  x  x  x  x  P   P u  v  v  - - - 1 0 1  d  d d  d  d Vd.cur=vmem(Rx++Mu):nt
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u1                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        103
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
        Load - temporary immediate use
                  Read a full vector register Vd (and/or temporary vector register) from memory, using a
                  vector-size-aligned address. The operation has three ways to generate the memory pointer
                  address: Rt with a constant 4-bit signed offset, Rx with a signed post-increment, and Rx
                  with a modifier register Mu post-increment. For the immediate forms, the value indicates
                  the number of vectors worth of data. Mu contains the actual byte offset.
                  If the pointer presented to the instruction is not aligned, the instruction simply ignores the
                  lower bits, yielding an aligned address. The value is used immediately in the packet as a
                  source operand of any instruction.
                  "Vd.tmp" does not write the incoming data to the vector register file. The data is only used
                  as a source in the current packet, and then immediately discarded. Note that this form does
                  not consume any vector resources, allowing it to be placed in parallel with some
                  instructions that a normal align load cannot.
                  If a scalar predicate register Pv evaluates true, load a full vector register Vs from memory,
                  using a vector-size-aligned address. Otherwise, the operation becomes a NOP.
                   Syntax                                Behavior
                   Vd.tmp=vmem(Rt+#s4)                    EA=Rt+#s*VBYTES;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                   Vd.tmp=vmem(Rt+#s4):nt                 EA=Rt+#s*VBYTES;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                   Vd.tmp=vmem(Rx++#s3)                   EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+#s*VBYTES;
                   Vd.tmp=vmem(Rx++#s3):nt                EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+#s*VBYTES;
                   Vd.tmp=vmem(Rx++Mu)                    EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+MuV;
                   Vd.tmp=vmem(Rx++Mu):nt                 EA=Rx;
                                                          Vd = *(EA&~(ALIGNMENT-1));
                                                          Rx=Rx+MuV;
                   if ([!]Pv) Vd.tmp=vmem(Rt)             Assembler mapped to: "if ([!]Pv)
                                                          Vd.tmp=vmem(Rt+#0)"
                   if ([!]Pv) Vd.tmp=vmem(Rt):nt          Assembler mapped to: "if ([!]Pv)
                                                          Vd.tmp=vmem(Rt+#0):nt"
                   if ([!]Pv) Vd.tmp=vmem(Rt+#s4)         if ([!]Pv[0]) {
                                                               EA=Rt+#s*VBYTES;
                                                               Vd = *(EA&~(ALIGNMENT-1));
                                                          ;
                                                          } else {
                                                               NOP;
                                                          }
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        104
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
                   Syntax                               Behavior
                   if ([!]Pv)                            if ([!]Pv[0]) {
                   Vd.tmp=vmem(Rt+#s4):nt                     EA=Rt+#s*VBYTES;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv) Vd.tmp=vmem(Rx++#s3)       if ([!]Pv[0]) {
                                                              EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+#s*VBYTES;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv)                            if ([!]Pv[0]) {
                   Vd.tmp=vmem(Rx++#s3):nt                    EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+#s*VBYTES;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv) Vd.tmp=vmem(Rx++Mu)        if ([!]Pv[0]) {
                                                              EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+MuV;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv)                            if ([!]Pv[0]) {
                   Vd.tmp=vmem(Rx++Mu):nt                     EA=Rx;
                                                              Vd = *(EA&~(ALIGNMENT-1));
                                                         ;
                                                              Rx=Rx+MuV;
                                                         } else {
                                                              NOP;
                                                         }
                  Class: COPROC_VMEM (slots 0,1)
                  Notes
                       ■  This instruction can use any HVX resource.
                       ■  An optional "non-temporal" hint to the micro-architecture can be specified to
                          indicate the data has no reuse.
                       ■  Immediates used in address computation are specified in multiples of vector
                          length.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  105
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                  NT           t5       Parse                            d5
 0  0  1  0 1  0   0 0  0  0  0   t  t   t  t  t P   P  i 0  0  i i i 0 1 0  d  d d  d  d Vd.tmp=vmem(Rt+#s4)
 0  0  1  0 1  0   0 0  0  1  0   t  t   t  t  t P   P  i 0  0  i i i 0 1 0  d  d d  d  d Vd.tmp=vmem(Rt+#s4):nt
                                                                                          if (Pv)
 0  0  1  0 1  0   0 0  1  0  0   t  t   t  t  t P   P  i v  v  i i i 1 1 0  d  d d  d  d
                                                                                          Vd.tmp=vmem(Rt+#s4)
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 0  1  0  0   t  t   t  t  t P   P  i v  v  i i i 1 1 1  d  d d  d  d Vd.tmp=vmem(Rt+#s4)
                                                                                          if (Pv)
 0  0  1  0 1  0   0 0  1  1  0   t  t   t  t  t P   P  i v  v  i i i 1 1 0  d  d d  d  d
                                                                                          Vd.tmp=vmem(Rt+#s4):nt
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 0  1  1  0   t  t   t  t  t P   P  i v  v  i i i 1 1 1  d  d d  d  d Vd.tmp=vmem(Rt+#s4):nt
   ICLASS                  NT          x5        Parse                            d5
 0  0  1  0 1  0   0 1  0  0  0   x  x  x  x  x  P   P  - 0  0  i i i 0 1 0  d  d d  d  d Vd.tmp=vmem(Rx++#s3)
 0  0  1  0 1  0   0 1  0  1  0   x  x  x  x  x  P   P  - 0  0  i i i 0 1 0  d  d d  d  d Vd.tmp=vmem(Rx++#s3):nt
                                                                                        d ifVd.tmp=vmem(Rx++#s3)
                                                                                             (Pv)
 0  0  1  0 1  0   0 1  1  0  0   x  x   x x  x  P   P  - v  v  i i i 1 1 0  d  d d  d
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 1  1  0  0   x  x   x x  x  P   P  - v  v  i i i 1 1 1  d  d d  d  d Vd.tmp=vmem(Rx++#s3)
                                                                                        d ifVd.tmp=vmem(Rx++#s3):nt
                                                                                             (Pv)
 0  0  1  0 1  0   0 1  1  1  0   x  x   x x  x  P   P  - v  v  i i i 1 1 0  d  d d  d
                                                                                        d ifVd.tmp=vmem(Rx++#s3):nt
                                                                                             (!Pv)
 0  0  1  0 1  0   0 1  1  1  0   x  x   x x  x  P   P  - v  v  i i i 1 1 1  d  d d  d
   ICLASS                  NT          x5        Parse u1                         d5
 0  0  1  0 1  0   1 1  0  0  0   x  x   x x  x  P   P u 0   0  - - - 0 1 0  d  d d  d  d Vd.tmp=vmem(Rx++Mu)
 0  0  1  0 1  0   1 1  0  1  0   x  x   x x  x  P   P u 0   0  - - - 0 1 0  d  d d  d  d Vd.tmp=vmem(Rx++Mu):nt
                                                                                          if (Pv)
 0  0  1  0 1  0   1 1  1  0  0   x  x   x x  x  P   P u  v  v  - - - 1 1 0  d  d d  d  d Vd.tmp=vmem(Rx++Mu)
                                                                                        d ifVd.tmp=vmem(Rx++Mu)
                                                                                             (!Pv)
 0  0  1  0 1  0   1 1  1  0  0   x  x   x x  x  P   P u  v  v  - - - 1 1 1  d  d d  d
 0  0  1  0 1  0   1 1  1  1  0   x  x  x  x  x  P   P u  v  v  - - - 1 1 0  d  d d  d  d ifVd.tmp=vmem(Rx++Mu):nt
                                                                                             (Pv)
                                                                                          if (!Pv)
 0  0  1  0 1  0   1 1  1  1  0   x  x  x  x  x  P   P u  v  v  - - - 1 1 1  d  d d  d  d Vd.tmp=vmem(Rx++Mu):nt
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u1                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        106
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
          Load - unaligned
                  Read a full vector register Vd from memory, using an arbitrary byte-aligned address. The
                  operation has three ways to generate the memory pointer address: Rt with a constant 4-bit
                  signed offset, Rx with a 3-bit signed post-increment, and Rx with a modifier register Mu
                  post-increment. For the immediate forms, the value indicates the number of vectors worth
                  of data. Mu contains the actual byte offset. Unaligned memory operations require two
                  accesses to the memory system, and thus incur increased power and bandwidth over
                  aligned accesses. However, they require fewer instructions.
                  It is more efficient to use aligned memory operations when possible, and sometimes
                  multiple aligned memory accesses and the valign operation, to synthesize a non-aligned
                  access.
                  Note that this instruction uses both slot 0 and slot 1, allowing only 3 instructions at most to
                  execute in a packet with vmemu in it.
                   Syntax                                   Behavior
                   Vd=vmemu(Rt)                             Assembler mapped to: "Vd=vmemu(Rt+#0)"
                   Vd=vmemu(Rt+#s4)                         EA=Rt+#s*VBYTES;
                                                            Vd = *EA;
                   Vd=vmemu(Rx++#s3)                        EA=Rx;
                                                            Vd = *EA;
                                                            Rx=Rx+#s*VBYTES;
                   Vd=vmemu(Rx++Mu)                         EA=Rx;
                                                            Vd = *EA;
                                                            Rx=Rx+MuV;
                  Class: COPROC_VMEM (slots 0)
                  Notes
                        ■  This instruction uses the HVX permute resource.
                        ■  Immediates used in address computation are specified in multiples of vector
                           length.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4 3  2  1  0
   ICLASS                  NT          t5        Parse                              d5
 0  0  1  0 1  0   0  0  0 0  0   t  t  t  t  t  P   P  i 0  0  i  i i 1  1  1 d d  d  d  d Vd=vmemu(Rt+#s4)
   ICLASS                  NT          x5        Parse                              d5
 0  0  1  0 1  0   0  1  0 0  0   x  x  x  x  x  P   P  - 0  0  i  i i 1  1  1 d d  d  d  d Vd=vmemu(Rx++#s3)
   ICLASS                  NT          x5        Parse u1                           d5
 0  0  1  0 1  0   1  1  0 0  0   x  x  x  x  x  P   P u 0   0  -  - - 1  1  1 d d  d  d  d Vd=vmemu(Rx++Mu)
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       107
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  NT              NonTemporal
                  Parse           Packet/Loop parse bits
                  d5              Field to encode register d
                  t5              Field to encode register t
                  u1              Field to encode register u
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             108
Hexagon V66 HVX Programmer’s Reference Manual                                                             Instruction Set
       5.8       HVX/MPY-DOUBLE-RESOURCE
                 The HVX/MPY-DOUBLE-RESOURCE instruction subclass includes memory load
                 instructions.
        Arithmetic widening
                 Add or subtract the elements of vector registers Vu and Vv. The resulting elements are
                 double the width of the input size in order to capture any data growth in the result. The
                 result is placed in a double vector register.
                 Supports unsigned byte, and signed and unsigned halfword.
                                         Vdd.w=vadd(Vu.h,Vv.h)
                                                                                 N bits
                                                                 [1]              [0]         Vu
                                                                 [1]              [0]         Vv
                     To other slices
                                                                +/-              +/-
                                                                         [0]                Vdd_e
                                                                         [0]                Vdd_o
                                                                       2N bits
                 Class: COPROC_VX (slots 2,3)
                 Notes
                                 ■       This instruction uses both HVX multiply resources.
80-N2040-44 Rev. B                     MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION              109
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vdd.h=vadd(Vu.ub,Vv.ub)               for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] = Vu.uh[i].ub[0] +
                                                         Vv.uh[i].ub[0];
                                                              Vdd.v[1].h[i] = Vu.uh[i].ub[1] +
                                                         Vv.uh[i].ub[1] ;
                                                         }
                   Vdd.h=vsub(Vu.ub,Vv.ub)               for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] = Vu.uh[i].ub[0] -
                                                         Vv.uh[i].ub[0];
                                                              Vdd.v[1].h[i] = Vu.uh[i].ub[1] -
                                                         Vv.uh[i].ub[1] ;
                                                         }
                   Vdd.w=vadd(Vu.h,Vv.h)                 for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = Vu.w[i].h[0] + Vv.w[i].h[0];
                                                              Vdd.v[1].w[i] = Vu.w[i].h[1] + Vv.w[i].h[1]
                                                         ;
                                                         }
                   Vdd.w=vadd(Vu.uh,Vv.uh)               for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = Vu.uw[i].uh[0] +
                                                         Vv.uw[i].uh[0];
                                                              Vdd.v[1].w[i] = Vu.uw[i].uh[1] +
                                                         Vv.uw[i].uh[1] ;
                                                         }
                   Vdd.w=vsub(Vu.h,Vv.h)                 for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = Vu.w[i].h[0] - Vv.w[i].h[0];
                                                              Vdd.v[1].w[i] = Vu.w[i].h[1] - Vv.w[i].h[1]
                                                         ;
                                                         }
                   Vdd.w=vsub(Vu.uh,Vv.uh)               for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = Vu.uw[i].uh[0] -
                                                         Vv.uw[i].uh[0];
                                                              Vdd.v[1].w[i] = Vu.uw[i].uh[1] -
                                                         Vv.uw[i].uh[1] ;
                                                         }
                   Vxx.h+=vadd(Vu.ub,Vv.ub)              for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].h[i] += Vu.h[i].ub[0] +
                                                         Vv.h[i].ub[0];
                                                              Vxx.v[1].h[i] += Vu.h[i].ub[1] +
                                                         Vv.h[i].ub[1] ;
                                                         }
                   Vxx.w+=vadd(Vu.h,Vv.h)                for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].w[i] += Vu.w[i].h[0] +
                                                         Vv.w[i].h[0];
                                                              Vxx.v[1].w[i] += Vu.w[i].h[1] + Vv.w[i].h[1]
                                                         ;
                                                         }
                   Vxx.w+=vadd(Vu.uh,Vv.uh)              for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].w[i] += Vu.w[i].uh[0] +
                                                         Vv.w[i].uh[0];
                                                              Vxx.v[1].w[i] += Vu.w[i].uh[1] +
                                                         Vv.w[i].uh[1] ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   110
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Intrinsics
                   Vdd.h=vadd(Vu.ub,Vv.ub)                 HVX_VectorPair Q6_Wh_vadd_VubVub(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vdd.h=vsub(Vu.ub,Vv.ub)                 HVX_VectorPair Q6_Wh_vsub_VubVub(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vdd.w=vadd(Vu.h,Vv.h)                   HVX_VectorPair Q6_Ww_vadd_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vdd.w=vadd(Vu.uh,Vv.uh)                 HVX_VectorPair Q6_Ww_vadd_VuhVuh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vdd.w=vsub(Vu.h,Vv.h)                   HVX_VectorPair Q6_Ww_vsub_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vdd.w=vsub(Vu.uh,Vv.uh)                 HVX_VectorPair Q6_Ww_vsub_VuhVuh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vxx.h+=vadd(Vu.ub,Vv.ub)                HVX_VectorPair
                                                           Q6_Wh_vaddacc_WhVubVub(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                   Vxx.w+=vadd(Vu.h,Vv.h)                  HVX_VectorPair
                                                           Q6_Ww_vaddacc_WwVhVh(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                   Vxx.w+=vadd(Vu.uh,Vv.uh)                HVX_VectorPair
                                                           Q6_Ww_vaddacc_WwVuhVuh(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                                        Parse         u5                 x5
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 1  u  u  u u u 0  1 0  x x  x x  x Vxx.w+=vadd(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  0  1  0   v  v  v  v  v  P   P 1  u  u  u u u 1  0 0  x x  x x  x Vxx.w+=vadd(Vu.uh,Vv.uh)
 0  0  0  1 1  1   0 0  0  1  0   v  v  v  v  v  P   P 1  u  u  u u u 1  0 1  x x  x x  x Vxx.h+=vadd(Vu.ub,Vv.ub)
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   0 0  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0  1 0  d d  d d  d Vdd.h=vadd(Vu.ub,Vv.ub)
 0  0  0  1 1  1   0 0  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0  1 1  d d  d d  d Vdd.w=vadd(Vu.uh,Vv.uh)
 0  0  0  1 1  1   0 0  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1  0 0  d d  d d  d Vdd.w=vadd(Vu.h,Vv.h)
 0  0  0  1 1  1   0 0  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1  0 1  d d  d d  d Vdd.h=vsub(Vu.ub,Vv.ub)
 0  0  0  1 1  1   0 0  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1  1 0  d d  d d  d Vdd.w=vsub(Vu.uh,Vv.uh)
 0  0  0  1 1  1   0 0  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1  1 1  d d  d d  d Vdd.w=vsub(Vu.h,Vv.h)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        111
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                        Instruction Set
        Multiply with 2-wide reduction
                  Multiply elements from Vu by the corresponding elements in the scalar register Rt. The
                  products are added in pairs to yield a by-2 reduction. The products can optionally be
                  accumulated with Vx, with optional saturation after summation.
                  This instruction supports multiplication of unsigned bytes by bytes, halfwords by signed
                  bytes, and halfwords by halfwords. The double-vector version performs a sliding window
                  2-way reduction, where the odd register output contains the offset computation.
                       Vd.h[+]=vdmpy(Vu.ub, Rt.b) / Vd.w[+]=vdmpy(Vu.h, Rt.b)                 Vdd.h[+]=vdmpy(Vuu.ub, Rt.b) / Vdd.w[+]=vdmpy(Vuu.h, Rt.b)
                                                                                    ub/h[3] ub/h[2] ub/h[1] ub/h[0]  Vuu[1]                 ub/h[3] ub/h[2] ub/h[1] ub/h[0]   Vuu[0]
                          ub/h[3] ub/h[2] ub/h[1] ub/h[0]  Vu
                                                       X      Rt.b[0]                                         X            Rt.b[0]                                      X
                                               X              Rt.b[1]                                 X                    Rt.b[1]                            X
                                       X                      Rt.b[2]                          X                           Rt.b[2]                    X
                             X                                Rt.b[3]                 X                                    Rt.b[3]            X
                                  +                +      Optional Accumulation            +               +           Optional Accumulation        +              +
                              h/w[1]            h/w[0]     Vd                           h/w[1]          h/w[0]       Vdd[1]                     h/w[1]          h/w[0]        Vdd[0]
                                    32/64bit Lane                                                                   32/64bit Lane Pair
                             Vd.w[+]=vdmpy(Vu.h, Rt.h):sat                         Vd.w[+]=vdmpy(Vuu.h, Rt.h):sat
                                     h[1]            h[0]      Vu                        h[1]            h[0]        Vuu[1]             h[1]             h[0]        Vuu[0]
                                                      X            Rt.h[0]                                            Rt.h[0]                              X
                                     X                             Rt.h[1]
                                                                                                                      Rt.h[1]             X
                                              +              Optional Accumulation                                                                +             Optional Accumulation
                        Optional Saturation  SAT                                                                          Optional Saturation   SAT
                                            w[0]               Vd                                                                                w[0]                Vdd[0]
                                          32bit Lane                                                                                           32bit Lane Pair
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                                              112
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
                  Multiply halfword elements from vector register Vu by the corresponding halfword
                  elements in the vector register Vv. The products are added in pairs to make a 32-bit wide
                  sum. The sum is optionally accumulated with the vector register destination Vx, and then
                  saturated to 32 bits.
                     Vd.w[+]=vdmpy(Vu.h, Vv.h):sat
                          h[1]              h[0]          Vv
                          h[1]              h[0]         Vu
                           X                  X
                                    +               Optional
                                                  Accumulation
                                   sat
                                   w0                     Vd
                               32bit Lane
                   Syntax                                Behavior
                   Vd.w=vdmpy(Vu.h,Rt.h):sat             for (i = 0; i < VELEM(32); i++) {
                                                              accum = (Vu.w[i].h[0] * Rt.h[0]);
                                                              accum += (Vu.w[i].h[1] * Rt.h[1]);
                                                              Vd.w[i] = sat32(accum) ;
                                                         }
                   Vd.w=vdmpy(Vu.h,Rt.uh):sat            for (i = 0; i < VELEM(32); i++) {
                                                              accum = (Vu.w[i].h[0] * Rt.uh[0]);
                                                              accum += (Vu.w[i].h[1] * Rt.uh[1]);
                                                              Vd.w[i] = sat32(accum) ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    113
Hexagon V66 HVX Programmer’s Reference Manual                                                    Instruction Set
                   Syntax                               Behavior
                   Vd.w=vdmpy(Vu.h,Vv.h):sat             for (i = 0; i < VELEM(32); i++) {
                                                              accum = (Vu.w[i].h[0] * Vv.w[i].h[0]);
                                                              accum += (Vu.w[i].h[1] * Vv.w[i].h[1]);
                                                              Vd.w[i] = sat32(accum) ;
                                                         }
                   Vd.w=vdmpy(Vuu.h,Rt.h):sat            for (i = 0; i < VELEM(32); i++) {
                                                              accum = (Vuu.v[0].w[i].h[1] * Rt.h[0]);
                                                              accum += (Vuu.v[1].w[i].h[0] * Rt.h[1]);
                                                              Vd.w[i] = sat32(accum) ;
                                                         }
                   Vd.w=vdmpy(Vuu.h,Rt.uh,#1):sat        for (i = 0; i < VELEM(32); i++) {
                                                              accum = (Vuu.v[0].w[i].h[1] * Rt.uh[0]);
                                                              accum += (Vuu.v[1].w[i].h[0] * Rt.uh[1]);
                                                              Vd.w[i] = sat32(accum) ;
                                                         }
                   Vdd.h=vdmpy(Vuu.ub,Rt.b)              for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] = (Vuu.v[0].uh[i].ub[0] *
                                                         Rt.b[(2*i) % 4]);
                                                              Vdd.v[0].h[i] += (Vuu.v[0].uh[i].ub[1] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vdd.v[1].h[i] = (Vuu.v[0].uh[i].ub[1] *
                                                         Rt.b[(2*i) % 4]);
                                                              Vdd.v[1].h[i] += (Vuu.v[1].uh[i].ub[0] *
                                                         Rt.b[(2*i+1)%4]) ;
                                                         }
                   Vdd.w=vdmpy(Vuu.h,Rt.b)               for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = (Vuu.v[0].w[i].h[0] *
                                                         Rt.b[(2*i+0)%4]);
                                                              Vdd.v[0].w[i] += (Vuu.v[0].w[i].h[1] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vdd.v[1].w[i] = (Vuu.v[0].w[i].h[1] *
                                                         Rt.b[(2*i+0)%4]);
                                                              Vdd.v[1].w[i] += (Vuu.v[1].w[i].h[0] *
                                                         Rt.b[(2*i+1)%4]) ;
                                                         }
                   Vx.w+=vdmpy(Vu.h,Rt.h):sat            for (i = 0; i < VELEM(32);    i++) {
                                                              accum = Vx.w[i];
                                                              accum += (Vu.w[i].h[0]   * Rt.h[0]);
                                                              accum += (Vu.w[i].h[1]   * Rt.h[1]);
                                                              Vx.w[i] = sat32(accum)  ;
                                                         }
                   Vx.w+=vdmpy(Vu.h,Rt.uh):sat           for (i = 0; i < VELEM(32);    i++) {
                                                              accum=Vx.w[i];
                                                              accum += (Vu.w[i].h[0]   * Rt.uh[0]);
                                                              accum += (Vu.w[i].h[1]   * Rt.uh[1]);
                                                              Vx.w[i] = sat32(accum)  ;
                                                         }
                   Vx.w+=vdmpy(Vu.h,Vv.h):sat            for (i = 0; i < VELEM(32); i++) {
                                                              accum = (Vu.w[i].h[0] * Vv.w[i].h[0]);
                                                              accum += (Vu.w[i].h[1] * Vv.w[i].h[1]);
                                                              Vx.w[i] = sat32(Vx.w[i]+accum) ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     114
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vx.w+=vdmpy(Vuu.h,Rt.h):sat           for (i = 0; i < VELEM(32); i++) {
                                                              accum = Vx.w[i];
                                                              accum += (Vuu.v[0].w[i].h[1] * Rt.h[0]);
                                                              accum += (Vuu.v[1].w[i].h[0] * Rt.h[1]);
                                                              Vx.w[i] = sat32(accum) ;
                                                         }
                   Vx.w+=vdmpy(Vuu.h,Rt.uh,#1):sat       for (i = 0; i < VELEM(32); i++) {
                                                              accum=Vx.w[i];
                                                              accum += (Vuu.v[0].w[i].h[1] * Rt.uh[0]);
                                                              accum += (Vuu.v[1].w[i].h[0] * Rt.uh[1]);
                                                              Vx.w[i] = sat32(accum) ;
                                                         }
                   Vxx.h+=vdmpy(Vuu.ub,Rt.b)             for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].h[i] += (Vuu.v[0].uh[i].ub[0]   *
                                                         Rt.b[(2*i) % 4]);
                                                              Vxx.v[0].h[i] += (Vuu.v[0].uh[i].ub[1]   *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vxx.v[1].h[i] += (Vuu.v[0].uh[i].ub[1]   *
                                                         Rt.b[(2*i) % 4]);
                                                              Vxx.v[1].h[i] += (Vuu.v[1].uh[i].ub[0]   *
                                                         Rt.b[(2*i+1)%4]) ;
                                                         }
                   Vxx.w+=vdmpy(Vuu.h,Rt.b)              for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].w[i] += (Vuu.v[0].w[i].h[0]  *
                                                         Rt.b[(2*i+0)%4]);
                                                              Vxx.v[0].w[i] += (Vuu.v[0].w[i].h[1]  *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vxx.v[1].w[i] += (Vuu.v[0].w[i].h[1]  *
                                                         Rt.b[(2*i+0)%4]);
                                                              Vxx.v[1].w[i] += (Vuu.v[1].w[i].h[0]  *
                                                         Rt.b[(2*i+1)%4]) ;
                                                         }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■  This instruction uses both HVX multiply resources.
                  Intrinsics
                   Vd.w=vdmpy(Vu.h,Rt.h):sat             HVX_Vector Q6_Vw_vdmpy_VhRh_sat(HVX_Vector Vu,
                                                         Word32 Rt)
                   Vd.w=vdmpy(Vu.h,Rt.uh):sat            HVX_Vector Q6_Vw_vdmpy_VhRuh_sat(HVX_Vector Vu,
                                                         Word32 Rt)
                   Vd.w=vdmpy(Vu.h,Vv.h):sat             HVX_Vector Q6_Vw_vdmpy_VhVh_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.w=vdmpy(Vuu.h,Rt.h):sat            HVX_Vector Q6_Vw_vdmpy_WhRh_sat(HVX_VectorPair
                                                         Vuu, Word32 Rt)
                   Vd.w=vdmpy(Vuu.h,Rt.uh,#1):sat        HVX_Vector Q6_Vw_vdmpy_WhRuh_sat(HVX_VectorPair
                                                         Vuu, Word32 Rt)
                   Vdd.h=vdmpy(Vuu.ub,Rt.b)              HVX_VectorPair Q6_Wh_vdmpy_WubRb(HVX_VectorPair
                                                         Vuu, Word32 Rt)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   115
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                   Vdd.w=vdmpy(Vuu.h,Rt.b)                 HVX_VectorPair Q6_Ww_vdmpy_WhRb(HVX_VectorPair
                                                           Vuu, Word32 Rt)
                   Vx.w+=vdmpy(Vu.h,Rt.h):sat              HVX_Vector Q6_Vw_vdmpyacc_VwVhRh_sat(HVX_Vector
                                                           Vx, HVX_Vector Vu, Word32 Rt)
                   Vx.w+=vdmpy(Vu.h,Rt.uh):sat             HVX_Vector Q6_Vw_vdmpyacc_VwVhRuh_sat(HVX_Vector
                                                           Vx, HVX_Vector Vu, Word32 Rt)
                   Vx.w+=vdmpy(Vu.h,Vv.h):sat              HVX_Vector Q6_Vw_vdmpyacc_VwVhVh_sat(HVX_Vector
                                                           Vx, HVX_Vector Vu, HVX_Vector Vv)
                   Vx.w+=vdmpy(Vuu.h,Rt.h):sat             HVX_Vector Q6_Vw_vdmpyacc_VwWhRh_sat(HVX_Vector
                                                           Vx, HVX_VectorPair Vuu, Word32 Rt)
                   Vx.w+=vdmpy(Vuu.h,Rt.uh,#1):sat         HVX_Vector Q6_Vw_vdmpyacc_VwWhRuh_sat(HVX_Vector
                                                           Vx, HVX_VectorPair Vuu, Word32 Rt)
                   Vxx.h+=vdmpy(Vuu.ub,Rt.b)               HVX_VectorPair
                                                           Q6_Wh_vdmpyacc_WhWubRb(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt)
                   Vxx.w+=vdmpy(Vuu.h,Rt.b)                HVX_VectorPair
                                                           Q6_Ww_vdmpyacc_WwWhRb(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8  7 6  5 4  3 2  1 0
   ICLASS                              t5       Parse          u5                  d5
 0  0  0  1 1  0   0 1  0  0  0   t  t  t  t  t P   P 0  u   u  u u u 1  1 1  d  d d  d d Vdd.h=vdmpy(Vuu.ub,Rt.b)
   ICLASS                              t5       Parse          u5                  x5
 0  0  0  1 1  0   0 1  0  0  0   t  t  t  t  t P   P 1  u   u  u u u 1  1 1  x  x  x x x Vxx.h+=vdmpy(Vuu.ub,Rt.b
                                                                                          )
   ICLASS                              t5       Parse          u5                  d5
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 0  u   u  u u u 0  0 0  d  d d  d d Vd.w=vdmpy(Vu.h,Rt.uh):s
                                                                                          at
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 0  u   u  u u u 0  0 1  d  d d  d d Vd.w=vdmpy(Vuu.h,Rt.uh,#
                                                                                          1):sat
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 0  u   u  u u u 0  1 0  d  d d  d d Vd.w=vdmpy(Vu.h,Rt.h):sat
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 0  u   u  u u u 0  1 1  d  d d  d d Vd.w=vdmpy(Vuu.h,Rt.h):s
                                                                                          at
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 0  u   u  u u u 1  0 0  d  d d  d d Vdd.w=vdmpy(Vuu.h,Rt.b)
   ICLASS                              t5       Parse          u5                  x5
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 1  u   u  u u u 0  0 0  x  x  x x x Vx.w+=vdmpy(Vu.h,Rt.uh):
                                                                                          sat
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 1  u   u  u u u 0  0 1  x  x  x x x Vx.w+=vdmpy(Vuu.h,Rt.uh,
                                                                                          #1):sat
                                                                                          Vx.w+=vdmpy(Vuu.h,Rt.h):
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 1  u   u  u u u 0  1 0  x  x  x x x sat
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 1  u   u  u u u 0  1 1  x  x  x x x Vx.w+=vdmpy(Vu.h,Rt.h):s
                                                                                          at
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 1  u   u  u u u 1  0 0  x  x  x x x Vxx.w+=vdmpy(Vuu.h,Rt.b)
   ICLASS                                       Parse          u5                  d5
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v P   P 0  u   u  u u u 0  1 1  d  d d  d d Vd.w=vdmpy(Vu.h,Vv.h):sat
   ICLASS                                       Parse          u5                  x5
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v P   P 1  u   u  u u u 0  1 1  x  x  x x x Vx.w+=vdmpy(Vu.h,Vv.h):s
                                                                                          at
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       116
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Parse           Packet/Loop parse bits
                  d5              Field to encode register d
                  t5              Field to encode register t
                  u5              Field to encode register u
                  v5              Field to encode register v
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             117
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
          Lookup table for piecewise from 64-bit scalar
                  Instruction vlut4 is a four-entry lookup table in a scalar register pair (Rtt) used to enable
                  polynomial approximations with four intervals.
                   Syntax                                  Behavior
                   Vd.h=vlut4(Vu.uh,Rtt.h)                  for (i = 0; i < VELEM(16); i++) {
                                                                 Vd.h[i]= Rtt.h[((Vu.h[i]>>14)&0x3)] ;
                                                            }
                  Class: COPROC_VX (slots 2)
                  Notes
                       ■   This instruction uses both HVX multiply resources.
                  Intrinsics
                   Vd.h=vlut4(Vu.uh,Rtt.h)                 HVX_Vector Q6_Vh_vlut4_VuhPh(HVX_Vector Vu,
                                                           Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1  0
   ICLASS                               t5       Parse          u5                  d5
 0  0  0  1 1  0   0 1  0  1  1   t  t   t  t  t P   P 0  u   u u  u  u 1 0  0 d  d d  d  d Vd.h=vlut4(Vu.uh,Rtt.h)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u5                Field to encode register u
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                            118
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
          Multiply with piecewise add/sub from 64-bit scalar
                  Instructions to help nonlinear function calculations.
                   Syntax                                   Behavior
                   Vx.h=vmpa(Vx.h,Vu.h,Rtt.h):sat            for (i = 0; i < VELEM(16); i++) {
                                                                  Vx.h[i]= sat16(( ( (Vx.h[i] * Vu.h[i])<<1)
                                                             + (Rtt.h[( (Vu.h[i]>>14)&0x3)]<<15))>>16) ;
                                                             }
                   Vx.h=vmpa(Vx.h,Vu.uh,Rtt.uh):sat          for (i = 0; i < VELEM(16); i++) {
                                                                  Vx.h[i]= sat16(( (Vx.h[i] * Vu.uh[i]) +
                                                             (Rtt.uh[((Vu.uh[i]>>14)&0x3)]<<15))>>16) ;
                                                             }
                   Vx.h=vmps(Vx.h,Vu.uh,Rtt.uh):sat          for (i = 0; i < VELEM(16); i++) {
                                                                  Vx.h[i]= sat16(( (Vx.h[i] * Vu.uh[i]) -
                                                             (Rtt.uh[((Vu.uh[i]>>14)&0x3)]<<15))>>16) ;
                                                             }
                  Class: COPROC_VX (slots 2)
                  Notes
                       ■   This instruction uses both HVX multiply resources.
                  Intrinsics
                   Vx.h=vmpa(Vx.h,Vu.h,Rtt.h):sat          HVX_Vector Q6_Vh_vmpa_VhVhVhPh_sat(HVX_Vector
                                                           Vx, HVX_Vector Vu, Word64 Rtt)
                   Vx.h=vmpa(Vx.h,Vu.uh,Rtt.uh):sa         HVX_Vector Q6_Vh_vmpa_VhVhVuhPuh_sat(HVX_Vector
                   t                                       Vx, HVX_Vector Vu, Word64 Rtt)
                   Vx.h=vmps(Vx.h,Vu.uh,Rtt.uh):sa         HVX_Vector Q6_Vh_vmps_VhVhVuhPuh_sat(HVX_Vector
                   t                                       Vx, HVX_Vector Vu, Word64 Rtt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6  5 4  3 2  1 0
   ICLASS                               t5       Parse         u5                   x5
                                                                                            Vx.h=vmpa(Vx.h,Vu.h,Rtt.h
 0  0  0  1 1  0   0 1  1  0  0   t  t   t t   t P   P 1 u   u  u  u u 1  0 0  x  x x  x x ):sat
 0  0  0  1 1  0   0 1  1  0  0   t  t   t t   t P   P 1 u   u  u  u u 1  0 1  x  x x  x x Vx.h=vmpa(Vx.h,Vu.uh,Rtt.
                                                                                            uh):sat
 0  0  0  1 1  0   0 1  1  0  0   t  t   t t   t P   P 1 u   u  u  u u 1  1 0  x  x x  x x Vx.h=vmps(Vx.h,Vu.uh,Rtt.
                                                                                            uh):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         119
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  t5              Field to encode register t
                  u5              Field to encode register u
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             120
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
        Multiply - add
                  Compute the sum of two byte multiplies. The two products consist of either unsigned
                  bytes or signed halfwords coming from the vector registers Vuu and Vvv. These are
                  multiplied by a signed byte coming from a scalar register Rt. The result of the summation
                  is a signed halfword or word. Each corresponding pair of elements in Vuu and Vvv is
                  weighted, using Rt.b[0] and Rt.b[1] for the even elements, and Rt.b[2] amd Rt.b[3] for the
                  odd elements.
                  Optionally accumulates the product with the destination vector register Vxx.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   121
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                  For vector by vector, compute the sum of two byte multiplies. The two products consist of
                  an unsigned byte vector operand multiplied by a signed byte scalar. The result of the
                  summation is a signed halfword. Even elements from the input vector register pairs Vuu
                  and Vvv are multiplied together and placed in the even register of Vdd. Odd elements are
                  placed in the odd register of Vdd.
                             Vdd.h [+]=vmpa(Vuu.ub,Rt.b)
                                    [1]              [0]        Vuu.V[1]
                                    [1]              [0]        Vuu.V[0]
                   Rt.b[3]       X                X               Rt.b[1]
                   Rt.b[2]                X              X        Rt.b[0]
                                     +                +
                                              [0]               Vdd.V[1]
                                              [0]               Vdd.V[0]
                                          Each lane
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   122
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
  Vdd.h =vmpa(Vuu.ub,Vvv.b)
       b[1]             b[0]        Vuu.V[1]                   b[1]           b[0]       Vuu.V[0]
       b[1]             b[0]       Vvv.V[1]                    b[1]           b[0]       Vvv.V[0]
         X                X                                      X             X
         +
                                                                               +
               h[0]               Vdd.V[1]                            h[0]               Vdd.V[0]
                                 Each 16bit lane pair
                   Syntax                               Behavior
                   Vdd.h=vmpa(Vuu.ub,Rt.b)               for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] = (Vuu.v[0].uh[i].ub[0] *
                                                         Rt.b[0]) + (Vuu.v[1].uh[i].ub[0] * Rt.b[1]);
                                                              Vdd.v[1].h[i] = (Vuu.v[0].uh[i].ub[1] *
                                                         Rt.b[2]) + (Vuu.v[1].uh[i].ub[1] * Rt.b[3]) ;
                                                         }
                   Vdd.h=vmpa(Vuu.ub,Rt.ub)              for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].uh[i] = (Vuu.v[0].uh[i].ub[0] *
                                                         Rt.ub[0]) + (Vuu.v[1].uh[i].ub[0] * Rt.ub[1]);
                                                              Vdd.v[1].uh[i] = (Vuu.v[0].uh[i].ub[1] *
                                                         Rt.ub[2]) + (Vuu.v[1].uh[i].ub[1] * Rt.ub[3]) ;
                                                         }
                   Vdd.h=vmpa(Vuu.ub,Vvv.b)              for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] = (Vuu.v[0].uh[i].ub[0] *
                                                         Vvv.v[0].uh[i].b[0]) + (Vuu.v[1].uh[i].ub[0] *
                                                         Vvv.v[1].uh[i].b[0]);
                                                              Vdd.v[1].h[i] = (Vuu.v[0].uh[i].ub[1] *
                                                         Vvv.v[0].uh[i].b[1]) + (Vuu.v[1].uh[i].ub[1] *
                                                         Vvv.v[1].uh[i].b[1]) ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    123
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vdd.h=vmpa(Vuu.ub,Vvv.ub)             for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] = (Vuu.v[0].uh[i].ub[0] *
                                                         Vvv.v[0].uh[i].ub[0]) + (Vuu.v[1].uh[i].ub[0] *
                                                         Vvv.v[1].uh[i].ub[0]);
                                                              Vdd.v[1].h[i] = (Vuu.v[0].uh[i].ub[1] *
                                                         Vvv.v[0].uh[i].ub[1]) + (Vuu.v[1].uh[i].ub[1] *
                                                         Vvv.v[1].uh[i].ub[1]) ;
                                                         }
                   Vdd.w=vmpa(Vuu.h,Rt.b)                for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = (Vuu.v[0].w[i].h[0] *
                                                         Rt.b[0]) + (Vuu.v[1].w[i].h[0] * Rt.b[1]);
                                                              Vdd.v[1].w[i] = (Vuu.v[0].w[i].h[1] *
                                                         Rt.b[2]) + (Vuu.v[1].w[i].h[1] * Rt.b[3]) ;
                                                         }
                   Vdd.w=vmpa(Vuu.uh,Rt.b)               for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = (Vuu.v[0].w[i].uh[0] *
                                                         Rt.b[0]) + (Vuu.v[1].w[i].uh[0] * Rt.b[1]);
                                                              Vdd.v[1].w[i] = (Vuu.v[0].w[i].uh[1] *
                                                         Rt.b[2]) + (Vuu.v[1].w[i].uh[1] * Rt.b[3]) ;
                                                         }
                   Vxx.h+=vmpa(Vuu.ub,Rt.b)              for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].h[i] += (Vuu.v[0].uh[i].ub[0] *
                                                         Rt.b[0]) + (Vuu.v[1].uh[i].ub[0] * Rt.b[1]);
                                                              Vxx.v[1].h[i] += (Vuu.v[0].uh[i].ub[1] *
                                                         Rt.b[2]) + (Vuu.v[1].uh[i].ub[1] * Rt.b[3]) ;
                                                         }
                   Vxx.h+=vmpa(Vuu.ub,Rt.ub)             for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].uh[i] += (Vuu.v[0].uh[i].ub[0] *
                                                         Rt.ub[0]) + (Vuu.v[1].uh[i].ub[0] * Rt.ub[1]);
                                                              Vxx.v[1].uh[i] += (Vuu.v[0].uh[i].ub[1] *
                                                         Rt.ub[2]) + (Vuu.v[1].uh[i].ub[1] * Rt.ub[3]) ;
                                                         }
                   Vxx.w+=vmpa(Vuu.h,Rt.b)               for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].w[i] += (Vuu.v[0].w[i].h[0] *
                                                         Rt.b[0]) + (Vuu.v[1].w[i].h[0] * Rt.b[1]);
                                                              Vxx.v[1].w[i] += (Vuu.v[0].w[i].h[1] *
                                                         Rt.b[2]) + (Vuu.v[1].w[i].h[1] * Rt.b[3]) ;
                                                         }
                   Vxx.w+=vmpa(Vuu.uh,Rt.b)              for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].w[i] += (Vuu.v[0].w[i].uh[0] *
                                                         Rt.b[0]) + (Vuu.v[1].w[i].uh[0] * Rt.b[1]);
                                                              Vxx.v[1].w[i] += (Vuu.v[0].w[i].uh[1] *
                                                         Rt.b[2]) + (Vuu.v[1].w[i].uh[1] * Rt.b[3]) ;
                                                         }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■  This instruction uses both HVX multiply resources.
                       ■  This may not work correctly in Napali V1.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   124
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Intrinsics
                   Vdd.h=vmpa(Vuu.ub,Rt.b)                 HVX_VectorPair Q6_Wh_vmpa_WubRb(HVX_VectorPair
                                                           Vuu, Word32 Rt)
                   Vdd.h=vmpa(Vuu.ub,Rt.ub)                HVX_VectorPair Q6_Wh_vmpa_WubRub(HVX_VectorPair
                                                           Vuu, Word32 Rt)
                   Vdd.h=vmpa(Vuu.ub,Vvv.b)                HVX_VectorPair Q6_Wh_vmpa_WubWb(HVX_VectorPair
                                                           Vuu, HVX_VectorPair Vvv)
                   Vdd.h=vmpa(Vuu.ub,Vvv.ub)               HVX_VectorPair Q6_Wh_vmpa_WubWub(HVX_VectorPair
                                                           Vuu, HVX_VectorPair Vvv)
                   Vdd.w=vmpa(Vuu.h,Rt.b)                  HVX_VectorPair Q6_Ww_vmpa_WhRb(HVX_VectorPair
                                                           Vuu, Word32 Rt)
                   Vdd.w=vmpa(Vuu.uh,Rt.b)                 HVX_VectorPair Q6_Ww_vmpa_WuhRb(HVX_VectorPair
                                                           Vuu, Word32 Rt)
                   Vxx.h+=vmpa(Vuu.ub,Rt.b)                HVX_VectorPair
                                                           Q6_Wh_vmpaacc_WhWubRb(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt)
                   Vxx.h+=vmpa(Vuu.ub,Rt.ub)               HVX_VectorPair
                                                           Q6_Wh_vmpaacc_WhWubRub(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt)
                   Vxx.w+=vmpa(Vuu.h,Rt.b)                 HVX_VectorPair
                                                           Q6_Ww_vmpaacc_WwWhRb(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt)
                   Vxx.w+=vmpa(Vuu.uh,Rt.b)                HVX_VectorPair
                                                           Q6_Ww_vmpaacc_WwWuhRb(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                              t5       Parse          u5                 d5
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 0  u   u  u u u 1  1 0  d d  d d  d Vdd.h=vmpa(Vuu.ub,Rt.b)
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 0  u   u  u u u 1  1 1  d d  d d  d Vdd.w=vmpa(Vuu.h,Rt.b)
   ICLASS                              t5       Parse          u5                 x5
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 1  u   u  u u u 1  1 0  x x  x x  x Vxx.h+=vmpa(Vuu.ub,Rt.b)
 0  0  0  1 1  0   0 1  0  0  1   t  t  t  t  t P   P 1  u   u  u u u 1  1 1  x x  x x  x Vxx.w+=vmpa(Vuu.h,Rt.b)
   ICLASS                              t5       Parse          u5                 d5
 0  0  0  1 1  0   0 1  0  1  1   t  t  t  t  t P   P 0  u   u  u u u 0  1 1  d d  d d  d Vdd.h=vmpa(Vuu.ub,Rt.ub)
 0  0  0  1 1  0   0 1  1  0  0   t  t  t  t  t P   P 0  u   u  u u u 1  0 1  d d  d d  d Vdd.w=vmpa(Vuu.uh,Rt.b)
   ICLASS                              t5       Parse          u5                 x5
 0  0  0  1 1  0   0 1  1  0  0   t  t  t  t  t P   P 1  u   u  u u u 0  1 0  x x  x x  x Vxx.w+=vmpa(Vuu.uh,Rt.b)
 0  0  0  1 1  0   0 1  1  0  1   t  t  t  t  t P   P 1  u   u  u u u 1  0 0  x x  x x  x Vxx.h+=vmpa(Vuu.ub,Rt.ub
                                                                                          )
   ICLASS                                       Parse          u5                 d5
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v P   P 0  u   u  u u u 0  1 1  d d  d d  d Vdd.h=vmpa(Vuu.ub,Vvv.b)
 0  0  0  1 1  1   0 0  1  1  1   v  v  v  v  v P   P 0  u   u  u u u 1  1 1  d d  d d  d Vdd.h=vmpa(Vuu.ub,Vvv.u
                                                                                          b)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       125
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Parse           Packet/Loop parse bits
                  d5              Field to encode register d
                  t5              Field to encode register t
                  u5              Field to encode register u
                  v5              Field to encode register v
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             126
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
        Multiply - vector by scalar
                  Multiply groups of elements in the vector Vu by the corresponding elements in the scalar
                  register Rt.
                  This operation has two forms. In the first form the product is not modified, and is
                  optionally accumulated with the destination register. The even results are placed in the
                  even vector register of the destination register pair, while the odd results are placed in the
                  odd vector register.
                  Supports signed by signed halfword, unsigned by unsigned byte, unsigned by signed byte,
                  and unsigned halfword by unsigned halfword.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       127
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                  The second form of this operation keeps the output precision the same as the input width
                  by shifting the product left by 1, saturating the product to 32 bits, and placing the upper 16
                  bits in the output. Optional rounding of the result is supported.
        Vxx.h [+]=vmpy(Vu.ub,Rt.b)                                      Vd.h =vmpy(Vu.h,Rt.h):<<1:rnd:sat
          ub[3] ub[2] ub[1] ub[0]            Vu                                h[1]           h[0]                 Vu
                                     X               Rt.b[0]                                     X               Rt.h[0]
                              X                      Rt.b[1]
                     X                               Rt.b[2]                     X                               Rt.h[1]
             X                                       Rt.b[3]
                                                                               <<1             <<1
             +                +                                               +0x8000        +0x8000     Optional Round
                                                     Optional
                                                     Accumulation
                     +               +
                                                                                                         Saturate upper
                                                                                SAT             SAT
                                                                                                               16bits
                h[1]            h[0]                Vdd.V[0]
                                                                                H[1]           H[1]
                h[1]            h[0]                Vdd.V[1]                   h[1]            h[0]                 Vd
                  Each 32bit lane                                                Each 32bit lane
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        128
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
                   Syntax                               Behavior
                   Vd.h=vmpy(Vu.h,Rt.h):<<1:rnd:sa       for (i = 0; i < VELEM(32); i++) {
                   t                                          Vd.w[i].h[0]=sat16(sat32(round(((Vu.w[i].h[0]
                                                         * Rt.h[0])<<1))).h[1]);
                                                              Vd.w[i].h[1]=sat16(sat32(round(((Vu.w[i].h[1]
                                                         * Rt.h[1])<<1))).h[1]);
                                                         ;
                                                         }
                   Vd.h=vmpy(Vu.h,Rt.h):<<1:sat          for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i].h[0]=sat16(sat32(((Vu.w[i].h[0] *
                                                         Rt.h[0])<<1)).h[1]);
                                                              Vd.w[i].h[1]=sat16(sat32(((Vu.w[i].h[1] *
                                                         Rt.h[1])<<1)).h[1]);
                                                         ;
                                                         }
                   Vdd.h=vmpy(Vu.ub,Rt.b)                for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] = (Vu.uh[i].ub[0] *
                                                         Rt.b[(2*i+0)%4]);
                                                              Vdd.v[1].h[i] = (Vu.uh[i].ub[1] *
                                                         Rt.b[(2*i+1)%4]) ;
                                                         }
                   Vdd.uh=vmpy(Vu.ub,Rt.ub)              for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].uh[i] = (Vu.uh[i].ub[0] *
                                                         Rt.ub[(2*i+0)%4]);
                                                              Vdd.v[1].uh[i] = (Vu.uh[i].ub[1] *
                                                         Rt.ub[(2*i+1)%4]) ;
                                                         }
                   Vdd.uw=vmpy(Vu.uh,Rt.uh)              for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].uw[i] = (Vu.uw[i].uh[0] *
                                                         Rt.uh[0]);
                                                              Vdd.v[1].uw[i] = (Vu.uw[i].uh[1] * Rt.uh[1])
                                                         ;
                                                         }
                   Vdd.w=vmpy(Vu.h,Rt.h)                 for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = (Vu.w[i].h[0] * Rt.h[0]);
                                                              Vdd.v[1].w[i] = (Vu.w[i].h[1] * Rt.h[1]) ;
                                                         }
                   Vxx.h+=vmpy(Vu.ub,Rt.b)               for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].h[i] += (Vu.uh[i].ub[0] *
                                                         Rt.b[(2*i+0)%4]);
                                                              Vxx.v[1].h[i] += (Vu.uh[i].ub[1] *
                                                         Rt.b[(2*i+1)%4]) ;
                                                         }
                   Vxx.uh+=vmpy(Vu.ub,Rt.ub)             for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].uh[i] += (Vu.uh[i].ub[0] *
                                                         Rt.ub[(2*i+0)%4]);
                                                              Vxx.v[1].uh[i] += (Vu.uh[i].ub[1] *
                                                         Rt.ub[(2*i+1)%4]) ;
                                                         }
                   Vxx.uw+=vmpy(Vu.uh,Rt.uh)             for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].uw[i] += (Vu.uw[i].uh[0] *
                                                         Rt.uh[0]);
                                                              Vxx.v[1].uw[i] += (Vu.uw[i].uh[1] *
                                                         Rt.uh[1]) ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    129
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vxx.w+=vmpy(Vu.h,Rt.h)                for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].w[i] = Vxx.v[0].w[i].s64 +
                                                         (Vu.w[i].h[0] * Rt.h[0]);
                                                              Vxx.v[1].w[i] = Vxx.v[1].w[i].s64 +
                                                         (Vu.w[i].h[1] * Rt.h[1]) ;
                                                         }
                   Vxx.w+=vmpy(Vu.h,Rt.h):sat            for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].w[i] = sat32(Vxx.v[0].w[i].s64 +
                                                         (Vu.w[i].h[0] * Rt.h[0]));
                                                              Vxx.v[1].w[i] = sat32(Vxx.v[1].w[i].s64 +
                                                         (Vu.w[i].h[1] * Rt.h[1])) ;
                                                         }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■  This instruction uses both HVX multiply resources.
                       ■  This may not work correctly in Napali V1.
                  Intrinsics
                   Vd.h=vmpy(Vu.h,Rt.h):<<1:rnd:sa       HVX_Vector Q6_Vh_vmpy_VhRh_s1_rnd_sat(HVX_Vector
                   t                                     Vu, Word32 Rt)
                   Vd.h=vmpy(Vu.h,Rt.h):<<1:sat          HVX_Vector Q6_Vh_vmpy_VhRh_s1_sat(HVX_Vector Vu,
                                                         Word32 Rt)
                   Vdd.h=vmpy(Vu.ub,Rt.b)                HVX_VectorPair Q6_Wh_vmpy_VubRb(HVX_Vector Vu,
                                                         Word32 Rt)
                   Vdd.uh=vmpy(Vu.ub,Rt.ub)              HVX_VectorPair Q6_Wuh_vmpy_VubRub(HVX_Vector Vu,
                                                         Word32 Rt)
                   Vdd.uw=vmpy(Vu.uh,Rt.uh)              HVX_VectorPair Q6_Wuw_vmpy_VuhRuh(HVX_Vector Vu,
                                                         Word32 Rt)
                   Vdd.w=vmpy(Vu.h,Rt.h)                 HVX_VectorPair Q6_Ww_vmpy_VhRh(HVX_Vector Vu,
                                                         Word32 Rt)
                   Vxx.h+=vmpy(Vu.ub,Rt.b)               HVX_VectorPair
                                                         Q6_Wh_vmpyacc_WhVubRb(HVX_VectorPair Vxx,
                                                         HVX_Vector Vu, Word32 Rt)
                   Vxx.uh+=vmpy(Vu.ub,Rt.ub)             HVX_VectorPair
                                                         Q6_Wuh_vmpyacc_WuhVubRub(HVX_VectorPair Vxx,
                                                         HVX_Vector Vu, Word32 Rt)
                   Vxx.uw+=vmpy(Vu.uh,Rt.uh)             HVX_VectorPair
                                                         Q6_Wuw_vmpyacc_WuwVuhRuh(HVX_VectorPair Vxx,
                                                         HVX_Vector Vu, Word32 Rt)
                   Vxx.w+=vmpy(Vu.h,Rt.h)                HVX_VectorPair
                                                         Q6_Ww_vmpyacc_WwVhRh(HVX_VectorPair Vxx,
                                                         HVX_Vector Vu, Word32 Rt)
                   Vxx.w+=vmpy(Vu.h,Rt.h):sat            HVX_VectorPair
                                                         Q6_Ww_vmpyacc_WwVhRh_sat(HVX_VectorPair Vxx,
                                                         HVX_Vector Vu, Word32 Rt)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   130
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                               t5       Parse         u5                 d5
 0  0  0  1 1  0   0 1  0  0  1   t  t   t  t  t P   P 0  u  u  u u u 1 0 1  d  d d  d  d Vdd.h=vmpy(Vu.ub,Rt.b)
   ICLASS                               t5       Parse         u5                 x5
 0  0  0  1 1  0   0 1  0  0  1   t  t   t  t  t P   P 1  u  u  u u u 1 0 1  x  x  x x  x Vxx.h+=vmpy(Vu.ub,Rt.b)
   ICLASS                               t5       Parse         u5                 d5
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 0  u  u  u u u 0 0 0  d  d d  d  d Vdd.w=vmpy(Vu.h,Rt.h)
                                                                                          Vd.h=vmpy(Vu.h,Rt.h):<<1:
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 0  u  u  u u u 0 0 1  d  d d  d  d
                                                                                          sat
                                                                                          Vd.h=vmpy(Vu.h,Rt.h):<<1:
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 0  u  u  u u u 0 1 0  d  d d  d  d rnd:sat
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 0  u  u  u u u 0 1 1  d  d d  d  d Vdd.uw=vmpy(Vu.uh,Rt.uh)
   ICLASS                               t5       Parse         u5                 x5
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 1  u  u  u u u 0 0 0  x  x  x x  x Vxx.w+=vmpy(Vu.h,Rt.h):s
                                                                                          at
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 1  u  u  u u u 0 0 1  x  x  x x  x Vxx.uw+=vmpy(Vu.uh,Rt.u
                                                                                          h)
                                                                                          Vxx.uh+=vmpy(Vu.ub,Rt.ub
 0  0  0  1 1  0   0 1  1  0  0   t  t   t  t  t P   P 1  u  u  u u u 0 0 0  x  x  x x  x )
 0  0  0  1 1  0   0 1  1  0  1   t  t   t  t  t P   P 1  u  u  u u u 1 1 0  x  x  x x  x Vxx.w+=vmpy(Vu.h,Rt.h)
   ICLASS                               t5       Parse         u5                 d5
 0  0  0  1 1  0   0 1  1  1  0   t  t   t  t  t P   P 0  u  u  u u u 0 0 0  d  d d  d  d Vdd.uh=vmpy(Vu.ub,Rt.ub)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        131
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
        Multiply - vector by vector
                  Multiply groups of elements in the vector Vu by the corresponding elements in the vector
                  register Vv.
                  This operation has two forms. In the first form the product is not modified, and is
                  optionally accumulated with the destination register. The even results are placed in the
                  even vector register of the destination register pair, while the odd results are placed in the
                  odd vector register.
                  Supports signed by signed halfword, unsigned by unsigned byte, unsigned by signed byte,
                  and unsigned halfword by unsigned halfword.
                  The second form of this operation keeps the output precision the same as the input width
                  by shifting the product left by 1, saturating the product to 32 bits, and placing the upper 16
                  bits in the output. Optional rounding of the result is supported.
                   Syntax                                Behavior
                   Vd.h=vmpy(Vu.h,Vv.h):<<1:rnd:sa        for (i = 0; i < VELEM(16); i++) {
                   t                                           Vd.h[i] = sat16(sat32(round(((Vu.h[i] *
                                                          Vv.h[i])<<1))).h[1]) ;
                                                          }
                   Vdd.h=vmpy(Vu.b,Vv.b)                  for (i = 0; i < VELEM(16); i++) {
                                                               Vdd.v[0].h[i] = (Vu.h[i].b[0] *
                                                          Vv.h[i].b[0]);
                                                               Vdd.v[1].h[i] = (Vu.h[i].b[1] *
                                                          Vv.h[i].b[1]) ;
                                                          }
                   Vdd.h=vmpy(Vu.ub,Vv.b)                 for (i = 0; i < VELEM(16); i++) {
                                                               Vdd.v[0].h[i] = (Vu.uh[i].ub[0] *
                                                          Vv.h[i].b[0]);
                                                               Vdd.v[1].h[i] = (Vu.uh[i].ub[1] *
                                                          Vv.h[i].b[1]) ;
                                                          }
                   Vdd.uh=vmpy(Vu.ub,Vv.ub)               for (i = 0; i < VELEM(16); i++) {
                                                               Vdd.v[0].uh[i] = (Vu.uh[i].ub[0] *
                                                          Vv.uh[i].ub[0]);
                                                               Vdd.v[1].uh[i] = (Vu.uh[i].ub[1] *
                                                          Vv.uh[i].ub[1]) ;
                                                          }
                   Vdd.uw=vmpy(Vu.uh,Vv.uh)               for (i = 0; i < VELEM(32); i++) {
                                                               Vdd.v[0].uw[i] = (Vu.uw[i].uh[0] *
                                                          Vv.uw[i].uh[0]);
                                                               Vdd.v[1].uw[i] = (Vu.uw[i].uh[1] *
                                                          Vv.uw[i].uh[1]) ;
                                                          }
                   Vdd.w=vmpy(Vu.h,Vv.h)                  for (i = 0; i < VELEM(32); i++) {
                                                               Vdd.v[0].w[i] = (Vu.w[i].h[0] *
                                                          Vv.w[i].h[0]);
                                                               Vdd.v[1].w[i] = (Vu.w[i].h[1] *
                                                          Vv.w[i].h[1]) ;
                                                          }
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       132
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vdd.w=vmpy(Vu.h,Vv.uh)                for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = (Vu.w[i].h[0] *
                                                         Vv.uw[i].uh[0]);
                                                              Vdd.v[1].w[i] = (Vu.w[i].h[1] *
                                                         Vv.uw[i].uh[1]) ;
                                                         }
                   Vxx.h+=vmpy(Vu.b,Vv.b)                for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].h[i] += (Vu.h[i].b[0] *
                                                         Vv.h[i].b[0]);
                                                              Vxx.v[1].h[i] += (Vu.h[i].b[1] *
                                                         Vv.h[i].b[1]) ;
                                                         }
                   Vxx.h+=vmpy(Vu.ub,Vv.b)               for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].h[i] += (Vu.uh[i].ub[0] *
                                                         Vv.h[i].b[0]);
                                                              Vxx.v[1].h[i] += (Vu.uh[i].ub[1] *
                                                         Vv.h[i].b[1]) ;
                                                         }
                   Vxx.uh+=vmpy(Vu.ub,Vv.ub)             for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].uh[i] += (Vu.uh[i].ub[0] *
                                                         Vv.uh[i].ub[0]);
                                                              Vxx.v[1].uh[i] += (Vu.uh[i].ub[1] *
                                                         Vv.uh[i].ub[1]) ;
                                                         }
                   Vxx.uw+=vmpy(Vu.uh,Vv.uh)             for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].uw[i] += (Vu.uw[i].uh[0] *
                                                         Vv.uw[i].uh[0]);
                                                              Vxx.v[1].uw[i] += (Vu.uw[i].uh[1] *
                                                         Vv.uw[i].uh[1]) ;
                                                         }
                   Vxx.w+=vmpy(Vu.h,Vv.h)                for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].w[i] += (Vu.w[i].h[0] *
                                                         Vv.w[i].h[0]);
                                                              Vxx.v[1].w[i] += (Vu.w[i].h[1] *
                                                         Vv.w[i].h[1]) ;
                                                         }
                   Vxx.w+=vmpy(Vu.h,Vv.uh)               for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].w[i] += (Vu.w[i].h[0] *
                                                         Vv.uw[i].uh[0]);
                                                              Vxx.v[1].w[i] += (Vu.w[i].h[1] *
                                                         Vv.uw[i].uh[1]) ;
                                                         }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■  This instruction uses both HVX multiply resources.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   133
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Intrinsics
                   Vd.h=vmpy(Vu.h,Vv.h):<<1:rnd:sa         HVX_Vector Q6_Vh_vmpy_VhVh_s1_rnd_sat(HVX_Vector
                   t                                       Vu, HVX_Vector Vv)
                   Vdd.h=vmpy(Vu.b,Vv.b)                   HVX_VectorPair Q6_Wh_vmpy_VbVb(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vdd.h=vmpy(Vu.ub,Vv.b)                  HVX_VectorPair Q6_Wh_vmpy_VubVb(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vdd.uh=vmpy(Vu.ub,Vv.ub)                HVX_VectorPair Q6_Wuh_vmpy_VubVub(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vdd.uw=vmpy(Vu.uh,Vv.uh)                HVX_VectorPair Q6_Wuw_vmpy_VuhVuh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vdd.w=vmpy(Vu.h,Vv.h)                   HVX_VectorPair Q6_Ww_vmpy_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vdd.w=vmpy(Vu.h,Vv.uh)                  HVX_VectorPair Q6_Ww_vmpy_VhVuh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vxx.h+=vmpy(Vu.b,Vv.b)                  HVX_VectorPair
                                                           Q6_Wh_vmpyacc_WhVbVb(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                   Vxx.h+=vmpy(Vu.ub,Vv.b)                 HVX_VectorPair
                                                           Q6_Wh_vmpyacc_WhVubVb(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                   Vxx.uh+=vmpy(Vu.ub,Vv.ub)               HVX_VectorPair
                                                           Q6_Wuh_vmpyacc_WuhVubVub(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                   Vxx.uw+=vmpy(Vu.uh,Vv.uh)               HVX_VectorPair
                                                           Q6_Wuw_vmpyacc_WuwVuhVuh(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                   Vxx.w+=vmpy(Vu.h,Vv.h)                  HVX_VectorPair
                                                           Q6_Ww_vmpyacc_WwVhVh(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                   Vxx.w+=vmpy(Vu.h,Vv.uh)                 HVX_VectorPair
                                                           Q6_Ww_vmpyacc_WwVhVuh(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8  7 6  5 4  3 2  1 0
   ICLASS                                       Parse          u5                  d5
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v P   P 0  u   u  u u u 1  0 0  d  d d  d d Vdd.h=vmpy(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v P   P 0  u   u  u u u 1  0 1  d  d d  d d Vdd.uh=vmpy(Vu.ub,Vv.ub)
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v P   P 0  u   u  u u u 1  1 0  d  d d  d d Vdd.h=vmpy(Vu.ub,Vv.b)
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v P   P 0  u   u  u u u 1  1 1  d  d d  d d Vdd.w=vmpy(Vu.h,Vv.h)
   ICLASS                                       Parse          u5                  x5
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v P   P 1  u   u  u u u 1  0 0  x  x  x x x Vxx.h+=vmpy(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v P   P 1  u   u  u u u 1  0 1  x  x  x x x Vxx.uh+=vmpy(Vu.ub,Vv.ub
                                                                                          )
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v P   P 1  u   u  u u u 1  1 0  x  x  x x x Vxx.h+=vmpy(Vu.ub,Vv.b)
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v P   P 1  u   u  u u u 1  1 1  x  x  x x x Vxx.w+=vmpy(Vu.h,Vv.h)
   ICLASS                                       Parse          u5                  d5
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        134
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0 0 0  d  d d  d  d Vdd.uw=vmpy(Vu.uh,Vv.uh)
                                                                                          Vd.h=vmpy(Vu.h,Vv.h):<<1:
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0 0 1  d  d d  d  d
                                                                                          rnd:sat
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0 1 0  d  d d  d  d Vdd.w=vmpy(Vu.h,Vv.uh)
   ICLASS                                        Parse         u5                 x5
                                                                                          Vxx.uw+=vmpy(Vu.uh,Vv.u
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 1  u  u  u u u 0 0 0  x  x x  x  x
                                                                                          h)
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 1  u  u  u u u 0 0 1  x  x x  x  x Vxx.w+=vmpy(Vu.h,Vv.uh)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        135
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
        Integer multiply - vector by vector
                  Multiply corresponding elements in Vu by the corresponding elements in Vv, and place
                  the lower half of the result in the destination vector register Vd. Supports signed
                  halfwords, and optional accumulation of the product with the destination vector register
                  Vx.
                                     Vd.h = vmpyi(Vu.h,Vv.h)
                                             h[0]          Vv
                                             h[0]          Vu
                    Output only lower          X
                    16 LSBs
                                               +
                    Optional
                    accumulate
                                              h[0]         Vd
                                         Each 16bit
                                             lane
                   Syntax                                Behavior
                   Vd.h=vmpyi(Vu.h,Vv.h)                 for (i = 0; i < VELEM(16); i++) {
                                                              Vd.h[i] = (Vu.h[i] * Vv.h[i]) ;
                                                         }
                   Vx.h+=vmpyi(Vu.h,Vv.h)                for (i = 0; i < VELEM(16); i++) {
                                                              Vx.h[i] += (Vu.h[i] * Vv.h[i]) ;
                                                         }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■  This instruction uses both HVX multiply resources.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      136
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Intrinsics
                   Vd.h=vmpyi(Vu.h,Vv.h)                   HVX_Vector Q6_Vh_vmpyi_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vx.h+=vmpyi(Vu.h,Vv.h)                  HVX_Vector Q6_Vh_vmpyiacc_VhVhVh(HVX_Vector Vx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1  0 0  d d  d d  d Vd.h=vmpyi(Vu.h,Vv.h)
   ICLASS                                        Parse         u5                 x5
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 1  u  u  u u u 1  0 0  x x  x x  x Vx.h+=vmpyi(Vu.h,Vv.h)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        137
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
          Integer Multiply (32x16)
                  Multiply words in one vector by even or odd halfwords in another vector. Take the lower
                  part. Some versions of this operation perform unusual shifts to facilitate 32x32 multiply
                  synthesis.
                   Syntax                                 Behavior
                   Vd.w=vmpyie(Vu.w,Vv.uh)                 for (i = 0; i < VELEM(32); i++) {
                                                                Vd.w[i] = (Vu.w[i] * Vv.w[i].uh[0]) ;
                                                           }
                   Vd.w=vmpyio(Vu.w,Vv.h)                  for (i = 0; i < VELEM(32); i++) {
                                                                Vd.w[i] = (Vu.w[i] * Vv.w[i].h[1]) ;
                                                           }
                   Vx.w+=vmpyie(Vu.w,Vv.h)                 for (i = 0; i < VELEM(32); i++) {
                                                                Vx.w[i] = Vx.w[i] + (Vu.w[i] * Vv.w[i].h[0])
                                                           ;
                                                           }
                   Vx.w+=vmpyie(Vu.w,Vv.uh)                for (i = 0; i < VELEM(32); i++) {
                                                                Vx.w[i] = Vx.w[i] + (Vu.w[i] *
                                                           Vv.w[i].uh[0]) ;
                                                           }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                        ■  This instruction uses both HVX multiply resources.
                  Intrinsics
                   Vd.w=vmpyie(Vu.w,Vv.uh)                 HVX_Vector Q6_Vw_vmpyie_VwVuh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.w=vmpyio(Vu.w,Vv.h)                  HVX_Vector Q6_Vw_vmpyio_VwVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vx.w+=vmpyie(Vu.w,Vv.h)                 HVX_Vector Q6_Vw_vmpyieacc_VwVwVh(HVX_Vector Vx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                   Vx.w+=vmpyie(Vu.w,Vv.uh)                HVX_Vector Q6_Vw_vmpyieacc_VwVwVuh(HVX_Vector
                                                           Vx, HVX_Vector Vu, HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS                                        Parse         u5                  x5
 0  0  0   1 1 1   0 0   0 0  1   v  v  v  v  v  P   P 1 u   u  u u  u 1  0 1  x x  x x  x Vx.w+=vmpyie(Vu.w,Vv.uh)
 0  0  0   1 1 1   0 0   0 1  0   v  v  v  v  v  P   P 1 u   u  u u  u 0  0 0  x x  x x  x Vx.w+=vmpyie(Vu.w,Vv.h)
   ICLASS                                        Parse         u5                  d5
 0  0  0   1 1 1   1 1   1 1  0   v  v  v  v  v  P   P 0 u   u  u u  u 0  0 0  d d  d d  d Vd.w=vmpyie(Vu.w,Vv.uh)
 0  0  0   1 1 1   1 1   1 1  0   v  v  v  v  v  P   P 0 u   u  u u  u 0  0 1  d d  d d  d Vd.w=vmpyio(Vu.w,Vv.h)
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       138
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Parse           Packet/Loop parse bits
                  d5              Field to encode register d
                  u5              Field to encode register u
                  v5              Field to encode register v
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             139
Hexagon V66 HVX Programmer’s Reference Manual                                                                                        Instruction Set
        Integer multiply accumulate even/odd
                  Multiply groups of words in vector register Vu by the elements in Rt. The lower 32-bit
                  results are placed in vector register Vd.
                  The operation has one form: Signed words multiplied by halfwords in Rt.
                  The operation has two forms: signed words or halfwords in Vu, multiplied by signed bytes
                  in Rt.
                  Optionally accumulates the product with the destination vector register Vx.
                             Vd.w [+]= vmpyi(Vu.w,Rt.b)                              Vd.w [+]= vmpyi(Vu.w,Rt.h)
                            w[3]              w[2]          w[1] w[0]   Vu               w[3]              w[2]          w[1] w[0]   Vu
                              X                                       Rt.b[3]              X                                             Rt.h[1]
                                               X                      Rt.b[2]                               X
                                                              X       Rt.b[1]                                              X
                    Output only lower 32 LSBs                     X   Rt.b[0]    Output only lower 32 LSBs                     X          Rt.h[0]
                                                                      Optional                                                     Optional
                              +                +              +   +   Accumulate
                                                                                           +                +              +   +   Accumulate
                            w[3]              w[2]          w[1] w[0]   Vd               w[3]              w[2]          w[1] w[0]   Vd
                                               Each 128bit lane                                             Each 128bit lane
                   Syntax                                              Behavior
                   Vd.w=vmpyi(Vu.w,Rt.h)                                for (i = 0; i < VELEM(32); i++) {
                                                                                Vd.w[i] = (Vu.w[i] * Rt.h[i % 2]) ;
                                                                        }
                   Vx.w+=vmpyi(Vu.w,Rt.h)                               for (i = 0; i < VELEM(32); i++) {
                                                                                Vx.w[i] += (Vu.w[i] * Rt.h[i % 2]) ;
                                                                        }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                          ■       This instruction uses both HVX multiply resources.
                  Intrinsics
                   Vd.w=vmpyi(Vu.w,Rt.h)                               HVX_Vector Q6_Vw_vmpyi_VwRh(HVX_Vector Vu,
                                                                       Word32 Rt)
                   Vx.w+=vmpyi(Vu.w,Rt.h)                              HVX_Vector Q6_Vw_vmpyiacc_VwVwRh(HVX_Vector Vx,
                                                                       HVX_Vector Vu, Word32 Rt)
80-N2040-44 Rev. B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                      140
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                               t5       Parse         u5                 x5
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 1  u  u  u u u 0 1 1  x  x  x x  x Vx.w+=vmpyi(Vu.w,Rt.h)
   ICLASS                               t5       Parse         u5                 d5
 0  0  0  1 1  0   0 1  1  0  0   t  t   t  t  t P   P 0  u  u  u u u 1 1 1  d  d d  d  d Vd.w=vmpyi(Vu.w,Rt.h)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        141
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
        Multiply (32x16)
                  Multiply words in one vector by even or odd halfwords in another vector. Take the upper
                  part. Some versions of this operation perform specific shifts to facilitate 32x32 multiply
                  synthesis.
                  An important operation is a 32 x 32 fractional multiply, equivalent to (OP1 * OP2)>>31.
                  The case of fn(0x80000000, 0x80000000) must saturate to 0x7fffffff.
                  The rounding fractional multiply:
                      vectorize( sat32(x * y + 0x40000000)>>31) )
                  equivalent to:
                      {
                      V2 = vmpye(V0.w, V1.uh)
                      } {
                      V2+= vmpyo(V0.w, V1.h):<<1:rnd:sat:shift }
                  and the non rounding fractional multiply version:
                      vectorize( sat32(x * y)>>31) )
                  equivalent to:
                      {
                      V2 = vmpye(V0.w, V1.uh)
                      } {
                      V2+= vmpyo(V0.w, V1.h):<<1:sat:shift
                      }
                  Also a key function is a 32-bit x 32-bit signed multiply where the 64-bit result is kept.
                      vectorize( (int64) x * (int64) y )
                  equivalent to:
                      {
                      V3:2 = vmpye(V0.w, V1.uh)
                      } {
                      V3:2+= vmpyo(V0.w, V1.h)
                      }
                  The lower 32 bits of products are in V2, and the upper 32 bits in V3. If only vmpye is
                  performed, the result is a 48-bit product of 32 signed x 16-bit unsigned asserted into the
                  upper 48 bits of Vdd. If vmpyo only is performed, assuming Vxx = #0, the result is a 32
                  signed x 16 signed product asserted into the upper 48 bits of Vxx.
                   Syntax                               Behavior
                   Vd.w=vmpye(Vu.w,Vv.uh)                for (i = 0; i < VELEM(32); i++) {
                                                              Vd.w[i] = (Vu.w[i] * Vv.w[i].uh[0]) >> 16 ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      142
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vd.w=vmpyo(Vu.w,Vv.h):<<1[:rnd]       for (i = 0; i < VELEM(32); i++) {
                   :sat                                       Vd.w[i] = sat32(((((Vu.w[i] * Vv.w[i].h[1])
                                                         >> 14) + 1) >> 1)) ;
                                                         }
                   Vdd=vmpye(Vu.w,Vv.uh)                 for (i = 0; i < VELEM(32); i++) {
                                                              prod = (Vu.w[i] * Vv.w[i].uh[0]);
                                                              Vdd.v[1].w[i] = prod >> 16;
                                                              Vdd.v[0].w[i] = prod << 16 ;
                                                         }
                   Vx.w+=vmpyo(Vu.w,Vv.h):<<1[:rnd       for (i = 0; i < VELEM(32); i++) {
                   ]:sat:shift                                Vx.w[i] = sat32(((((Vx.w[i] + (Vu.w[i] *
                                                         Vv.w[i].h[1])) >> 14) + 1) >> 1)) ;
                                                         }
                   Vxx+=vmpyo(Vu.w,Vv.h)                 for (i = 0; i < VELEM(32); i++) {
                                                              prod = (Vu.w[i] * Vv.w[i].h[1]) +
                                                         Vxx.v[1].w[i];
                                                              Vxx.v[1].w[i] = prod >> 16;
                                                              Vxx.v[0].w[i].h[0]=Vxx.v[0].w[i] >> 16;
                                                              Vxx.v[0].w[i].h[1]=prod & 0x0000ffff ;
                                                         }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■  This instruction uses both HVX multiply resources.
                  Intrinsics
                   Vd.w=vmpye(Vu.w,Vv.uh)                     HVX_Vector Q6_Vw_vmpye_VwVuh(HVX_Vector Vu,
                                                              HVX_Vector Vv)
                   Vd.w=vmpyo(Vu.w,Vv.h):<<1:rnd:sat          HVX_Vector
                                                              Q6_Vw_vmpyo_VwVh_s1_rnd_sat(HVX_Vector Vu,
                                                              HVX_Vector Vv)
                   Vd.w=vmpyo(Vu.w,Vv.h):<<1:sat              HVX_Vector
                                                              Q6_Vw_vmpyo_VwVh_s1_sat(HVX_Vector Vu,
                                                              HVX_Vector Vv)
                   Vdd=vmpye(Vu.w,Vv.uh)                      HVX_VectorPair Q6_W_vmpye_VwVuh(HVX_Vector
                                                              Vu, HVX_Vector Vv)
                   Vx.w+=vmpyo(Vu.w,Vv.h):<<1:rnd:sat:        HVX_Vector
                   shift                                      Q6_Vw_vmpyoacc_VwVwVh_s1_rnd_sat_shift(HVX_
                                                              Vector Vx, HVX_Vector Vu, HVX_Vector Vv)
                   Vx.w+=vmpyo(Vu.w,Vv.h):<<1:sat:shif        HVX_Vector
                   t                                          Q6_Vw_vmpyoacc_VwVwVh_s1_sat_shift(HVX_Vect
                                                              or Vx, HVX_Vector Vu, HVX_Vector Vv)
                   Vxx+=vmpyo(Vu.w,Vv.h)                      HVX_VectorPair
                                                              Q6_W_vmpyoacc_WVwVh(HVX_VectorPair Vxx,
                                                              HVX_Vector Vu, HVX_Vector Vv)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   143
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                                        Parse         u5                 x5
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 1  u  u  u u u 0 1 1  x  x  x x  x Vxx+=vmpyo(Vu.w,Vv.h)
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 1  u  u  u u u 1 1 0  x  x  x x  x Vx.w+=vmpyo(Vu.w,Vv.h):<
                                                                                          <1:sat:shift
                                                                                          Vx.w+=vmpyo(Vu.w,Vv.h):<
 0  0  0  1 1  1   0 0  0  0  1   v  v  v  v  v  P   P 1  u  u  u u u 1 1 1  x  x  x x  x
                                                                                          <1:rnd:sat:shift
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   1 0  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1 1 0  d  d d  d  d Vdd=vmpye(Vu.w,Vv.uh)
                                                                                          Vd.w=vmpyo(Vu.w,Vv.h):<<
 0  0  0  1 1  1   1 1  0  1  0   v  v  v  v  v  P   P 0  u  u  u u u 0 0 0  d  d d  d  d
                                                                                          1:rnd:sat
 0  0  0  1 1  1   1 1  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 1 0 1  d  d d  d  d Vd.w=vmpye(Vu.w,Vv.uh)
                                                                                          Vd.w=vmpyo(Vu.w,Vv.h):<<
 0  0  0  1 1  1   1 1  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 1 1 1  d  d d  d  d 1:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        144
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                          Instruction Set
             Multiply bytes with 4-wide reduction - vector by scalar
                          Perform multiplication between the elements in vector Vu and the corresponding elements
                          in the scalar register Rt, followed by a 4-way reduction to a word in each 32-bit lane.
                          Accumulate the result in Vx or Vxx.
                          Supports the multiplication of unsigned byte data by signed or unsigned bytes in the
                          scalar.
                          The operation has two forms: the first performs simple dot product of 4 elements into a
                          single result. The second form takes a 1 bit immediate input and generates a vector register
                          pair. For #1 = 0 the even destination contains a simple dot product, the odd destination
                          contains a dot product of the coefficients rotated by two elements and the upper two data
                          elements taken from the even register of Vuu. For #u = 1, the even destination takes
                          coefficients rotated by -1 and data element 0 from the odd register of Vuu. The odd
                          destination uses coefficients rotated by -1 and takes data element 3 from the even register
                          of Vuu.
                                          Vdd.w[+]=vrmpy(Vuu.ub,Rt.b, #0)                                                   Vdd.w[+]=vrmpy(Vuu.h,Rt.b, #1)
 Vd.w[+]=vrmpy(Vu.ub,Rt.b)
 b[3]   b[2]   b[1] b[0]      Vu          ub[3] ub[2] ub[1] ub[0] Vuu.V[1]          ub[3] ub[2] ub[1] ub[0] Vuu.V[0]        ub[3] ub[2] ub[1] ub[0] Vuu.V[1]           ub[3] ub[2] ub[1] ub[0] Vu
                      X          Rt.b[0]
                X                Rt.b[1]
         X                       Rt.b[2]
  X                              Rt.b[3]                      X        Rt.b[0]                          X                                       X         Rt.b[0]                          X
                                                         X             Rt.b[1]                     X                                       X              Rt.b[1]                     X
                           Optional
             +          Accumulation              X                    Rt.b[2]              X                                       X                     Rt.b[2]              X
                                            X                          Rt.b[3]        X                                       X                           Rt.b[3]        X
           w[0]
        32bit Lane                                                           Optional
                                                                                                                 Optional
                                                                                                                                                                Optional
                                                     +                     Accumulation        +               Accumulation            +                      Accumulation        +             Ac
                                                    w[0]              Vdd.V[1]                w[0]            Vdd.V[0]                w[0]                Vdd.V[1]               w[0]          Vd
                                                                   32bit lane pair                                                                    32bit lane pair
                          Class: COPROC_VX (slots 2,3)
                          Notes
                                     ■   This instruction uses both HVX multiply resources.
80-N2040-44 Rev. B                    MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                     145
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vdd.uw=vrmpy(Vuu.ub,Rt.ub,#u1)        for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].uw[i] = (Vuu.v[#u ?
                                                         1:0].uw[i].ub[0] * Rt.ub[(0-#u) & 0x3]);
                                                              Vdd.v[0].uw[i] += (Vuu.v[0 ].uw[i].ub[1] *
                                                         Rt.ub[(1-#u) & 0x3]);
                                                              Vdd.v[0].uw[i] += (Vuu.v[0 ].uw[i].ub[2] *
                                                         Rt.ub[(2-#u) & 0x3]);
                                                              Vdd.v[0].uw[i] += (Vuu.v[0 ].uw[i].ub[3] *
                                                         Rt.ub[(3-#u) & 0x3]);
                                                              Vdd.v[1].uw[i] = (Vuu.v[1 ].uw[i].ub[0] *
                                                         Rt.ub[(2-#u) & 0x3]);
                                                              Vdd.v[1].uw[i] += (Vuu.v[1 ].uw[i].ub[1] *
                                                         Rt.ub[(3-#u) & 0x3]);
                                                              Vdd.v[1].uw[i] += (Vuu.v[#u ?
                                                         1:0].uw[i].ub[2] * Rt.ub[(0-#u) & 0x3]);
                                                              Vdd.v[1].uw[i] += (Vuu.v[0 ].uw[i].ub[3] *
                                                         Rt.ub[(1-#u) & 0x3]) ;
                                                         }
                   Vdd.w=vrmpy(Vuu.ub,Rt.b,#u1)          for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = (Vuu.v[#u ? 1:0].uw[i].ub[0]
                                                         * Rt.b[(0-#u) & 0x3]);
                                                              Vdd.v[0].w[i] += (Vuu.v[0 ].uw[i].ub[1] *
                                                         Rt.b[(1-#u) & 0x3]);
                                                              Vdd.v[0].w[i] += (Vuu.v[0 ].uw[i].ub[2] *
                                                         Rt.b[(2-#u) & 0x3]);
                                                              Vdd.v[0].w[i] += (Vuu.v[0 ].uw[i].ub[3] *
                                                         Rt.b[(3-#u) & 0x3]);
                                                              Vdd.v[1].w[i] = (Vuu.v[1 ].uw[i].ub[0] *
                                                         Rt.b[(2-#u) & 0x3]);
                                                              Vdd.v[1].w[i] += (Vuu.v[1 ].uw[i].ub[1] *
                                                         Rt.b[(3-#u) & 0x3]);
                                                              Vdd.v[1].w[i] += (Vuu.v[#u ?
                                                         1:0].uw[i].ub[2] * Rt.b[(0-#u) & 0x3]);
                                                              Vdd.v[1].w[i] += (Vuu.v[0 ].uw[i].ub[3] *
                                                         Rt.b[(1-#u) & 0x3]) ;
                                                         }
                   Vxx.uw+=vrmpy(Vuu.ub,Rt.ub,#u1)       for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].uw[i] += (Vuu.v[#u ?
                                                         1:0].uw[i].ub[0] * Rt.ub[(0-#u) & 0x3]);
                                                              Vxx.v[0].uw[i] += (Vuu.v[0 ].uw[i].ub[1]   *
                                                         Rt.ub[(1-#u) & 0x3]);
                                                              Vxx.v[0].uw[i] += (Vuu.v[0 ].uw[i].ub[2]   *
                                                         Rt.ub[(2-#u) & 0x3]);
                                                              Vxx.v[0].uw[i] += (Vuu.v[0 ].uw[i].ub[3]   *
                                                         Rt.ub[(3-#u) & 0x3]);
                                                              Vxx.v[1].uw[i] += (Vuu.v[1 ].uw[i].ub[0]   *
                                                         Rt.ub[(2-#u) & 0x3]);
                                                              Vxx.v[1].uw[i] += (Vuu.v[1 ].uw[i].ub[1]   *
                                                         Rt.ub[(3-#u) & 0x3]);
                                                              Vxx.v[1].uw[i] += (Vuu.v[#u ?
                                                         1:0].uw[i].ub[2] * Rt.ub[(0-#u) & 0x3]);
                                                              Vxx.v[1].uw[i] += (Vuu.v[0 ].uw[i].ub[3]   *
                                                         Rt.ub[(1-#u) & 0x3]) ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   146
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                   Syntax                                  Behavior
                   Vxx.w+=vrmpy(Vuu.ub,Rt.b,#u1)            for (i = 0; i < VELEM(32); i++) {
                                                                 Vxx.v[0].w[i] += (Vuu.v[#u ?
                                                            1:0].uw[i].ub[0] * Rt.b[(0-#u) & 0x3]);
                                                                 Vxx.v[0].w[i] += (Vuu.v[0 ].uw[i].ub[1]      *
                                                            Rt.b[(1-#u) & 0x3]);
                                                                 Vxx.v[0].w[i] += (Vuu.v[0 ].uw[i].ub[2]      *
                                                            Rt.b[(2-#u) & 0x3]);
                                                                 Vxx.v[0].w[i] += (Vuu.v[0 ].uw[i].ub[3]      *
                                                            Rt.b[(3-#u) & 0x3]);
                                                                 Vxx.v[1].w[i] += (Vuu.v[1 ].uw[i].ub[0]      *
                                                            Rt.b[(2-#u) & 0x3]);
                                                                 Vxx.v[1].w[i] += (Vuu.v[1 ].uw[i].ub[1]      *
                                                            Rt.b[(3-#u) & 0x3]);
                                                                 Vxx.v[1].w[i] += (Vuu.v[#u ?
                                                            1:0].uw[i].ub[2] * Rt.b[(0-#u) & 0x3]);
                                                                 Vxx.v[1].w[i] += (Vuu.v[0 ].uw[i].ub[3]      *
                                                            Rt.b[(1-#u) & 0x3]) ;
                                                            }
                  Intrinsics
                   Vdd.uw=vrmpy(Vuu.ub,Rt.ub,#u1)          HVX_VectorPair
                                                           Q6_Wuw_vrmpy_WubRubI(HVX_VectorPair Vuu, Word32
                                                           Rt, Word32 Iu1)
                   Vdd.w=vrmpy(Vuu.ub,Rt.b,#u1)            HVX_VectorPair Q6_Ww_vrmpy_WubRbI(HVX_VectorPair
                                                           Vuu, Word32 Rt, Word32 Iu1)
                   Vxx.uw+=vrmpy(Vuu.ub,Rt.ub,#u1)         HVX_VectorPair
                                                           Q6_Wuw_vrmpyacc_WuwWubRubI(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt, Word32 Iu1)
                   Vxx.w+=vrmpy(Vuu.ub,Rt.b,#u1)           HVX_VectorPair
                                                           Q6_Ww_vrmpyacc_WwWubRbI(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt, Word32 Iu1)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS                               t5       Parse          u5                  d5
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 0  u   u u  u  u 1 0  i d  d d  d d Vdd.w=vrmpy(Vuu.ub,Rt.b,
                                                                                            #u1)
   ICLASS                               t5       Parse          u5                  x5
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 1  u   u u  u  u 1 0  i  x x  x x x Vxx.w+=vrmpy(Vuu.ub,Rt.b
                                                                                            ,#u1)
 0  0  0  1 1  0   0 1  0  1  1   t  t   t  t  t P   P 1  u   u u  u  u 1 1  i  x x  x x x Vxx.uw+=vrmpy(Vuu.ub,Rt.
                                                                                            ub,#u1)
   ICLASS                               t5       Parse          u5                  d5
 0  0  0  1 1  0   0 1  1  0  1   t  t   t  t  t P   P 0  u   u u  u  u 1 1  i d  d d  d d Vdd.uw=vrmpy(Vuu.ub,Rt.u
                                                                                            b,#u1)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        147
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  t5              Field to encode register t
                  u5              Field to encode register u
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             148
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
        Multiply by byte with accumulate and 4-wide reduction - vector by
        vector
                  vrmpy performs a dot product function between 4 byte elements in vector register Vu and
                  4 byte elements in Vv. the sum of products can be optionally accumulated into Vx or
                  written into Vd as words within each 32-bit lane.
                  Data types can be unsigned by unsigned, signed by signed, or unsigned by signed.
                      Vd.w[+]=vrmpy(Vu.b,Vv.b)
                     b[3]     b[2]     b[1]      b[0]          Vu
                              b[3]     b[2]      b[1]   b[0]      Vv
                            X        X        X       X
                                         +               Optional Accumulation
                                       w[0]                    Vd
                                   32bit Lane
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■   This instruction uses both HVX multiply resources.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  149
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                   Syntax                                  Behavior
                   Vx.uw+=vrmpy(Vu.ub,Vv.ub)                for (i = 0; i < VELEM(32); i++)     {
                                                                 Vx.uw[i] += (Vu.uw[i].ub[0]    *
                                                            Vv.uw[i].ub[0]);
                                                                 Vx.uw[i] += (Vu.uw[i].ub[1]    *
                                                            Vv.uw[i].ub[1]);
                                                                 Vx.uw[i] += (Vu.uw[i].ub[2]    *
                                                            Vv.uw[i].ub[2]);
                                                                 Vx.uw[i] += (Vu.uw[i].ub[3]    *
                                                            Vv.uw[i].ub[3]) ;
                                                            }
                   Vx.w+=vrmpy(Vu.b,Vv.b)                   for (i = 0;    i < VELEM(32); i++) {
                                                                 Vx.w[i]   += (Vu.w[i].b[0] * Vv.w[i].b[0]);
                                                                 Vx.w[i]   += (Vu.w[i].b[1] * Vv.w[i].b[1]);
                                                                 Vx.w[i]   += (Vu.w[i].b[2] * Vv.w[i].b[2]);
                                                                 Vx.w[i]   += (Vu.w[i].b[3] * Vv.w[i].b[3]) ;
                                                            }
                   Vx.w+=vrmpy(Vu.ub,Vv.b)                  for (i = 0;    i < VELEM(32); i++) {
                                                                 Vx.w[i]   += (Vu.uw[i].ub[0] * Vv.w[i].b[0]);
                                                                 Vx.w[i]   += (Vu.uw[i].ub[1] * Vv.w[i].b[1]);
                                                                 Vx.w[i]   += (Vu.uw[i].ub[2] * Vv.w[i].b[2]);
                                                                 Vx.w[i]   += (Vu.uw[i].ub[3] * Vv.w[i].b[3]) ;
                                                            }
                  Intrinsics
                   Vx.uw+=vrmpy(Vu.ub,Vv.ub)               HVX_Vector Q6_Vuw_vrmpyacc_VuwVubVub(HVX_Vector
                                                           Vx, HVX_Vector Vu, HVX_Vector Vv)
                   Vx.w+=vrmpy(Vu.b,Vv.b)                  HVX_Vector Q6_Vw_vrmpyacc_VwVbVb(HVX_Vector Vx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                   Vx.w+=vrmpy(Vu.ub,Vv.b)                 HVX_Vector Q6_Vw_vrmpyacc_VwVubVb(HVX_Vector Vx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7   6 5  4 3 2  1 0
   ICLASS                                        Parse          u5                    x5
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v  P   P 1  u   u u  u  u 0   0  0  x x x  x x Vx.uw+=vrmpy(Vu.ub,Vv.ub
                                                                                              )
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v  P   P 1  u   u u  u  u 0   0  1  x x x  x x Vx.w+=vrmpy(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v  P   P 1  u   u u  u  u 0   1  0  x x x  x x Vx.w+=vrmpy(Vu.ub,Vv.b)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  u5                Field to encode register u
                  v5                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          150
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
        Multiply with 3-wide reduction
                  Perform a three-element sliding window pattern operation consisting of a two multiplies
                  with an additional accumulation. Data elements are stored in the vector register pair Vuu,
                  and coefficients in the scalar register Rt.
          Vdd.h[+]=vtmpy(Vuu.b,Rt.b)
           b[3]    b[2]    b[1]    b[0]    Vuu.V[1]                      b[3]    b[2]   b[1]    b[0]      Vuu.V[0]
                                    X                    Rt.b[0]                                 X
                             X                           Rt.b[1]                         X
                     X                                   Rt.b[2]                  X
             X                                           Rt.b[3]          X
                 +              +              Optional Accumulation           +             +              Optional Accumulation
               h[1]            h[0]            Vdd.V[1]                      h[1]           h[0]            Vdd.V[0]
                                                   32bit lane pair
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      151
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
                                Vdd[+]=vtmpyhb(Vuu,Rt)
                      h[1]     h[0]     Vuu.V[1]          h[1]    h[0]     Vuu.V[0]
                                                   X                X         Rt.b[0/2]
                                X                           X                 Rt.b[1/3]
                            +                                   +         Optional Accumulation
                          w[0]          Vdd.V[1]              w[0]       Vdd.V[0]
                                                           32bit lane
                   Syntax                               Behavior
                   Vdd.h=vtmpy(Vuu.b,Rt.b)               for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] = (Vuu.v[0].h[i].b[0] *
                                                         Rt.b[(2*i )%4]);
                                                              Vdd.v[0].h[i] += (Vuu.v[0].h[i].b[1] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vdd.v[0].h[i] += Vuu.v[1].h[i].b[0];
                                                              Vdd.v[1].h[i] = (Vuu.v[0].h[i].b[1] *
                                                         Rt.b[(2*i )%4]);
                                                              Vdd.v[1].h[i] += (Vuu.v[1].h[i].b[0] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vdd.v[1].h[i] += Vuu.v[1].h[i].b[1] ;
                                                         }
                   Vdd.h=vtmpy(Vuu.ub,Rt.b)              for (i = 0; i < VELEM(16); i++) {
                                                              Vdd.v[0].h[i] = (Vuu.v[0].uh[i].ub[0] *
                                                         Rt.b[(2*i )%4]);
                                                              Vdd.v[0].h[i] += (Vuu.v[0].uh[i].ub[1] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vdd.v[0].h[i] += Vuu.v[1].uh[i].ub[0];
                                                              Vdd.v[1].h[i] = (Vuu.v[0].uh[i].ub[1] *
                                                         Rt.b[(2*i )%4]);
                                                              Vdd.v[1].h[i] += (Vuu.v[1].uh[i].ub[0] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vdd.v[1].h[i] += Vuu.v[1].uh[i].ub[1] ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    152
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vdd.w=vtmpy(Vuu.h,Rt.b)               for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].w[i] = (Vuu.v[0].w[i].h[0] *
                                                         Rt.b[(2*i+0)%4]);
                                                              Vdd.v[0].w[i]+= (Vuu.v[0].w[i].h[1] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vdd.v[0].w[i]+= Vuu.v[1].w[i].h[0];
                                                              Vdd.v[1].w[i] = (Vuu.v[0].w[i].h[1] *
                                                         Rt.b[(2*i+0)%4]);
                                                              Vdd.v[1].w[i]+= (Vuu.v[1].w[i].h[0] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vdd.v[1].w[i]+= Vuu.v[1].w[i].h[1] ;
                                                         }
                   Vxx.h+=vtmpy(Vuu.b,Rt.b)              for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].h[i] += (Vuu.v[0].h[i].b[0] *
                                                         Rt.b[(2*i )%4]);
                                                              Vxx.v[0].h[i] += (Vuu.v[0].h[i].b[1] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vxx.v[0].h[i] += Vuu.v[1].h[i].b[0];
                                                              Vxx.v[1].h[i] += (Vuu.v[0].h[i].b[1] *
                                                         Rt.b[(2*i )%4]);
                                                              Vxx.v[1].h[i] += (Vuu.v[1].h[i].b[0] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vxx.v[1].h[i] += Vuu.v[1].h[i].b[1] ;
                                                         }
                   Vxx.h+=vtmpy(Vuu.ub,Rt.b)             for (i = 0; i < VELEM(16); i++) {
                                                              Vxx.v[0].h[i] += (Vuu.v[0].uh[i].ub[0] *
                                                         Rt.b[(2*i )%4]);
                                                              Vxx.v[0].h[i] += (Vuu.v[0].uh[i].ub[1] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vxx.v[0].h[i] += Vuu.v[1].uh[i].ub[0];
                                                              Vxx.v[1].h[i] += (Vuu.v[0].uh[i].ub[1] *
                                                         Rt.b[(2*i )%4]);
                                                              Vxx.v[1].h[i] += (Vuu.v[1].uh[i].ub[0] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vxx.v[1].h[i] += Vuu.v[1].uh[i].ub[1] ;
                                                         }
                   Vxx.w+=vtmpy(Vuu.h,Rt.b)              for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].w[i]+= (Vuu.v[0].w[i].h[0] *
                                                         Rt.b[(2*i+0)%4]);
                                                              Vxx.v[0].w[i]+= (Vuu.v[0].w[i].h[1] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vxx.v[0].w[i]+= Vuu.v[1].w[i].h[0];
                                                              Vxx.v[1].w[i]+= (Vuu.v[0].w[i].h[1] *
                                                         Rt.b[(2*i+0)%4]);
                                                              Vxx.v[1].w[i]+= (Vuu.v[1].w[i].h[0] *
                                                         Rt.b[(2*i+1)%4]);
                                                              Vxx.v[1].w[i]+= Vuu.v[1].w[i].h[1] ;
                                                         }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■  This instruction uses both HVX multiply resources.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   153
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
                  Intrinsics
                   Vdd.h=vtmpy(Vuu.b,Rt.b)                 HVX_VectorPair Q6_Wh_vtmpy_WbRb(HVX_VectorPair
                                                           Vuu, Word32 Rt)
                   Vdd.h=vtmpy(Vuu.ub,Rt.b)                HVX_VectorPair Q6_Wh_vtmpy_WubRb(HVX_VectorPair
                                                           Vuu, Word32 Rt)
                   Vdd.w=vtmpy(Vuu.h,Rt.b)                 HVX_VectorPair Q6_Ww_vtmpy_WhRb(HVX_VectorPair
                                                           Vuu, Word32 Rt)
                   Vxx.h+=vtmpy(Vuu.b,Rt.b)                HVX_VectorPair
                                                           Q6_Wh_vtmpyacc_WhWbRb(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt)
                   Vxx.h+=vtmpy(Vuu.ub,Rt.b)               HVX_VectorPair
                                                           Q6_Wh_vtmpyacc_WhWubRb(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt)
                   Vxx.w+=vtmpy(Vuu.h,Rt.b)                HVX_VectorPair
                                                           Q6_Ww_vtmpyacc_WwWhRb(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                               t5       Parse         u5                 d5
 0  0  0  1 1  0   0 1  0  0  0   t  t   t  t  t P   P 0  u  u  u u u 0  0 0  d d  d d  d Vdd.h=vtmpy(Vuu.b,Rt.b)
 0  0  0  1 1  0   0 1  0  0  0   t  t   t  t  t P   P 0  u  u  u u u 0  0 1  d d  d d  d Vdd.h=vtmpy(Vuu.ub,Rt.b)
   ICLASS                               t5       Parse         u5                 x5
 0  0  0  1 1  0   0 1  0  0  0   t  t   t  t  t P   P 1  u  u  u u u 0  0 0  x x  x x  x Vxx.h+=vtmpy(Vuu.b,Rt.b)
 0  0  0  1 1  0   0 1  0  0  0   t  t   t  t  t P   P 1  u  u  u u u 0  0 1  x x  x x  x Vxx.h+=vtmpy(Vuu.ub,Rt.b)
 0  0  0  1 1  0   0 1  0  0  0   t  t   t  t  t P   P 1  u  u  u u u 0  1 0  x x  x x  x Vxx.w+=vtmpy(Vuu.h,Rt.b)
   ICLASS                               t5       Parse         u5                 d5
 0  0  0  1 1  0   0 1  1  0  1   t  t   t  t  t P   P 0  u  u  u u u 1  0 0  d d  d d  d Vdd.w=vtmpy(Vuu.h,Rt.b)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        154
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
        Sum of reduction of absolute differences halfwords
                  Takes groups of two unsigned halfwords from the vector register source Vuu, subtracts the
                  halfwords from the scalar register Rt, and takes the absolute value as an unsigned result.
                  These are summed together and optionally added to the destination register Vxx, or
                  written directly to Vdd. The even destination register contains the data from Vuu[0] and
                  Rt, Vdd[1] contains the absolute difference of half of the data from Vuu[0] and half from
                  Vuu[1].
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    155
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
                  This operation is used to implement a sliding window.
                 Vdd.uw=vdsad(Vuu.uh,Rt.uh)
                   h[1]            h[0]         Vuu[1]             h[1]           h[0]     Vuu[0]
                     -                          Rt.uh[0]                            -
                                     -          Rt.uh[1]             -
                   |.|             |.|                             |.|             |.|   ABS
                                      Optional
                             +                                              +
                                    Accumulate
                           w[0]                 Vdd[1]                    w[0]             Vdd[0]
                        32hit Lane                                      32hit Lane
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    156
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                   Syntax                                  Behavior
                   Vdd.uw=vdsad(Vuu.uh,Rt.uh)               for (i = 0; i < VELEM(32); i++) {
                                                                 Vdd.v[0].uw[i] = ABS(Vuu.v[0].uw[i].uh[0] -
                                                            Rt.uh[0]);
                                                                 Vdd.v[0].uw[i] += ABS(Vuu.v[0].uw[i].uh[1] -
                                                            Rt.uh[1]);
                                                                 Vdd.v[1].uw[i] = ABS(Vuu.v[0].uw[i].uh[1] -
                                                            Rt.uh[0]);
                                                                 Vdd.v[1].uw[i] += ABS(Vuu.v[1].uw[i].uh[0] -
                                                            Rt.uh[1]) ;
                                                            }
                   Vxx.uw+=vdsad(Vuu.uh,Rt.uh)              for (i = 0; i < VELEM(32); i++) {
                                                                 Vxx.v[0].uw[i] += ABS(Vuu.v[0].uw[i].uh[0]      -
                                                            Rt.uh[0]);
                                                                 Vxx.v[0].uw[i] += ABS(Vuu.v[0].uw[i].uh[1]      -
                                                            Rt.uh[1]);
                                                                 Vxx.v[1].uw[i] += ABS(Vuu.v[0].uw[i].uh[1]      -
                                                            Rt.uh[0]);
                                                                 Vxx.v[1].uw[i] += ABS(Vuu.v[1].uw[i].uh[0]      -
                                                            Rt.uh[1]) ;
                                                            }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■   This instruction uses both HVX multiply resources.
                  Intrinsics
                   Vdd.uw=vdsad(Vuu.uh,Rt.uh)              HVX_VectorPair
                                                           Q6_Wuw_vdsad_WuhRuh(HVX_VectorPair Vuu, Word32
                                                           Rt)
                   Vxx.uw+=vdsad(Vuu.uh,Rt.uh)             HVX_VectorPair
                                                           Q6_Wuw_vdsadacc_WuwWuhRuh(HVX_VectorPair Vxx,
                                                           HVX_VectorPair Vuu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3  2 1  0
   ICLASS                               t5       Parse          u5                  d5
 0  0  0  1 1  0   0 1  0  0  0   t  t   t  t  t P   P 0  u   u u  u  u 1 0  1  d d  d d  d Vdd.uw=vdsad(Vuu.uh,Rt.u
                                                                                            h)
   ICLASS                               t5       Parse          u5                  x5
 0  0  0  1 1  0   0 1  0  1  1   t  t   t  t  t P   P 1  u   u u  u  u 0 0  0  x x  x x  x Vxx.uw+=vdsad(Vuu.uh,Rt.
                                                                                            uh)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        157
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  t5              Field to encode register t
                  u5              Field to encode register u
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             158
Hexagon V66 HVX Programmer’s Reference Manual                                                                                       Instruction Set
           Sum of absolute differences byte
                          Take groups of four bytes from the vector register source Vuu, subtract the bytes from the
                          scalar register Rt, and take the absolute value as an unsigned result. These are summed
                          together and optionally added to the destination register Vxx, or written directly to Vdd. If
                          #u1 is 0, the even destination register contains the data from Vuu[0] and Rt, Vdd[1]
                          contains the absolute difference of half of the data from Vuu[0] and half from Vuu[1]. If
                          #u1 is 1, Vdd[0] takes btye 0 from Vuu[1] and bytes 1,2,3 from Vuu[0], while Vdd[1]
                          takes byte 3 from Vuu[0] and the rest from Vuu[1].
                          This operation is used to implement a sliding window between data in Vuu and Rt.
   Vdd.uw=vrsad(Vuu.ub,Rt.ub, #0)                                       Vdd.uw=vrsad(Vuu.ub,Rt.ub, #1)
   b[3]  b[2]    b[1]    b[0] Vuu[1]      b[3] b[2]    b[1] b[0] Vuu[0] b[3]  b[2]    b[1]    b[0]  Vuu[1]      b[3] b[2]    b[1] b[0] Vuu[0]
          -                       Rt.b[0]                    -           -                             Rt.b[0]                -
    -                             Rt.b[1]               -                                      -       Rt.b[1]        -
                          -       Rt.b[2]        -                                     -                Rt.b[2]  -
                  -               Rt.b[3]  -                                   -                       Rt.b[3]                     -
   |.| |.| |.| |.|                        |.| |.| |.| |.|        ABS    |.| |.| |.| |.|                         |.| |.| |.| |.|        ABS
                       Optional                                                             Optional
              +                                     +                              +                                      +
                      Accumulate                                                           Accumulate
             w[0]              Vdd[1]              w[0]          Vdd[0]           w[0]               Vdd[1]              w[0]          Vdd[0]
          32bit Lane                            32bit Lane                     32bit Lane                             32bit Lane
                          Class: COPROC_VX (slots 2,3)
                          Notes
                                  ■    This instruction uses both HVX multiply resources.
80-N2040-44 Rev. B                 MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                             159
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vdd.uw=vrsad(Vuu.ub,Rt.ub,#u1)        for (i = 0; i < VELEM(32); i++) {
                                                              Vdd.v[0].uw[i] =
                                                         ABS(Vuu.v[#u?1:0].uw[i].ub[0] - Rt.ub[(0-
                                                         #u)&3]);
                                                              Vdd.v[0].uw[i] += ABS(Vuu.v[0 ].uw[i].ub[1]
                                                         - Rt.ub[(1-#u)&3]);
                                                              Vdd.v[0].uw[i] += ABS(Vuu.v[0 ].uw[i].ub[2]
                                                         - Rt.ub[(2-#u)&3]);
                                                              Vdd.v[0].uw[i] += ABS(Vuu.v[0 ].uw[i].ub[3]
                                                         - Rt.ub[(3-#u)&3]);
                                                              Vdd.v[1].uw[i] = ABS(Vuu.v[1 ].uw[i].ub[0] -
                                                         Rt.ub[(2-#u)&3]);
                                                              Vdd.v[1].uw[i] += ABS(Vuu.v[1 ].uw[i].ub[1]
                                                         - Rt.ub[(3-#u)&3]);
                                                              Vdd.v[1].uw[i] +=
                                                         ABS(Vuu.v[#u?1:0].uw[i].ub[2] - Rt.ub[(0-
                                                         #u)&3]);
                                                              Vdd.v[1].uw[i] += ABS(Vuu.v[0 ].uw[i].ub[3]
                                                         - Rt.ub[(1-#u)&3]) ;
                                                         }
                   Vxx.uw+=vrsad(Vuu.ub,Rt.ub,#u1)       for (i = 0; i < VELEM(32); i++) {
                                                              Vxx.v[0].uw[i] +=
                                                         ABS(Vuu.v[#u?1:0].uw[i].ub[0] - Rt.ub[(0-
                                                         #u)&3]);
                                                              Vxx.v[0].uw[i] += ABS(Vuu.v[0 ].uw[i].ub[1]
                                                         - Rt.ub[(1-#u)&3]);
                                                              Vxx.v[0].uw[i] += ABS(Vuu.v[0 ].uw[i].ub[2]
                                                         - Rt.ub[(2-#u)&3]);
                                                              Vxx.v[0].uw[i] += ABS(Vuu.v[0 ].uw[i].ub[3]
                                                         - Rt.ub[(3-#u)&3]);
                                                              Vxx.v[1].uw[i] += ABS(Vuu.v[1 ].uw[i].ub[0]
                                                         - Rt.ub[(2-#u)&3]);
                                                              Vxx.v[1].uw[i] += ABS(Vuu.v[1 ].uw[i].ub[1]
                                                         - Rt.ub[(3-#u)&3]);
                                                              Vxx.v[1].uw[i] +=
                                                         ABS(Vuu.v[#u?1:0].uw[i].ub[2] - Rt.ub[(0-
                                                         #u)&3]);
                                                              Vxx.v[1].uw[i] += ABS(Vuu.v[0 ].uw[i].ub[3]
                                                         - Rt.ub[(1-#u)&3]) ;
                                                         }
                  Intrinsics
                   Vdd.uw=vrsad(Vuu.ub,Rt.ub,#u1)        HVX_VectorPair
                                                         Q6_Wuw_vrsad_WubRubI(HVX_VectorPair Vuu, Word32
                                                         Rt, Word32 Iu1)
                   Vxx.uw+=vrsad(Vuu.ub,Rt.ub,#u1)       HVX_VectorPair
                                                         Q6_Wuw_vrsadacc_WuwWubRubI(HVX_VectorPair Vxx,
                                                         HVX_VectorPair Vuu, Word32 Rt, Word32 Iu1)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   160
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                               t5       Parse         u5                 d5
                                                                                          Vdd.uw=vrsad(Vuu.ub,Rt.u
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 0  u  u  u u u 1 1 i  d  d d  d  d
                                                                                          b,#u1)
   ICLASS                               t5       Parse         u5                 x5
                                                                                          Vxx.uw+=vrsad(Vuu.ub,Rt.
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 1  u  u  u u u 1 1 i  x  x  x x  x
                                                                                          ub,#u1)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       161
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                       Instruction Set
       5.9        HVX/MPY-RESOURCE
                  The HVX/MPY-RESOURCE instruction subclass includes instructions that use a single
                  HVX multiply resource.
        Multiply by byte with 2-wide reduction
                  Multiply elements from Vu by the corresponding elements in the scalar register Rt. The
                  products are added in pairs to yield a by-2 reduction. The products can optionally be
                  accumulated with Vx.
                  Supports multiplication of unsigned bytes by bytes, and halfwords by signed bytes. The
                  double-vector version performs a sliding-window 2-way reduction, where the odd register
                  output contains the offset computation.
                    Vd.h[+]=vdmpy(Vu.ub, Rt.b) / Vd.w[+]=vdmpy(Vu.h, Rt.b)            Vdd.h[+]=vdmpy(Vuu.ub, Rt.b) / Vdd.w[+]=vdmpy(Vuu.h, Rt.b)
                                                                             ub/h[3] ub/h[2] ub/h[1] ub/h[0]  Vuu[1]                ub/h[3] ub/h[2] ub/h[1] ub/h[0]  Vuu[0]
                       ub/h[3] ub/h[2] ub/h[1] ub/h[0]  Vu
                                                 X         Rt.b[0]                                     X           Rt.b[0]                                    X
                                         X                 Rt.b[1]                             X                   Rt.b[1]                            X
                                 X                         Rt.b[2]                     X                           Rt.b[2]                    X
                         X                                 Rt.b[3]             X                                   Rt.b[3]            X
                              +               +        Optional Accumulation        +               +          Optional Accumulation       +               +
                           h/w[1]          h/w[0]       Vd                       h/w[1]          h/w[0]       Vdd[1]                    h/w[1]          h/w[0]       Vdd[0]
                               32/64bit Lane                                                                 32/64bit Lane Pair
                   Syntax                                                        Behavior
                   Vd.h=vdmpy(Vu.ub,Rt.b)                                         for (i = 0; i < VELEM(16); i++) {
                                                                                           Vd.h[i] = (Vu.uh[i].ub[0] * Rt.b[(2*i) %
                                                                                  4]);
                                                                                           Vd.h[i] += (Vu.uh[i].ub[1] *
                                                                                  Rt.b[(2*i+1)%4]) ;
                                                                                  }
                   Vd.w=vdmpy(Vu.h,Rt.b)                                          for (i = 0; i < VELEM(32); i++) {
                                                                                           Vd.w[i] = (Vu.w[i].h[0] * Rt.b[(2*i+0)%4]);
                                                                                           Vd.w[i] += (Vu.w[i].h[1] * Rt.b[(2*i+1)%4])
                                                                                  ;
                                                                                  }
80-N2040-44 Rev. B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                                    162
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
                   Syntax                                  Behavior
                   Vx.h+=vdmpy(Vu.ub,Rt.b)                  for (i = 0; i < VELEM(16); i++) {
                                                                 Vx.h[i] += (Vu.uh[i].ub[0] * Rt.b[(2*i) %
                                                            4]);
                                                                 Vx.h[i] += (Vu.uh[i].ub[1] *
                                                            Rt.b[(2*i+1)%4]) ;
                                                            }
                   Vx.w+=vdmpy(Vu.h,Rt.b)                   for (i = 0; i < VELEM(32); i++) {
                                                                 Vx.w[i] += (Vu.w[i].h[0] * Rt.b[(2*i+0)%4]);
                                                                 Vx.w[i] += (Vu.w[i].h[1] * Rt.b[(2*i+1)%4])
                                                            ;
                                                            }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■   This instruction uses a HVX multiply resource.
                  Intrinsics
                   Vd.h=vdmpy(Vu.ub,Rt.b)                  HVX_Vector Q6_Vh_vdmpy_VubRb(HVX_Vector Vu,
                                                           Word32 Rt)
                   Vd.w=vdmpy(Vu.h,Rt.b)                   HVX_Vector Q6_Vw_vdmpy_VhRb(HVX_Vector Vu,
                                                           Word32 Rt)
                   Vx.h+=vdmpy(Vu.ub,Rt.b)                 HVX_Vector Q6_Vh_vdmpyacc_VhVubRb(HVX_Vector Vx,
                                                           HVX_Vector Vu, Word32 Rt)
                   Vx.w+=vdmpy(Vu.h,Rt.b)                  HVX_Vector Q6_Vw_vdmpyacc_VwVhRb(HVX_Vector Vx,
                                                           HVX_Vector Vu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS                               t5       Parse          u5                  d5
 0  0  0  1 1  0   0 1  0  0  0   t  t   t  t  t P   P 0  u   u u  u  u 0 1  0 d  d d  d d Vd.w=vdmpy(Vu.h,Rt.b)
 0  0  0  1 1  0   0 1  0  0  0   t  t   t  t  t P   P 0  u   u u  u  u 1 1  0 d  d d  d d Vd.h=vdmpy(Vu.ub,Rt.b)
   ICLASS                               t5       Parse          u5                  x5
 0  0  0  1 1  0   0 1  0  0  0   t  t   t  t  t P   P 1  u   u u  u  u 0 1  1  x x  x x x Vx.w+=vdmpy(Vu.h,Rt.b)
 0  0  0  1 1  0   0 1  0  0  0   t  t   t  t  t P   P 1  u   u u  u  u 1 1  0  x x  x x x Vx.h+=vdmpy(Vu.ub,Rt.b)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         163
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
          Multiply half of the elements (16x16)
                  Multiply even elements of Vu by odd elements of Vv, shift the result left by 16 bits, and
                  place the result in each lane of Vd. This instruction is useful for 32x32 low-half multiplies.
                   Syntax                                  Behavior
                   Vd.w=vmpyieo(Vu.h,Vv.h)                  for (i = 0; i < VELEM(32); i++) {
                                                                 Vd.w[i] = (Vu.w[i].h[0]*Vv.w[i].h[1]) << 16
                                                            ;
                                                            }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■   This instruction uses a HVX multiply resource.
                  Intrinsics
                   Vd.w=vmpyieo(Vu.h,Vv.h)                 HVX_Vector Q6_Vw_vmpyieo_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS                                        Parse          u5                  d5
 0  0  0  1 1  1   1 1  0  1  1   v  v  v  v  v  P   P 0  u   u u  u  u 0 0  0 d  d d  d d Vd.w=vmpyieo(Vu.h,Vv.h)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        164
Hexagon V66 HVX Programmer’s Reference Manual                                                                                         Instruction Set
        Integer multiply by byte
                  Multiply groups of words in vector register Vu by the elements in Rt. The lower 32-bit
                  results are placed in vector register Vd.
                  The operation has one forms: signed words in Vu multiplied by signed bytes in Rt.
                  Optionally accumulates the product with the destination vector register Vx.
                             Vd.w [+]= vmpyi(Vu.w,Rt.b)                               Vd.w [+]= vmpyi(Vu.w,Rt.h)
                            w[3]              w[2]           w[1] w[0]   Vu               w[3]              w[2]          w[1] w[0]   Vu
                              X                                        Rt.b[3]              X                                             Rt.h[1]
                                               X                       Rt.b[2]                               X
                                                              X        Rt.b[1]                                              X
                    Output only lower 32 LSBs                      X   Rt.b[0]    Output only lower 32 LSBs                     X          Rt.h[0]
                                                                       Optional                                                     Optional
                              +                +              +    +   Accumulate
                                                                                            +                +              +   +   Accumulate
                            w[3]              w[2]           w[1] w[0]   Vd               w[3]              w[2]          w[1] w[0]   Vd
                                               Each 128bit lane                                              Each 128bit lane
                   Syntax                                               Behavior
                   Vd.h=vmpyi(Vu.h,Rt.b)                                 for (i = 0; i < VELEM(16); i++) {
                                                                                 Vd.h[i] = (Vu.h[i] * Rt.b[i % 4]) ;
                                                                         }
                   Vd.w=vmpyi(Vu.w,Rt.b)                                 for (i = 0; i < VELEM(32); i++) {
                                                                                 Vd.w[i] = (Vu.w[i] * Rt.b[i % 4]) ;
                                                                         }
                   Vd.w=vmpyi(Vu.w,Rt.ub)                                for (i = 0; i < VELEM(32); i++) {
                                                                                 Vd.w[i] = (Vu.w[i] * Rt.ub[i % 4]) ;
                                                                         }
                   Vx.h+=vmpyi(Vu.h,Rt.b)                                for (i = 0; i < VELEM(16); i++) {
                                                                                 Vx.h[i] += (Vu.h[i] * Rt.b[i % 4]) ;
                                                                         }
                   Vx.w+=vmpyi(Vu.w,Rt.b)                                for (i = 0; i < VELEM(32); i++) {
                                                                                 Vx.w[i] += (Vu.w[i] * Rt.b[i % 4]) ;
                                                                         }
                   Vx.w+=vmpyi(Vu.w,Rt.ub)                               for (i = 0; i < VELEM(32); i++) {
                                                                                 Vx.w[i] += (Vu.w[i] * Rt.ub[i % 4]) ;
                                                                         }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                          ■       This instruction uses a HVX multiply resource.
80-N2040-44 Rev. B          MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                       165
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Intrinsics
                   Vd.h=vmpyi(Vu.h,Rt.b)                   HVX_Vector Q6_Vh_vmpyi_VhRb(HVX_Vector Vu,
                                                           Word32 Rt)
                   Vd.w=vmpyi(Vu.w,Rt.b)                   HVX_Vector Q6_Vw_vmpyi_VwRb(HVX_Vector Vu,
                                                           Word32 Rt)
                   Vd.w=vmpyi(Vu.w,Rt.ub)                  HVX_Vector Q6_Vw_vmpyi_VwRub(HVX_Vector Vu,
                                                           Word32 Rt)
                   Vx.h+=vmpyi(Vu.h,Rt.b)                  HVX_Vector Q6_Vh_vmpyiacc_VhVhRb(HVX_Vector Vx,
                                                           HVX_Vector Vu, Word32 Rt)
                   Vx.w+=vmpyi(Vu.w,Rt.b)                  HVX_Vector Q6_Vw_vmpyiacc_VwVwRb(HVX_Vector Vx,
                                                           HVX_Vector Vu, Word32 Rt)
                   Vx.w+=vmpyi(Vu.w,Rt.ub)                 HVX_Vector Q6_Vw_vmpyiacc_VwVwRub(HVX_Vector Vx,
                                                           HVX_Vector Vu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8  7 6  5 4 3  2  1 0
   ICLASS                               t5       Parse         u5                  x5
 0  0  0  1 1  0   0 1  0  1  0   t  t   t  t  t P   P 1  u  u  u u u 0  1 0  x x   x x x Vx.w+=vmpyi(Vu.w,Rt.b)
   ICLASS                               t5       Parse         u5                  d5
 0  0  0  1 1  0   0 1  0  1  1   t  t   t  t  t P   P 0  u  u  u u u 0  0 0  d d  d  d d Vd.h=vmpyi(Vu.h,Rt.b)
   ICLASS                               t5       Parse         u5                  x5
 0  0  0  1 1  0   0 1  0  1  1   t  t   t  t  t P   P 1  u  u  u u u 0  0 1  x x   x x x Vx.h+=vmpyi(Vu.h,Rt.b)
   ICLASS                               t5       Parse         u5                  d5
 0  0  0  1 1  0   0 1  1  0  0   t  t   t  t  t P   P 0  u  u  u u u 1  1 0  d d  d  d d Vd.w=vmpyi(Vu.w,Rt.ub)
   ICLASS                               t5       Parse         u5                  x5
 0  0  0  1 1  0   0 1  1  0  0   t  t   t  t  t P   P 1  u  u  u u u 0  0 1  x x   x x x Vx.w+=vmpyi(Vu.w,Rt.ub)
   ICLASS                               t5       Parse         u5                  d5
 0  0  0  1 1  0   0 1  1  0  1   t  t   t  t  t P   P 0  u  u  u u u 0  0 0  d d  d  d d Vd.w=vmpyi(Vu.w,Rt.b)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         166
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
          Multiply half of the elements with scalar (16 x 16)
                  Unsigned 16 x 16 multiply of the lower halfword of each word in the vector with the lower
                  halfword of the 32-bit scalar.
                   Syntax                                  Behavior
                   Vd.uw=vmpye(Vu.uh,Rt.uh)                 for (i = 0; i < VELEM(32); i++) {
                                                                 Vd.uw[i] = (Vu.uw[i].uh[0] * Rt.uh[0]) ;
                                                            }
                   Vx.uw+=vmpye(Vu.uh,Rt.uh)                for (i = 0; i < VELEM(32); i++) {
                                                                 Vx.uw[i] += (Vu.uw[i].uh[0] * Rt.uh[0]) ;
                                                            }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■   This instruction uses a HVX multiply resource.
                       ■   This may not work correctly in Napali V1.
                  Intrinsics
                   Vd.uw=vmpye(Vu.uh,Rt.uh)                HVX_Vector Q6_Vuw_vmpye_VuhRuh(HVX_Vector Vu,
                                                           Word32 Rt)
                   Vx.uw+=vmpye(Vu.uh,Rt.uh)               HVX_Vector Q6_Vuw_vmpyeacc_VuwVuhRuh(HVX_Vector
                                                           Vx, HVX_Vector Vu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS                               t5       Parse          u5                  d5
 0  0  0  1 1  0   0 1  0  1  1   t  t   t  t  t P   P 0  u   u u  u  u 0 1  0 d  d d  d d Vd.uw=vmpye(Vu.uh,Rt.uh)
   ICLASS                               t5       Parse          u5                  x5
                                                                                            Vx.uw+=vmpye(Vu.uh,Rt.u
 0  0  0  1 1  0   0 1  1  0  0   t  t   t  t  t P   P 1  u   u u  u  u 0 1  1  x x  x x x h)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        167
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                         Instruction Set
             Multiply bytes with 4-wide reduction - vector by scalar
                          Perform multiplication between the elements in vector Vu and the corresponding elements
                          in the scalar register Rt, followed by a 4-way reduction to a word in each 32-bit lane.
                          Supports the multiplication of unsigned byte data by signed or unsigned bytes in the
                          scalar.
                          The operation has two forms: the first performs simple dot product of four elements into a
                          single result. The second form takes a 1 bit immediate input and generates a vector register
                          pair. For #1 = 0 the even destination contains a simple dot product, the odd destination
                          contains a dot product of the coefficients rotated by two elements and the upper two data
                          elements taken from the even register of Vuu. For #u = 1, the even destination takes
                          coefficients rotated by -1 and data element 0 from the odd register of Vuu. The odd
                          destination uses coefficients rotated by -1 and takes data element three from the even
                          register of Vuu.
                                         Vdd.w[+]=vrmpy(Vuu.ub,Rt.b, #0)                                                   Vdd.w[+]=vrmpy(Vuu.h,Rt.b, #1)
 Vd.w[+]=vrmpy(Vu.ub,Rt.b)
 b[3]   b[2]   b[1] b[0]      Vu         ub[3] ub[2] ub[1] ub[0] Vuu.V[1]          ub[3] ub[2] ub[1] ub[0] Vuu.V[0]        ub[3] ub[2] ub[1] ub[0] Vuu.V[1]           ub[3] ub[2] ub[1] ub[0] Vu
                      X          Rt.b[0]
                X                Rt.b[1]
         X                       Rt.b[2]
  X                              Rt.b[3]                     X        Rt.b[0]                          X                                       X         Rt.b[0]                          X
                                                        X             Rt.b[1]                     X                                       X              Rt.b[1]                     X
                           Optional
             +          Accumulation             X                    Rt.b[2]              X                                       X                     Rt.b[2]              X
                                           X                          Rt.b[3]        X                                       X                           Rt.b[3]        X
           w[0]
        32bit Lane                                                          Optional
                                                                                                                Optional
                                                                                                                                                               Optional
                                                    +                     Accumulation        +               Accumulation            +                      Accumulation        +             Ac
                                                   w[0]              Vdd.V[1]                w[0]            Vdd.V[0]                w[0]                Vdd.V[1]               w[0]          Vd
                                                                  32bit lane pair                                                                    32bit lane pair
                           Syntax                                                      Behavior
                            Vd.uw=vrmpy(Vu.ub,Rt.ub)                                    for (i = 0; i < VELEM(32); i++) {
                                                                                              Vd.uw[i] = (Vu.uw[i].ub[0] * Rt.ub[0]);
                                                                                              Vd.uw[i] += (Vu.uw[i].ub[1] * Rt.ub[1]);
                                                                                              Vd.uw[i] += (Vu.uw[i].ub[2] * Rt.ub[2]);
                                                                                              Vd.uw[i] += (Vu.uw[i].ub[3] * Rt.ub[3]) ;
                                                                                        }
80-N2040-44 Rev. B                    MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                    168
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                   Syntax                                 Behavior
                   Vd.w=vrmpy(Vu.ub,Rt.b)                  for (i = 0;    i < VELEM(32); i++) {
                                                                Vd.w[i]   = (Vu.uw[i].ub[0] * Rt.b[0]);
                                                                Vd.w[i]   += (Vu.uw[i].ub[1] * Rt.b[1]);
                                                                Vd.w[i]   += (Vu.uw[i].ub[2] * Rt.b[2]);
                                                                Vd.w[i]   += (Vu.uw[i].ub[3] * Rt.b[3]) ;
                                                           }
                   Vx.uw+=vrmpy(Vu.ub,Rt.ub)               for (i = 0; i <    VELEM(32); i++)  {
                                                                Vx.uw[i] +=   (Vu.uw[i].ub[0]  * Rt.ub[0]);
                                                                Vx.uw[i] +=   (Vu.uw[i].ub[1]  * Rt.ub[1]);
                                                                Vx.uw[i] +=   (Vu.uw[i].ub[2]  * Rt.ub[2]);
                                                                Vx.uw[i] +=   (Vu.uw[i].ub[3]  * Rt.ub[3]) ;
                                                           }
                   Vx.w+=vrmpy(Vu.ub,Rt.b)                 for (i = 0;    i < VELEM(32); i++) {
                                                                Vx.w[i]   += (Vu.uw[i].ub[0] * Rt.b[0]);
                                                                Vx.w[i]   += (Vu.uw[i].ub[1] * Rt.b[1]);
                                                                Vx.w[i]   += (Vu.uw[i].ub[2] * Rt.b[2]);
                                                                Vx.w[i]   += (Vu.uw[i].ub[3] * Rt.b[3]) ;
                                                           }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■   This instruction uses a HVX multiply resource.
                  Intrinsics
                   Vd.uw=vrmpy(Vu.ub,Rt.ub)                HVX_Vector Q6_Vuw_vrmpy_VubRub(HVX_Vector Vu,
                                                           Word32 Rt)
                   Vd.w=vrmpy(Vu.ub,Rt.b)                  HVX_Vector Q6_Vw_vrmpy_VubRb(HVX_Vector Vu,
                                                           Word32 Rt)
                   Vx.uw+=vrmpy(Vu.ub,Rt.ub)               HVX_Vector Q6_Vuw_vrmpyacc_VuwVubRub(HVX_Vector
                                                           Vx, HVX_Vector Vu, Word32 Rt)
                   Vx.w+=vrmpy(Vu.ub,Rt.b)                 HVX_Vector Q6_Vw_vrmpyacc_VwVubRb(HVX_Vector Vx,
                                                           HVX_Vector Vu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7   6 5  4 3 2  1 0
   ICLASS                              t5       Parse          u5                    d5
 0  0  0  1 1  0   0 1  0  0  0   t  t  t  t  t P   P 0  u   u  u u  u 0   1  1 d  d d  d d Vd.uw=vrmpy(Vu.ub,Rt.ub)
 0  0  0  1 1  0   0 1  0  0  0   t  t  t  t  t P   P 0  u   u  u u  u 1   0  0 d  d d  d d Vd.w=vrmpy(Vu.ub,Rt.b)
   ICLASS                              t5       Parse          u5                    x5
 0  0  0  1 1  0   0 1  0  0  0   t  t  t  t  t P   P 1  u   u  u u  u 1   0  0  x x  x x x Vx.uw+=vrmpy(Vu.ub,Rt.ub
                                                                                             )
 0  0  0  1 1  0   0 1  0  0  0   t  t  t  t  t P   P 1  u   u  u u  u 1   0  1  x x  x x x Vx.w+=vrmpy(Vu.ub,Rt.b)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         169
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Parse           Packet/Loop parse bits
                  d5              Field to encode register d
                  t5              Field to encode register t
                  u5              Field to encode register u
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             170
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
        Multiply by byte with 4-wide reduction - vector by vector
                  vrmpy performs a dot product function between 4-byte elements in vector register Vu, and
                  4-byte elements in Vv. The sum of the products is written into Vd as words within each
                  32-bit lane.
                  Data types can be unsigned by unsigned, signed by signed or unsigned by signed.
                      Vd.w[+]=vrmpy(Vu.b,Vv.b)
                      b[3]     b[2]    b[1]      b[0]           Vu
                               b[3]    b[2]      b[1]   b[0]      Vv
                            X        X        X       X
                                         +               Optional Accumulation
                                       w[0]                     Vd
                                    32bit Lane
                   Syntax                               Behavior
                   Vd.uw=vrmpy(Vu.ub,Vv.ub)              for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uw[i] = (Vu.uw[i].ub[0] *
                                                         Vv.uw[i].ub[0]);
                                                              Vd.uw[i] += (Vu.uw[i].ub[1] *
                                                         Vv.uw[i].ub[1]);
                                                              Vd.uw[i] += (Vu.uw[i].ub[2] *
                                                         Vv.uw[i].ub[2]);
                                                              Vd.uw[i] += (Vu.uw[i].ub[3] *
                                                         Vv.uw[i].ub[3]) ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  171
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                   Syntax                                  Behavior
                   Vd.w=vrmpy(Vu.b,Vv.b)                    for (i = 0;    i < VELEM(32); i++) {
                                                                 Vd.w[i]   = (Vu.w[i].b[0] * Vv.w[i].b[0]);
                                                                 Vd.w[i]   += (Vu.w[i].b[1] * Vv.w[i].b[1]);
                                                                 Vd.w[i]   += (Vu.w[i].b[2] * Vv.w[i].b[2]);
                                                                 Vd.w[i]   += (Vu.w[i].b[3] * Vv.w[i].b[3]) ;
                                                            }
                   Vd.w=vrmpy(Vu.ub,Vv.b)                   for (i = 0;    i < VELEM(32); i++) {
                                                                 Vd.w[i]   = (Vu.uw[i].ub[0] * Vv.w[i].b[0]);
                                                                 Vd.w[i]   += (Vu.uw[i].ub[1] * Vv.w[i].b[1]);
                                                                 Vd.w[i]   += (Vu.uw[i].ub[2] * Vv.w[i].b[2]);
                                                                 Vd.w[i]   += (Vu.uw[i].ub[3] * Vv.w[i].b[3]) ;
                                                            }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■   This instruction uses a HVX multiply resource.
                  Intrinsics
                   Vd.uw=vrmpy(Vu.ub,Vv.ub)                HVX_Vector Q6_Vuw_vrmpy_VubVub(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.w=vrmpy(Vu.b,Vv.b)                   HVX_Vector Q6_Vw_vrmpy_VbVb(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.w=vrmpy(Vu.ub,Vv.b)                  HVX_Vector Q6_Vw_vrmpy_VubVb(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8  7   6 5  4 3 2  1 0
   ICLASS                                        Parse          u5                    d5
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v  P   P 0  u   u u  u  u 0   0  0 d  d d  d d Vd.uw=vrmpy(Vu.ub,Vv.ub)
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v  P   P 0  u   u u  u  u 0   0  1 d  d d  d d Vd.w=vrmpy(Vu.b,Vv.b)
 0  0  0  1 1  1   0 0  0  0  0   v  v  v  v  v  P   P 0  u   u u  u  u 0   1  0 d  d d  d d Vd.w=vrmpy(Vu.ub,Vv.b)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           172
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
        Splat from scalar
                  Set all destination vector register words to the value specified by the contents of scalar
                  register Rt.
                       Vd=vsplat(Rt)                                           w           Rt
                        w[N*-1]                ...           w[1]            w[0]          Vd
                     *N number of operations in vector
                   Syntax                               Behavior
                   Vd.b=vsplat(Rt)                       for (i = 0; i < VELEM(8); i++) {
                                                              Vd.ub[i] = Rt ;
                                                         }
                   Vd.h=vsplat(Rt)                       for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i] = Rt ;
                                                         }
                   Vd=vsplat(Rt)                         for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uw[i] = Rt ;
                                                         }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■   This instruction uses a HVX multiply resource.
                  Intrinsics
                   Vd.b=vsplat(Rt)                       HVX_Vector Q6_Vb_vsplat_R(Word32 Rt)
                   Vd.h=vsplat(Rt)                       HVX_Vector Q6_Vh_vsplat_R(Word32 Rt)
                   Vd=vsplat(Rt)                         HVX_Vector Q6_V_vsplat_R(Word32 Rt)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      173
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                               t5       Parse                            d5
 0  0  0  1 1  0   0 1  1  0  1   t  t   t  t  t P   P 0  -   - - - 0 0 0 1  d  d d  d  d Vd=vsplat(Rt)
 0  0  0  1 1  0   0 1  1  1  0   t  t   t  t  t P   P 0  -   - - - - 0 0 1  d  d d  d  d Vd.h=vsplat(Rt)
 0  0  0  1 1  0   0 1  1  1  0   t  t   t  t  t P   P 0  -   - - - - 0 1 0  d  d d  d  d Vd.b=vsplat(Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t5                Field to encode register t
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       174
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
          Vector to predicate transfer
                  Copy bits into the destination vector predicate register, under the control of the scalar
                  register Rt and the input vector register Vu. Instead of a direct write, the destination can
                  also be OR’d with the result. If the corresponding byte i of Vu matches any of the bits in
                  Rt byte[i%4] the destination Qd is or'd with or set to 1 or 0.
                  If Rt contains 0x01010101 then Qt can effectively be filled with the lsb's of Vu, 1 bit per
                  byte.
                   Syntax                           Behavior
                   Qd4=vand(Vu,Rt)                   for (i = 0; i < VELEM(8); i++) {
                                                         QdV[i]=((Vu.ub[i] & Rt.ub[i % 4]) != 0) ? 1 : 0 ;
                                                     }
                   Qx4|=vand(Vu,Rt)                  for (i = 0; i < VELEM(8); i++) {
                                                         QxV[i]=QxV[i]|(((Vu.ub[i] & Rt.ub[i % 4]) != 0) ? 1
                                                     : 0) ;
                                                     }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                        ■  This instruction uses a HVX multiply resource.
                  Intrinsics
                   Qd4=vand(Vu,Rt)                         HVX_VectorPred Q6_Q_vand_VR(HVX_Vector Vu,
                                                           Word32 Rt)
                   Qx4|=vand(Vu,Rt)                        HVX_VectorPred Q6_Q_vandor_QVR(HVX_VectorPred
                                                           Qx, HVX_Vector Vu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4  3  2 1    0
   ICLASS                               t5       Parse         u5                       x2
 0  0  0  1 1  0   0 1   0 1  1   t  t   t  t  t P   P 1  u  u  u u u 1  0 0   - -  - x    x Qx4|=vand(Vu,Rt)
   ICLASS                               t5       Parse         u5                       d2
 0  0  0  1 1  0   0 1   1 0  1   t  t   t  t  t P   P 0  u  u  u u u 0  1 0   - 1 0  d    d Qd4=vand(Vu,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  t5                Field to encode register t
                  u5                Field to encode register u
                  x2                Field to encode register x
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        175
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
          Predicate to vector transfer
                  Copy the byte elements of scalar register Rt into the destination vector register Vd, under
                  the control of the vector predicate register. Instead of a direct write, the destination can
                  also be OR’d with the result. If the corresponding bit i of Qu is set, the contents of byte[i
                  % 4] are written or OR'd into Vd or Vx.
                  If Rt contains 0x01010101 then Qt can effectively be expanded into Vd or Vx, 1 bit per
                  byte.
                   Syntax                                   Behavior
                   Vd=vand([!]Qu4,Rt)                       for (i = 0; i < VELEM(8); i++) {
                                                                 Vd.ub[i] = [!]QuV[i] ? Rt.ub[i % 4] : 0 ;
                                                            }
                   Vx|=vand([!]Qu4,Rt)                      for (i = 0; i < VELEM(8); i++) {
                                                                 Vx.ub[i] |= [!](QuV[i]) ? Rt.ub[i % 4] : 0 ;
                                                            }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                        ■  This instruction uses a HVX multiply resource.
                  Intrinsics
                   Vd=vand(!Qu4,Rt)                         HVX_Vector Q6_V_vand_QnR(HVX_VectorPred Qu,
                                                            Word32 Rt)
                   Vd=vand(Qu4,Rt)                          HVX_Vector Q6_V_vand_QR(HVX_VectorPred Qu,
                                                            Word32 Rt)
                   Vx|=vand(!Qu4,Rt)                        HVX_Vector Q6_V_vandor_VQnR(HVX_Vector Vx,
                                                            HVX_VectorPred Qu, Word32 Rt)
                   Vx|=vand(Qu4,Rt)                         HVX_Vector Q6_V_vandor_VQR(HVX_Vector Vx,
                                                            HVX_VectorPred Qu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1  0
   ICLASS                              t5        Parse              u2              x5
 0  0  0  1 1  0   0 1   0 1  1   t  t  t  t  t  P   P 1  -   - 0  u  u 0 1  1  x x  x x  x Vx|=vand(Qu4,Rt)
 0  0  0  1 1  0   0 1   0 1  1   t  t  t  t  t  P   P 1  -   - 1  u  u 0 1  1  x x  x x  x Vx|=vand(!Qu4,Rt)
   ICLASS                              t5        Parse              u2              d5
 0  0  0  1 1  0   0 1   1 0  1   t  t  t  t  t  P   P 0  -   - 0  u  u 1 0  1 d  d d  d  d Vd=vand(Qu4,Rt)
 0  0  0  1 1  0   0 1   1 0  1   t  t  t  t  t  P   P 0  -   - 1  u  u 1 0  1 d  d d  d  d Vd=vand(!Qu4,Rt)
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       176
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Parse           Packet/Loop parse bits
                  d5              Field to encode register d
                  t5              Field to encode register t
                  u2              Field to encode register u
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             177
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
        Absolute value of difference
                  Return the absolute value of the difference between corresponding elements in vector
                  registers Vu and Vv, and place the result in Vd. Supports unsigned byte, signed and
                  unsigned halfword, and signed word.
                     Vd.uh=vabsdiff(Vu.h,Vv.h)
                          [N-1]                               [1]             [0]        Vu
                          [N-1]                               [1]             [0]        Vv
                            -                                  -               -
                           Abs                               Abs             Abs
                          [N-1]                               [1]             [0]        Vd
                  N is the number of elements implemented in a vector register.
                   Syntax                               Behavior
                   Vd.ub=vabsdiff(Vu.ub,Vv.ub)           for (i = 0; i < VELEM(8); i++) {
                                                              Vd.ub[i] = (Vu.ub[i] > Vv.ub[i]) ? (Vu.ub[i]
                                                         - Vv.ub[i]) : (Vv.ub[i] - Vu.ub[i]) ;
                                                         }
                   Vd.uh=vabsdiff(Vu.h,Vv.h)             for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i] = (Vu.h[i] > Vv.h[i]) ? (Vu.h[i] -
                                                         Vv.h[i]) : (Vv.h[i] - Vu.h[i]) ;
                                                         }
                   Vd.uh=vabsdiff(Vu.uh,Vv.uh)           for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i] = (Vu.uh[i] > Vv.uh[i]) ? (Vu.uh[i]
                                                         - Vv.uh[i]) : (Vv.uh[i] - Vu.uh[i]) ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   178
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                   Syntax                                  Behavior
                   Vd.uw=vabsdiff(Vu.w,Vv.w)                for (i = 0; i < VELEM(32); i++) {
                                                                 Vd.uw[i] = (Vu.w[i] > Vv.w[i]) ? (Vu.w[i] -
                                                            Vv.w[i]) : (Vv.w[i] - Vu.w[i]) ;
                                                            }
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■   This instruction uses a HVX multiply resource.
                  Intrinsics
                   Vd.ub=vabsdiff(Vu.ub,Vv.ub)             HVX_Vector Q6_Vub_vabsdiff_VubVub(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.uh=vabsdiff(Vu.h,Vv.h)               HVX_Vector Q6_Vuh_vabsdiff_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.uh=vabsdiff(Vu.uh,Vv.uh)             HVX_Vector Q6_Vuh_vabsdiff_VuhVuh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.uw=vabsdiff(Vu.w,Vv.w)               HVX_Vector Q6_Vuw_vabsdiff_VwVw(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS                                        Parse          u5                  d5
                                                                                            Vd.ub=vabsdiff(Vu.ub,Vv.ub
 0  0  0  1 1  1   0 0  1  1  0   v  v  v  v  v  P   P 0  u   u u  u  u 0 0  0 d  d d  d d )
 0  0  0  1 1  1   0 0  1  1  0   v  v  v  v  v  P   P 0  u   u u  u  u 0 0  1 d  d d  d d Vd.uh=vabsdiff(Vu.h,Vv.h)
                                                                                            Vd.uh=vabsdiff(Vu.uh,Vv.uh
 0  0  0  1 1  1   0 0  1  1  0   v  v  v  v  v  P   P 0  u   u u  u  u 0 1  0 d  d d  d d )
 0  0  0  1 1  1   0 0  1  1  0   v  v  v  v  v  P   P 0  u   u u  u  u 0 1  1 d  d d  d d Vd.uw=vabsdiff(Vu.w,Vv.w)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          179
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
          Insert element
                  Insert a 32-bit element in Rt into the destination vector register Vx, at the word element 0.
                   Syntax                                   Behavior
                   Vx.w=vinsert(Rt)                         Vx.uw[0] = Rt;
                  Class: COPROC_VX (slots 2,3)
                  Notes
                       ■   This instruction uses a HVX multiply resource.
                  Intrinsics
                   Vx.w=vinsert(Rt)                         HVX_Vector Q6_Vw_vinsert_VwR(HVX_Vector Vx,
                                                            Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1  0
   ICLASS                               t5       Parse                             x5
 0  0  0   1 1 0   0 1  1  0  1   t  t   t  t  t P   P 1  -   - -  - - 0  0 1  x x  x x  x Vx.w=vinsert(Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  t5                Field to encode register t
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        180
Hexagon V66 HVX Programmer’s Reference Manual                                                         Instruction Set
      5.10        HVX/PERMUTE-RESOURCE
                  The HVX/PERMUTE-RESOURCE instruction subclass includes instructions that use the
                  HVX permute resource.
          Byte alignment
                  Select a continuous group of bytes the size of a vector register from vector registers Vu
                  and Vv. The starting location is provided by the lower bits of Rt (modulo the vector
                  length) or by a 3-bit immediate value.
                  There are two forms of the operation, The first, valign, uses the Rt or immediate input
                  directly to specify the beginning of the block. The second, vlalign, uses the inverse of the
                  input value by subtracting it from the vector length.
                  The operation can be used to implement a non-aligned vector load, using two aligned
                  loads (above and below the pointer) and a valign where the pointer is used as the control
                  input.
      Vd=valign(Vu,Vv, Rt/u3)
   b[N-1]    ...    b[3]    b[2]    b[1]     b[0]    Vu                   b[N-1]    ...   b[3]     b[2]       b[1]     b[0]       Vv
                                                                                                         Starting Byte = Rt (E.g. 2)
                                            b[N-1]  b[N-2] b[N-3]    ...   b[1]    b[0]   Vd
      Vd=vlalign(Vu,Vv, Rt/u3)
   b[N-1]  b[N-2]  b[N-3]     ...   b[1]     b[0]    Vu                   b[N-1]  b[N-2] b[N-3]      ...      b[1]     b[0]       Vv
                                                                                            Starting Byte = N-Rt (E.g. 2)
                                            b[N-1]    ...    b[3]   b[2]   b[1]    b[0]    Vd
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          181
Hexagon V66 HVX Programmer’s Reference Manual                                                                                  Instruction Set
                  Perform a right rotate vector operation on vector register Vu, by the number of bytes
                  specified by the lower bits of Rt. The result is written into Vd. Byte[i] moves to
                  Byte[(i+N-R)%N], where R is the right rotate amount in bytes, and N is the vector register
                  size in bytes.
                                                                                                   Rt indicates rotation
                            Vd = vror(Vu, Rt)                                                    amount in bytes (e.g. 4)
                     b[N-1]  b[N-2]   b[N-3]                ...                 b[5] b[4]     b[3]      b[2]     b[1]     b[0]    Vu
                     b[N-1]  b[N-2]   b[N-3]  b[N-4] b[N-5]     b[N-4]  b[N-3]            ...                    b[1]     b[0]    Vd
                   Syntax                                              Behavior
                   Vd=valign(Vu,Vv,#u3)                                for(i = 0; i < VWIDTH; i++) {
                                                                             Vd.ub[i] = (i+#u>=VWIDTH) ? Vu.ub[i+#u-
                                                                       VWIDTH] : Vv.ub[i+#u];
                                                                       }
                   Vd=valign(Vu,Vv,Rt)                                 unsigned shift = Rt & (VWIDTH-1);
                                                                       for(i = 0; i < VWIDTH; i++) {
                                                                             Vd.ub[i] = (i+shift>=VWIDTH) ?
                                                                       Vu.ub[i+shift-VWIDTH] : Vv.ub[i+shift];
                                                                       }
                   Vd=vlalign(Vu,Vv,#u3)                               unsigned shift = VWIDTH - #u;
                                                                       for(i = 0; i < VWIDTH; i++) {
                                                                             Vd.ub[i] = (i+shift>=VWIDTH) ?
                                                                       Vu.ub[i+shift-VWIDTH] : Vv.ub[i+shift];
                                                                       }
                   Vd=vlalign(Vu,Vv,Rt)                                unsigned shift = VWIDTH - (Rt & (VWIDTH-1));
                                                                       for(i = 0; i < VWIDTH; i++) {
                                                                             Vd.ub[i] = (i+shift>=VWIDTH) ?
                                                                       Vu.ub[i+shift-VWIDTH] : Vv.ub[i+shift];
                                                                       }
                   Vd=vror(Vu,Rt)                                      for (k=0;k<VWIDTH;k++) {
                                                                             Vd.ub[k] = Vu.ub[(k+Rt)&(VWIDTH-1)];
                                                                       }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                        ■    This instruction uses the HVX permute resource.
                        ■    Input scalar register Rt is limited to registers 0 through 7
80-N2040-44 Rev. B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                 182
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
                  Intrinsics
                   Vd=valign(Vu,Vv,#u3)                    HVX_Vector Q6_V_valign_VVI(HVX_Vector Vu,
                                                           HVX_Vector Vv, Word32 Iu3)
                   Vd=valign(Vu,Vv,Rt)                     HVX_Vector Q6_V_valign_VVR(HVX_Vector Vu,
                                                           HVX_Vector Vv, Word32 Rt)
                   Vd=vlalign(Vu,Vv,#u3)                   HVX_Vector Q6_V_vlalign_VVI(HVX_Vector Vu,
                                                           HVX_Vector Vv, Word32 Iu3)
                   Vd=vlalign(Vu,Vv,Rt)                    HVX_Vector Q6_V_vlalign_VVR(HVX_Vector Vu,
                                                           HVX_Vector Vv, Word32 Rt)
                   Vd=vror(Vu,Rt)                          HVX_Vector Q6_V_vror_VR(HVX_Vector Vu, Word32
                                                           Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2  1 0
   ICLASS                               t5       Parse         u5                 d5
 0  0  0  1 1  0   0 1  0  1  1   t  t   t  t  t P   P 0  u  u  u u u 0  0 1  d d  d  d d Vd=vror(Vu,Rt)
   ICLASS                                  t3    Parse         u5                 d5
 0  0  0  1 1  0   1 1   v  v  v  v  v   t  t  t P   P 0  u  u  u u u 0  0 0  d d  d  d d Vd=valign(Vu,Vv,Rt)
 0  0  0  1 1  0   1 1   v  v  v  v  v   t  t  t P   P 0  u  u  u u u 0  0 1  d d  d  d d Vd=vlalign(Vu,Vv,Rt)
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   1 0  0  0  1   v  v   v v  v  P   P 1  u  u  u u u  i i  i d d  d  d d Vd=valign(Vu,Vv,#u3)
 0  0  0  1 1  1   1 0  0  1  1   v  v   v v  v  P   P 1  u  u  u u u  i i  i d d  d  d d Vd=vlalign(Vu,Vv,#u3)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t3                Field to encode register t
                  t5                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  v3                Field to encode register v
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        183
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
        General permute network
                  Perform permutation and re-arrangement of the input bytes. The input data is passed
                  through a network of switch boxes, these are able to take two inputs and based on the two
                  controls can pass through, swap, replicate the first input, or replicate the second input.
                  Though the functionality is powerful the algorithms to compute the controls are complex.
                  The input vector of bytes is passed through multiple levels of switches which have
                  increasing power of two strides up to half of the vector length. The diagram below shows
                  the vrdelta network, the vdelta network is the mirror image, with the largest stride first
                  followed by smaller strides down to 1.
                             Vu[0]                                                      Vd[0]
                    Vv[0]                          b[0]            b[1]            b[2]
                              Vu[1]                 0                                   Vd[1]
                    Vv[1]                          b[0]            b[1]            b[2]
                              Vu[2]                                                     Vd[2]
                    Vv[2]                          b[0]            b[1]            b[2]
                              Vu[3]                                 1               1   Vd[3]
                    Vv[3]                          b[0]            b[1]            b[2]
                              Vu[4]                                                     Vd[4]
                    Vv[4]                          b[0]            b[1]            b[2]
                              Vu[5]                                                     Vd[5]
                    Vv[5]                          b[0]            b[1]            b[2]
                              Vu[6]                                                     Vd[6]
                    Vv[6]                          b[0]            b[1]            b[2]
                              Vu[7]                 1               0               1   Vd[7]
                    Vv[7]                          b[0]            b[1]            b[2]
                  Each stage output is controlled by the control inputs in the vector register Vv. For each
                  stage (for example stage 3), the bit at that position would look at the corresponding bit (bit
                  3) in the control byte. This is shown in the switch box in the diagram.
                  There are two main forms of data rearrangement. One uses a simple reverse butterfly
                  network shown as vrdelta, and a butterfly network vdelta shown below. These are known
                  as blocking networks, as not all possible paths can be allowed, simultaneously from input
                  to output. The data does not have to be a permutation, defined as a one-to-one mapping of
                  every input to its own output position. A subset of data rearrangement such as data
                  replication can be accommodated. It can handle a family of patterns that have symmetric
                  properties.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      184
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                  An example is shown in the diagram above of such a valid pattern using an 8-element
                  vrdelta network for clarity: 0,2,4,6,7,5,3,1.
                               Vu[0]                                                        Vd[0]
                    Vv[0]                          b[0]              b[1]              b[2]
                              Vu[1]                                   0                     Vd[1]
                    Vv[1]
                                                   b[0]              b[1]              b[2]
                              Vu[2]                                                         Vd[2]
                    Vv[2]                          b[0]              b[1]              b[2]
                              Vu[3]                 1                                   1   Vd[3]
                    Vv[3]                          b[0]              b[1]              b[2]
                              Vu[4]                                                         Vd[4]
                    Vv[4]                          b[0]             b[1]              b[2]
                              Vu[5]                                                         Vd[5]
                    Vv[5]                          b[0]              b[1]              b[2]
                              Vu[6]                                                         Vd[6]
                    Vv[6]                          b[0]              b[1]              b[2]
                              Vu[7]                 0                 1                 1   Vd[7]
                    Vv[7]                          b[0]              b[1]              b[2]
                  However the desired pattern 0,2,4,6,1,3,5,7 is not possible, as this overuses available paths
                  in the trellis. The position of the output for a particular input is determined by using the bit
                  sequence produced by the destination position D from source position S. The bit vector for
                  the path through the trellis is a function of this destination bit sequence.
                  In the example D = 7, S = 1, the element in position 1 is to be moved to position 7. The
                  first switch box control bit at position 1 is 0, the next control bit at position 3 is 1, and
                  finally the bit at position 7 is 1, yielding the sequence 0,1,1. Also, element 6 is moved to
                  position 3, with the control vector 1,0,1. Bits must be placed at the appropriate position in
                  the control bytes to guide the inputs to the desired positions. Every input can be placed
                  into any output, but certain combinations conflict for resources, and so the rearrangement
                  is not possible. A total of 512 control bits are required for a single vrdelta or vdelta slice.
                  The other general form of permute is a Benes Network, which requires a vrdelta
                  immediately followed by a vdelta operation. This form is non-blocking: any possible
                  permute, however random, can be accommodated, though it has to be a permutation, each
                  input must have a position in the output. Replication can be performed by using a pre- or
                  post-conditioning vrdelta pass to perform the replications before or after the permute.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        185
Hexagon V66 HVX Programmer’s Reference Manual                                                    Instruction Set
                  Element sizes larger than a byte can be implemented by grouping bytes together and
                  moving them to a group in the output.
                 Vd = vrdelta(Vu,Vv)                                    Vd = vdelta(Vu,Vv)
                                                     Vd   Vu                                           Vd
Vu
                                                                                                                          Example Switch box
                                                                                                             Vu.ub[i]                0
                                                                                                                                     1
                                                                                                                                     1
                                                                                                            Vu.ub[i+2k]              0
                                                                                                                                             O
                             Vv                                                        Vv
                                                                                                              Vv.ub[i]&(1<<k)            Vv.ub
                   Syntax                                  Behavior
                   Vd=vdelta(Vu,Vv)                        for (offset=VWIDTH; (offset>>=1)>0; ) {
                                                                for (k = 0; k<VWIDTH; k++) {
                                                                    Vd.ub[k] = (Vv.ub[k]&offset) ?
                                                           Vu.ub[k^offset] : Vu.ub[k];
                                                                }
                                                                for (k = 0; k<VWIDTH; k++) {
                                                                    Vu.ub[k] = Vd.ub[k];
                                                                }
                                                           }
80-N2040-44 Rev. B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   186
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                   Syntax                                  Behavior
                   Vd=vrdelta(Vu,Vv)                        for (offset=1; offset<VWIDTH; offset<<=1){
                                                                 for (k = 0; k<VWIDTH; k++) {
                                                                     Vd.ub[k] = (Vv.ub[k]&offset) ?
                                                            Vu.ub[k^offset] : Vu.ub[k];
                                                                 }
                                                                 for (k = 0; k<VWIDTH; k++) {
                                                                     Vu.ub[k] = Vd.ub[k];
                                                                 }
                                                            }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses the HVX permute resource.
                  Intrinsics
                   Vd=vdelta(Vu,Vv)                        HVX_Vector Q6_V_vdelta_VV(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd=vrdelta(Vu,Vv)                       HVX_Vector Q6_V_vrdelta_VV(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1  0
   ICLASS                                        Parse          u5                  d5
 0  0  0  1 1  1   1 1  0  0  1   v  v  v  v  v  P   P 0  u   u u  u  u 0 0  1 d  d d  d  d Vd=vdelta(Vu,Vv)
 0  0  0  1 1  1   1 1  0  0  1   v  v  v  v  v  P   P 0  u   u u  u  u 0 1  1 d  d d  d  d Vd=vrdelta(Vu,Vv)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         187
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                 Instruction Set
             Shuffle - deal
                            Deal or deinterleave the elements into the destination register Vd. Even elements of Vu are
                            placed in the lower half of Vd, and odd elements are placed in the upper half.
                            In the case of vdeale, the even elements of Vv are dealt into the lower half of the
                            destination vector register Vd, and the even elements of Vu are dealt into the upper half of
                            Vd. The deal operation takes even-even elements of Vv and places them in the lower
                            quarter of Vd, while odd-even elements of Vv are placed in the second quarter of Vd.
                            Similarly, even-even elements of Vu are placed in the third quarter of Vd, while odd-even
                            elements of Vu are placed in the fourth quarter of Vd.
                       Vd.h=vdeal(Vu.h)
   [N-1] [N-2]   ...     [4]    [3]    [2]   [1]     [0]  Vu
   [N-1]  ...  [N/2+2]  [N/2] [N/2-1]  [2]   [1]     [0]  Vd
                    Vd.b=vdeale(Vu.b, Vv.b)
    ...  [10]    [9]     [8]    [7]    [6]   [5]     [4]   [3]     [2]   [1]     [0]    Vu       ...   [10]     [9]    [8]      [7]  [6]     [5] [4]     [3] [2]   [1]  [0]   Vv
                                            [3N/    [3N/
                                       ...  4+2]    4+2]
                                                         [3N/4]    ... [N/2+2] [N/2+1] [N/2]     ... [N/4+2]  [N/4+1] [N/4]      ... [2]     [1] [0]     Vd
                            Shuffle elements within a vector. Elements from the same position - but in the upper half
                            of the vector register - are packed together in even and odd element pairs, and then placed
                            in the destination vector register Vd.
                            Supports byte and halfword. Operates on a single register input, in a way similar to
                            vshuffoe.
                              Vd.b=vshuff(Vu.b)
                                  [N-1]          ...      [N/2+2]        [N/2+1]          [N/2]         [N/2-1]             [2]          [1]         [0]         Vu
                                  [N-1]        [N-2]           ...           [5]             [4]            [3]             [2]          [1]         [0]         Vd
                                *N is the number of element operations allowed in the vector
80-N2040-44 Rev. B                    MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                      188
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                   Syntax                                 Behavior
                   Vd.b=vdeal(Vu.b)                        for (i = 0; i < VELEM(16); i++) {
                                                                Vd.ub[i ] = Vu.uh[i].ub[0];
                                                                Vd.ub[i+VBITS/16] = Vu.uh[i].ub[1] ;
                                                           }
                   Vd.b=vdeale(Vu.b,Vv.b)                  for (i = 0; i < VELEM(32); i++) {
                                                                Vd.ub[0+i ] = Vv.uw[i].ub[0];
                                                                Vd.ub[VBITS/32+i ] = Vv.uw[i].ub[2];
                                                                Vd.ub[2*VBITS/32+i] = Vu.uw[i].ub[0];
                                                                Vd.ub[3*VBITS/32+i] = Vu.uw[i].ub[2] ;
                                                           }
                   Vd.b=vshuff(Vu.b)                       for (i = 0; i < VELEM(16); i++) {
                                                                Vd.uh[i].b[0]=Vu.ub[i];
                                                                Vd.uh[i].b[1]=Vu.ub[i+VBITS/16] ;
                                                           }
                   Vd.h=vdeal(Vu.h)                        for (i = 0; i < VELEM(32); i++) {
                                                                Vd.uh[i ] = Vu.uw[i].uh[0];
                                                                Vd.uh[i+VBITS/32] = Vu.uw[i].uh[1] ;
                                                           }
                   Vd.h=vshuff(Vu.h)                       for (i = 0; i < VELEM(32); i++) {
                                                                Vd.uw[i].h[0]=Vu.uh[i];
                                                                Vd.uw[i].h[1]=Vu.uh[i+VBITS/32] ;
                                                           }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses the HVX permute resource.
                  Intrinsics
                   Vd.b=vdeal(Vu.b)                        HVX_Vector Q6_Vb_vdeal_Vb(HVX_Vector Vu)
                   Vd.b=vdeale(Vu.b,Vv.b)                  HVX_Vector Q6_Vb_vdeale_VbVb(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.b=vshuff(Vu.b)                       HVX_Vector Q6_Vb_vshuff_Vb(HVX_Vector Vu)
                   Vd.h=vdeal(Vu.h)                        HVX_Vector Q6_Vh_vdeal_Vh(HVX_Vector Vu)
                   Vd.h=vshuff(Vu.h)                       HVX_Vector Q6_Vh_vshuff_Vh(HVX_Vector Vu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS                                       Parse          u5                  d5
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 0  u   u  u u  u 1 1  0 d  d d  d d Vd.h=vdeal(Vu.h)
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 0  u   u  u u  u 1 1  1 d  d d  d d Vd.b=vdeal(Vu.b)
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  1  P   P 0  u   u  u u  u 1 1  1 d  d d  d d Vd.h=vshuff(Vu.h)
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 1  0  P   P 0  u   u  u u  u 0 0  0 d  d d  d d Vd.b=vshuff(Vu.b)
 0  0  0  1 1  1   1 1  0  0  1   v  v  v  v  v P   P 0  u   u  u u  u 1 1  1 d  d d  d d Vd.b=vdeale(Vu.b,Vv.b)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         189
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Parse           Packet/Loop parse bits
                  d5              Field to encode register d
                  u5              Field to encode register u
                  v5              Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             190
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                  Instruction Set
        Pack
                  The vpack operation has three forms. All of them pack elements from the vector registers
                  Vu and Vv into the destination vector register Vd.
                  vpacke writes even elements from Vv and Vu into the lower half and upper half of Vd
                  respectively.
                  vpacko writes odd elements from Vv and Vu into the lower half and upper half of Vd
                  respectively.
                  vpack takes all elements from Vv and Vu, saturates them to the next smallest element size,
                  and writes them into Vd.
                   Vd.b=vpacke(Vu.h,Vv.h)
                    [N-1]   [N-2]         ....           [3]       [2]   [1]        [0]   Vv
                    [N-1]   [N-2]          ...         [3]       [2]   [1]       [0]    Vu
                    [N-1]     ...  [N/2+1]     [N/2] [N/2-1]     ...  [1]        [0]    Vd
                   Vd.b=vpacko(Vu.h,Vv.h)
                    [N-1]    [N-2]        ....           [3]       [2]   [1]        [0]   Vv
                    [N-1]   [N-2]          ...         [3]        [2]  [1]        [0]   Vu
                    [N-1]     ...  [N/2+1]     [N/2] [N/2-1]      ... [1]        [0]    Vd
                   Vd.b=vpack(Vu.h,Vv.h):sat
                       [N/2-1]             ...              [1]             [0]         Vu         [N/2-1]        ....        [1]     [0]     Vv
                              sat                                sat             sat                     sat                    sat     sat
                                                                [N-1]   ...    [N/2+1] [N/2]   [N/2-1]    ... [1]    [0] Vd
                   Syntax                                                                  Behavior
                   Vd.b=vpack(Vu.h,Vv.h):sat                                                 for (i = 0; i < VELEM(16); i++) {
                                                                                                       Vd.b[i] = sat8(Vv.h[i]);
                                                                                                       Vd.b[i+VBITS/16] = sat8(Vu.h[i]) ;
                                                                                             }
                   Vd.b=vpacke(Vu.h,Vv.h)                                                    for (i = 0; i < VELEM(16); i++) {
                                                                                                       Vd.ub[i] = Vv.uh[i].ub[0];
                                                                                                       Vd.ub[i+VBITS/16] = Vu.uh[i].ub[0] ;
                                                                                             }
80-N2040-44 Rev. B           MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                              191
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   Vd.b=vpacko(Vu.h,Vv.h)                for (i = 0; i < VELEM(16); i++) {
                                                              Vd.ub[i] = Vv.uh[i].ub[1];
                                                              Vd.ub[i+VBITS/16] = Vu.uh[i].ub[1] ;
                                                         }
                   Vd.h=vpack(Vu.w,Vv.w):sat             for (i = 0; i < VELEM(32); i++) {
                                                              Vd.h[i] = sat16(Vv.w[i]);
                                                              Vd.h[i+VBITS/32] = sat16(Vu.w[i]) ;
                                                         }
                   Vd.h=vpacke(Vu.w,Vv.w)                for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uh[i] = Vv.uw[i].uh[0];
                                                              Vd.uh[i+VBITS/32] = Vu.uw[i].uh[0] ;
                                                         }
                   Vd.h=vpacko(Vu.w,Vv.w)                for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uh[i] = Vv.uw[i].uh[1];
                                                              Vd.uh[i+VBITS/32] = Vu.uw[i].uh[1] ;
                                                         }
                   Vd.ub=vpack(Vu.h,Vv.h):sat            for (i = 0; i < VELEM(16); i++) {
                                                              Vd.ub[i] = usat8(Vv.h[i]);
                                                              Vd.ub[i+VBITS/16] = usat8(Vu.h[i]) ;
                                                         }
                   Vd.uh=vpack(Vu.w,Vv.w):sat            for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uh[i] = usat16(Vv.w[i]);
                                                              Vd.uh[i+VBITS/32] = usat16(Vu.w[i]) ;
                                                         }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction uses the HVX permute resource.
                  Intrinsics
                   Vd.b=vpack(Vu.h,Vv.h):sat             HVX_Vector Q6_Vb_vpack_VhVh_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.b=vpacke(Vu.h,Vv.h)                HVX_Vector Q6_Vb_vpacke_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.b=vpacko(Vu.h,Vv.h)                HVX_Vector Q6_Vb_vpacko_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vpack(Vu.w,Vv.w):sat             HVX_Vector Q6_Vh_vpack_VwVw_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vpacke(Vu.w,Vv.w)                HVX_Vector Q6_Vh_vpacke_VwVw(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vpacko(Vu.w,Vv.w)                HVX_Vector Q6_Vh_vpacko_VwVw(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.ub=vpack(Vu.h,Vv.h):sat            HVX_Vector Q6_Vub_vpack_VhVh_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.uh=vpack(Vu.w,Vv.w):sat            HVX_Vector Q6_Vuh_vpack_VwVw_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   192
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   1 1  1  1  0   v  v  v  v  v  P   P 0  u  u  u u u 0 1 0  d  d d  d  d Vd.b=vpacke(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  1  1  0   v  v  v  v  v  P   P 0  u  u  u u u 0 1 1  d  d d  d  d Vd.h=vpacke(Vu.w,Vv.w)
 0  0  0  1 1  1   1 1  1  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1 0 1  d  d d  d  d Vd.ub=vpack(Vu.h,Vv.h):sat
 0  0  0  1 1  1   1 1  1  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1 1 0  d  d d  d  d Vd.b=vpack(Vu.h,Vv.h):sat
 0  0  0  1 1  1   1 1  1  1  0   v  v  v  v  v  P   P 0  u  u  u u u 1 1 1  d  d d  d  d Vd.uh=vpack(Vu.w,Vv.w):sa
                                                                                          t
 0  0  0  1 1  1   1 1  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 0 0  d  d d  d  d Vd.h=vpack(Vu.w,Vv.w):sat
 0  0  0  1 1  1   1 1  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 0 1  d  d d  d  d Vd.b=vpacko(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 1 0  d  d d  d  d Vd.h=vpacko(Vu.w,Vv.w)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        193
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
          Set predicate
                  Set a vector predicate register with a sequence of 1's based on the lower bits of the scalar
                  register Rt.
                  Rt = 0x11 : Qd4 = 0-----0011111111111111111b
                  Rt = 0x07 : Qd4 = 0-----0000000000001111111b
                  The operation is element-size agnostic, and typically is used to create a mask to predicate
                  an operation if it does not span a whole vector register width.
                   Syntax                                   Behavior
                   Qd4=vsetq(Rt)                            for(i = 0; i < VWIDTH; i++) QdV[i]=(i < (Rt &
                                                            (VWIDTH-1))) ? 1 : 0;
                   Qd4=vsetq2(Rt)                           for(i = 0; i < VWIDTH; i++) QdV[i]=(i <= ((Rt-1)
                                                            & (VWIDTH-1))) ? 1 : 0;
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses the HVX permute resource.
                  Intrinsics
                   Qd4=vsetq(Rt)                            HVX_VectorPred Q6_Q_vsetq_R(Word32 Rt)
                   Qd4=vsetq2(Rt)                           HVX_VectorPred Q6_Q_vsetq2_R(Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2 1   0
   ICLASS                               t5       Parse                                  d2
 0  0  0  1 1  0   0 1  1  0   1  t  t   t  t  t P   P 0  -   - -  - - 0  1 0  - 0  1 d   d Qd4=vsetq(Rt)
 0  0  0  1 1  0   0 1  1  0   1  t  t   t  t  t P   P 0  -   - -  - - 0  1 0  - 1  1 d   d Qd4=vsetq2(Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d2                Field to encode register d
                  t5                Field to encode register t
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        194
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
        Vector in-lane lookup table
                   The vlut instructions are used to implement fast vectorized lookup-tables. The lookup
                  table is contained in the Vv register while the indexes are held in Vu. Table elements can
                  be either 8-bit or 16-bit. An aggregation feature is used to implement tables larger than 64
                  bytes in 64B mode and 128 bytes in 128B mode. This explanation discusses both the 64B
                  and 128B modes of operation. In both 64 and 128byte modes the maximum amount of
                  lookup table accessible is 32 bytes for byte lookups(vlut32) and 16 half words in hwords
                  lookup(vlut16).
                  8-bit elements
                  In the case of 64Byte mode, tables with 8-bit elements support 32 entry lookup tables
                  using the vlut32 instructions. The required entry is conditionally selected by using the
                  lower 5 bits of the input byte for the respective output byte. A control input register, Rt,
                  contains match and select bits. The lower 3 bits of Rt must match the upper 3 bits of the
                  input byte index in order for the table entry to be written to or Or'ed with the destination
                  vector register byte in Vd or Vx respectively. The LSB of Rt selects odd or even (32 entry)
                  lookup tables in Vv. If a 256B table is stored naturally in memory it would look as below
                  127,126,.....66, 65, 64, 63, 62,.........2, 1, 0
                  255,254,....194,193,192,191,190,.......130,129,128
                  To prepare it for use with the vlut instruction in 64B mode, it must be shuffled in blocks of
                  32 bytes:
                  63, 31, 62, 30,......36, 4, 35, 3, 34, 2, 33, 1, 32, 0 Rt=0, Rt=1 127, 95,126, 94,.....100, 68,
                  99, 67, 98, 66, 97, 65, 96, 64 Rt=2, Rt=3 same ordering for bytes 128-255 Rt=4, 5, 6, 7
                  For 128B mode, the data must be shuffled in blocks of 64 bytes.
                  127, 63,126, 62,........68, 4, 67, 3, 66, 2, 65, 1, 64, 0 Rt=0,1,2,3 same ordering for bytes
                  128-255 Rt=4,5,6,7
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        195
Hexagon V66 HVX Programmer’s Reference Manual                                                          Instruction Set
                 If data is stored in this way accessing this with 64 or 128B mode gives the same results. In
                 the case of 128B mode, bit 1 of Rt selects whether to use the odd or even packed table and
                 bit 0 chooses the high of low 32 elements of that high or low table.
 Vd.b = vlut32(Vu.b, Vv.b, Rt) and Vx.b |= vlut32(Vu.b, Vv.b, Rt)
Vu Input         Vd.b =vlut32(Vu.b, Vv.b, Rt)                                                                            Rt
                 b[63:8]     b[7] b[6] b[5]                  b[4]      b[3]   b[2]   b[1]      b[0]
 Vector
                                                                                      b[7:5]                             b[2:0]
                                 Replicated for all other input bytes
                                                                                               == ?
                                                                                                                         b[31:4]
Vv Table         b[i]/a[i]
                                 b[3]    a[3]    b[2]        a[2]      b[1]   a[1]   b[0]      a[0]
 Vector        i = 31 to 4
             To other selects                                                                                     b[0]
                                     1   0           1       0            1   0         1      0
             Other
             inputs
                                                                                                               b[4:0]
                                                                 ‘0’
                                                         1       0
                                Replicated for all other output bytes                              |
 Vd/Vx
 Output                                                                                                        Optional OR
                                                b[63:1]                                        b[0]
 Vector                                                                                                        accumulate
80-N2040-44 Rev. B     MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           196
Hexagon V66 HVX Programmer’s Reference Manual                                                                            Instruction Set
              Vd.b = vlut32(Vu.b, Vv.b, Rt) and Vx.b |= vlut32(Vu.b, Vv.b, Rt)
                                                                                                                                                  Rt
 Vu Input Bytes 127 to B[68] B[67] B[65] B[64] Bytes 63 to 4                   B[3]          B[2]    B[1]         B[0]
  Vector       69                                                                                                                               Bits 2
                                                                                                                          Bits 2:0
                                                                                                    bits 7 to 5                               downto 0
                                                              Replicated for all other input bytes
                                                                                                              == ?
 Vv Table   b[i]/a[i]                                          b[i]/a[i]                                                                        b31 to 4
                          b[33] a[33] b[32] a[32]                              b[1]          a[1]    b[0]         a[0]
  Vector i = 63 to 34                                        i = 31 to 2
                                                          To other selects                       Bit 1
                                                                                     1       0            1   0
                                                                                                                                     Bit 0
                                      Select hi or lo 32 for Vv
                                          32 x 32 to 1 selectors                                                                bits 4 to 0
                                                                                         ‘0’
                                                                                 1       0
                                   Replicated for all other output bytes                                           |
  Vd/Vx
                                                                                                                                 Optional OR
  Output             B127 downto 65               B[64]                    B63 downto 1                           B[0]
                                                                                                                                 accumulate
  Vector
                                          128Byte mode
80-N2040-44 Rev. B     MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                197
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  16-bit elements
                  For tables with 16-bit elements, the basic unit is a 16-entry lookup table in 64B mode and
                  128B mode. Supported by the vlut16 instructions. The even byte entries conditionally
                  select using the lower 4 bits for the even destination register Vdd0, the odd byte entries
                  select table entries into the odd vector destination register Vdd1. A control input register,
                  Rt, contains match and select bits in the same way as the byte table case. In the case of
                  64B mode, the lower 4 bits of Rt must match the upper 4 bits of the input bytes in order for
                  the table entry to be written to or OR'd with the destination Vector Register bytes in Vdd
                  or Vxx respectively. Bit 0 of Rt selects the even or odd 16 entries in Vv. In the 128B case
                  only the upper four bits of input bytes must also match the lower four bits of Rt. Bit 1 of Rt
                  selects odd or even hwords and bit 0 selects the lower or upper 16 entries in the Vv
                  register.
                  For larger than 32-element tables in the hword case (for example 256 entries), the user
                  must access the main lookup table in 8 different 32 hword sections. If a 256H table is
                  stored naturally in memory it would look as below
                       63, 62,.........2, 1, 0
                       127,126,.......66, 65, 64
                       191,190,......130,129,128
                       255,254,......194,193,192
                  To prepare it for use with the vlut instruction in 64B mode, it must be shuffled in blocks of
                  16 hwords, the LSB of Rt is used to choose the even or odd 16 entry hword tables in Vv.
                       31, 15, 30, 14,......20, 4, 19, 3, 18, 2, 17, 1, 16, 0 Rt=0, Rt=1
                       63, 47, 62, 46,..... 52, 36, 51, 35, 50, 34, 49, 33, 48, 32 Rt=2,
                       Rt=3
                       same ordering for bytes 64-255 Rt=4, 5, 6, 7, 8, 9,
                       10,11,12,13,14,15
                  in the case of the 128B mode the data must be shuffled in blocks of 32 hwords. Bit 1 of Rt
                  is used to choose between the even or odd 32 hwords in Vv. Bit 0 accesses the hi or lo 16
                  half words of the odd or even set.
                       63, 31, 62, 30,........36, 4, 35, 3, 34, 2, 33, 1, 32, 0 Rt=0,1
                       Rt=2,3
                       same ordering for bytes 128-255
                       Rt=4,5, Rt=6,7, Rt=8,9, Rt=10,11, Rt=12,13, Rt=14,15
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      198
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                                                           Instruction Set
                                The following diagram shows vlut16 with even bytes being used to look up a table value,
                                with the result written into the even destination register. Odd values going into the odd
                                destination, 64B and 128B modes are shown.
                                  Vdd.h = vlut16(Vu.b, Vv.h, Rt) / Vxx.h |= vlut16(Vu.b, Vv.h, Rt)
                                                                        Odd bytes                                                                                               Even bytes
   Rt                           Bytes                                                                                     Vu Input               Bytes
                                               b[7]            b[5]                  b[3]              b[1]                                                             b[6]                b[4]             b[2]              b[0]
                             i = 63 to 9                                                                                   Vector             i = 62 to 8
                                                                                            Bits 7:4                                                                                                                Bits 7:4
   Bits 3:0
                                      Replicated for all other odd input bytes                                                                              Replicated for all other even input bytes
                                                                                                       == ?                                                                                                                    == ?
                                                                                                                                 Vv Table
                Vv Table       b[i]/a[i]
   Bits 31:4
                                                                                                                                                b[i]/a[i]
                                               b[3]    a[3]    b[2]        a[2]      b[1]   a[1]       b[0]       a[0]            Vector                        b[3]    a[3]    b[2]        a[2]      b[1]   a[1]   b[0]       a[0]
                 Vector      i = 15 to 4                                                                                                      i = 15 to 4
                                                                                                                                  (copy)
                           To other selects                                                                                  Bit 0          To other selects                                                                              Bit 0
                                                   1   0           1       0            1   0                 1   0                                                 1   0           1       0            1   0          1      0
                           Other                                                                                                            Other
                           inputs                                                                                                           inputs
                                                                                                                          Bits 3:0                                                                                                     Bits 3:0
                                                                               ‘0’                                                                                                              ‘0’
                                                                       1       0                                                                                                        1       0
                                              Replicated for all other output bytes                                   |                                        Replicated for all other output bytes                               |
               Vdd1/Vxx1                                                                                                       Vdd0/Vxx0
                Output                                        h[31:1]                                             h[0]          Output                                         h[31:1]                                         h[0]
                 Vector                                                                                                          Vector
                                                                                                Optional OR                                                                                                      Optional OR
                                                                                                accumulate                                                                                                       accumulate
80-N2040-44 Rev. B                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                                                              199
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                                                                                                                Instruction Set
                                          Vdd.h = vlut16(Vu.b, Vv.h, Rt) Vxx.h
                                                                          /    |= vlut16(Vu.b, Vv.h, Rt)
                                                                                                                           Bytes                                                                                   Bytes            Vu Input
                                                                                                                                                 B[2i+1]                       B[2i]
                                               128B MODE                                                                 127 to 2i+2                                                                              2i-1 to 0          Vector
                                                                                                                                                                                                                                         Rt
                                                                                                                                                   bits 7 to 4   bits 3 to 0   bits 7 to 4                            bits 3 to 0
                                                                                                                                                                                                                                         Bits 3
                                                                                                                                                                                                                                       downto 0
                                                                                                                                                   == ?                        == ?
                                                                                                                                                                                                                                         Bits 31 down to 4
                                                                                                             b[i]/a[i]
                                                                                                                            bh[1] ah[1] bh[0] ah[0]
                                                                                                           i = 31 to 2
                                                                                                           Vv Table
                                                                                                            Vector
                                                                                                           (hwords)
                                                                                                                                                                                             Bit 1 – odd / even
                                                                                                                                                                                                hword select
                                                                                                                To other selects
                      To other selects                                        Bit 1
                                                                                                                                   1       0                     1             0
                                               1       0          1   0
                      Other
                      inputs
                                 Choose hi or lo 16 hwords                              Bit 0                        Choose hi or lo 16 hwords
                                                                                                                                                                                                                        Bit 0 – hi or lo 16 hwords
                                                                                                                                                                                                                                  from Vv
                                                                                                                                                                                                                       Bits 3 to 0
                                                                                      Bits 3 to 0                      16 x 16 to 1 selects                                                                             of input
                                                                                                                                                                                                                          byte
                                               ‘0’                                                                                 ‘0’
                                           1       0                                                                           1       0
                                 Replicated for all other                                                            Replicated for all other
                                                                          |                                                                                                           |
                                       odd bytes                                                                           even bytes
                                                                                                    Vdd1/Vxx1                                                                                                                        Vdd0/Vxx0
                                                                      H[i+       H[i+62] down                                                                                                                       H[i-1]
                                    H127 down to i+65                               to H64
                                                                                                     Output               H63 down to i+1                                      H[i]                                                   Output
                                                                      64]                                                                                                                                         down to 0
                                                                                                      Vector                                                                                                                           Vector
                                                           Optional OR                                                                         Optional OR
                                                           accumulate                                                                          accumulate
                 vluts with the nomatch extension do not look at the upper bits and always produce a result.
                 These are for small lookup tables.
                     Syntax                                                                              Behavior
                     Vd.b=vlut32(Vu.b,Vv.b,#u3)                                                           for (i = 0; i < VELEM(8); i++) {
                                                                                                               matchval = #u & 0x7;
                                                                                                               oddhalf = (#u >> (log2(VECTOR_SIZE)-6)) &
                                                                                                          0x1;
                                                                                                               idx = Vu.ub[i];
                                                                                                               Vd.b[i] = ((idx & 0xE0) == (matchval << 5))
                                                                                                          ? Vv.h[idx % VBITS/16].b[oddhalf] : 0 ;
                                                                                                          }
                     Vd.b=vlut32(Vu.b,Vv.b,Rt)                                                            for (i = 0; i < VELEM(8); i++) {
                                                                                                               matchval = Rt & 0x7;
                                                                                                               oddhalf = (Rt >> (log2(VECTOR_SIZE)-6)) &
                                                                                                          0x1;
                                                                                                               idx = Vu.ub[i];
                                                                                                               Vd.b[i] = ((idx & 0xE0) == (matchval << 5))
                                                                                                          ? Vv.h[idx % VBITS/16].b[oddhalf] : 0 ;
                                                                                                          }
80-N2040-44 Rev. B             MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                                                                                                                         200
Hexagon V66 HVX Programmer’s Reference Manual                                                         Instruction Set
                   Syntax                                    Behavior
                   Vd.b=vlut32(Vu.b,Vv.b,Rt):nomatch for (i = 0; i < VELEM(8); i++) {
                                                                    matchval = Rt & 0x7;
                                                                    oddhalf = (Rt >> (log2(VECTOR_SIZE)-6)) &
                                                              0x1;
                                                                    idx = Vu.ub[i];
                                                                    idx = (idx&0x1F) | (matchval<<5);
                                                                    Vd.b[i] = Vv.h[idx % VBITS/16].b[oddhalf] ;
                                                              }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses the HVX permute resource.
                       ■   Input scalar register Rt is limited to registers 0 through 7
                  Intrinsics
                   Vd.b=vlut32(Vu.b,Vv.b,#u3)                   HVX_Vector Q6_Vb_vlut32_VbVbI(HVX_Vector Vu,
                                                                HVX_Vector Vv, Word32 Iu3)
                   Vd.b=vlut32(Vu.b,Vv.b,Rt)                    HVX_Vector Q6_Vb_vlut32_VbVbR(HVX_Vector Vu,
                                                                HVX_Vector Vv, Word32 Rt)
                   Vd.b=vlut32(Vu.b,Vv.b,Rt):nomatch            HVX_Vector
                                                                Q6_Vb_vlut32_VbVbR_nomatch(HVX_Vector Vu,
                                                                HVX_Vector Vv, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9    8  7 6  5 4  3 2  1 0
   ICLASS                                  t3    Parse           u5                   d5
 0  0  0  1 1  0   0 0   v  v  v  v  v  t   t  t P   P 0  u  u   u   u u 0  1 1  d  d d  d d Vd.b=vlut32(Vu.b,Vv.b,Rt):n
                                                                                             omatch
 0  0  0  1 1  0   1 1   v  v  v  v  v  t   t  t P   P 1  u  u   u   u u 0  0 1  d  d d  d d Vd.b=vlut32(Vu.b,Vv.b,Rt)
   ICLASS                                        Parse           u5                   d5
 0  0  0  1 1  1   1 0  0  0  1   v  v  v  v  v  P   P 0  u  u   u   u u  i i  i d  d d  d d Vd.b=vlut32(Vu.b,Vv.b,#u3)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t3                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  v3                Field to encode register v
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                            201
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
      5.11        HVX/PERMUTE-SHIFT-RESOURCE
                  The HVX/PERMUTE-SHIFT-RESOURCE instruction subclass includes instructions that
                  use both the HVX permute and shift resources.
          Vector ASR overlay
                  The primary use of this instruction is to complete a 64b bi-dir ASR by shifting the high-
                  word source(Vu.w[i]) and merging with the destination register. This assumes a rotate on
                  the low-word source was already performed and placed in the low-word of the destination
                  register. However, this instruction could also be used to concatenate LSB portions of the
                  source and destination registers and placed into the high or low word of the destination
                  depending on the shift amount.
                   Syntax                                 Behavior
                   Vxx.w=vasrinto(Vu.w,Vv.w)               for (i = 0; i < VELEM(32); i++) {
                                                                shift = (Vu.w[i] << 32);
                                                                mask = (((Vxx.v[0].w[i]) << 32) |
                                                           Vxx.v[0].w[i]);
                                                                lomask = (((1) << 32) - 1);
                                                                count = -(0x40 & Vv.w[i]) + (Vv.w[i] & 0x3f);
                                                                result = (count == -0x40) ? 0 : (((count < 0)
                                                           ? ((shift << -(count)) | (mask & (lomask << -
                                                           (count)))) : ((shift >> count) | (mask & (lomask
                                                           >> count)))));
                                                                Vxx.v[1].w[i] = ((result >> 32) &
                                                           0xffffffff);
                                                                Vxx.v[0].w[i] = (result & 0xffffffff) ;
                                                           }
                   Vxx=vasrinto(Vu,Vv)                     Assembler mapped to: "Vxx.w=vasrinto(Vu.w,Vv.w)"
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses the HVX permute resource.
                       ■   This instruction uses the HVX shift resource.
                  Intrinsics
                   Vxx.w=vasrinto(Vu.w,Vv.w)               HVX_VectorPair
                                                           Q6_Ww_vasrinto_WwVwVw(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu, HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3  2  1 0
   ICLASS                                       Parse          u5                   x5
 0  0  0  1 1  0   1 0  1   0 1   v  v  v  v  v P   P 1  u   u  u u  u 1  1 1  x x  x  x x Vxx.w=vasrinto(Vu.w,Vv.w)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         202
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  ICLASS          Instruction Class
                  Parse           Packet/Loop parse bits
                  u5              Field to encode register u
                  v5              Field to encode register v
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             203
Hexagon V66 HVX Programmer’s Reference Manual                                                    Instruction Set
        Vector shuffle and deal cross-lane
                  vshuff (formerly vtrans2x2) and vdeal perform a multiple-level transpose operation
                  between groups of elements in two vectors. The element size is specified by the scalar
                  register Rt. Rt=1 indicates an element size of 1 byte, Rt=2 indicates halfwords, Rt=4
                  words, Rt=8 8 bytes, Rt=16 16 bytes, and Rt=32 32 bytes. The data in the two registers
                  should be considered as two rows of vectors. Each two-by-two group is transposed. For
                  example, if Rt = 4 this indicates that each element contains 4 bytes. The matrix of 4 of
                  these elements, made up of two elements from the even register and two corresponding
                  elements of the odd register. This two-by-two array is then transposed, and the resulting
                  elements are then presented in the two destination registers. Note that a value of Rt = 0
                  leaves the input unchanged.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     204
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                  Examples for Rt = 1,2,4,8,16,32 are shown below. In these cases vdeal and vshuff perform
                  the same operation. The diagram is valid for vshuff and vdeal.
   vshuff/vdeal(Vy,Vx,Rt) N = 64/Rt Rt = 2^i
   [N-1] [N-2]             ...           [1]      [0]     Vy    [N-1] [N-2]            ...       [1]      [0]   Vx
   [N-1] [N-2] [N-3] [N-4]                ...     [0]    Vy’    [N-1]     ...      [3]     [2]   [1]      [0]   Vx’
     Vdd = vshuff/vdeal(Vu,Vv,Rt) N = 64 / Rt Rt = 2^i
   [N-1] [N-2]             ...           [1]      [0]    Vu     [N-1] [N-2]            ...       [1]      [0]   Vv
   [N-1] [N-2] [N-3] [N-4]                ...     [0]   Vdd[1]  [N-1] [N-2]        [3]     [2]   [1]      [0]  Vdd[0]
                                                                                Elements
                                           3       2       1       0
                                            Element Rt = 4 N = 16
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   205
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                  When a value of Rt other than 1,2,4,8,16,32 is used, the effect is a compound hierarchical
                  transpose. For example, if the value 23 is used, 23 = 1+2+4+16. This indicates that the
                  transformation is the same as performing the vshuff instruction with Rt=1, then Rt=2 on
                  that result, then Rt = 4 on its result, then Rt = 16 on its result. Note that the order is in
                  increasing element size. In the case of vdeal the order is reversed, starting with the largest
                  element size first, then working down to the smallest.
                  When the Rt value is the negated power of 2: -1,-2,-4,-8,-16,-32, it performs a a perfect
                  shuffle for vshuff, or a deal for vdeal of the smallest element size. For example, if Rt = -24
                  this is a multiple of 8, so 8 is the smallest element size. With a -ve value of Rt, all the
                  upper bits of the value Rt are set. For example, with Rt=-8 this is the same as 32+16+8.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        206
Hexagon V66 HVX Programmer’s Reference Manual                                                                             Instruction Set
                  The diagram below shows the effect of this transform for both vshuff and vdeal.
                    vshuff(Vy,Vx,Rt) Rt = -8 == 32+16+8
                   [15]    [14]   [13]     [12]   [11]  [10]  [9] [8]  Vy     [7] [6]  [5] [4]   [3]   [2]    [1] [0]  Vx
                   [15]     [7]   [13]      [5]   [11]   [3]  [9] [1]        [14] [6] [12] [4]  [10]   [2]    [8] [0]
                   [15]     [7]   [14]      [6]   [11]   [3] [10] [2]        [13] [5] [12] [4]   [9]   [1]    [8] [0]
                   [15]     [7]   [14]      [6]   [13]   [5] [12] [4] Vy’    [11] [3] [10] [2]   [9]   [1]    [8] [0]  Vx’
                                                                                   7    6   5     4     3      2   1    0
                                                                                               Element size 8
                        Vdd = vshuff(Vu,Vv,Rt) Rt = 24
                   [15]    [14]   [13]     [12]   [11]  [10]  [9] [8] Vu      [7] [6]  [5] [4]   [3]   [2]    [1] [0]  Vv
                   [15]     [7]   [14]      [6]   [13]   [5] [12] [4] Vdd[1] [11] [3] [10] [2]   [9]   [1]    [8] [0] Vdd[0]
80-N2040-44 Rev. B         MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                           207
Hexagon V66 HVX Programmer’s Reference Manual                                                                                      Instruction Set
                      vdeal(Vy,Vx,Rt) Rt = -8 or 56
                     [15]   [14]   [13]     [12]    [11]   [10] [9] [8]  Vx              [7]    [6]    [5]   [4] [3] [2] [1] [0]  Vy
                     [15]   [14]   [13]     [12]     [7]    [6] [5] [4]                 [11]   [10]    [9]   [8] [3] [2] [1] [0]
                     [15]   [14]   [11]     10]      [7]    [6] [3] [2]                 [13]   [12]    [9]   [8] [5] [4] [1] [0]
                     [15]   [13]   [11]      [9]     [7]    [5] [3] [1] Vx’             [14]   [12]   [10]   [8] [6] [4] [2] [0]  Vy’
                                                                               Element size 8    7      6     5   4   3   2   1    0
                       Vdd = vdeal(Vu,Vv,Rt) Rt = -8 or 56
                     [15]   [14]   [13]     [12]    [11]   [10] [9] [8] Vu               [7]    [6]    [5]   [4] [3] [2] [1] [0]  Vv
                     [15]   [13]   [11]      [9]     [7]    [5] [3] [1] Vdd[1]          [14]   [12]   [10]   [8] [6] [4] [2] [0] Vdd[0]
                  If in addition to this family of transformations, a block size is defined B, and the element
                  size is defined as E, if Rt = B - E, the resulting transformation is a set of B contiguous
                  blocks, each containing perfectly shuffled or dealt elements of element size E. Each block
                  B contains the vector length divided by B elements. This represents the majority of data
                  transformations commonly used. When B is set to 0, the result is a shuffle or deal of
                  elements across the whole vector register pair.
                   Syntax                                                  Behavior
                   Vdd=vdeal(Vu,Vv,Rt)                                      Vdd.v[0] = Vv;
                                                                            Vdd.v[1] = Vu;
                                                                            for (offset=VWIDTH>>1; offset>0; offset>>=1) {
                                                                                    if ( Rt & offset) {
                                                                                             for (k = 0; k < VELEM(8); k++) {
                                                                                                    if (!( k & offset)) {
                                                                                                           SWAP(Vdd.v[1].ub[k],Vdd.v[0].ub[
                                                                            k+offset]);
                                                                                                    }
                                                                                             }
                                                                                    }
                                                                            }
80-N2040-44 Rev. B        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                     208
Hexagon V66 HVX Programmer’s Reference Manual                                                    Instruction Set
                   Syntax                               Behavior
                   Vdd=vshuff(Vu,Vv,Rt)                  Vdd.v[0] = Vv;
                                                         Vdd.v[1] = Vu;
                                                         for (offset=1; offset<VWIDTH; offset<<=1) {
                                                              if ( Rt & offset) {
                                                                  for (k = 0; k < VELEM(8); k++) {
                                                                       if (!( k & offset)) {
                                                                            SWAP(Vdd.v[1].ub[k],Vdd.v[0].ub[
                                                         k+offset]);
                                                                       }
                                                                  }
                                                              }
                                                         }
                   vdeal(Vy,Vx,Rt)                       for (offset=VWIDTH>>1; offset>0; offset>>=1) {
                                                              if ( Rt & offset) {
                                                                  for (k = 0; k < VELEM(8); k++) {
                                                                       if (!( k & offset)) {
                                                                            SWAP(Vy.ub[k],Vx.ub[k+offset]);
                                                                       }
                                                                  }
                                                              }
                                                         }
                   vshuff(Vy,Vx,Rt)                      for (offset=1; offset<VWIDTH; offset<<=1) {
                                                              if ( Rt & offset) {
                                                                  for (k = 0; k < VELEM(8); k++) {
                                                                       if (!( k & offset)) {
                                                                            SWAP(Vy.ub[k],Vx.ub[k+offset]);
                                                                       }
                                                                  }
                                                              }
                                                         }
                   vtrans2x2(Vy,Vx,Rt)                   Assembler mapped to: "vshuff(Vy,Vx,Rt)"
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction uses the HVX permute resource.
                       ■  Input scalar register Rt is limited to registers 0 through 7
                       ■  This instruction uses the HVX shift resource.
                  Intrinsics
                   Vdd=vdeal(Vu,Vv,Rt)                   HVX_VectorPair Q6_W_vdeal_VVR(HVX_Vector Vu,
                                                         HVX_Vector Vv, Word32 Rt)
                   Vdd=vshuff(Vu,Vv,Rt)                  HVX_VectorPair Q6_W_vshuff_VVR(HVX_Vector Vu,
                                                         HVX_Vector Vv, Word32 Rt)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     209
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                               t5       Parse         y5                 x5
 0  0  0  1 1  0   0 1  1  1  1   t  t   t  t  t P   P 1  y  y  y y y 0 0 1  x  x  x x  x vshuff(Vy,Vx,Rt)
 0  0  0  1 1  0   0 1  1  1  1   t  t   t  t  t P   P 1  y  y  y y y 0 1 0  x  x  x x  x vdeal(Vy,Vx,Rt)
   ICLASS                                  t3    Parse         u5                 d5
 0  0  0  1 1  0   1 1   v  v  v  v  v   t  t  t P   P 1  u  u  u u u 0 1 1  d  d d  d  d Vdd=vshuff(Vu,Vv,Rt)
 0  0  0  1 1  0   1 1   v  v  v  v  v   t  t  t P   P 1  u  u  u u u 1 0 0  d  d d  d  d Vdd=vdeal(Vu,Vv,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t3                Field to encode register t
                  t5                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  v3                Field to encode register v
                  x5                Field to encode register x
                  y5                Field to encode register y
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        210
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
        Vector in-lane lookup table
                  The vlut instructions are used to implement fast vectorized lookup-tables. The lookup
                  table is contained in the Vv register while the indexes are held in Vu. Table elements can
                  be either 8-bit or 16-bit. An aggregation feature is used to implement tables larger than 64
                  bytes in 64B mode and 128 bytes in 128B mode. This explanation discusses both the 64B
                  and 128B modes of operation. In both 64 and 128 byte modes the maximum amount of
                  lookup table accessible is 32 bytes for byte lookups (vlut32) and 16 half words in hwords
                  lookup (vlut16).
                  8-bit elements
                  In the case of 64Byte mode, tables with 8-bit elements support 32 entry lookup tables
                  using the vlut32 instructions. The required entry is conditionally selected by using the
                  lower 5 bits of the input byte for the respective output byte. A control input register, Rt,
                  contains match and select bits. The lower 3 bits of Rt must match the upper 3 bits of the
                  input byte index in order for the table entry to be written to or OR'd with the destination
                  vector register byte in Vd or Vx respectively. The LSB of Rt selects odd or even (32 entry)
                  lookup tables in Vv.
                  If a 256B table is stored naturally in memory it would look as below:
                       127,126,.....66, 65, 64, 63, 62,.........2, 1, 0
                       255,254,....194,193,192,191,190,.......130,129,128
                  To prepare it for use with the vlut instruction in 64B mode, it must be shuffled in blocks of
                  32 bytes:
                       63, 31, 62, 30,......36, 4, 35, 3, 34, 2, 33, 1, 32, 0 Rt=0, Rt=1
                       127, 95,126, 94,.....100, 68, 99, 67, 98, 66, 97, 65, 96, 64 Rt=2,
                       Rt=3
                       same ordering for bytes 128-255 Rt=4, 5, 6, 7
                  For the 128B mode, the data must be shuffled in blocks of 64 bytes:
                       127, 63,126, 62,........68, 4, 67, 3, 66, 2, 65, 1, 64, 0
                       Rt=0,1,2,3
                       same ordering for bytes 128-255 Rt=4,5,6,7
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      211
Hexagon V66 HVX Programmer’s Reference Manual                                                           Instruction Set
                 If data is stored in this way, accessing this with 64 or 128B mode gives the same results. In
                 the case of 128B mode, bit 1 of Rt selects whether to use the odd or even packed table and
                 bit 0 chooses the high of low 32 elements of that high or low table.
  Vd.b = vlut32(Vu.b, Vv.b, Rt) and Vx.b |= vlut32(Vu.b, Vv.b, Rt)
 Vu Input            Vd.b =vlut32(Vu.b, Vv.b, Rt)                                                                          Rt
                     b[63:8]     b[7] b[6] b[5]               b[4]      b[3]   b[2]   b[1]      b[0]
  Vector
                                                                                       b[7:5]                              b[2:0]
                                  Replicated for all other input bytes
                                                                                                == ?
                                                                                                                           b[31:4]
 Vv Table         b[i]/a[i]
                                  b[3]    a[3]    b[2]        a[2]      b[1]   a[1]   b[0]      a[0]
  Vector        i = 31 to 4
              To other selects                                                                                      b[0]
                                      1   0           1       0            1   0         1      0
              Other
              inputs
                                                                                                                 b[4:0]
                                                                  ‘0’
                                                          1       0
                                 Replicated for all other output bytes                              |
  Vd/Vx
  Output                                                                                                        Optional OR
                                                 b[63:1]                                        b[0]
  Vector                                                                                                        accumulate
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          212
Hexagon V66 HVX Programmer’s Reference Manual                                                                            Instruction Set
              Vd.b = vlut32(Vu.b, Vv.b, Rt) and Vx.b |= vlut32(Vu.b, Vv.b, Rt)
                                                                                                                                                  Rt
 Vu Input Bytes 127 to B[68] B[67] B[65] B[64] Bytes 63 to 4                   B[3]          B[2]    B[1]         B[0]
  Vector       69                                                                                                                               Bits 2
                                                                                                                          Bits 2:0
                                                                                                    bits 7 to 5                               downto 0
                                                              Replicated for all other input bytes
                                                                                                              == ?
 Vv Table   b[i]/a[i]                                          b[i]/a[i]                                                                        b31 to 4
                          b[33] a[33] b[32] a[32]                              b[1]          a[1]    b[0]         a[0]
  Vector i = 63 to 34                                        i = 31 to 2
                                                          To other selects                       Bit 1
                                                                                     1       0            1   0
                                                                                                                                     Bit 0
                                      Select hi or lo 32 for Vv
                                          32 x 32 to 1 selectors                                                                bits 4 to 0
                                                                                         ‘0’
                                                                                 1       0
                                   Replicated for all other output bytes                                           |
  Vd/Vx
                                                                                                                                 Optional OR
  Output             B127 downto 65               B[64]                    B63 downto 1                           B[0]
                                                                                                                                 accumulate
  Vector
                                          128Byte mode
80-N2040-44 Rev. B     MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                213
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  16-bit elements
                  For tables with 16-bit elements, the basic unit is a 16-entry lookup table in 64B mode and
                  128B mode. Supported by the vlut16 instructions. The even byte entries conditionally
                  select using the lower 4 bits for the even destination register Vdd0, the odd byte entries
                  select table entries into the odd vector destination register Vdd1. A control input register,
                  Rt, contains match and select bits in the same way as the byte table case. In the case of
                  64B mode, the lower 4 bits of Rt must match the upper 4 bits of the input bytes in order for
                  the table entry to be written to or OR’d with the destination Vector Register bytes in Vdd
                  or Vxx respectively. Bit 0 of Rt selects the even or odd 16 entries in Vv. In the 128B case
                  only the upper 4 bits of input bytes must also match the lower 4 of Rt. Bit 1 of Rt selects
                  odd or even hwords and bit 0 selects the lower or upper 16 entries in the Vv register.
                  For larger than 32-element tables in the hword case (for example 256 entries), the user
                  must access the main lookup table in eight different 32 hword sections. If a 256H table is
                  stored naturally in memory it would look as below:
                       63, 62,.........2, 1, 0 127,126,.......66, 65, 64
                       191,190,......130,129,128 255,254,......194,193,192
                  To prepare it for use with the vlut instruction in 64B mode, it must be shuffled in blocks of
                  16 hwords, the LSB of Rt is used to choose the even or odd 16 entry hword tables in Vv.
                       31, 15, 30, 14,......20, 4, 19, 3, 18, 2, 17, 1, 16, 0 Rt=0, Rt=1
                       63, 47, 62, 46,..... 52, 36, 51, 35, 50, 34, 49, 33, 48, 32 Rt=2,
                       Rt=3 same ordering for bytes 64-255 Rt=4, 5, 6, 7, 8, 9,
                       10,11,12,13,14,15
                  For 128B mode the data must be shuffled in blocks of 32 hwords. Bit 1 of Rt is used to
                  choose between the even or odd 32 hwords in Vv. Bit 0 accesses the high or lo 16 half
                  words of the odd or even set.
                       63, 31, 62, 30,........36, 4, 35, 3, 34, 2, 33, 1, 32, 0 Rt=0,1
                       Rt=2,3 same ordering for bytes 128-255 Rt=4,5, Rt=6,7, Rt=8,9,
                       Rt=10,11, Rt=12,13, Rt=14,15
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      214
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                                                           Instruction Set
                                The following diagram shows vlut16 with even bytes being used to look up a table value,
                                with the result written into the even destination register. Odd values going into the odd
                                destination, 64B and 128B modes are shown.
                                  Vdd.h = vlut16(Vu.b, Vv.h, Rt) / Vxx.h |= vlut16(Vu.b, Vv.h, Rt)
                                                                        Odd bytes                                                                                               Even bytes
   Rt                           Bytes                                                                                     Vu Input               Bytes
                                               b[7]            b[5]                  b[3]              b[1]                                                             b[6]                b[4]             b[2]              b[0]
                             i = 63 to 9                                                                                   Vector             i = 62 to 8
                                                                                            Bits 7:4                                                                                                                Bits 7:4
   Bits 3:0
                                      Replicated for all other odd input bytes                                                                              Replicated for all other even input bytes
                                                                                                       == ?                                                                                                                    == ?
                                                                                                                                 Vv Table
                Vv Table       b[i]/a[i]
   Bits 31:4
                                                                                                                                                b[i]/a[i]
                                               b[3]    a[3]    b[2]        a[2]      b[1]   a[1]       b[0]       a[0]            Vector                        b[3]    a[3]    b[2]        a[2]      b[1]   a[1]   b[0]       a[0]
                 Vector      i = 15 to 4                                                                                                      i = 15 to 4
                                                                                                                                  (copy)
                           To other selects                                                                                  Bit 0          To other selects                                                                              Bit 0
                                                   1   0           1       0            1   0                 1   0                                                 1   0           1       0            1   0          1      0
                           Other                                                                                                            Other
                           inputs                                                                                                           inputs
                                                                                                                          Bits 3:0                                                                                                     Bits 3:0
                                                                               ‘0’                                                                                                              ‘0’
                                                                       1       0                                                                                                        1       0
                                              Replicated for all other output bytes                                   |                                        Replicated for all other output bytes                               |
               Vdd1/Vxx1                                                                                                       Vdd0/Vxx0
                Output                                        h[31:1]                                             h[0]          Output                                         h[31:1]                                         h[0]
                 Vector                                                                                                          Vector
                                                                                                Optional OR                                                                                                      Optional OR
                                                                                                accumulate                                                                                                       accumulate
80-N2040-44 Rev. B                            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                                                              215
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                                                                                    Instruction Set
                                                      Vdd.h = vlut16(Vu.b, Vv.h, Rt) Vxx.h
                                                                                      /    |= vlut16(Vu.b, Vv.h, Rt)
                                                                                                                                       Bytes                                                                                   Bytes            Vu Input
                                                                                                                                                             B[2i+1]                       B[2i]
                                                           128B MODE                                                                 127 to 2i+2                                                                              2i-1 to 0          Vector
                                                                                                                                                                                                                                                     Rt
                                                                                                                                                               bits 7 to 4   bits 3 to 0   bits 7 to 4                            bits 3 to 0
                                                                                                                                                                                                                                                     Bits 3
                                                                                                                                                                                                                                                   downto 0
                                                                                                                                                               == ?                        == ?
                                                                                                                                                                                                                                                     Bits 31 down to 4
                                                                                                                         b[i]/a[i]
                                                                                                                                        bh[1] ah[1] bh[0] ah[0]
                                                                                                                       i = 31 to 2
                                                                                                                       Vv Table
                                                                                                                        Vector
                                                                                                                       (hwords)
                                                                                                                                                                                                         Bit 1 – odd / even
                                                                                                                                                                                                            hword select
                                                                                                                            To other selects
                                  To other selects                                        Bit 1
                                                                                                                                               1       0                     1             0
                                                           1       0          1   0
                                  Other
                                  inputs
                                             Choose hi or lo 16 hwords                              Bit 0                        Choose hi or lo 16 hwords
                                                                                                                                                                                                                                    Bit 0 – hi or lo 16 hwords
                                                                                                                                                                                                                                              from Vv
                                                                                                                                                                                                                                   Bits 3 to 0
                                                                                                  Bits 3 to 0                      16 x 16 to 1 selects                                                                             of input
                                                                                                                                                                                                                                      byte
                                                           ‘0’                                                                                 ‘0’
                                                       1       0                                                                           1       0
                                             Replicated for all other                                                            Replicated for all other
                                                                                      |                                                                                                           |
                                                   odd bytes                                                                           even bytes
                                                                                                                Vdd1/Vxx1                                                                                                                        Vdd0/Vxx0
                                                                                  H[i+       H[i+62] down                                                                                                                       H[i-1]
                                                H127 down to i+65                               to H64
                                                                                                                 Output               H63 down to i+1                                      H[i]                                                   Output
                                                                                  64]                                                                                                                                         down to 0
                                                                                                                  Vector                                                                                                                           Vector
                                                                       Optional OR                                                                         Optional OR
                                                                       accumulate                                                                          accumulate
                 vluts with the nomatch extension do not look at the upper bits and always produce a result.
                 These are for small lookup tables.
                     Syntax                                                                  Behavior
                     Vdd.h=vlut16(Vu.b,Vv.h,#u3)                                              for (i = 0; i < VELEM(16); i++) {
                                                                                                   matchval = #u & 0xF;
                                                                                                   oddhalf = (#u >> (log2(VECTOR_SIZE)-6)) &
                                                                                              0x1;
                                                                                                   idx = Vu.uh[i].ub[0];
                                                                                                   Vdd.v[0].h[i] = ((idx & 0xF0) ==
                                                                                              (matchval << 4)) ? Vv.w[idx %
                                                                                              VBITS/32].h[oddhalf] : 0;
                                                                                                   idx = Vu.uh[i].ub[1];
                                                                                                   Vdd.v[1].h[i] = ((idx & 0xF0) ==
                                                                                              (matchval << 4)) ? Vv.w[idx %
                                                                                              VBITS/32].h[oddhalf] : 0 ;
                                                                                              }
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                                                                                                                                216
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
                   Syntax                                   Behavior
                   Vdd.h=vlut16(Vu.b,Vv.h,Rt)                for (i = 0; i < VELEM(16); i++) {
                                                                  matchval = Rt & 0xF;
                                                                  oddhalf = (Rt >> (log2(VECTOR_SIZE)-6)) &
                                                             0x1;
                                                                  idx = Vu.uh[i].ub[0];
                                                                  Vdd.v[0].h[i] = ((idx & 0xF0) ==
                                                             (matchval << 4)) ? Vv.w[idx %
                                                             VBITS/32].h[oddhalf] : 0;
                                                                  idx = Vu.uh[i].ub[1];
                                                                  Vdd.v[1].h[i] = ((idx & 0xF0) ==
                                                             (matchval << 4)) ? Vv.w[idx %
                                                             VBITS/32].h[oddhalf] : 0 ;
                                                             }
                   Vdd.h=vlut16(Vu.b,Vv.h,Rt):nomatch        for (i = 0; i < VELEM(16); i++) {
                                                                  matchval = Rt & 0xF;
                                                                  oddhalf = (Rt >> (log2(VECTOR_SIZE)-6)) &
                                                             0x1;
                                                                  idx = Vu.uh[i].ub[0];
                                                                  idx = (idx&0x0F) | (matchval<<4);
                                                                  Vdd.v[0].h[i] = Vv.w[idx %
                                                             VBITS/32].h[oddhalf];
                                                                  idx = Vu.uh[i].ub[1];
                                                                  idx = (idx&0x0F) | (matchval<<4);
                                                                  Vdd.v[1].h[i] = Vv.w[idx %
                                                             VBITS/32].h[oddhalf] ;
                                                             }
                   Vx.b|=vlut32(Vu.b,Vv.b,#u3)               for (i = 0; i < VELEM(8); i++) {
                                                                  matchval = #u & 0x7;
                                                                  oddhalf = (#u >> (log2(VECTOR_SIZE)-6)) &
                                                             0x1;
                                                                  idx = Vu.ub[i];
                                                                  Vx.b[i] |= ((idx & 0xE0) == (matchval <<
                                                             5)) ? Vv.h[idx % VBITS/16].b[oddhalf] : 0 ;
                                                             }
                   Vx.b|=vlut32(Vu.b,Vv.b,Rt)                for (i = 0; i < VELEM(8); i++) {
                                                                  matchval = Rt & 0x7;
                                                                  oddhalf = (Rt >> (log2(VECTOR_SIZE)-6)) &
                                                             0x1;
                                                                  idx = Vu.ub[i];
                                                                  Vx.b[i] |= ((idx & 0xE0) == (matchval <<
                                                             5)) ? Vv.h[idx % VBITS/16].b[oddhalf] : 0 ;
                                                             }
                   Vxx.h|=vlut16(Vu.b,Vv.h,#u3)              for (i = 0; i < VELEM(16); i++) {
                                                                  matchval = #u & 0xF;
                                                                  oddhalf = (#u >> (log2(VECTOR_SIZE)-6)) &
                                                             0x1;
                                                                  idx = Vu.uh[i].ub[0];
                                                                  Vxx.v[0].h[i] |= ((idx & 0xF0) ==
                                                             (matchval << 4)) ? Vv.w[idx %
                                                             VBITS/32].h[oddhalf] : 0;
                                                                  idx = Vu.uh[i].ub[1];
                                                                  Vxx.v[1].h[i] |= ((idx & 0xF0) ==
                                                             (matchval << 4)) ? Vv.w[idx %
                                                             VBITS/32].h[oddhalf] : 0 ;
                                                             }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    217
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
                   Syntax                                   Behavior
                   Vxx.h|=vlut16(Vu.b,Vv.h,Rt)               for (i = 0; i < VELEM(16); i++) {
                                                                  matchval = Rt.ub[0] & 0xF;
                                                                  oddhalf = (Rt >> (log2(VECTOR_SIZE)-6)) &
                                                             0x1;
                                                                  idx = Vu.uh[i].ub[0];
                                                                  Vxx.v[0].h[i] |= ((idx & 0xF0) ==
                                                             (matchval << 4)) ? Vv.w[idx %
                                                             VBITS/32].h[oddhalf] : 0;
                                                                  idx = Vu.uh[i].ub[1];
                                                                  Vxx.v[1].h[i] |= ((idx & 0xF0) ==
                                                             (matchval << 4)) ? Vv.w[idx %
                                                             VBITS/32].h[oddhalf] : 0 ;
                                                             }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction uses the HVX permute resource.
                       ■  Input scalar register Rt is limited to registers 0 through 7
                       ■  This instruction uses the HVX shift resource.
                  Intrinsics
                   Vdd.h=vlut16(Vu.b,Vv.h,#u3)              HVX_VectorPair Q6_Wh_vlut16_VbVhI(HVX_Vector
                                                            Vu, HVX_Vector Vv, Word32 Iu3)
                   Vdd.h=vlut16(Vu.b,Vv.h,Rt)               HVX_VectorPair Q6_Wh_vlut16_VbVhR(HVX_Vector
                                                            Vu, HVX_Vector Vv, Word32 Rt)
                   Vdd.h=vlut16(Vu.b,Vv.h,Rt):nomatch       HVX_VectorPair
                                                            Q6_Wh_vlut16_VbVhR_nomatch(HVX_Vector Vu,
                                                            HVX_Vector Vv, Word32 Rt)
                   Vx.b|=vlut32(Vu.b,Vv.b,#u3)              HVX_Vector Q6_Vb_vlut32or_VbVbVbI(HVX_Vector
                                                            Vx, HVX_Vector Vu, HVX_Vector Vv, Word32
                                                            Iu3)
                   Vx.b|=vlut32(Vu.b,Vv.b,Rt)               HVX_Vector Q6_Vb_vlut32or_VbVbVbR(HVX_Vector
                                                            Vx, HVX_Vector Vu, HVX_Vector Vv, Word32 Rt)
                   Vxx.h|=vlut16(Vu.b,Vv.h,#u3)             HVX_VectorPair
                                                            Q6_Wh_vlut16or_WhVbVhI(HVX_VectorPair Vxx,
                                                            HVX_Vector Vu, HVX_Vector Vv, Word32 Iu3)
                   Vxx.h|=vlut16(Vu.b,Vv.h,Rt)              HVX_VectorPair
                                                            Q6_Wh_vlut16or_WhVbVhR(HVX_VectorPair Vxx,
                                                            HVX_Vector Vu, HVX_Vector Vv, Word32 Rt)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    218
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                                  t3    Parse         u5                 d5
                                                                                          Vdd.h=vlut16(Vu.b,Vv.h,Rt):
 0  0  0  1 1  0   0 0   v  v  v  v  v  t   t  t P   P 0  u  u  u u u 1 0 0  d  d d  d  d
                                                                                          nomatch
   ICLASS                                  t3    Parse         u5                 x5
 0  0  0  1 1  0   1 1   v  v  v  v  v  t   t  t P   P 1  u  u  u u u 1 0 1  x  x  x x  x Vx.b|=vlut32(Vu.b,Vv.b,Rt)
   ICLASS                                  t3    Parse         u5                 d5
 0  0  0  1 1  0   1 1   v  v  v  v  v  t   t  t P   P 1  u  u  u u u 1 1 0  d  d d  d  d Vdd.h=vlut16(Vu.b,Vv.h,Rt)
   ICLASS                                  t3    Parse         u5                 x5
 0  0  0  1 1  0   1 1   v  v  v  v  v  t   t  t P   P 1  u  u  u u u 1 1 1  x  x  x x  x Vxx.h|=vlut16(Vu.b,Vv.h,Rt)
   ICLASS                                        Parse         u5                 x5
                                                                                          Vx.b|=vlut32(Vu.b,Vv.b,#u3
 0  0  0  1 1  1   0 0  1  1  0   v  v  v  v  v  P   P 1  u  u  u u u i i i   x x  x x  x )
 0  0  0  1 1  1   0 0  1  1  1   v  v  v  v  v  P   P 1  u  u  u u u i i i   x x  x x  x Vxx.h|=vlut16(Vu.b,Vv.h,#u
                                                                                          3)
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   1 0  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u i i i  d  d d  d  d Vdd.h=vlut16(Vu.b,Vv.h,#u
                                                                                          3)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t3                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  v3                Field to encode register v
                  v5                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          219
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
         Unpack
                  The unpack operation has two forms. The first form takes each element in vector register
                  Vu and either zero or sign extends it to the next largest element size. The results are
                  written into the vector register Vdd. This operation supports the unpacking of signed or
                  unsigned byte to halfword, signed or unsigned halfword to word, and unsigned word to
                  unsigned double.
                  The second form inserts elements from Vu into the odd element locations of Vxx. The
                  even elements of Vxx are not changed. This operation supports the unpacking of signed or
                  unsigned byte to halfword, and signed or unsigned halfword to word.
        Vdd.h=vunpack(Vu.b)
                                                   [N-1]           ...          [3]   [2]    [1]    [0]     Vu
       sign   [2N-1]
                                 ...               sign    [6]    sign  [4]    sign   [2]   sign    [0]     Vdd
        Vxx.h|=vunpacko(Vu.b)
                                                   [N-1]       ...      [4]     [3]   [2]    [1]    [0]      Vu
      [2N-1] [2N-2]       ...        [9]    [8]     [7]    [6]     [5]  [4]     [3]   [2]    [1]    [0]     Vxx
                  Unmodified
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      220
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
                   Syntax                                 Behavior
                   Vdd.h=vunpack(Vu.b)                     for (i = 0; i < VELEM(8); i++) {
                                                                Vdd.h[i] = Vu.b[i] ;
                                                           }
                   Vdd.uh=vunpack(Vu.ub)                   for (i = 0; i < VELEM(8); i++) {
                                                                Vdd.uh[i] = Vu.ub[i] ;
                                                           }
                   Vdd.uw=vunpack(Vu.uh)                   for (i = 0; i < VELEM(16); i++) {
                                                                Vdd.uw[i] = Vu.uh[i] ;
                                                           }
                   Vdd.w=vunpack(Vu.h)                     for (i = 0; i < VELEM(16); i++) {
                                                                Vdd.w[i] = Vu.h[i] ;
                                                           }
                   Vxx.h|=vunpacko(Vu.b)                   for (i = 0; i < VELEM(8); i++) {
                                                                Vxx.uh[i] |= Vu.ub[i]<<8 ;
                                                           }
                   Vxx.w|=vunpacko(Vu.h)                   for (i = 0; i < VELEM(16); i++) {
                                                                Vxx.uw[i] |= Vu.uh[i]<<16 ;
                                                           }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses the HVX permute resource.
                       ■   This instruction uses the HVX shift resource.
                  Intrinsics
                   Vdd.h=vunpack(Vu.b)                     HVX_VectorPair Q6_Wh_vunpack_Vb(HVX_Vector Vu)
                   Vdd.uh=vunpack(Vu.ub)                   HVX_VectorPair Q6_Wuh_vunpack_Vub(HVX_Vector Vu)
                   Vdd.uw=vunpack(Vu.uh)                   HVX_VectorPair Q6_Wuw_vunpack_Vuh(HVX_Vector Vu)
                   Vdd.w=vunpack(Vu.h)                     HVX_VectorPair Q6_Ww_vunpack_Vh(HVX_Vector Vu)
                   Vxx.h|=vunpacko(Vu.b)                   HVX_VectorPair
                                                           Q6_Wh_vunpackoor_WhVb(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu)
                   Vxx.w|=vunpacko(Vu.h)                   HVX_VectorPair
                                                           Q6_Ww_vunpackoor_WwVh(HVX_VectorPair Vxx,
                                                           HVX_Vector Vu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6 5  4 3 2  1 0
   ICLASS                                       Parse          u5                  x5
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 1  u   u  u u  u 0 0  0  x x x  x x Vxx.h|=vunpacko(Vu.b)
 0  0  0  1 1  1   1 0   -  - 0   -  -  - 0  0  P   P 1  u   u  u u  u 0 0  1  x x x  x x Vxx.w|=vunpacko(Vu.h)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        221
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  0  1  P   P 0  u  u  u u u 0 0 0  d  d d  d  d Vdd.uh=vunpack(Vu.ub)
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  0  1  P   P 0  u  u  u u u 0 0 1  d  d d  d  d Vdd.uw=vunpack(Vu.uh)
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  0  1  P   P 0  u  u  u u u 0 1 0  d  d d  d  d Vdd.h=vunpack(Vu.b)
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  0  1  P   P 0  u  u  u u u 0 1 1  d  d d  d  d Vdd.w=vunpack(Vu.h)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       222
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                                                                        Instruction Set
     5.12        HVX/SCATTER-DOUBLE-RESOURCE
                 The HVX/SCATTER-DOUBLE-RESOURCE instruction subclass includes instructions
                 that perform scatter operations to the vector TCM.
        Vector scatter
                 Scatter operations copy values from the register file to a region in VTCM, enabling
                 parallelized data stores to noncontiguous addresses in VTCM. This region of memory is
                 specified by two scalar registers: Rt32 is the base and Mu2 specified the length-1 of the
                 region in bytes. This region must reside in VTCM and cannot cross a page boundary. A
                 vector register, Vvv32, specifies byte offsets in this region. Elements of either halfword or
                 word granularity, specified by Vw32, are sent to addresses pointed to by Rt + Vvv32 for
                 each element. In the memory, the element is either write to memory or accumulated with
                 the memory (scatter-accumulate).
                 If multiple values are written to the same memory location, ordering is not guaranteed.
                 This applies to a single scatter or multiple scatters.
                 The offset vector, Vvv32, can contain byte offsets specified in word sizes. The vector pair
                 contains even element offsets in the lower vector and the odd in the upper vector. The final
                 element addresses do not have to be byte aligned for regular scatter operations. However,
                 for scatter accumulate instructions, the addresses are aligned. If an offset crosses the end
                 of the scatter region end, it is simply dropped. Offsets must be positive otherwise they are
                 dropped.
                                                            vscatter(Rt,Mu,Vvv.w)=Vw.h
                     Rt – Scalar Indicating base address in VTCM                                                        Vv – Vector with byte offsets from base
                                                                                                                        Vw – Vector with halfword elements to be
                     Mu – Scalar indicating length-1 of Region                                                          scattered
                                                                                        Example of vscatter (only first 4 elements shown)
                                           Rt+Mu
                                ...
                                            Region            Vw.h
                                                                                                                                                                                         ...
                      ...       ...          End               [2]
                                                                                                                                                                                               Scatter VTCM Region
                                                                                                                        Vw.h
                                                                                                                                                                                         ...
                      ...       ...                                                                                      [3]
                                                                                                                                 Vw.h
                                                                                                                                                                                         ...
                      ...       ...                .h[2]                                                                          [1]
                                  *(Rt+
                                                                                    ]                                                                                                    ...
                      ...       ...                                               [3
                                                                                .h
                                        Vvv.V                                 Vw                               1]
                                                                          )] =                               h[
                                                                                                          w.
                                             [0].w
                                                                        [1                                                                                                               ...
                      ...       ...                                .w                                   =V
                                                                1]                                 ])
                                                  [1])=
                                                            [                                   [0
                                                         .V
                                                       vv                                   ].w                                         Vw.h         Region
                                                       Vw
                      ...                           t+V                               .[1                                                [0]          Base
                                                                                                                                                                                         ...
                                                *(
                                                  R                             v.V
                                                                             Vv                                                .h[0
                                                                                                                                   ]
                                                                       R   t+                                              w                                                            VTCM
                                                                    *(                          [0                  ]   )=V                                                 ...   ...
                      ...       ...                                                        0].w
                                                                                                                                                                                        Base
                                                                                      v.V[
                                                                                   +Vv
                                                                              *(Rt                                                                    Rt
                      h3        h2              h1             h0          Vw.h      offset1                               offset1      Vvv.V[1].w
                                                                                                offset2                    offset0      Vvv.V[0].w   Byte Offsets from Rt
                            Values to Scatter
80-N2040-44 Rev. B            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                                                                                  223
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   if (Qs4)                              MuV = MuV | (element_size-1);
                   vscatter(Rt,Mu,Vvv.w).h=Vw32          Rt = Rt & ~(element_size-1);
                                                         for (i = 0; i < VELEM(32); i++) {
                                                              for(j = 0; j < 2; j++) {
                                                                  EA = Rt+Vvv.v[j].uw[i];
                                                                  if ( (Rt <= EA <= Rt + MuV) & QsV) *EA =
                                                         VwV.w[i].uh[j];
                                                              }
                                                         }
                   if (Qs4)                              Assembler mapped to: "if (Qs4)
                   vscatter(Rt,Mu,Vvv.w)=Vw32.h          vscatter(Rt,Mu2,Vvv.w).h=Vw32"
                   vscatter(Rt,Mu,Vvv.w)+=Vw32.h         Assembler mapped to:
                                                         "vscatter(Rt,Mu2,Vvv.w).h+=Vw32"
                   vscatter(Rt,Mu,Vvv.w).h+=Vw32         MuV = MuV | (element_size-1);
                                                         Rt = Rt & ~(element_size-1);
                                                         for (i = 0; i < VELEM(32); i++) {
                                                              for(j = 0; j < 2; j++) {
                                                                  EA = Rt + Vvv.v[j].uw[i] =
                                                         Vvv.v[j].uw[i] & ~(ALIGNMENT-1);
                                                         ;
                                                                  if (Rt <= EA <= Rt + MuV) *EA +=
                                                         VwV.w[i].uh[j];
                                                              }
                                                         }
                   vscatter(Rt,Mu,Vvv.w).h=Vw32          MuV = MuV | (element_size-1);
                                                         Rt = Rt & ~(element_size-1);
                                                         for (i = 0; i < VELEM(32); i++) {
                                                              for(j = 0; j < 2; j++) {
                                                                  EA = Rt+Vvv.v[j].uw[i];
                                                                  if (Rt <= EA <= Rt + MuV) *EA =
                                                         VwV.w[i].uh[j];
                                                              }
                                                         }
                   vscatter(Rt,Mu,Vvv.w)=Vw32.h          Assembler mapped to:
                                                         "vscatter(Rt,Mu2,Vvv.w).h=Vw32"
                  Class: COPROC_VMEM (slots 0)
                  Notes
                       ■  This instruction uses any pair of the HVX resources (both multiply or
                          shift/permute).
                  Intrinsics
                   if (Qs4)                              void Q6_vscatter_QRMWwV(HVX_VectorPred Qs,
                   vscatter(Rt,Mu,Vvv.w).h=Vw32          HVX_Vector* Rb, Word32 Mu, HVX_VectorPair Vvv,
                                                         HVX_Vector Vw)
                   vscatter(Rt,Mu,Vvv.w).h+=Vw32         void Q6_vscatteracc_RMWwV(HVX_Vector* Rb, Word32
                                                         Mu, HVX_VectorPair Vvv, HVX_Vector Vw)
                   vscatter(Rt,Mu,Vvv.w).h=Vw32          void Q6_vscatter_RMWwV(HVX_Vector* Rb, Word32
                                                         Mu, HVX_VectorPair Vvv, HVX_Vector Vw)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   224
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6    5 4 3 2 1  0
   ICLASS                  NT           t5       Parse u1
                                                                                          vscatter(Rt,Mu,Vvv.w).h=V
 0  0  1  0 1  1   1 1  0  0  1   t  t   t  t  t P   P u  v  v  v v v 0 1   0  w w w w w
                                                                                          w32
 0  0  1  0 1  1   1 1  0  0  1   t  t   t  t  t P   P u  v  v  v v v 1 1   0  w w w w w vscatter(Rt,Mu,Vvv.w).h+=
                                                                                          Vw32
   ICLASS                  NT           t5       Parse u1                 s2
                                                                                          if (Qs4)
 0  0  1  0 1  1   1 1  1  0  1   t  t   t  t  t P   P u  v  v  v v v 0 s    s w w w w w vscatter(Rt,Mu,Vvv.w).h=V
                                                                                          w32
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  s2                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         225
Hexagon V66 HVX Programmer’s Reference Manual                                                                                                                                                             Instruction Set
     5.13        HVX/SCATTER
                 The HVX/SCATTER instruction subclass includes instructions that perform scatter
                 operations to the vector TCM.
        Vector scatter
                 Scatter operations copy values from the register file to a region in VTCM. This region of
                 memory is specified by two scalar registers: Rt32 is the base and Mu2 specified the
                 length-1 of the region in bytes. This region must reside in VTCM and cannot cross a page
                 boundary. A vector register, Vv32, specifies byte offsets in this region. Elements of either
                 halfword or word granularity, specified by Vw32, are sent to addresses pointed to by Rt +
                 Vv32 for each element. In the memory, the element is either write to memory or
                 accumulated with the memory (scatter-accumulate).
                 If multiple values are written to the same memory location, ordering is not guaranteed.
                 The offset vector, Vv32, can contain byte offsets specified in either halfword or word
                 sizes. The final element addresses do not have to be byte aligned for regular scatter
                 operations. However, for scatter accumulate instructions, the addresses are aligned. If an
                 offset crosses the end of the scatter region end, it is simply dropped. Offsets must be
                 positive otherwise they are dropped.
                                                               vscatter(Rt,Mu,Vv.h)=Vw.h
                     Rt – Scalar Indicating base address in VTCM                                                      Vv – Vector with byte offsets from base
                                                                                                                      Vw – Vector with halfword elements to be
                     Mu – Scalar indicating length-1 of Region                                                        scattered
                                                                                            Example of vscatter (only first 4 elements shown)
                                            Rt+Mu
                                ...
                                             Region             Vw.h
                                                                                                                                                                              ...
                      ...       ...           End                [2]
                                                                                                                                                                                    Scatter VTCM Region
                                                                                                                      Vw.h
                                                                                                                                                                              ...
                      ...       ...                                                                                    [3]
                                                                                                                                  Vw.h
                                                                                                                                                                              ...
                      ...       ...                                                                                                [1]
                                      *(Rt+                                                                                                                                   ...
                                           Vv.h[2
                      ...       ...
                                                                                    3]
                                                                                  h[
                                                                               w.
                                                 ])=Vw
                                                                                                              ]
                                                                             V                              [1                                                                ...
                      ...       ...                                       ])=                             .h
                                                                                                     Vw
                                                       .h[2]
                                                                        [3
                                                                     v.h                      ])
                                                                                                 =
                                                                +V                          [1                                               Vw.h     Region
                                                          Rt                             v.h
                                                                                                                                                                              ...
                      ...                               *(                                                                                    [0]      Base
                                                                                    +V
                                                                               Rt
                                                                             *(                                        .h[0
                                                                                                                            ]                                                VTCM
                      ...       ...                                                                           ])   = Vw                                          ...   ...   Base
                                                                                                    .h[0
                                                                                                + Vv
                                                                                           *(Rt
                                                                                                                                                       Rt
                      h3        h2                h1             h0          Vw.h             offset3       offset2     offset1    offset0     Vv.h
                            Values to Scatter                                                        Byte Offsets from Rt
80-N2040-44 Rev. B            MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                                                                                                                       226
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
                   Syntax                               Behavior
                   if (Qs4)                              MuV = MuV | (element_size-1);
                   vscatter(Rt,Mu,Vv.h).h=Vw32           Rt = Rt & ~(element_size-1);
                                                         for (i = 0; i < VELEM(16); i++) {
                                                              EA = Rt+Vv.uh[i];
                                                              if ( (Rt <= EA <= Rt + MuV) & QsV) *EA =
                                                         VwV.uh[i];
                                                         }
                   if (Qs4)                              Assembler mapped to: "if (Qs4)
                   vscatter(Rt,Mu,Vv.h)=Vw32.h           vscatter(Rt,Mu2,Vv.h).h=Vw32"
                   if (Qs4)                              MuV = MuV | (element_size-1);
                   vscatter(Rt,Mu,Vv.w).w=Vw32           Rt = Rt & ~(element_size-1);
                                                         for (i = 0; i < VELEM(32); i++) {
                                                              EA = Rt+Vv.uw[i];
                                                              if ( (Rt <= EA <= Rt + MuV) & QsV) *EA =
                                                         VwV.uw[i];
                                                         }
                   if (Qs4)                              Assembler mapped to: "if (Qs4)
                   vscatter(Rt,Mu,Vv.w)=Vw32.w           vscatter(Rt,Mu2,Vv.w).w=Vw32"
                   vscatter(Rt,Mu,Vv.h)+=Vw32.h          Assembler mapped to:
                                                         "vscatter(Rt,Mu2,Vv.h).h+=Vw32"
                   vscatter(Rt,Mu,Vv.h).h+=Vw32          MuV = MuV | (element_size-1);
                                                         Rt = Rt & ~(element_size-1);
                                                         for (i = 0; i < VELEM(16); i++) {
                                                              EA = (Rt+Vv.uh[i] = Vv.uh[i] & ~(ALIGNMENT-
                                                         1));
                                                              if (Rt <= EA <= Rt + MuV) *EA += VwV.uh[i];
                                                         }
                   vscatter(Rt,Mu,Vv.h).h=Vw32           MuV = MuV | (element_size-1);
                                                         Rt = Rt & ~(element_size-1);
                                                         for (i = 0; i < VELEM(16); i++) {
                                                              EA = Rt+Vv.uh[i];
                                                              if (Rt <= EA <= Rt + MuV) *EA = VwV.uh[i];
                                                         }
                   vscatter(Rt,Mu,Vv.h)=Vw32.h           Assembler mapped to:
                                                         "vscatter(Rt,Mu2,Vv.h).h=Vw32"
                   vscatter(Rt,Mu,Vv.w)+=Vw32.w          Assembler mapped to:
                                                         "vscatter(Rt,Mu2,Vv.w).w+=Vw32"
                   vscatter(Rt,Mu,Vv.w).w+=Vw32          MuV = MuV | (element_size-1);
                                                         Rt = Rt & ~(element_size-1);
                                                         for (i = 0; i < VELEM(32); i++) {
                                                              EA = (Rt+Vv.uw[i] = Vv.uw[i] & ~(ALIGNMENT-
                                                         1));
                                                              if (Rt <= EA <= Rt + MuV) *EA += VwV.uw[i];
                                                         }
                   vscatter(Rt,Mu,Vv.w).w=Vw32           MuV = MuV | (element_size-1);
                                                         Rt = Rt & ~(element_size-1);
                                                         for (i = 0; i < VELEM(32); i++) {
                                                              EA = Rt+Vv.uw[i];
                                                              if (Rt <= EA <= Rt + MuV) *EA = VwV.uw[i];
                                                         }
                   vscatter(Rt,Mu,Vv.w)=Vw32.w           Assembler mapped to:
                                                         "vscatter(Rt,Mu2,Vv.w).w=Vw32"
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                   227
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                  Class: COPROC_VMEM (slots 0)
                  Notes
                       ■   This instruction can use any HVX resource.
                  Intrinsics
                   if (Qs4)                                 void Q6_vscatter_QRMVhV(HVX_VectorPred Qs,
                   vscatter(Rt,Mu,Vv.h).h=Vw32              HVX_Vector* Rb, Word32 Mu, HVX_Vector Vv,
                                                            HVX_Vector Vw)
                   if (Qs4)                                 void Q6_vscatter_QRMVwV(HVX_VectorPred Qs,
                   vscatter(Rt,Mu,Vv.w).w=Vw32              HVX_Vector* Rb, Word32 Mu, HVX_Vector Vv,
                                                            HVX_Vector Vw)
                   vscatter(Rt,Mu,Vv.h).h+=Vw32             void Q6_vscatteracc_RMVhV(HVX_Vector* Rb, Word32
                                                            Mu, HVX_Vector Vv, HVX_Vector Vw)
                   vscatter(Rt,Mu,Vv.h).h=Vw32              void Q6_vscatter_RMVhV(HVX_Vector* Rb, Word32
                                                            Mu, HVX_Vector Vv, HVX_Vector Vw)
                   vscatter(Rt,Mu,Vv.w).w+=Vw32             void Q6_vscatteracc_RMVwV(HVX_Vector* Rb, Word32
                                                            Mu, HVX_Vector Vv, HVX_Vector Vw)
                   vscatter(Rt,Mu,Vv.w).w=Vw32              void Q6_vscatter_RMVwV(HVX_Vector* Rb, Word32
                                                            Mu, HVX_Vector Vv, HVX_Vector Vw)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6    5 4 3 2 1 0
   ICLASS                  NT           t5       Parse u1
 0  0  1  0 1  1   1 1  0  0  1   t  t   t  t  t P   P u  v   v v  v v 0  0   0  w w w w w vscatter(Rt,Mu,Vv.w).w=Vw
                                                                                           32
 0  0  1  0 1  1   1 1  0  0  1   t  t   t  t  t P   P u  v   v v  v v 0  0   1  w w w w w vscatter(Rt,Mu,Vv.h).h=Vw
                                                                                           32
                                                                                           vscatter(Rt,Mu,Vv.w).w+=V
 0  0  1  0 1  1   1 1  0  0  1   t  t   t  t  t P   P u  v   v v  v v 1  0   0  w w w w w w32
 0  0  1  0 1  1   1 1  0  0  1   t  t   t  t  t P   P u  v   v v  v v 1  0   1  w w w w w vscatter(Rt,Mu,Vv.h).h+=V
                                                                                           w32
   ICLASS                  NT           t5       Parse u1                   s2
                                                                                           if (Qs4)
 0  0  1  0 1  1   1 1  1  0  0   t  t   t  t  t P   P u  v   v v  v v 0  s    s w w w w w vscatter(Rt,Mu,Vv.w).w=Vw
                                                                                           32
                                                                                           if (Qs4)
 0  0  1  0 1  1   1 1  1  0  0   t  t   t  t  t P   P u  v   v v  v v 1  s    s w w w w w vscatter(Rt,Mu,Vv.h).h=Vw
                                                                                           32
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  s2                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          228
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
     5.14         HVX/SHIFT-RESOURCE
                  The HVX/SHIFT-RESOURCE instruction subclass includes instructions that use the
                  HVX shift resource.
        Narrowing shift
                  Arithmetically shift-right the elements in vector registers Vu and Vv by the lower bits of
                  the scalar register Rt. Each result is optionally saturated, rounded to infinity, and packed
                  into a single destination vector register. Each even element in the destination vector
                  register Vd comes from the vector register Vv, and each odd element in Vd comes from
                  the vector register Vu.
                       Vd.h=vasr(Vu.w,Vv.w,Rt)[:rnd][:sat]
              [N-1]                                  [1]             [0]         Vu
              [N-1]                                  [1]             [0]         Vv
          rnd       rnd                         rnd      rnd    rnd      rnd       Optional Round
                                                                                   Arithmetic
          >>Rt      >>Rt                       >>Rt      >>Rt  >>Rt      >>Rt
                                                                                   Shift by Rt
                                                                                 Optional Saturate to next
           sat       sat                        sat       sat   sat       sat
                                                                                 smaller element limits
         [2N-1]    [2N-2]                        [3]      [2]    [1]      [0]    Vd
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       229
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
                   Syntax                                     Behavior
                   Vd.b=vasr(Vu.h,Vv.h,Rt)[:rnd]:sat          for (i = 0; i < VELEM(16); i++) {
                                                                   shamt = Rt & 0x7;
                                                                   Vd.h[i].b[0]=sat8(Vv.h[i] + (1<<(shamt-
                                                              1)) >> shamt);
                                                                   Vd.h[i].b[1]=sat8(Vu.h[i] + (1<<(shamt-
                                                              1)) >> shamt) ;
                                                              }
                   Vd.h=vasr(Vu.w,Vv.w,Rt):rnd:sat            for (i = 0; i < VELEM(32); i++) {
                                                                   shamt = Rt & 0xF;
                                                                   Vd.w[i].h[0]=sat16(Vv.w[i] + (1<<(shamt-
                                                              1)) >> shamt);
                                                                   Vd.w[i].h[1]=sat16(Vu.w[i] + (1<<(shamt-
                                                              1)) >> shamt) ;
                                                              }
                   Vd.h=vasr(Vu.w,Vv.w,Rt)[:sat]              for (i = 0; i < VELEM(32); i++) {
                                                                   shamt = Rt & 0xF;
                                                                   Vd.w[i].h[0]=[sat16](Vv.w[i] >> shamt);
                                                                   Vd.w[i].h[1]=[sat16](Vu.w[i] >> shamt) ;
                                                              }
                   Vd.ub=vasr(Vu.h,Vv.h,Rt)[:rnd]:sat         for (i = 0; i < VELEM(16); i++) {
                                                                   shamt = Rt & 0x7;
                                                                   Vd.h[i].b[0]=usat8(Vv.h[i] + (1<<(shamt-
                                                              1)) >> shamt);
                                                                   Vd.h[i].b[1]=usat8(Vu.h[i] + (1<<(shamt-
                                                              1)) >> shamt) ;
                                                              }
                   Vd.ub=vasr(Vu.uh,Vv.uh,Rt)[:rnd]:sat for (i = 0; i < VELEM(16); i++) {
                                                                   shamt = Rt & 0x7;
                                                                   Vd.uh[i].b[0]=usat8(Vv.uh[i] +
                                                              (1<<(shamt-1)) >> shamt);
                                                                   Vd.uh[i].b[1]=usat8(Vu.uh[i] +
                                                              (1<<(shamt-1)) >> shamt) ;
                                                              }
                   Vd.uh=vasr(Vu.uw,Vv.uw,Rt)[:rnd]:sat for (i = 0; i < VELEM(32); i++) {
                                                                   shamt = Rt & 0xF;
                                                                   Vd.uw[i].h[0]=usat16(Vv.uw[i] +
                                                              (1<<(shamt-1)) >> shamt);
                                                                   Vd.uw[i].h[1]=usat16(Vu.uw[i] +
                                                              (1<<(shamt-1)) >> shamt) ;
                                                              }
                   Vd.uh=vasr(Vu.w,Vv.w,Rt)[:rnd]:sat         for (i = 0; i < VELEM(32); i++) {
                                                                   shamt = Rt & 0xF;
                                                                   Vd.w[i].h[0]=usat16(Vv.w[i] +
                                                              (1<<(shamt-1)) >> shamt);
                                                                   Vd.w[i].h[1]=usat16(Vu.w[i] +
                                                              (1<<(shamt-1)) >> shamt) ;
                                                              }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This may not work correctly in Napali V1.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    230
Hexagon V66 HVX Programmer’s Reference Manual                                                         Instruction Set
                       ■   Input scalar register Rt is limited to registers 0 through 7
                       ■   This instruction uses the HVX shift resource.
                  Intrinsics
                   Vd.b=vasr(Vu.h,Vv.h,Rt):rnd:sat            HVX_Vector
                                                              Q6_Vb_vasr_VhVhR_rnd_sat(HVX_Vector Vu,
                                                              HVX_Vector Vv, Word32 Rt)
                   Vd.b=vasr(Vu.h,Vv.h,Rt):sat                HVX_Vector Q6_Vb_vasr_VhVhR_sat(HVX_Vector
                                                              Vu, HVX_Vector Vv, Word32 Rt)
                   Vd.h=vasr(Vu.w,Vv.w,Rt)                    HVX_Vector Q6_Vh_vasr_VwVwR(HVX_Vector Vu,
                                                              HVX_Vector Vv, Word32 Rt)
                   Vd.h=vasr(Vu.w,Vv.w,Rt):rnd:sat            HVX_Vector
                                                              Q6_Vh_vasr_VwVwR_rnd_sat(HVX_Vector Vu,
                                                              HVX_Vector Vv, Word32 Rt)
                   Vd.h=vasr(Vu.w,Vv.w,Rt):sat                HVX_Vector Q6_Vh_vasr_VwVwR_sat(HVX_Vector
                                                              Vu, HVX_Vector Vv, Word32 Rt)
                   Vd.ub=vasr(Vu.h,Vv.h,Rt):rnd:sat           HVX_Vector
                                                              Q6_Vub_vasr_VhVhR_rnd_sat(HVX_Vector Vu,
                                                              HVX_Vector Vv, Word32 Rt)
                   Vd.ub=vasr(Vu.h,Vv.h,Rt):sat               HVX_Vector Q6_Vub_vasr_VhVhR_sat(HVX_Vector
                                                              Vu, HVX_Vector Vv, Word32 Rt)
                   Vd.ub=vasr(Vu.uh,Vv.uh,Rt):rnd:sat         HVX_Vector
                                                              Q6_Vub_vasr_VuhVuhR_rnd_sat(HVX_Vector Vu,
                                                              HVX_Vector Vv, Word32 Rt)
                   Vd.ub=vasr(Vu.uh,Vv.uh,Rt):sat             HVX_Vector Q6_Vub_vasr_VuhVuhR_sat(HVX_Vector
                                                              Vu, HVX_Vector Vv, Word32 Rt)
                   Vd.uh=vasr(Vu.uw,Vv.uw,Rt):rnd:sat         HVX_Vector
                                                              Q6_Vuh_vasr_VuwVuwR_rnd_sat(HVX_Vector Vu,
                                                              HVX_Vector Vv, Word32 Rt)
                   Vd.uh=vasr(Vu.uw,Vv.uw,Rt):sat             HVX_Vector Q6_Vuh_vasr_VuwVuwR_sat(HVX_Vector
                                                              Vu, HVX_Vector Vv, Word32 Rt)
                   Vd.uh=vasr(Vu.w,Vv.w,Rt):rnd:sat           HVX_Vector
                                                              Q6_Vuh_vasr_VwVwR_rnd_sat(HVX_Vector Vu,
                                                              HVX_Vector Vv, Word32 Rt)
                   Vd.uh=vasr(Vu.w,Vv.w,Rt):sat               HVX_Vector Q6_Vuh_vasr_VwVwR_sat(HVX_Vector
                                                              Vu, HVX_Vector Vv, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8  7  6  5  4 3 2   1 0
   ICLASS                                 t3    Parse          u5                   d5
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 0   0  0  d d d   d d Vd.b=vasr(Vu.h,Vv.h,Rt):sat
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 0   0  1  d d d   d d Vd.uh=vasr(Vu.uw,Vv.uw,Rt
                                                                                            ):rnd:sat
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 0   1  0  d d d   d d Vd.uh=vasr(Vu.w,Vv.w,Rt):r
                                                                                            nd:sat
                                                                                            Vd.ub=vasr(Vu.uh,Vv.uh,Rt
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 1   1  1  d d d   d d ):rnd:sat
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 1  u  u   u u u 1   0  0  d d d   d d Vd.uh=vasr(Vu.uw,Vv.uw,Rt
                                                                                            ):sat
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                           231
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
                                                                                          Vd.ub=vasr(Vu.uh,Vv.uh,Rt
 0  0 0  1  1  0   0 0   v  v  v  v  v  t   t  t P  P 1   u  u  u u u 1 0 1  d  d d  d  d
                                                                                          ):sat
 0  0 0  1  1  0   1 1   v  v  v  v  v  t   t  t P  P 0   u  u  u u u 0 1 0  d  d d  d  d Vd.h=vasr(Vu.w,Vv.w,Rt)
                                                                                          Vd.h=vasr(Vu.w,Vv.w,Rt):sa
 0  0 0  1  1  0   1 1   v  v  v  v  v  t   t  t P  P 0   u  u  u u u 0 1 1  d  d d  d  d
                                                                                          t
 0  0 0  1  1  0   1 1   v  v  v  v  v  t   t  t P  P 0   u  u  u u u 1 0 0  d  d d  d  d Vd.h=vasr(Vu.w,Vv.w,Rt):rn
                                                                                          d:sat
                                                                                          Vd.uh=vasr(Vu.w,Vv.w,Rt):s
 0  0 0  1  1  0   1 1   v  v  v  v  v  t   t  t P  P 0   u  u  u u u 1 0 1  d  d d  d  d
                                                                                          at
                                                                                          Vd.ub=vasr(Vu.h,Vv.h,Rt):s
 0  0 0  1  1  0   1 1   v  v  v  v  v  t   t  t P  P 0   u  u  u u u 1 1 0  d  d d  d  d at
                                                                                          Vd.ub=vasr(Vu.h,Vv.h,Rt):r
 0  0 0  1  1  0   1 1   v  v  v  v  v  t   t  t P  P 0   u  u  u u u 1 1 1  d  d d  d  d
                                                                                          nd:sat
                                                                                          Vd.b=vasr(Vu.h,Vv.h,Rt):rn
 0  0 0  1  1  0   1 1   v  v  v  v  v  t   t  t P  P 1   u  u  u u u 0 0 0  d  d d  d  d d:sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t3                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  v3                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         232
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
         Compute contiguous offsets for valid positions
                  Perform a cumulative sum of the bits in the predicate register.
                  Using the prefix sum instruction (prefixsum) to compute contiguous offsets for valid
                  positions when processing and consolidating sparse data is faster than dynamically
                  computing the permute codeword for vdelta.
     Input    A     -     B    -      C     D     E     -     F        ...
 Predicate    1     0     1    0      1     1     1    0      1        ...
                                                                                  prefixsum
     Offset   1     1     2    2      3     4     5    5      6        ...
                                                                                                       scatter
    Output    A     B     C    D      E     F                   ...
                                                Vd32.h = prefixsum(qv4)
                                 ...                  q[5]     q[4]  q[3]    q[2]    q[1]     q[0]    Qv
                                                            +              +               +
                           Remained of the                                 +
                               adders
                                                            +
                                  ...                     h[2]           h[1]             h[0]        Vd
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       233
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                   Syntax                                   Behavior
                   Vd.b=prefixsum(Qv4)                      for (i = 0; i < VELEM(8); i++) {
                                                                 acc += QvV[i];
                                                                 Vd.ub[i] = acc;
                                                            }
                   Vd.h=prefixsum(Qv4)                      for (i = 0; i < VELEM(16); i++) {
                                                                 acc += QvV[i*2+0];
                                                                 acc += QvV[i*2+1];
                                                                 Vd.uh[i] = acc;
                                                            }
                   Vd.w=prefixsum(Qv4)                      for (i = 0; i < VELEM(32); i++) {
                                                                 acc += QvV[i*4+0];
                                                                 acc += QvV[i*4+1];
                                                                 acc += QvV[i*4+2];
                                                                 acc += QvV[i*4+3];
                                                                 Vd.uw[i] = acc;
                                                            }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses the HVX shift resource.
                  Intrinsics
                   Vd.b=prefixsum(Qv4)                      HVX_Vector Q6_Vb_prefixsum_Q(HVX_VectorPred Qv)
                   Vd.h=prefixsum(Qv4)                      HVX_Vector Q6_Vh_prefixsum_Q(HVX_VectorPred Qv)
                   Vd.w=prefixsum(Qv4)                      HVX_Vector Q6_Vw_prefixsum_Q(HVX_VectorPred Qv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9   8 7  6 5  4 3 2  1 0
   ICLASS                                        Parse                              d5
 0  0  0  1 1  1   1 0   v  v 0   -  -  -  1  1  P   P 1  -   - 0  0 0  0 1  0  d d d  d d Vd.b=prefixsum(Qv4)
 0  0  0  1 1  1   1 0   v  v 0   -  -  -  1  1  P   P 1  -   - 0  0 1  0 1  0  d d d  d d Vd.h=prefixsum(Qv4)
 0  0  0  1 1  1   1 0   v  v 0   -  -  -  1  1  P   P 1  -   - 0  1 0  0 1  0  d d d  d d Vd.w=prefixsum(Qv4)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  v2                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        234
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
        Shift and add
                  Each element in the vector register Vu is arithmetically shifted right by the value specified
                  by the lower bits of the scalar register Rt. The result is then added to the destination vector
                  register Vx. For signed word shifts, the lower five bits of Rt specify the shift amount.
                  The left shift does not saturate the result to the element size.
                                  Vx.w += vasr(Vu.w,Rt)
                               w[N-1]                                w[1]            w[0]         Vu
                                                                                             Shift right, and
                                  >>                                   >>             >>    sign fill, by lower
                                                                                                5 bits of Rt
                                   +                                    +              +
                               w[N-1]                                w[1]            w[0]         Vx
                           *N is the number of operations implemented in each vector
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         235
Hexagon V66 HVX Programmer’s Reference Manual                                                    Instruction Set
                                 Vx.w += vasl(Vu.w,Rt)
                              w[N-1]                                w[1]            w[0]       Vu
                                                                                             Shift by lower
                                 <<                                   <<             <<
                                                                                              5 bits of Rt
                                  +                                    +              +
                              w[N-1]                                w[1]            w[0]       Vx
                          *N is the number of operations implemented in each vector
                   Syntax                                  Behavior
                   Vx.h+=vasl(Vu.h,Rt)                     for (i = 0; i < VELEM(16); i++) {
                                                               Vx.h[i] += (Vu.h[i] << (Rt & (16-1))) ;
                                                           }
                   Vx.h+=vasr(Vu.h,Rt)                     for (i = 0; i < VELEM(16); i++) {
                                                               Vx.h[i] += (Vu.h[i] >> (Rt & (16-1))) ;
                                                           }
                   Vx.w+=vasl(Vu.w,Rt)                     for (i = 0; i < VELEM(32); i++) {
                                                               Vx.w[i] += (Vu.w[i] << (Rt & (32-1))) ;
                                                           }
                   Vx.w+=vasr(Vu.w,Rt)                     for (i = 0; i < VELEM(32); i++) {
                                                               Vx.w[i] += (Vu.w[i] >> (Rt & (32-1))) ;
                                                           }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This may not work correctly in Napali V1.
                       ■  This instruction uses the HVX shift resource.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     236
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
                  Intrinsics
                   Vx.h+=vasl(Vu.h,Rt)                     HVX_Vector Q6_Vh_vaslacc_VhVhR(HVX_Vector Vx,
                                                           HVX_Vector Vu, Word32 Rt)
                   Vx.h+=vasr(Vu.h,Rt)                     HVX_Vector Q6_Vh_vasracc_VhVhR(HVX_Vector Vx,
                                                           HVX_Vector Vu, Word32 Rt)
                   Vx.w+=vasl(Vu.w,Rt)                     HVX_Vector Q6_Vw_vaslacc_VwVwR(HVX_Vector Vx,
                                                           HVX_Vector Vu, Word32 Rt)
                   Vx.w+=vasr(Vu.w,Rt)                     HVX_Vector Q6_Vw_vasracc_VwVwR(HVX_Vector Vx,
                                                           HVX_Vector Vu, Word32 Rt)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                               t5       Parse         u5                 x5
 0  0  0  1 1  0   0 1  0  1  1   t  t   t  t  t P   P 1  u  u  u u u 0  1 0  x x  x x  x Vx.w+=vasl(Vu.w,Rt)
 0  0  0  1 1  0   0 1  0  1  1   t  t   t  t  t P   P 1  u  u  u u u 1  0 1  x x  x x  x Vx.w+=vasr(Vu.w,Rt)
 0  0  0  1 1  0   0 1  1  0  0   t  t   t  t  t P   P 1  u  u  u u u 1  1 1  x x  x x  x Vx.h+=vasr(Vu.h,Rt)
 0  0  0  1 1  0   0 1  1  0  1   t  t   t  t  t P   P 1  u  u  u u u 1  0 1  x x  x x  x Vx.h+=vasl(Vu.h,Rt)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  t5                Field to encode register t
                  u5                Field to encode register u
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                      237
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
        Shift
                  Each element in the vector register Vu is arithmetically (logically) shifted right (left) by
                  the value specified in the lower bits of the corresponding element of vector register Vv (or
                  scalar register Rt). For halfword shifts the lower 4 bits are used, while for word shifts the
                  lower 5 bits are used.
                  The logical left shift does not saturate the result to the element size.
               Vd.w=vlsr(Vu.w,Rt)
                                          Rt                                                Rt
                                        Don’t                                            Don’t
                       [N-1]                                               [0]                        Vu
                                         care                                              care
                                                                                                    Logical
                                                     N-1 to 1                                       Shift by Rt
                   Zero fill        [N-1]                            Zero fill          [0]           Vd
                 Vd.w=vasl(Vu.w,Rt)
                       Rt                                                 Rt
                     Don’t                                              Don’t
                                       [N-1]                                              [0]           Vu
                      care                                               care
                                                                                                      Shift left
                                                       N-1 to 1                                       by Rt
                         [N-1]           Zero fill                           [0]          Zero fill     Vd
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        238
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
            Syntax                                    Behavior
             Vd.b=vasr(Vu.h,Vv.h,Rt)[:rnd]:sat         for (i = 0; i < VELEM(16); i++) {
                                                             shamt = Rt & 0x7;
                                                             Vd.h[i].b[0]=sat8(Vv.h[i] + (1<<(shamt-1))
                                                       >> shamt);
                                                             Vd.h[i].b[1]=sat8(Vu.h[i] + (1<<(shamt-1))
                                                       >> shamt) ;
                                                       }
             Vd.h=vasl(Vu.h,Rt)                        for (i = 0; i < VELEM(16); i++) {
                                                             Vd.h[i] = (Vu.h[i] << (Rt & (16-1))) ;
                                                       }
             Vd.h=vasl(Vu.h,Vv.h)                      for (i = 0; i < VELEM(16); i++) {
                                                             Vd.h[i] = (sxt(4+1)-
                                                       >16(Vv.h[i])>0)?(Vu.h[i]<<sxt(4+1)-
                                                       >16(Vv.h[i])):(Vu.h[i]>>sxt(4+1)->16(Vv.h[i])) ;
                                                       }
             Vd.h=vasr(Vu.h,Rt)                        for (i = 0; i < VELEM(16); i++) {
                                                             Vd.h[i] = (Vu.h[i] >> (Rt & (16-1))) ;
                                                       }
             Vd.h=vasr(Vu.h,Vv.h)                      for (i = 0; i < VELEM(16); i++) {
                                                             Vd.h[i] = (sxt(4+1)-
                                                       >16 (Vv.h[i])>0)?(Vu.h[i]>>sxt (4+1)-
                                                       >16(Vv.h[i])):(Vu.h[i]<<sxt(4+1)->16(Vv.h[i])) ;
                                                       }
             Vd.h=vasr(Vu.w,Vv.w,Rt):rnd:sat           for (i = 0; i < VELEM(32); i++) {
                                                             shamt = Rt & 0xF;
                                                             Vd.w[i].h[0]=sat16(Vv.w[i] + (1<<(shamt-1))
                                                       >> shamt);
                                                             Vd.w[i].h[1]=sat16(Vu.w[i] + (1<<(shamt-1))
                                                       >> shamt) ;
                                                       }
             Vd.h=vasr(Vu.w,Vv.w,Rt)[:sat]             for (i = 0; i < VELEM(32); i++) {
                                                             shamt = Rt & 0xF;
                                                             Vd.w[i].h[0]=[sat16](Vv.w[i] >> shamt);
                                                             Vd.w[i].h[1]=[sat16](Vu.w[i] >> shamt) ;
                                                       }
             Vd.h=vlsr(Vu.h,Vv.h)                      for (i = 0; i < VELEM(16); i++) {
                                                             Vd.uh[i] = (sxt(4+1)-
                                                       >16(Vv.h[i])>0)?(Vu.uh[i]>>>sxt(4+1)-
                                                       >16(Vv.h[i])):(Vu.uh[i]<<sxt(4+1)->16(Vv.h[i])) ;
                                                       }
             Vd.ub=vasr(Vu.h,Vv.h,Rt)[:rnd]:sat        for (i = 0; i < VELEM(16); i++) {
                                                             shamt = Rt & 0x7;
                                                             Vd.h[i].b[0]=usat8(Vv.h[i] + (1<<(shamt-1))
                                                       >> shamt);
                                                             Vd.h[i].b[1]=usat8(Vu.h[i] + (1<<(shamt-1))
                                                       >> shamt) ;
                                                       }
80-N2040-44 Rev. B    MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    239
Hexagon V66 HVX Programmer’s Reference Manual                                                  Instruction Set
            Syntax                                    Behavior
             Vd.ub=vasr(Vu.uh,Vv.uh,Rt)[:rnd]:sat for (i = 0; i < VELEM(16); i++) {
                                                             shamt = Rt & 0x7;
                                                             Vd.uh[i].b[0]=usat8(Vv.uh[i] + (1<<(shamt-
                                                       1)) >> shamt);
                                                             Vd.uh[i].b[1]=usat8(Vu.uh[i] + (1<<(shamt-
                                                       1)) >> shamt) ;
                                                       }
             Vd.ub=vlsr(Vu.ub,Rt)                      for (i = 0; i < VELEM(8); i++) {
                                                             Vd.b[i] = Vu.ub[i] >> (Rt & 0x7) ;
                                                       }
             Vd.uh=vasr(Vu.uw,Vv.uw,Rt)[:rnd]:sat for (i = 0; i < VELEM(32); i++) {
                                                             shamt = Rt & 0xF;
                                                             Vd.uw[i].h[0]=usat16(Vv.uw[i] + (1<<(shamt-
                                                       1)) >> shamt);
                                                             Vd.uw[i].h[1]=usat16(Vu.uw[i] + (1<<(shamt-
                                                       1)) >> shamt) ;
                                                       }
             Vd.uh=vasr(Vu.w,Vv.w,Rt)[:rnd]:sat        for (i = 0; i < VELEM(32); i++) {
                                                             shamt = Rt & 0xF;
                                                             Vd.w[i].h[0]=usat16(Vv.w[i] + (1<<(shamt-1))
                                                       >> shamt);
                                                             Vd.w[i].h[1]=usat16(Vu.w[i] + (1<<(shamt-1))
                                                       >> shamt) ;
                                                       }
             Vd.uh=vlsr(Vu.uh,Rt)                      for (i = 0; i < VELEM(16); i++) {
                                                             Vd.uh[i] = (Vu.uh[i] >> (Rt & (16-1))) ;
                                                       }
             Vd.uw=vlsr(Vu.uw,Rt)                      for (i = 0; i < VELEM(32); i++) {
                                                             Vd.uw[i] = (Vu.uw[i] >> (Rt & (32-1))) ;
                                                       }
             Vd.w=vasl(Vu.w,Rt)                        for (i = 0; i < VELEM(32); i++) {
                                                             Vd.w[i] = (Vu.w[i] << (Rt & (32-1))) ;
                                                       }
             Vd.w=vasl(Vu.w,Vv.w)                      for (i = 0; i < VELEM(32); i++) {
                                                             Vd.w[i] = (sxt(5+1)-
                                                       >32 (Vv.w[i])>0)?(Vu.w[i]<<sxt (5+1)-
                                                       >32(Vv.w[i])):(Vu.w[i]>>sxt(5+1)->32(Vv.w[i])) ;
                                                       }
             Vd.w=vasr(Vu.w,Rt)                        for (i = 0; i < VELEM(32); i++) {
                                                             Vd.w[i] = (Vu.w[i] >> (Rt & (32-1))) ;
                                                       }
             Vd.w=vasr(Vu.w,Vv.w)                      for (i = 0; i < VELEM(32); i++) {
                                                             Vd.w[i] = (sxt(5+1)-
                                                       >32 (Vv.w[i])>0)?(Vu.w[i]>>sxt (5+1)-
                                                       >32(Vv.w[i])):(Vu.w[i]<<sxt(5+1)->32(Vv.w[i])) ;
                                                       }
             Vd.w=vlsr(Vu.w,Vv.w)                      for (i = 0; i < VELEM(32); i++) {
                                                             Vd.uw[i] = (sxt(5+1)-
                                                       >32 (Vv.w[i])>0)?(Vu.uw[i]>>>sxt (5+1)-
                                                       >32(Vv.w[i])):(Vu.uw[i]<<sxt(5+1)->32(Vv.w[i])) ;
                                                       }
80-N2040-44 Rev. B    MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     240
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This may not work correctly in Napali V1.
                       ■  Input scalar register Rt is limited to registers 0 through 7
                       ■  This instruction uses the HVX shift resource.
                  Intrinsics
              Vd.b=vasr(Vu.h,Vv.h,Rt):rnd:sat            HVX_Vector Q6_Vb_vasr_VhVhR_rnd_sat(HVX_Vector
                                                         Vu, HVX_Vector Vv, Word32 Rt)
              Vd.b=vasr(Vu.h,Vv.h,Rt):sat                HVX_Vector Q6_Vb_vasr_VhVhR_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv, Word32 Rt)
              Vd.h=vasl(Vu.h,Rt)                         HVX_Vector Q6_Vh_vasl_VhR(HVX_Vector Vu, Word32
                                                         Rt)
              Vd.h=vasl(Vu.h,Vv.h)                       HVX_Vector Q6_Vh_vasl_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
              Vd.h=vasr(Vu.h,Rt)                         HVX_Vector Q6_Vh_vasr_VhR(HVX_Vector Vu, Word32
                                                         Rt)
              Vd.h=vasr(Vu.h,Vv.h)                       HVX_Vector Q6_Vh_vasr_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
              Vd.h=vasr(Vu.w,Vv.w,Rt)                    HVX_Vector Q6_Vh_vasr_VwVwR(HVX_Vector Vu,
                                                         HVX_Vector Vv, Word32 Rt)
              Vd.h=vasr(Vu.w,Vv.w,Rt):rnd:sat            HVX_Vector Q6_Vh_vasr_VwVwR_rnd_sat(HVX_Vector
                                                         Vu, HVX_Vector Vv, Word32 Rt)
              Vd.h=vasr(Vu.w,Vv.w,Rt):sat                HVX_Vector Q6_Vh_vasr_VwVwR_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv, Word32 Rt)
              Vd.h=vlsr(Vu.h,Vv.h)                       HVX_Vector Q6_Vh_vlsr_VhVh(HVX_Vector Vu,
                                                         HVX_Vector Vv)
              Vd.ub=vasr(Vu.h,Vv.h,Rt):rnd:sat           HVX_Vector Q6_Vub_vasr_VhVhR_rnd_sat(HVX_Vector
                                                         Vu, HVX_Vector Vv, Word32 Rt)
              Vd.ub=vasr(Vu.h,Vv.h,Rt):sat               HVX_Vector Q6_Vub_vasr_VhVhR_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv, Word32 Rt)
              Vd.ub=vasr(Vu.uh,Vv.uh,Rt):rnd:sat         HVX_Vector
                                                         Q6_Vub_vasr_VuhVuhR_rnd_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv, Word32 Rt)
              Vd.ub=vasr(Vu.uh,Vv.uh,Rt):sat             HVX_Vector Q6_Vub_vasr_VuhVuhR_sat(HVX_Vector
                                                         Vu, HVX_Vector Vv, Word32 Rt)
              Vd.ub=vlsr(Vu.ub,Rt)                       HVX_Vector Q6_Vub_vlsr_VubR(HVX_Vector Vu,
                                                         Word32 Rt)
              Vd.uh=vasr(Vu.uw,Vv.uw,Rt):rnd:sat         HVX_Vector
                                                         Q6_Vuh_vasr_VuwVuwR_rnd_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv, Word32 Rt)
              Vd.uh=vasr(Vu.uw,Vv.uw,Rt):sat             HVX_Vector Q6_Vuh_vasr_VuwVuwR_sat(HVX_Vector
                                                         Vu, HVX_Vector Vv, Word32 Rt)
              Vd.uh=vasr(Vu.w,Vv.w,Rt):rnd:sat           HVX_Vector Q6_Vuh_vasr_VwVwR_rnd_sat(HVX_Vector
                                                         Vu, HVX_Vector Vv, Word32 Rt)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  241
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
               Vd.uh=vasr(Vu.w,Vv.w,Rt):sat                HVX_Vector Q6_Vuh_vasr_VwVwR_sat(HVX_Vector Vu,
                                                           HVX_Vector Vv, Word32 Rt)
               Vd.uh=vlsr(Vu.uh,Rt)                        HVX_Vector Q6_Vuh_vlsr_VuhR(HVX_Vector Vu,
                                                           Word32 Rt)
               Vd.uw=vlsr(Vu.uw,Rt)                        HVX_Vector Q6_Vuw_vlsr_VuwR(HVX_Vector Vu,
                                                           Word32 Rt)
               Vd.w=vasl(Vu.w,Rt)                          HVX_Vector Q6_Vw_vasl_VwR(HVX_Vector Vu, Word32
                                                           Rt)
               Vd.w=vasl(Vu.w,Vv.w)                        HVX_Vector Q6_Vw_vasl_VwVw(HVX_Vector Vu,
                                                           HVX_Vector Vv)
               Vd.w=vasr(Vu.w,Rt)                          HVX_Vector Q6_Vw_vasr_VwR(HVX_Vector Vu, Word32
                                                           Rt)
               Vd.w=vasr(Vu.w,Vv.w)                        HVX_Vector Q6_Vw_vasr_VwVw(HVX_Vector Vu,
                                                           HVX_Vector Vv)
               Vd.w=vlsr(Vu.w,Vv.w)                        HVX_Vector Q6_Vw_vlsr_VwVw(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                                 t3    Parse          u5                 d5
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 0  0 0  d d  d d  d Vd.b=vasr(Vu.h,Vv.h,Rt):sat
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 0  0 1  d d  d d  d Vd.uh=vasr(Vu.uw,Vv.uw,Rt
                                                                                          ):rnd:sat
                                                                                          Vd.uh=vasr(Vu.w,Vv.w,Rt):r
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 0  1 0  d d  d d  d nd:sat
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 1  1 1  d d  d d  d Vd.ub=vasr(Vu.uh,Vv.uh,Rt
                                                                                          ):rnd:sat
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 1  u  u   u u u 1  0 0  d d  d d  d Vd.uh=vasr(Vu.uw,Vv.uw,Rt
                                                                                          ):sat
                                                                                          Vd.ub=vasr(Vu.uh,Vv.uh,Rt
 0  0  0  1 1  0   0 0   v  v  v  v  v  t  t  t P   P 1  u  u   u u u 1  0 1  d d  d d  d ):sat
   ICLASS                              t5       Parse          u5                 d5
 0  0  0  1 1  0   0 1  0  1  1   t  t  t  t  t P   P 0  u  u   u u u 1  0 1  d d  d d  d Vd.w=vasr(Vu.w,Rt)
 0  0  0  1 1  0   0 1  0  1  1   t  t  t  t  t P   P 0  u  u   u u u 1  1 0  d d  d d  d Vd.h=vasr(Vu.h,Rt)
 0  0  0  1 1  0   0 1  0  1  1   t  t  t  t  t P   P 0  u  u   u u u 1  1 1  d d  d d  d Vd.w=vasl(Vu.w,Rt)
 0  0  0  1 1  0   0 1  1  0  0   t  t  t  t  t P   P 0  u  u   u u u 0  0 0  d d  d d  d Vd.h=vasl(Vu.h,Rt)
 0  0  0  1 1  0   0 1  1  0  0   t  t  t  t  t P   P 0  u  u   u u u 0  0 1  d d  d d  d Vd.uw=vlsr(Vu.uw,Rt)
 0  0  0  1 1  0   0 1  1  0  0   t  t  t  t  t P   P 0  u  u   u u u 0  1 0  d d  d d  d Vd.uh=vlsr(Vu.uh,Rt)
 0  0  0  1 1  0   0 1  1  0  0   t  t  t  t  t P   P 0  u  u   u u u 0  1 1  d d  d d  d Vd.ub=vlsr(Vu.ub,Rt)
   ICLASS                                 t3    Parse          u5                 d5
 0  0  0  1 1  0   1 1   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 0  1 0  d d  d d  d Vd.h=vasr(Vu.w,Vv.w,Rt)
                                                                                          Vd.h=vasr(Vu.w,Vv.w,Rt):sa
 0  0  0  1 1  0   1 1   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 0  1 1  d d  d d  d t
 0  0  0  1 1  0   1 1   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 1  0 0  d d  d d  d Vd.h=vasr(Vu.w,Vv.w,Rt):rn
                                                                                          d:sat
 0  0  0  1 1  0   1 1   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 1  0 1  d d  d d  d Vd.uh=vasr(Vu.w,Vv.w,Rt):s
                                                                                          at
                                                                                          Vd.ub=vasr(Vu.h,Vv.h,Rt):s
 0  0  0  1 1  0   1 1   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 1  1 0  d d  d d  d at
 0  0  0  1 1  0   1 1   v  v  v  v  v  t  t  t P   P 0  u  u   u u u 1  1 1  d d  d d  d Vd.ub=vasr(Vu.h,Vv.h,Rt):r
                                                                                          nd:sat
 0  0  0  1 1  0   1 1   v  v  v  v  v  t  t  t P   P 1  u  u   u u u 0  0 0  d d  d d  d Vd.b=vasr(Vu.h,Vv.h,Rt):rn
                                                                                          d:sat
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         242
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   1 1  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0 0 0  d  d d  d  d Vd.w=vasr(Vu.w,Vv.w)
 0  0  0  1 1  1   1 1  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0 0 1  d  d d  d  d Vd.w=vlsr(Vu.w,Vv.w)
 0  0  0  1 1  1   1 1  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0 1 0  d  d d  d  d Vd.h=vlsr(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 0 1 1  d  d d  d  d Vd.h=vasr(Vu.h,Vv.h)
 0  0  0  1 1  1   1 1  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1 0 0  d  d d  d  d Vd.w=vasl(Vu.w,Vv.w)
 0  0  0  1 1  1   1 1  1  0  1   v  v  v  v  v  P   P 0  u  u  u u u 1 0 1  d  d d  d  d Vd.h=vasl(Vu.h,Vv.h)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  t3                Field to encode register t
                  t5                Field to encode register t
                  u5                Field to encode register u
                  v2                Field to encode register v
                  v3                Field to encode register v
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       243
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
        Round to next smaller element size
                  Pack signed words to signed or unsigned halfwords, add 0x8000 to the lower 16 bits,
                  logically or arithmetically right-shift by 16, and saturate the results to unsigned or signed
                  halfwords respectively. Alternatively pack signed halfwords to signed or unsigned bytes,
                  add 0x80 to the lower 8 bits, logically or arithmetically right-shift by 8, and saturate the
                  results to unsigned or signed bytes respectively. The odd elements in the destination vector
                  register Vd come from vector register Vv, and the even elements from Vu.
                     Vd.b=vround(Vu.h,Vv.h):sat
                         h[N-1]                              h[1]             h[0]           Vu
                         h[N-1]                              h[1]             h[0]           Vv
                     +0x80    +0x80                     +0x80    +0x80   +0x80    +0x80       Round
                      >>8      >>8                       >>8      >>8     >>8      >>8       Shift by 8
                                                                                              Saturate
                       sat     sat                       sat      sat     sat      sat           to
                                                                                                Byte
                     b[2N-1] b[2N-2]                     b[3]     b[2]    b[1]     b[0]      Vd
                   Syntax                                Behavior
                   Vd.b=vround(Vu.h,Vv.h):sat            for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i].b[0]=sat8((Vv.h[i] + 0x80) >> 8);
                                                              Vd.uh[i].b[1]=sat8((Vu.h[i] + 0x80) >> 8) ;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        244
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
                   Syntax                               Behavior
                   Vd.h=vround(Vu.w,Vv.w):sat            for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uw[i].h[0]=sat16((Vv.w[i] + 0x8000) >>
                                                         16);
                                                              Vd.uw[i].h[1]=sat16((Vu.w[i] + 0x8000) >> 16)
                                                         ;
                                                         }
                   Vd.ub=vround(Vu.h,Vv.h):sat           for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i].b[0]=usat8((Vv.h[i] + 0x80) >> 8);
                                                              Vd.uh[i].b[1]=usat8((Vu.h[i] + 0x80) >> 8) ;
                                                         }
                   Vd.ub=vround(Vu.uh,Vv.uh):sat         for (i = 0; i < VELEM(16); i++) {
                                                              Vd.uh[i].b[0]=usat8((Vv.uh[i] + 0x80) >> 8);
                                                              Vd.uh[i].b[1]=usat8((Vu.uh[i] + 0x80) >> 8)
                                                         ;
                                                         }
                   Vd.uh=vround(Vu.uw,Vv.uw):sat         for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uw[i].h[0]=usat16((Vv.uw[i] + 0x8000) >>
                                                         16);
                                                              Vd.uw[i].h[1]=usat16((Vu.uw[i] + 0x8000) >>
                                                         16) ;
                                                         }
                   Vd.uh=vround(Vu.w,Vv.w):sat           for (i = 0; i < VELEM(32); i++) {
                                                              Vd.uw[i].h[0]=usat16((Vv.w[i] + 0x8000) >>
                                                         16);
                                                              Vd.uw[i].h[1]=usat16((Vu.w[i] + 0x8000) >>
                                                         16) ;
                                                         }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This instruction uses the HVX shift resource.
                  Intrinsics
                   Vd.b=vround(Vu.h,Vv.h):sat            HVX_Vector Q6_Vb_vround_VhVh_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.h=vround(Vu.w,Vv.w):sat            HVX_Vector Q6_Vh_vround_VwVw_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.ub=vround(Vu.h,Vv.h):sat           HVX_Vector Q6_Vub_vround_VhVh_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
                   Vd.ub=vround(Vu.uh,Vv.uh):sat         HVX_Vector Q6_Vub_vround_VuhVuh_sat(HVX_Vector
                                                         Vu, HVX_Vector Vv)
                   Vd.uh=vround(Vu.uw,Vv.uw):sat         HVX_Vector Q6_Vuh_vround_VuwVuw_sat(HVX_Vector
                                                         Vu, HVX_Vector Vv)
                   Vd.uh=vround(Vu.w,Vv.w):sat           HVX_Vector Q6_Vuh_vround_VwVw_sat(HVX_Vector Vu,
                                                         HVX_Vector Vv)
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    245
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                                        Parse         u5                 d5
                                                                                          Vd.h=vround(Vu.w,Vv.w):sa
 0  0  0  1 1  1   1 1  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 1 0 0  d  d d  d  d
                                                                                          t
 0  0  0  1 1  1   1 1  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 1 0 1  d  d d  d  d Vd.uh=vround(Vu.w,Vv.w):s
                                                                                          at
 0  0  0  1 1  1   1 1  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 1 1 0  d  d d  d  d Vd.b=vround(Vu.h,Vv.h):sat
                                                                                          Vd.ub=vround(Vu.h,Vv.h):s
 0  0  0  1 1  1   1 1  0  1  1   v  v  v  v  v  P   P 0  u  u  u u u 1 1 1  d  d d  d  d
                                                                                          at
                                                                                          Vd.ub=vround(Vu.uh,Vv.uh)
 0  0  0  1 1  1   1 1  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 0 1 1  d  d d  d  d
                                                                                          :sat
 0  0  0  1 1  1   1 1  1  1  1   v  v  v  v  v  P   P 0  u  u  u u u 1 0 0  d  d d  d  d Vd.uh=vround(Vu.uw,Vv.uw
                                                                                          ):sat
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        246
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
          Vector rotate right word
                  Rotate right each element of Vu.w by the unsigned amount specified by bits 4:0 of the
                  corresponding element of Vv.w, place the result in respective elements of Vd.w.
                   Syntax                           Behavior
                   Vd.w=vrotr(Vu.uw,Vv.uw)           for (i = 0; i < VELEM(32); i++) {
                                                         Vd.uw[i] = ((Vu.uw[i] >> (Vv.uw[i] & 0x1f)) |
                                                     (Vu.uw[i] << (32 - (Vv.uw[i] & 0x1f)))) ;
                                                     }
                   Vd=vrotr(Vu,Vv)                   Assembler mapped to: "Vd.w=vrotr(Vu.uw,Vv.uw)"
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■   This instruction uses the HVX shift resource.
                  Intrinsics
                   Vd.w=vrotr(Vu.uw,Vv.uw)          HVX_Vector Q6_Vw_vrotr_VuwVuw(HVX_Vector Vu,
                                                    HVX_Vector Vv)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3 2  1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  0   1 0  1  0  0   v  v  v  v  v  P   P 1  u  u  u u u 1 1  1  d d d  d  d Vd.w=vrotr(Vu.uw,Vv.uw)
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        247
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
        Bit counting
                  The bit counting operations are applied to each vector element in a vector register Vu,
                  place the result in the corresponding element in the vector destination register Vd.
                  Count leading zeros (vcl0) counts the number of consecutive zeros starting with the most
                  significant bit. It supports unsigned halfword and word. Population count (vpopcount)
                  counts the number of non-zero bits in a halfword element. Normalization amount
                  (vnormamt) counts the number of bits for normalization (consecutive sign bits minus one,
                  with zero treated specially). Count leading identical bits, and add a value to it for each
                  lane.
                   Syntax                             Behavior
                   Vd.h=vadd(vclb(Vu.h),Vv.h)          for (i = 0; i < VELEM(16); i++) {
                                                           Vd.h[i] =
                                                       max(count_leading_ones(~Vu.h[i]),count_leading_ones
                                                       (Vu.h[i])) + Vv.h[i] ;
                                                       }
                   Vd.h=vnormamt(Vu.h)                 for (i = 0; i < VELEM(16); i++) {
                                                           Vd.h[i]=max(count_leading_ones(~Vu.h[i]),count_
                                                       leading_ones(Vu.h[i]))-1;
                                                       ;
                                                       }
                   Vd.h=vpopcount(Vu.h)                for (i = 0; i < VELEM(16); i++) {
                                                           Vd.uh[i]=count_ones(Vu.uh[i]) ;
                                                       }
                   Vd.uh=vcl0(Vu.uh)                   for (i = 0; i < VELEM(16); i++) {
                                                           Vd.uh[i]=count_leading_ones(~Vu.uh[i]) ;
                                                       }
                   Vd.uw=vcl0(Vu.uw)                   for (i = 0; i < VELEM(32); i++) {
                                                           Vd.uw[i]=count_leading_ones(~Vu.uw[i]) ;
                                                       }
                   Vd.w=vadd(vclb(Vu.w),Vv.w)          for (i = 0; i < VELEM(32); i++) {
                                                           Vd.w[i] =
                                                       max(count_leading_ones(~Vu.w[i]),count_leading_ones
                                                       (Vu.w[i])) + Vv.w[i] ;
                                                       }
                   Vd.w=vnormamt(Vu.w)                 for (i = 0; i < VELEM(32); i++) {
                                                           Vd.w[i]=max(count_leading_ones(~Vu.w[i]),count_
                                                       leading_ones(Vu.w[i]))-1;
                                                       ;
                                                       }
                   Vd=vnormamth(Vu)                    Assembler mapped to: "Vd.h=vnormamt(Vu.h)"
                   Vd=vnormamtw(Vu)                    Assembler mapped to: "Vd.w=vnormamt(Vu.w)"
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                        ■  This instruction uses the HVX shift resource.
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                     248
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
                  Intrinsics
                   Vd.h=vadd(vclb(Vu.h),Vv.h)              HVX_Vector Q6_Vh_vadd_vclb_VhVh(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.h=vnormamt(Vu.h)                     HVX_Vector Q6_Vh_vnormamt_Vh(HVX_Vector Vu)
                   Vd.h=vpopcount(Vu.h)                    HVX_Vector Q6_Vh_vpopcount_Vh(HVX_Vector Vu)
                   Vd.uh=vcl0(Vu.uh)                       HVX_Vector Q6_Vuh_vcl0_Vuh(HVX_Vector Vu)
                   Vd.uw=vcl0(Vu.uw)                       HVX_Vector Q6_Vuw_vcl0_Vuw(HVX_Vector Vu)
                   Vd.w=vadd(vclb(Vu.w),Vv.w)              HVX_Vector Q6_Vw_vadd_vclb_VwVw(HVX_Vector Vu,
                                                           HVX_Vector Vv)
                   Vd.w=vnormamt(Vu.w)                     HVX_Vector Q6_Vw_vnormamt_Vw(HVX_Vector Vu)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7  6 5  4 3  2 1  0
   ICLASS                                        Parse         u5                 d5
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  1  0  P   P 0  u  u  u u u 1  0 1  d d  d d  d Vd.uw=vcl0(Vu.uw)
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  1  0  P   P 0  u  u  u u u 1  1 0  d d  d d  d Vd.h=vpopcount(Vu.h)
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  1  0  P   P 0  u  u  u u u 1  1 1  d d  d d  d Vd.uh=vcl0(Vu.uh)
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  1  1  P   P 0  u  u  u u u 1  0 0  d d  d d  d Vd.w=vnormamt(Vu.w)
 0  0  0  1 1  1   1 0   -  - 0   -  -  -  1  1  P   P 0  u  u  u u u 1  0 1  d d  d d  d Vd.h=vnormamt(Vu.h)
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 1  u  u  u u u 0  0 0  d d  d d  d Vd.h=vadd(vclb(Vu.h),Vv.h)
                                                                                          Vd.w=vadd(vclb(Vu.w),Vv.w
 0  0  0  1 1  1   1 1  0  0  0   v  v  v  v  v  P   P 1  u  u  u u u 0  0 1  d d  d d  d )
                  Field name        Description
                  ICLASS            Instruction Class
                  Parse             Packet/Loop parse bits
                  d5                Field to encode register d
                  u5                Field to encode register u
                  v5                Field to encode register v
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        249
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
     5.15         HVX/STORE
                  The HVX/STORE instruction subclass includes memory store instructions.
        Store - byte-enabled aligned
                  Of the bytes in vector register Vs, store to memory only the ones where the corresponding
                  bit in the predicate register Qv is enabled. The block of memory to store into is at a vector-
                  size-aligned address. The operation has three ways to generate the memory pointer
                  address:
                        ■   Rt with a constant 4-bit signed offset
                        ■   Rx with a signed post-increment
                        ■   Rx with a modifier register Mu post-increment
                  For the immediate forms, the value indicates the number of vectors worth of data. Mu
                  contains the actual byte offset.
                  If all bits in Qv are set to zero, no data is stored to memory, but the post-increment of the
                  pointer in Rt occurs.
                  If the pointer presented to the instruction is not aligned, the instruction ignores the lower
                  bits, yielding an aligned address.
                       If (Qv4) vmem(Rt) = Vs
                      [N-1]                    ...                  [2]     [1]     [0]     Vs.b
                                                                                    En            Qv.b[0]
                                                                            En                    Qv.b[1]
                                                                    En                            Qv.b[2]
                        En                                                                        Qv.b[N-1]
                                                   MEMORY
                   Syntax                                 Behavior
                   if ([!]Qv4) vmem(Rt):nt=Vs             Assembler mapped to: "if ([!]Qv4)
                                                          vmem(Rt+#0):nt=Vs"
                   if ([!]Qv4) vmem(Rt)=Vs                Assembler mapped to: "if ([!]Qv4)
                                                          vmem(Rt+#0)=Vs"
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       250
Hexagon V66 HVX Programmer’s Reference Manual                                                         Instruction Set
                   Syntax                                  Behavior
                   if ([!]Qv4) vmem(Rt+#s4):nt=Vs           EA=Rt+#s*VBYTES;
                                                            *(EA&~(ALIGNMENT-1)) = Vs;
                   if ([!]Qv4) vmem(Rt+#s4)=Vs              EA=Rt+#s*VBYTES;
                                                            *(EA&~(ALIGNMENT-1)) = Vs;
                   if ([!]Qv4) vmem(Rx++#s3):nt=Vs          EA=Rx;
                                                            *(EA&~(ALIGNMENT-1)) = Vs;
                                                            Rx=Rx+#s*VBYTES;
                   if ([!]Qv4) vmem(Rx++#s3)=Vs             EA=Rx;
                                                            *(EA&~(ALIGNMENT-1)) = Vs;
                                                            Rx=Rx+#s*VBYTES;
                   if ([!]Qv4) vmem(Rx++Mu):nt=Vs           EA=Rx;
                                                            *(EA&~(ALIGNMENT-1)) = Vs;
                                                            Rx=Rx+MuV;
                   if ([!]Qv4) vmem(Rx++Mu)=Vs              EA=Rx;
                                                            *(EA&~(ALIGNMENT-1)) = Vs;
                                                            Rx=Rx+MuV;
                  Class: COPROC_VMEM (slots 0)
                  Notes
                       ■   This instruction can use any HVX resource.
                       ■   An optional "non-temporal" hint to the micro-architecture can be specified to
                           indicate that the data has no reuse.
                       ■   Immediates used in address computation are specified in multiples of vector
                           length.
                  Intrinsics
                   if (!Qv4) vmem(Rt+#s4):nt=Vs             void Q6_vmem_QnRIV_nt(HVX_VectorPred Qv,
                                                            HVX_Vector* A, HVX_Vector Vs)
                   if (!Qv4) vmem(Rt+#s4)=Vs                void Q6_vmem_QnRIV(HVX_VectorPred Qv,
                                                            HVX_Vector* A, HVX_Vector Vs)
                   if (Qv4) vmem(Rt+#s4):nt=Vs              void Q6_vmem_QRIV_nt(HVX_VectorPred Qv,
                                                            HVX_Vector* A, HVX_Vector Vs)
                   if (Qv4) vmem(Rt+#s4)=Vs                 void Q6_vmem_QRIV(HVX_VectorPred Qv, HVX_Vector*
                                                            A, HVX_Vector Vs)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7 6  5 4 3  2  1 0
   ICLASS                  NT          t5       Parse                               s5
 0  0  1  0 1  0   0 0  1  0  0   t  t  t  t  t P   P  i  v   v i  i i 0  0 0  s s  s  s s if (Qv4) vmem(Rt+#s4)=Vs
 0  0  1  0 1  0   0 0  1  0  0   t  t  t  t  t P   P  i  v   v i  i i 0  0 1  s s  s  s s if (!Qv4) vmem(Rt+#s4)=Vs
                                                                                           if (Qv4)
 0  0  1  0 1  0   0 0  1  1  0   t  t  t  t  t P   P  i  v   v i  i i 0  0 0  s s  s  s s vmem(Rt+#s4):nt=Vs
                                                                                         s ifvmem(Rt+#s4):nt=Vs
                                                                                              (!Qv4)
 0  0  1  0 1  0   0 0  1  1  0   t  t  t  t  t P   P  i  v   v i  i i 0  0 1  s s  s  s
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                          251
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                  NT          x5        Parse                            s5
                                                                                          if (Qv4)
 0  0  1  0 1  0   0 1  1  0  0   x  x  x  x  x  P   P  - v  v  i i i 0 0 0  s  s s  s  s
                                                                                          vmem(Rx++#s3)=Vs
                                                                                          if (!Qv4)
 0  0  1  0 1  0   0 1  1  0  0   x  x  x  x  x  P   P  - v  v  i i i 0 0 1  s  s s  s  s
                                                                                          vmem(Rx++#s3)=Vs
                                                                                          if (Qv4)
 0  0  1  0 1  0   0 1  1  1  0   x  x  x  x  x  P   P  - v  v  i i i 0 0 0  s  s s  s  s
                                                                                          vmem(Rx++#s3):nt=Vs
                                                                                          if (!Qv4)
 0  0  1  0 1  0   0 1  1  1  0   x  x  x  x  x  P   P  - v  v  i i i 0 0 1  s  s s  s  s
                                                                                          vmem(Rx++#s3):nt=Vs
   ICLASS                  NT          x5        Parse u1                         s5
                                                                                          if (Qv4)
 0  0  1  0 1  0   1 1  1  0  0   x  x  x  x  x  P   P u  v  v  - - - 0 0 0  s  s s  s  s
                                                                                          vmem(Rx++Mu)=Vs
                                                                                          if (!Qv4)
 0  0  1  0 1  0   1 1  1  0  0   x  x  x  x  x  P   P u  v  v  - - - 0 0 1  s  s s  s  s
                                                                                          vmem(Rx++Mu)=Vs
                                                                                          if (Qv4)
 0  0  1  0 1  0   1 1  1  1  0   x  x  x  x  x  P   P u  v  v  - - - 0 0 0  s  s s  s  s
                                                                                          vmem(Rx++Mu):nt=Vs
                                                                                        s ifvmem(Rx++Mu):nt=Vs
                                                                                             (!Qv4)
 0  0  1  0 1  0   1 1  1  1  0   x  x  x  x  x  P   P u  v  v  - - - 0 0 1  s  s s  s
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        252
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
        Store - new
                  Store the result of an operation in the current packet to memory, using a vector-aligned
                  address. The result is also written to the vector register file at the vector register location.
                  For example, in the instruction "vmem(R8++#1) = V12.new", the value in V12 in this
                  packet is written to memory, and V12 is also written to the vector register file.
                  The operation has three ways to generate the memory pointer address:
                       ■   Rt with a constant 4-bit signed offset
                       ■   Rx with a 3-bit signed post-increment
                       ■   Rx with a modifier register Mu post-increment
                  For the immediate forms, the value indicates the number of vectors worth of data. Mu
                  contains the actual byte offset.
                  The store is conditional, based on the value of the scalar predicate register Pv. If the
                  condition evaluates false, the operation becomes a NOP.
                   Syntax                               Behavior
                   if ([!]Pv)                            if ([!]Pv[0]) {
                   vmem(Rt+#s4):nt=Os8.new                    EA=Rt+#s*VBYTES;
                                                              *(EA&~(ALIGNMENT-1)) = OsN.new;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv) vmem(Rt+#s4)=Os8.new       if ([!]Pv[0]) {
                                                              EA=Rt+#s*VBYTES;
                                                              *(EA&~(ALIGNMENT-1)) = OsN.new;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv)                            if ([!]Pv[0]) {
                   vmem(Rx++#s3):nt=Os8.new                   EA=Rx;
                                                              *(EA&~(ALIGNMENT-1)) = OsN.new;
                                                              Rx=Rx+#s*VBYTES;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv)                            if ([!]Pv[0]) {
                   vmem(Rx++#s3)=Os8.new                      EA=Rx;
                                                              *(EA&~(ALIGNMENT-1)) = OsN.new;
                                                              Rx=Rx+#s*VBYTES;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv)                            if ([!]Pv[0]) {
                   vmem(Rx++Mu):nt=Os8.new                    EA=Rx;
                                                              *(EA&~(ALIGNMENT-1)) = OsN.new;
                                                              Rx=Rx+MuV;
                                                         } else {
                                                              NOP;
                                                         }
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         253
Hexagon V66 HVX Programmer’s Reference Manual                                                       Instruction Set
                   Syntax                                   Behavior
                   if ([!]Pv) vmem(Rx++Mu)=Os8.new          if ([!]Pv[0]) {
                                                                EA=Rx;
                                                                *(EA&~(ALIGNMENT-1)) = OsN.new;
                                                                Rx=Rx+MuV;
                                                            } else {
                                                                NOP;
                                                            }
                   vmem(Rt):nt=Os8.new                      Assembler mapped to: "vmem(Rt+#0):nt=Os8.new"
                   vmem(Rt)=Os8.new                         Assembler mapped to: "vmem(Rt+#0)=Os8.new"
                   vmem(Rt+#s4):nt=Os8.new                  EA=Rt+#s*VBYTES;
                                                            *(EA&~(ALIGNMENT-1)) = OsN.new;
                   vmem(Rt+#s4)=Os8.new                     EA=Rt+#s*VBYTES;
                                                            *(EA&~(ALIGNMENT-1)) = OsN.new;
                   vmem(Rx++#s3):nt=Os8.new                 EA=Rx;
                                                            *(EA&~(ALIGNMENT-1)) = OsN.new;
                                                            Rx=Rx+#s*VBYTES;
                   vmem(Rx++#s3)=Os8.new                    EA=Rx;
                                                            *(EA&~(ALIGNMENT-1)) = OsN.new;
                                                            Rx=Rx+#s*VBYTES;
                   vmem(Rx++Mu):nt=Os8.new                  EA=Rx;
                                                            *(EA&~(ALIGNMENT-1)) = OsN.new;
                                                            Rx=Rx+MuV;
                   vmem(Rx++Mu)=Os8.new                     EA=Rx;
                                                            *(EA&~(ALIGNMENT-1)) = OsN.new;
                                                            Rx=Rx+MuV;
                  Class: COPROC_VMEM (slots 0)
                  Notes
                       ■   This instruction can use any HVX resource.
                       ■   An optional "non-temporal" hint to the micro-architecture can be specified to
                           indicate that the data has no reuse.
                       ■   Immediates used in address computation are specified in multiples of vector
                           length.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4 3 2  1  0
   ICLASS                  NT          t5       Parse                                 s3
 0  0  1  0 1  0   0 0  0  0  1   t  t  t  t  t P   P  i  -   - i  i i 0 0  1  - 0 s   s s vmem(Rt+#s4)=Os8.new
 0  0  1  0 1  0   0 0  0  1  1   t  t  t  t  t P   P  i  -   - i  i i 0 0  1  - - s   s s vmem(Rt+#s4):nt=Os8.new
                                                                                         s ifvmem(Rt+#s4)=Os8.new
                                                                                              (Pv)
 0  0  1  0 1  0   0 0  1  0  1   t  t  t  t  t P   P  i  v   v i  i i 0 1  0  0 0 s   s
                                                                                           if (!Pv)
 0  0  1  0 1  0   0 0  1  0  1   t  t  t  t  t P   P  i  v   v i  i i 0 1  1  0 1 s   s s vmem(Rt+#s4)=Os8.new
                                                                                         s ifvmem(Rt+#s4):nt=Os8.new
                                                                                              (Pv)
 0  0  1  0 1  0   0 0  1  1  1   t  t  t  t  t P   P  i  v   v i  i i 0 1  0  1 0 s   s
                                                                                         s ifvmem(Rt+#s4):nt=Os8.new
                                                                                              (!Pv)
 0  0  1  0 1  0   0 0  1  1  1   t  t  t  t  t P   P  i  v   v i  i i 0 1  1  1 1 s   s
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         254
Hexagon V66 HVX Programmer’s Reference Manual                                                      Instruction Set
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                  NT          x5        Parse                              s3
 0  0  1  0 1  0   0 1  0  0  1   x  x  x  x  x  P   P  - -   - i i i 0 0 1   - 0 s  s  s vmem(Rx++#s3)=Os8.new
                                                                                          vmem(Rx++#s3):nt=Os8.ne
 0  0  1  0 1  0   0 1  0  1  1   x  x  x  x  x  P   P  - -   - i i i 0 0 1   - - s  s  s
                                                                                          w
                                                                                          if (Pv)
 0  0  1  0 1  0   0 1  1  0  1   x  x  x  x  x  P   P  - v  v  i i i 0 1 0  0  0 s  s  s vmem(Rx++#s3)=Os8.new
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 1  1  0  1   x  x  x  x  x  P   P  - v  v  i i i 0 1 1  0  1 s  s  s
                                                                                          vmem(Rx++#s3)=Os8.new
                                                                                          if (Pv)
 0  0  1  0 1  0   0 1  1  1  1   x  x  x  x  x  P   P  - v  v  i i i 0 1 0  1  0 s  s  s vmem(Rx++#s3):nt=Os8.ne
                                                                                          w
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 1  1  1  1   x  x  x  x  x  P   P  - v  v  i i i 0 1 1  1  1 s  s  s vmem(Rx++#s3):nt=Os8.ne
                                                                                          w
   ICLASS                  NT          x5        Parse u1                           s3
 0  0  1  0 1  0   1 1  0  0  1   x  x  x  x  x  P   P u  -   - - - - 0 0 1   - 0 s  s  s vmem(Rx++Mu)=Os8.new
 0  0  1  0 1  0   1 1  0  1  1   x  x  x  x  x  P   P u  -   - - - - 0 0 1   - - s  s  s vmem(Rx++Mu):nt=Os8.ne
                                                                                          w
                                                                                        s ifvmem(Rx++Mu)=Os8.new
                                                                                             (Pv)
 0  0  1  0 1  0   1 1  1  0  1   x  x  x  x  x  P   P u  v  v  - - - 0 1 0  0  0 s  s
                                                                                          if (!Pv)
 0  0  1  0 1  0   1 1  1  0  1   x  x  x  x  x  P   P u  v  v  - - - 0 1 1  0  1 s  s  s vmem(Rx++Mu)=Os8.new
                                                                                          if (Pv)
 0  0  1  0 1  0   1 1  1  1  1   x  x  x  x  x  P   P u  v  v  - - - 0 1 0  1  0 s  s  s vmem(Rx++Mu):nt=Os8.ne
                                                                                          w
                                                                                          if (!Pv)
 0  0  1  0 1  0   1 1  1  1  1   x  x  x  x  x  P   P u  v  v  - - - 0 1 1  1  1 s  s  s vmem(Rx++Mu):nt=Os8.ne
                                                                                          w
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  s3                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       255
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
        Store - aligned
                  Write a full vector register Vs to memory, using a vector-size-aligned address.
                  The operation has three ways to generate the memory pointer address:
                        ■  Rt with a constant 4-bit signed offset
                        ■  Rx with a signed post-increment
                        ■  Rx with a modifier register Mu post-increment
                  For the immediate forms, the value indicates the number of vectors worth of data. Mu
                  contains the actual byte offset.
                  If the pointer presented to the instruction is not aligned, the instruction ignores the lower
                  bits, yielding an aligned address.
                  If a scalar predicate register Pv evaluates true, store a full vector register Vs to memory,
                  using a vector-size-aligned address. Otherwise, the operation becomes a NOP
                   Syntax                                Behavior
                   if ([!]Pv) vmem(Rt):nt=Vs              Assembler mapped to: "if ([!]Pv)
                                                          vmem(Rt+#0):nt=Vs"
                   if ([!]Pv) vmem(Rt)=Vs                 Assembler mapped to: "if ([!]Pv) vmem(Rt+#0)=Vs"
                   if ([!]Pv) vmem(Rt+#s4):nt=Vs          if ([!]Pv[0]) {
                                                               EA=Rt+#s*VBYTES;
                                                               *(EA&~(ALIGNMENT-1)) = Vs;
                                                          } else {
                                                               NOP;
                                                          }
                   if ([!]Pv) vmem(Rt+#s4)=Vs             if ([!]Pv[0]) {
                                                               EA=Rt+#s*VBYTES;
                                                               *(EA&~(ALIGNMENT-1)) = Vs;
                                                          } else {
                                                               NOP;
                                                          }
                   if ([!]Pv) vmem(Rx++#s3):nt=Vs         if ([!]Pv[0]) {
                                                               EA=Rx;
                                                               *(EA&~(ALIGNMENT-1)) = Vs;
                                                               Rx=Rx+#s*VBYTES;
                                                          } else {
                                                               NOP;
                                                          }
                   if ([!]Pv) vmem(Rx++#s3)=Vs            if ([!]Pv[0]) {
                                                               EA=Rx;
                                                               *(EA&~(ALIGNMENT-1)) = Vs;
                                                               Rx=Rx+#s*VBYTES;
                                                          } else {
                                                               NOP;
                                                          }
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        256
Hexagon V66 HVX Programmer’s Reference Manual                                                 Instruction Set
                   Syntax                               Behavior
                   if ([!]Pv) vmem(Rx++Mu):nt=Vs         if ([!]Pv[0]) {
                                                              EA=Rx;
                                                              *(EA&~(ALIGNMENT-1)) = Vs;
                                                              Rx=Rx+MuV;
                                                         } else {
                                                              NOP;
                                                         }
                   if ([!]Pv) vmem(Rx++Mu)=Vs            if ([!]Pv[0]) {
                                                              EA=Rx;
                                                              *(EA&~(ALIGNMENT-1)) = Vs;
                                                              Rx=Rx+MuV;
                                                         } else {
                                                              NOP;
                                                         }
                   vmem(Rt):nt=Vs                        Assembler mapped to: "vmem(Rt+#0):nt=Vs"
                   vmem(Rt)=Vs                           Assembler mapped to: "vmem(Rt+#0)=Vs"
                   vmem(Rt+#s4):nt=Vs                    EA=Rt+#s*VBYTES;
                                                         *(EA&~(ALIGNMENT-1)) = Vs;
                   vmem(Rt+#s4)=Vs                       EA=Rt+#s*VBYTES;
                                                         *(EA&~(ALIGNMENT-1)) = Vs;
                   vmem(Rx++#s3):nt=Vs                   EA=Rx;
                                                         *(EA&~(ALIGNMENT-1)) = Vs;
                                                         Rx=Rx+#s*VBYTES;
                   vmem(Rx++#s3)=Vs                      EA=Rx;
                                                         *(EA&~(ALIGNMENT-1)) = Vs;
                                                         Rx=Rx+#s*VBYTES;
                   vmem(Rx++Mu):nt=Vs                    EA=Rx;
                                                         *(EA&~(ALIGNMENT-1)) = Vs;
                                                         Rx=Rx+MuV;
                   vmem(Rx++Mu)=Vs                       EA=Rx;
                                                         *(EA&~(ALIGNMENT-1)) = Vs;
                                                         Rx=Rx+MuV;
                  Class: COPROC_VMEM (slots 0)
                  Notes
                       ■  This instruction can use any HVX resource.
                       ■  An optional "non-temporal" hint to the micro-architecture can be specified to
                          indicate that the data has no reuse.
                       ■  Immediates used in address computation are specified in multiples of vector
                          length.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                  257
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5  4  3 2  1  0
   ICLASS                  NT           t5       Parse                            s5
 0  0  1  0 1  0   0 0  0  0  1   t  t   t  t  t P   P  i -   - i i i 0 0 0  s  s s  s  s vmem(Rt+#s4)=Vs
 0  0  1  0 1  0   0 0  0  1  1   t  t   t  t  t P   P  i -   - i i i 0 0 0  s  s s  s  s vmem(Rt+#s4):nt=Vs
 0  0  1  0 1  0   0 0  1  0  1   t  t   t  t  t P   P  i v  v  i i i 0 0 0  s  s s  s  s if (Pv) vmem(Rt+#s4)=Vs
 0  0  1  0 1  0   0 0  1  0  1   t  t   t  t  t P   P  i v  v  i i i 0 0 1  s  s s  s  s if (!Pv) vmem(Rt+#s4)=Vs
 0  0  1  0 1  0   0 0  1  1  1   t  t   t  t  t P   P  i v  v  i i i 0 0 0  s  s s  s  s if (Pv) vmem(Rt+#s4):nt=Vs
                                                                                          if (!Pv)
 0  0  1  0 1  0   0 0  1  1  1   t  t   t  t  t P   P  i v  v  i i i 0 0 1  s  s s  s  s
                                                                                          vmem(Rt+#s4):nt=Vs
   ICLASS                  NT          x5        Parse                            s5
 0  0  1  0 1  0   0 1  0  0  1   x  x  x  x  x  P   P  - -   - i i i 0 0 0  s  s s  s  s vmem(Rx++#s3)=Vs
 0  0  1  0 1  0   0 1  0  1  1   x  x  x  x  x  P   P  - -   - i i i 0 0 0  s  s s  s  s vmem(Rx++#s3):nt=Vs
 0  0  1  0 1  0   0 1  1  0  1   x  x  x  x  x  P   P  - v  v  i i i 0 0 0  s  s s  s  s if (Pv) vmem(Rx++#s3)=Vs
 0  0  1  0 1  0   0 1  1  0  1   x  x  x  x  x  P   P  - v  v  i i i 0 0 1  s  s s  s  s if (!Pv) vmem(Rx++#s3)=Vs
                                                                                          if (Pv)
 0  0  1  0 1  0   0 1  1  1  1   x  x  x  x  x  P   P  - v  v  i i i 0 0 0  s  s s  s  s
                                                                                          vmem(Rx++#s3):nt=Vs
                                                                                        s ifvmem(Rx++#s3):nt=Vs
                                                                                             (!Pv)
 0  0  1  0 1  0   0 1  1  1  1   x  x  x  x  x  P   P  - v  v  i i i 0 0 1  s  s s  s
   ICLASS                  NT          x5        Parse u1                         s5
 0  0  1  0 1  0   1 1  0  0  1   x  x  x  x  x  P   P u  -   - - - - 0 0 0  s  s s  s  s vmem(Rx++Mu)=Vs
 0  0  1  0 1  0   1 1  0  1  1   x  x  x  x  x  P   P u  -   - - - - 0 0 0  s  s s  s  s vmem(Rx++Mu):nt=Vs
 0  0  1  0 1  0   1 1  1  0  1   x  x  x  x  x  P   P u  v  v  - - - 0 0 0  s  s s  s  s if (Pv) vmem(Rx++Mu)=Vs
 0  0  1  0 1  0   1 1  1  0  1   x  x  x  x  x  P   P u  v  v  - - - 0 0 1  s  s s  s  s if (!Pv) vmem(Rx++Mu)=Vs
                                                                                          if (Pv)
 0  0  1  0 1  0   1 1  1  1  1   x  x  x  x  x  P   P u  v  v  - - - 0 0 0  s  s s  s  s vmem(Rx++Mu):nt=Vs
                                                                                        s ifvmem(Rx++Mu):nt=Vs
                                                                                             (!Pv)
 0  0  1  0 1  0   1 1  1  1  1   x  x  x  x  x  P   P u  v  v  - - - 0 0 1  s  s s  s
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
                  t5                Field to encode register t
                  u1                Field to encode register u
                  v2                Field to encode register v
                  x5                Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         258
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
        Store - unaligned
                  Write a full vector register Vs to memory, using an arbitrary byte-aligned address.
                  The operation has three ways to generate the memory pointer address:
                        ■  Rt with a constant 4-bit signed offset
                        ■  Rx with a 3-bit signed post-increment
                        ■  Rx with a modifier register Mu post-increment
                  For the immediate forms, the value indicates the number of vectors worth of data. Mu
                  contains the actual byte offset.
                  Unaligned memory operations require two accesses to the memory system, and thus incur
                  increased power and bandwidth over aligned accesses. However, they require fewer
                  instructions. Use aligned memory operations and combinations of permute operations,
                  when possible.
                  Note that this instruction uses both slot 0 and slot 1, allowing only three instructions at
                  most to execute in a packet with vmemu in it.
                  If the scalar predicate register Pv is true, store a full vector register Vs to memory, using an
                  arbitrary byte-aligned address. Otherwise, the operation becomes a NOP.
                   Syntax                                 Behavior
                   if ([!]Pv) vmemu(Rt)=Vs                 Assembler mapped to: "if ([!]Pv)
                                                           vmemu(Rt+#0)=Vs"
                   if ([!]Pv) vmemu(Rt+#s4)=Vs             if ([!]Pv[0]) {
                                                                EA=Rt+#s*VBYTES;
                                                                *EA = Vs;
                                                           } else {
                                                                NOP;
                                                           }
                   if ([!]Pv) vmemu(Rx++#s3)=Vs            if ([!]Pv[0]) {
                                                                EA=Rx;
                                                                *EA = Vs;
                                                                Rx=Rx+#s*VBYTES;
                                                           } else {
                                                                NOP;
                                                           }
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        259
Hexagon V66 HVX Programmer’s Reference Manual                                                        Instruction Set
                   Syntax                                   Behavior
                   if ([!]Pv) vmemu(Rx++Mu)=Vs              if ([!]Pv[0]) {
                                                                EA=Rx;
                                                                *EA = Vs;
                                                                Rx=Rx+MuV;
                                                            } else {
                                                                NOP;
                                                            }
                   vmemu(Rt)=Vs                             Assembler mapped to: "vmemu(Rt+#0)=Vs"
                   vmemu(Rt+#s4)=Vs                         EA=Rt+#s*VBYTES;
                                                            *EA = Vs;
                   vmemu(Rx++#s3)=Vs                        EA=Rx;
                                                            *EA = Vs;
                                                            Rx=Rx+#s*VBYTES;
                   vmemu(Rx++Mu)=Vs                         EA=Rx;
                                                            *EA = Vs;
                                                            Rx=Rx+MuV;
                  Class: COPROC_VMEM (slots 0)
                  Notes
                       ■   This instruction uses the HVX permute resource.
                       ■   Immediates used in address computation are specified in multiples of vector
                           length.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4 3 2  1 0
   ICLASS                  NT           t5       Parse                             s5
 0  0  1  0 1  0   0 0  0  0  1   t  t   t  t  t P   P  i -   - i  i i 1  1 1  s s s  s s vmemu(Rt+#s4)=Vs
 0  0  1  0 1  0   0 0  1  0  1   t  t   t  t  t P   P  i v   v i  i i 1  1 0  s s s  s s if (Pv) vmemu(Rt+#s4)=Vs
 0  0  1  0 1  0   0 0  1  0  1   t  t   t  t  t P   P  i v   v i  i i 1  1 1  s s s  s s if (!Pv) vmemu(Rt+#s4)=Vs
   ICLASS                  NT          x5        Parse                             s5
 0  0  1  0 1  0   0 1  0  0  1   x  x  x  x  x  P   P  - -   - i  i i 1  1 1  s s s  s s vmemu(Rx++#s3)=Vs
                                                                                        s ifvmemu(Rx++#s3)=Vs
                                                                                              (Pv)
 0  0  1  0 1  0   0 1  1  0  1   x  x  x  x  x  P   P  - v   v i  i i 1  1 0  s s s  s
                                                                                        s ifvmemu(Rx++#s3)=Vs
                                                                                              (!Pv)
 0  0  1  0 1  0   0 1  1  0  1   x  x  x  x  x  P   P  - v   v i  i i 1  1 1  s s s  s
   ICLASS                  NT          x5        Parse u1                          s5
 0  0  1  0 1  0   1 1  0  0  1   x  x  x  x  x  P   P u  -   - -  - - 1  1 1  s s s  s s vmemu(Rx++Mu)=Vs
 0  0  1  0 1  0   1 1  1  0  1   x  x  x  x  x  P   P u  v   v -  - - 1  1 0  s s s  s s if (Pv) vmemu(Rx++Mu)=Vs
                                                                                           if (!Pv)
 0  0  1  0 1  0   1 1  1  0  1   x  x  x  x  x  P   P u  v   v -  - - 1  1 1  s s s  s s vmemu(Rx++Mu)=Vs
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
                  s5                Field to encode register s
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         260
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  t5              Field to encode register t
                  u1              Field to encode register u
                  v2              Field to encode register v
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             261
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Set
          Scatter release
                  Specialized store that follows outstanding scatters or gathers to make sure they complete.
                  When written to VTCM space, no data is stored.
                  A VMEM load from the same address (Rt) causes a stalling sync until the scatter release
                  operation completes.
                  The EA of the store release must be in the VTCM, otherwise it is dropped
                   Syntax                                   Behavior
                   vmem(Rt+#s4):scatter_release             EA=Rt+#s*VBYTES;
                                                            char* addr = EA&~(ALIGNMENT-1);
                                                            Zero byte store release (non-blocking sync);
                   vmem(Rx++#s3):scatter_release            EA=Rx;
                                                            char* addr = EA&~(ALIGNMENT-1);
                                                            Zero byte store release (non-blocking sync);
                                                            Rx=Rx+#s*VBYTES;
                   vmem(Rx++Mu):scatter_release             EA=Rx;
                                                            char* addr = EA&~(ALIGNMENT-1);
                                                            Zero byte store release (non-blocking sync);
                                                            Rx=Rx+MuV;
                  Class: COPROC_VMEM (slots 0)
                  Notes
                       ■   This instruction can use any HVX resource.
                       ■   Immediates used in address computation are specified in multiples of vector
                           length.
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4 3 2  1 0
   ICLASS                  NT           t5       Parse
                                                                                           vmem(Rt+#s4):scatter_rele
 0  0  1  0 1  0   0 0  0  0  1   t  t   t t   t P   P  i -   - i  i i 0 0  1  - 1  - -  -
                                                                                           ase
   ICLASS                  NT          x5        Parse
                                                                                           vmem(Rx++#s3):scatter_re
 0  0  1  0 1  0   0 1  0  0  1   x  x  x  x  x  P   P  - -   - i  i i 0 0  1  - 1  - -  -
                                                                                           lease
   ICLASS                  NT          x5        Parse u1
                                                                                           vmem(Rx++Mu):scatter_rel
 0  0  1  0 1  0   1 1  0  0  1   x  x  x  x  x  P   P u  -   - -  - - 0 0  1  - 1  - -  -
                                                                                           ease
                  Field name        Description
                  ICLASS            Instruction Class
                  NT                NonTemporal
                  Parse             Packet/Loop parse bits
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                         262
Hexagon V66 HVX Programmer’s Reference Manual                                            Instruction Set
                  Field name      Description
                  t5              Field to encode register t
                  u1              Field to encode register u
                  x5              Field to encode register x
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             263
Instruction Index
A                                                           vadd
                                                               Vd.b=vadd(Vu.b,Vv.b)[:sat] 61
                                                               Vd.h=vadd(Vu.h,Vv.h)[:sat] 61
and
                                                               Vd.ub=vadd(Vu.ub,Vv.b):sat 61
    Qd4=and(Qs4,[!]Qt4) 40                                     Vd.ub=vadd(Vu.ub,Vv.ub):sat 61
                                                               Vd.uh=vadd(Vu.uh,Vv.uh):sat 61
N                                                              Vd.uw=vadd(Vu.uw,Vv.uw):sat 61
                                                               Vd.w,Qe4=vadd(Vu.w,Vv.w):carry 64
no mnemonic                                                    Vd.w=vadd(Vu.w,Vv.w,Qs4):carry:sat 64
    if ([!]Ps) Vd=Vu 68                                        Vd.w=vadd(Vu.w,Vv.w,Qx4):carry 64
    if ([!]Qv4) Vx.b[+-]=Vu.b 80                               Vd.w=vadd(Vu.w,Vv.w)[:sat] 61
    if ([!]Qv4) Vx.h[+-]=Vu.h 80                               Vdd.b=vadd(Vuu.b,Vvv.b)[:sat] 51
    if ([!]Qv4) Vx.w[+-]=Vu.w 80                               Vdd.h=vadd(Vu.ub,Vv.ub) 110
    Vd=Vu 68                                                   Vdd.h=vadd(Vuu.h,Vvv.h)[:sat] 51
                                                               Vdd.ub=vadd(Vuu.ub,Vvv.ub):sat 51
not                                                            Vdd.uh=vadd(Vuu.uh,Vvv.uh):sat 51
    Qd4=not(Qs4)  55                                           Vdd.uw=vadd(Vuu.uw,Vvv.uw):sat 52
                                                               Vdd.w=vadd(Vu.h,Vv.h) 110
O                                                              Vdd.w=vadd(Vu.uh,Vv.uh) 110
                                                               Vdd.w=vadd(Vuu.w,Vvv.w)[:sat] 52
                                                               Vxx.h+=vadd(Vu.ub,Vv.ub) 110
or                                                             Vxx.w+=vadd(Vu.h,Vv.h) 110
    Qd4=or(Qs4,[!]Qt4) 40                                      Vxx.w+=vadd(Vu.uh,Vv.uh) 110
P                                                           valign
                                                               Vd=valign(Vu,Vv,#u3) 182
prefixsum                                                      Vd=valign(Vu,Vv,Rt) 182
    Vd.b=prefixsum(Qv4) 234
    Vd.h=prefixsum(Qv4) 234                                 vand
    Vd.w=prefixsum(Qv4) 234                                    Qd4=vand(Vu,Rt) 175
                                                               Qx4|=vand(Vu,Rt) 175
V                                                              Vd=vand([!]Qu4,Rt) 176
                                                               Vd=vand([!]Qv4,Vu) 56
vabs                                                           Vd=vand(Vu,Vv) 66
    Vd.b=vabs(Vu.b)[:sat] 59                                   Vx|=vand([!]Qu4,Rt) 176
    Vd.h=vabs(Vu.h)[:sat] 59
    Vd.ub=vabs(Vu.b) 59                                     vasl
    Vd.uh=vabs(Vu.h) 59                                        Vd.h=vasl(Vu.h,Rt) 239
    Vd.uw=vabs(Vu.w) 59                                        Vd.h=vasl(Vu.h,Vv.h) 239
    Vd.w=vabs(Vu.w)[:sat] 59                                   Vd.w=vasl(Vu.w,Rt) 240
                                                               Vd.w=vasl(Vu.w,Vv.w) 240
vabsdiff                                                       Vx.h+=vasl(Vu.h,Rt) 236
    Vd.ub=vabsdiff(Vu.ub,Vv.ub) 178                            Vx.w+=vasl(Vu.w,Rt) 236
    Vd.uh=vabsdiff(Vu.h,Vv.h) 178
    Vd.uh=vabsdiff(Vu.uh,Vv.uh) 178
    Vd.uw=vabsdiff(Vu.w,Vv.w) 179
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION             264
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Index
vasr                                                       vcmp.gt
    Vd.b=vasr(Vu.h,Vv.h,Rt)[:rnd]:sat 230, 239                Qd4=vcmp.gt(Vu.b,Vv.b) 73
    Vd.h=vasr(Vu.h,Rt) 239                                    Qd4=vcmp.gt(Vu.h,Vv.h) 73
    Vd.h=vasr(Vu.h,Vv.h) 239                                  Qd4=vcmp.gt(Vu.ub,Vv.ub) 73
    Vd.h=vasr(Vu.w,Vv.w,Rt):rnd:sat 230, 239                  Qd4=vcmp.gt(Vu.uh,Vv.uh) 73
    Vd.h=vasr(Vu.w,Vv.w,Rt)[:sat] 230, 239                    Qd4=vcmp.gt(Vu.uw,Vv.uw) 74
    Vd.ub=vasr(Vu.h,Vv.h,Rt)[:rnd]:sat 230, 239               Qd4=vcmp.gt(Vu.w,Vv.w) 74
    Vd.ub=vasr(Vu.uh,Vv.uh,Rt)[:rnd]:sat 230, 240             Qx4^=vcmp.gt(Vu.b,Vv.b) 75
    Vd.uh=vasr(Vu.uw,Vv.uw,Rt)[:rnd]:sat 230, 240             Qx4^=vcmp.gt(Vu.h,Vv.h) 75
    Vd.uh=vasr(Vu.w,Vv.w,Rt)[:rnd]:sat 230, 240               Qx4^=vcmp.gt(Vu.ub,Vv.ub) 75
    Vd.w=vasr(Vu.w,Rt) 240                                    Qx4^=vcmp.gt(Vu.uh,Vv.uh) 75
    Vd.w=vasr(Vu.w,Vv.w) 240                                  Qx4^=vcmp.gt(Vu.uw,Vv.uw) 75
    Vx.h+=vasr(Vu.h,Rt) 236                                   Qx4^=vcmp.gt(Vu.w,Vv.w) 75
    Vx.w+=vasr(Vu.w,Rt) 236                                   Qx4[&|]=vcmp.gt(Vu.b,Vv.b) 74
                                                              Qx4[&|]=vcmp.gt(Vu.h,Vv.h) 74
vasrinto                                                      Qx4[&|]=vcmp.gt(Vu.ub,Vv.ub) 74
    Vxx.w=vasrinto(Vu.w,Vv.w) 202                             Qx4[&|]=vcmp.gt(Vu.uh,Vv.uh) 74
    Vxx=vasrinto(Vu,Vv) 202                                   Qx4[&|]=vcmp.gt(Vu.uw,Vv.uw) 74
                                                              Qx4[&|]=vcmp.gt(Vu.w,Vv.w) 74
vavg
    Vd.b=vavg(Vu.b,Vv.b)[:rnd] 70
                                                           vcombine
    Vd.h=vavg(Vu.h,Vv.h)[:rnd] 70                             if ([!]Ps) Vdd=vcombine(Vu,Vv) 42
    Vd.ub=vavg(Vu.ub,Vv.ub)[:rnd] 70                          Vdd=vcombine(Vu,Vv) 42
    Vd.uh=vavg(Vu.uh,Vv.uh)[:rnd] 71
    Vd.uw=vavg(Vu.uw,Vv.uw)[:rnd] 71                       vdeal
    Vd.w=vavg(Vu.w,Vv.w)[:rnd] 71                             Vd.b=vdeal(Vu.b) 189
                                                              Vd.h=vdeal(Vu.h) 189
vcl0                                                          Vdd=vdeal(Vu,Vv,Rt) 208
    Vd.uh=vcl0(Vu.uh) 248                                     vdeal(Vy,Vx,Rt) 209
    Vd.uw=vcl0(Vu.uw) 248
                                                           vdeale
vclb                                                          Vd.b=vdeale(Vu.b,Vv.b) 189
    Vd.h=vadd(vclb(Vu.h),Vv.h) 248
    Vd.w=vadd(vclb(Vu.w),Vv.w) 248                         vdelta
                                                              Vd=vdelta(Vu,Vv) 186
vcmp.eq
    Qd4=vcmp.eq(Vu.b,Vv.b) 73                              vdmpy
    Qd4=vcmp.eq(Vu.h,Vv.h) 73                                 Vd.h=vdmpy(Vu.ub,Rt.b) 162
    Qd4=vcmp.eq(Vu.ub,Vv.ub) 73                               Vd.w=vdmpy(Vu.h,Rt.b) 162
    Qd4=vcmp.eq(Vu.uh,Vv.uh) 73                               Vd.w=vdmpy(Vu.h,Rt.h):sat 113
    Qd4=vcmp.eq(Vu.uw,Vv.uw) 73                               Vd.w=vdmpy(Vu.h,Rt.uh):sat 113
    Qd4=vcmp.eq(Vu.w,Vv.w) 73                                 Vd.w=vdmpy(Vu.h,Vv.h):sat 114
    Qx4^=vcmp.eq(Vu.b,Vv.b) 74                                Vd.w=vdmpy(Vuu.h,Rt.h):sat 114
    Qx4^=vcmp.eq(Vu.h,Vv.h) 75                                Vd.w=vdmpy(Vuu.h,Rt.uh,#1):sat 114
    Qx4^=vcmp.eq(Vu.ub,Vv.ub) 75                              Vdd.h=vdmpy(Vuu.ub,Rt.b) 114
    Qx4^=vcmp.eq(Vu.uh,Vv.uh) 75                              Vdd.w=vdmpy(Vuu.h,Rt.b) 114
    Qx4^=vcmp.eq(Vu.uw,Vv.uw) 75                              Vx.h+=vdmpy(Vu.ub,Rt.b) 163
    Qx4^=vcmp.eq(Vu.w,Vv.w) 75                                Vx.w+=vdmpy(Vu.h,Rt.b) 163
    Qx4[&|]=vcmp.eq(Vu.b,Vv.b) 74                             Vx.w+=vdmpy(Vu.h,Rt.h):sat 114
    Qx4[&|]=vcmp.eq(Vu.h,Vv.h) 74                             Vx.w+=vdmpy(Vu.h,Rt.uh):sat 114
    Qx4[&|]=vcmp.eq(Vu.ub,Vv.ub) 74                           Vx.w+=vdmpy(Vu.h,Vv.h):sat 114
    Qx4[&|]=vcmp.eq(Vu.uh,Vv.uh) 74                           Vx.w+=vdmpy(Vuu.h,Rt.h):sat 115
    Qx4[&|]=vcmp.eq(Vu.uw,Vv.uw) 74                           Vx.w+=vdmpy(Vuu.h,Rt.uh,#1):sat 115
    Qx4[&|]=vcmp.eq(Vu.w,Vv.w) 74                             Vxx.h+=vdmpy(Vuu.ub,Rt.b) 115
                                                              Vxx.w+=vdmpy(Vuu.h,Rt.b) 115
                                                           vdsad
                                                              Vdd.uw=vdsad(Vuu.uh,Rt.uh) 157
                                                              Vxx.uw+=vdsad(Vuu.uh,Rt.uh) 157
                                                           vextract
                                                              Rd.w=vextract(Vu,Rs) 90
                                                              Rd=vextract(Vu,Rs) 90
                                                           vgather
                                                              if (Qs4) vtmp.w=vgather(Rt,Mu,Vv.w).w  96
                                                              vtmp.w=vgather(Rt,Mu,Vv.w).w 96
80-N2040-44 Rev. B     MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       265
Hexagon V66 HVX Programmer’s Reference Manual                                           Instruction Index
vhist
    vhist 33
    vhist(Qv4) 34
vinsert
    Vx.w=vinsert(Rt) 180
vlalign
    Vd=vlalign(Vu,Vv,#u3) 182
    Vd=vlalign(Vu,Vv,Rt) 182
vlsr
    Vd.h=vlsr(Vu.h,Vv.h) 239
    Vd.ub=vlsr(Vu.ub,Rt) 240
    Vd.uh=vlsr(Vu.uh,Rt) 240
    Vd.uw=vlsr(Vu.uw,Rt) 240
    Vd.w=vlsr(Vu.w,Vv.w) 240
vlut16
    Vdd.h=vlut16(Vu.b,Vv.h,#u3) 216
    Vdd.h=vlut16(Vu.b,Vv.h,Rt) 217
    Vdd.h=vlut16(Vu.b,Vv.h,Rt):nomatch 217
    Vxx.h|=vlut16(Vu.b,Vv.h,#u3) 217
    Vxx.h|=vlut16(Vu.b,Vv.h,Rt) 218
vlut32
    Vd.b=vlut32(Vu.b,Vv.b,#u3) 200
    Vd.b=vlut32(Vu.b,Vv.b,Rt) 200
    Vd.b=vlut32(Vu.b,Vv.b,Rt):nomatch 201
    Vx.b|=vlut32(Vu.b,Vv.b,#u3) 217
    Vx.b|=vlut32(Vu.b,Vv.b,Rt) 217
vlut4
    Vd.h=vlut4(Vu.uh,Rtt.h) 118
vmax
    Vd.b=vmax(Vu.b,Vv.b) 57
    Vd.h=vmax(Vu.h,Vv.h) 57
    Vd.ub=vmax(Vu.ub,Vv.ub) 57
    Vd.uh=vmax(Vu.uh,Vv.uh) 57
    Vd.w=vmax(Vu.w,Vv.w) 57
80-N2040-44 Rev. B     MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION               266
Hexagon V66 HVX Programmer’s Reference Manual                                                    Instruction Index
vmem                                                           vmem(Rt+#s4):nt=Vs 257
    if ([!]Pv) Vd.cur=vmem(Rt) 101                             vmem(Rt+#s4):scatter_release 262
    if ([!]Pv) Vd.cur=vmem(Rt):nt 101                          vmem(Rt+#s4)=Os8.new 254
    if ([!]Pv) Vd.cur=vmem(Rt+#s4) 101                         vmem(Rt+#s4)=Vs 257
    if ([!]Pv) Vd.cur=vmem(Rt+#s4):nt 102                      vmem(Rx++#s3):nt=Os8.new 254
    if ([!]Pv) Vd.cur=vmem(Rx++#s3) 102                        vmem(Rx++#s3):nt=Vs 257
    if ([!]Pv) Vd.cur=vmem(Rx++#s3):nt 102                     vmem(Rx++#s3):scatter_release 262
    if ([!]Pv) Vd.cur=vmem(Rx++Mu) 102                         vmem(Rx++#s3)=Os8.new 254
    if ([!]Pv) Vd.cur=vmem(Rx++Mu):nt 102                      vmem(Rx++#s3)=Vs 257
    if ([!]Pv) Vd.tmp=vmem(Rt) 104                             vmem(Rx++Mu):nt=Os8.new 254
    if ([!]Pv) Vd.tmp=vmem(Rt):nt 104                          vmem(Rx++Mu):nt=Vs 257
    if ([!]Pv) Vd.tmp=vmem(Rt+#s4) 104                         vmem(Rx++Mu):scatter_release 262
    if ([!]Pv) Vd.tmp=vmem(Rt+#s4):nt 105                      vmem(Rx++Mu)=Os8.new 254
    if ([!]Pv) Vd.tmp=vmem(Rx++#s3) 105                        vmem(Rx++Mu)=Vs 257
    if ([!]Pv) Vd.tmp=vmem(Rx++#s3):nt 105
    if ([!]Pv) Vd.tmp=vmem(Rx++Mu) 105                      vmemu
    if ([!]Pv) Vd.tmp=vmem(Rx++Mu):nt 105                      if ([!]Pv) vmemu(Rt)=Vs 259
    if ([!]Pv) Vd=vmem(Rt) 98                                  if ([!]Pv) vmemu(Rt+#s4)=Vs 259
    if ([!]Pv) Vd=vmem(Rt):nt 98                               if ([!]Pv) vmemu(Rx++#s3)=Vs 259
    if ([!]Pv) Vd=vmem(Rt+#s4) 98                              if ([!]Pv) vmemu(Rx++Mu)=Vs 260
    if ([!]Pv) Vd=vmem(Rt+#s4):nt 99                           Vd=vmemu(Rt) 107
    if ([!]Pv) Vd=vmem(Rx++#s3) 99                             Vd=vmemu(Rt+#s4) 107
    if ([!]Pv) Vd=vmem(Rx++#s3):nt 99                          Vd=vmemu(Rx++#s3) 107
    if ([!]Pv) Vd=vmem(Rx++Mu) 99                              Vd=vmemu(Rx++Mu) 107
    if ([!]Pv) Vd=vmem(Rx++Mu):nt 99                           vmemu(Rt)=Vs 260
    if ([!]Pv) vmem(Rt):nt=Vs 256                              vmemu(Rt+#s4)=Vs 260
    if ([!]Pv) vmem(Rt)=Vs 256                                 vmemu(Rx++#s3)=Vs 260
    if ([!]Pv) vmem(Rt+#s4):nt=Os8.new 253                     vmemu(Rx++Mu)=Vs 260
    if ([!]Pv) vmem(Rt+#s4):nt=Vs 256
    if ([!]Pv) vmem(Rt+#s4)=Os8.new 253                     vmin
    if ([!]Pv) vmem(Rt+#s4)=Vs 256
                                                               Vd.b=vmin(Vu.b,Vv.b) 57
    if ([!]Pv) vmem(Rx++#s3):nt=Os8.new 253
                                                               Vd.h=vmin(Vu.h,Vv.h) 57
    if ([!]Pv) vmem(Rx++#s3):nt=Vs 256
                                                               Vd.ub=vmin(Vu.ub,Vv.ub) 57
    if ([!]Pv) vmem(Rx++#s3)=Os8.new 253
                                                               Vd.uh=vmin(Vu.uh,Vv.uh) 57
    if ([!]Pv) vmem(Rx++#s3)=Vs 256
                                                               Vd.w=vmin(Vu.w,Vv.w) 57
    if ([!]Pv) vmem(Rx++Mu):nt=Os8.new 253
    if ([!]Pv) vmem(Rx++Mu):nt=Vs 257
    if ([!]Pv) vmem(Rx++Mu)=Os8.new 254                     vmpa
    if ([!]Pv) vmem(Rx++Mu)=Vs 257                             Vdd.h=vmpa(Vuu.ub,Rt.b) 123
    if ([!]Qv4) vmem(Rt):nt=Vs 250                             Vdd.h=vmpa(Vuu.ub,Rt.ub) 123
    if ([!]Qv4) vmem(Rt)=Vs 250                                Vdd.h=vmpa(Vuu.ub,Vvv.b) 123
    if ([!]Qv4) vmem(Rt+#s4):nt=Vs 251                         Vdd.h=vmpa(Vuu.ub,Vvv.ub) 124
    if ([!]Qv4) vmem(Rt+#s4)=Vs 251                            Vdd.w=vmpa(Vuu.h,Rt.b) 124
    if ([!]Qv4) vmem(Rx++#s3):nt=Vs 251                        Vdd.w=vmpa(Vuu.uh,Rt.b) 124
    if ([!]Qv4) vmem(Rx++#s3)=Vs 251                           Vx.h=vmpa(Vx.h,Vu.h,Rtt.h):sat 119
    if ([!]Qv4) vmem(Rx++Mu):nt=Vs 251                         Vx.h=vmpa(Vx.h,Vu.uh,Rtt.uh):sat 119
    if ([!]Qv4) vmem(Rx++Mu)=Vs 251                            Vxx.h+=vmpa(Vuu.ub,Rt.b) 124
    Vd.cur=vmem(Rt+#s4) 101                                    Vxx.h+=vmpa(Vuu.ub,Rt.ub) 124
    Vd.cur=vmem(Rt+#s4):nt 101                                 Vxx.w+=vmpa(Vuu.h,Rt.b) 124
    Vd.cur=vmem(Rx++#s3) 101                                   Vxx.w+=vmpa(Vuu.uh,Rt.b) 124
    Vd.cur=vmem(Rx++#s3):nt 101
    Vd.cur=vmem(Rx++Mu) 101                                 vmps
    Vd.cur=vmem(Rx++Mu):nt 101                                 Vx.h=vmps(Vx.h,Vu.uh,Rtt.uh):sat 119
    Vd.tmp=vmem(Rt+#s4) 104
    Vd.tmp=vmem(Rt+#s4):nt 104
    Vd.tmp=vmem(Rx++#s3) 104
    Vd.tmp=vmem(Rx++#s3):nt 104
    Vd.tmp=vmem(Rx++Mu) 104
    Vd.tmp=vmem(Rx++Mu):nt 104
    Vd=vmem(Rt) 98
    Vd=vmem(Rt):nt 98
    Vd=vmem(Rt+#s4) 98
    Vd=vmem(Rt+#s4):nt 98
    Vd=vmem(Rx++#s3) 98
    Vd=vmem(Rx++#s3):nt 98
    Vd=vmem(Rx++Mu) 98
    Vd=vmem(Rx++Mu):nt 98
    vmem(Rt):nt=Os8.new 254
    vmem(Rt):nt=Vs 257
    vmem(Rt)=Os8.new 254
    vmem(Rt)=Vs 257
    vmem(Rt+#s4):nt=Os8.new 254
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       267
Hexagon V66 HVX Programmer’s Reference Manual                                                    Instruction Index
vmpy                                                       vnormamt
    Vd.h=vmpy(Vu.h,Rt.h):<<1:rnd:sat 129                       Vd.h=vnormamt(Vu.h) 248
    Vd.h=vmpy(Vu.h,Rt.h):<<1:sat 129                           Vd.w=vnormamt(Vu.w) 248
    Vd.h=vmpy(Vu.h,Vv.h):<<1:rnd:sat 132
    Vdd.h=vmpy(Vu.b,Vv.b) 132                              vnormamth
    Vdd.h=vmpy(Vu.ub,Rt.b) 129                                 Vd=vnormamth(Vu) 248
    Vdd.h=vmpy(Vu.ub,Vv.b) 132
    Vdd.uh=vmpy(Vu.ub,Rt.ub) 129
    Vdd.uh=vmpy(Vu.ub,Vv.ub) 132
                                                           vnormamtw
    Vdd.uw=vmpy(Vu.uh,Rt.uh) 129                               Vd=vnormamtw(Vu) 248
    Vdd.uw=vmpy(Vu.uh,Vv.uh) 132
    Vdd.w=vmpy(Vu.h,Rt.h) 129                              vnot
    Vdd.w=vmpy(Vu.h,Vv.h) 132                                  Vd=vnot(Vu) 66
    Vdd.w=vmpy(Vu.h,Vv.uh) 133
    Vxx.h+=vmpy(Vu.b,Vv.b) 133                             vor
    Vxx.h+=vmpy(Vu.ub,Rt.b) 129                                Vd=vor(Vu,Vv) 66
    Vxx.h+=vmpy(Vu.ub,Vv.b) 133
    Vxx.uh+=vmpy(Vu.ub,Rt.ub) 129
    Vxx.uh+=vmpy(Vu.ub,Vv.ub) 133
                                                           vpack
    Vxx.uw+=vmpy(Vu.uh,Rt.uh) 129                              Vd.b=vpack(Vu.h,Vv.h):sat 191
    Vxx.uw+=vmpy(Vu.uh,Vv.uh) 133                              Vd.h=vpack(Vu.w,Vv.w):sat 192
    Vxx.w+=vmpy(Vu.h,Rt.h) 130                                 Vd.ub=vpack(Vu.h,Vv.h):sat 192
    Vxx.w+=vmpy(Vu.h,Rt.h):sat 130                             Vd.uh=vpack(Vu.w,Vv.w):sat 192
    Vxx.w+=vmpy(Vu.h,Vv.h) 133
    Vxx.w+=vmpy(Vu.h,Vv.uh) 133                            vpacke
                                                               Vd.b=vpacke(Vu.h,Vv.h) 191
vmpye                                                          Vd.h=vpacke(Vu.w,Vv.w) 192
    Vd.uw=vmpye(Vu.uh,Rt.uh) 167
    Vd.w=vmpye(Vu.w,Vv.uh) 142                             vpacko
    Vdd=vmpye(Vu.w,Vv.uh) 143                                  Vd.b=vpacko(Vu.h,Vv.h) 192
    Vx.uw+=vmpye(Vu.uh,Rt.uh) 167                              Vd.h=vpacko(Vu.w,Vv.w) 192
vmpyi                                                      vpopcount
    Vd.h=vmpyi(Vu.h,Rt.b) 165                                  Vd.h=vpopcount(Vu.h) 248
    Vd.h=vmpyi(Vu.h,Vv.h) 136
    Vd.w=vmpyi(Vu.w,Rt.b) 165                              vrdelta
    Vd.w=vmpyi(Vu.w,Rt.h) 140                                  Vd=vrdelta(Vu,Vv) 187
    Vd.w=vmpyi(Vu.w,Rt.ub) 165
    Vx.h+=vmpyi(Vu.h,Rt.b) 165
    Vx.h+=vmpyi(Vu.h,Vv.h) 136
                                                           vrmpy
    Vx.w+=vmpyi(Vu.w,Rt.b) 165                                 Vd.uw=vrmpy(Vu.ub,Rt.ub) 168
    Vx.w+=vmpyi(Vu.w,Rt.h) 140                                 Vd.uw=vrmpy(Vu.ub,Vv.ub) 171
    Vx.w+=vmpyi(Vu.w,Rt.ub) 165                                Vd.w=vrmpy(Vu.b,Vv.b) 172
                                                               Vd.w=vrmpy(Vu.ub,Rt.b) 169
                                                               Vd.w=vrmpy(Vu.ub,Vv.b) 172
vmpyie                                                         Vdd.uw=vrmpy(Vuu.ub,Rt.ub,#u1) 146
    Vd.w=vmpyie(Vu.w,Vv.uh) 138                                Vdd.w=vrmpy(Vuu.ub,Rt.b,#u1) 146
    Vx.w+=vmpyie(Vu.w,Vv.h) 138                                Vx.uw+=vrmpy(Vu.ub,Rt.ub) 169
    Vx.w+=vmpyie(Vu.w,Vv.uh) 138                               Vx.uw+=vrmpy(Vu.ub,Vv.ub) 150
                                                               Vx.w+=vrmpy(Vu.b,Vv.b) 150
vmpyieo                                                        Vx.w+=vrmpy(Vu.ub,Rt.b) 169
    Vd.w=vmpyieo(Vu.h,Vv.h) 164                                Vx.w+=vrmpy(Vu.ub,Vv.b) 150
                                                               Vxx.uw+=vrmpy(Vuu.ub,Rt.ub,#u1) 146
vmpyio                                                         Vxx.w+=vrmpy(Vuu.ub,Rt.b,#u1) 147
    Vd.w=vmpyio(Vu.w,Vv.h) 138
                                                           vror
vmpyo                                                          Vd=vror(Vu,Rt) 182
    Vd.w=vmpyo(Vu.w,Vv.h):<<1[:rnd]:sat 143
    Vx.w+=vmpyo(Vu.w,Vv.h):<<1[:rnd]:sat:shift  143        vrotr
    Vxx+=vmpyo(Vu.w,Vv.h) 143                                  Vd.w=vrotr(Vu.uw,Vv.uw) 247
                                                               Vd=vrotr(Vu,Vv) 247
vmux
    Vd=vmux(Qt4,Vu,Vv) 83                                  vround
                                                               Vd.b=vround(Vu.h,Vv.h):sat 244
vnavg                                                          Vd.h=vround(Vu.w,Vv.w):sat 245
    Vd.b=vnavg(Vu.b,Vv.b) 70                                   Vd.ub=vround(Vu.h,Vv.h):sat 245
    Vd.b=vnavg(Vu.ub,Vv.ub) 70                                 Vd.ub=vround(Vu.uh,Vv.uh):sat 245
    Vd.h=vnavg(Vu.h,Vv.h) 70                                   Vd.uh=vround(Vu.uw,Vv.uw):sat 245
    Vd.w=vnavg(Vu.w,Vv.w) 71                                   Vd.uh=vround(Vu.w,Vv.w):sat 245
80-N2040-44 Rev. B     MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                        268
Hexagon V66 HVX Programmer’s Reference Manual                                                     Instruction Index
vrsad                                                        vsplat
    Vdd.uw=vrsad(Vuu.ub,Rt.ub,#u1) 160                          Vd.b=vsplat(Rt) 173
    Vxx.uw+=vrsad(Vuu.ub,Rt.ub,#u1) 160                         Vd.h=vsplat(Rt) 173
                                                                Vd=vsplat(Rt) 173
vsat
    Vd.h=vsat(Vu.w,Vv.w) 85                                  vsub
    Vd.ub=vsat(Vu.h,Vv.h) 85                                    Vd.b=vsub(Vu.b,Vv.b)[:sat] 61
    Vd.uh=vsat(Vu.uw,Vv.uw) 85                                  Vd.h=vsub(Vu.h,Vv.h)[:sat] 61
                                                                Vd.ub=vsub(Vu.ub,Vv.b):sat 61
vsatdw                                                          Vd.ub=vsub(Vu.ub,Vv.ub):sat 61
    Vd.w=vsatdw(Vu.w, Vv.w)  85                                 Vd.uh=vsub(Vu.uh,Vv.uh):sat 61
                                                                Vd.uw=vsub(Vu.uw,Vv.uw):sat 61
                                                                Vd.w,Qe4=vsub(Vu.w,Vv.w):carry 64
vsathub                                                         Vd.w=vsub(Vu.w,Vv.w,Qx4):carry 64
    Vd=vsathub(Vu,Vv)  85                                       Vd.w=vsub(Vu.w,Vv.w)[:sat] 61
                                                                Vdd.b=vsub(Vuu.b,Vvv.b)[:sat] 51
vsatuwuh                                                        Vdd.h=vsub(Vu.ub,Vv.ub) 110
    Vd=vsatuwuh(Vu,Vv)  85                                      Vdd.h=vsub(Vuu.h,Vvv.h)[:sat] 51
                                                                Vdd.ub=vsub(Vuu.ub,Vvv.ub):sat 51
vsatwh                                                          Vdd.uh=vsub(Vuu.uh,Vvv.uh):sat 52
    Vd=vsatwh(Vu,Vv)  85                                        Vdd.uw=vsub(Vuu.uw,Vvv.uw):sat 52
                                                                Vdd.w=vsub(Vu.h,Vv.h) 110
                                                                Vdd.w=vsub(Vu.uh,Vv.uh) 110
vscatter                                                        Vdd.w=vsub(Vuu.w,Vvv.w)[:sat] 52
    if (Qs4) vscatter(Rt,Mu,Vv.h).h=Vw32 227
    if (Qs4) vscatter(Rt,Mu,Vv.h)=Vw32.h 227
    if (Qs4) vscatter(Rt,Mu,Vv.w).w=Vw32 227
                                                             vswap
    if (Qs4) vscatter(Rt,Mu,Vv.w)=Vw32.w 227                    Vdd=vswap(Qt4,Vu,Vv) 46
    if (Qs4) vscatter(Rt,Mu,Vvv.w).h=Vw32 224
    if (Qs4) vscatter(Rt,Mu,Vvv.w)=Vw32.h 224                vsxt
    vscatter(Rt,Mu,Vv.h).h+=Vw32 227                            Vdd.h=vsxt(Vu.b) 49
    vscatter(Rt,Mu,Vv.h).h=Vw32 227                             Vdd.w=vsxt(Vu.h) 49
    vscatter(Rt,Mu,Vv.h)+=Vw32.h 227
    vscatter(Rt,Mu,Vv.h)=Vw32.h 227                          vsxtb
    vscatter(Rt,Mu,Vv.w).w+=Vw32 227                            Vdd=vsxtb(Vu) 49
    vscatter(Rt,Mu,Vv.w).w=Vw32 227
    vscatter(Rt,Mu,Vv.w)+=Vw32.w 227
    vscatter(Rt,Mu,Vv.w)=Vw32.w 227
                                                             vsxth
    vscatter(Rt,Mu,Vvv.w).h+=Vw32 224                           Vdd=vsxth(Vu) 49
    vscatter(Rt,Mu,Vvv.w).h=Vw32 224
    vscatter(Rt,Mu,Vvv.w)+=Vw32.h 224                        vtmp.h
    vscatter(Rt,Mu,Vvv.w)=Vw32.h 224                            if (Qs4) vtmp.h=vgather(Rt,Mu,Vv.h).h 96
                                                                if (Qs4) vtmp.h=vgather(Rt,Mu,Vvv.w).h 93
vsetq                                                           vtmp.h=vgather(Rt,Mu,Vv.h).h 96
    Qd4=vsetq(Rt)  194                                          vtmp.h=vgather(Rt,Mu,Vvv.w).h 93
vsetq2                                                       vtmpy
    Qd4=vsetq2(Rt)  194                                         Vdd.h=vtmpy(Vuu.b,Rt.b) 152
                                                                Vdd.h=vtmpy(Vuu.ub,Rt.b) 152
                                                                Vdd.w=vtmpy(Vuu.h,Rt.b) 153
vshuff                                                          Vxx.h+=vtmpy(Vuu.b,Rt.b) 153
    Vd.b=vshuff(Vu.b) 189                                       Vxx.h+=vtmpy(Vuu.ub,Rt.b) 153
    Vd.h=vshuff(Vu.h) 189                                       Vxx.w+=vtmpy(Vuu.h,Rt.b) 153
    Vdd=vshuff(Vu,Vv,Rt) 209
    vshuff(Vy,Vx,Rt) 209
                                                             vtrans2x2
                                                                vtrans2x2(Vy,Vx,Rt) 209
vshuffe
    Qd4.b=vshuffe(Qs4.h,Qt4.h)  40
    Qd4.h=vshuffe(Qs4.w,Qt4.w)  40                           vunpack
    Vd.b=vshuffe(Vu.b,Vv.b) 88                                  Vdd.h=vunpack(Vu.b) 221
    Vd.h=vshuffe(Vu.h,Vv.h) 88                                  Vdd.uh=vunpack(Vu.ub) 221
                                                                Vdd.uw=vunpack(Vu.uh) 221
                                                                Vdd.w=vunpack(Vu.h) 221
vshuffo
    Vd.b=vshuffo(Vu.b,Vv.b)  88
    Vd.h=vshuffo(Vu.h,Vv.h)  88                              vunpacko
                                                                Vxx.h|=vunpacko(Vu.b) 221
                                                                Vxx.w|=vunpacko(Vu.h) 221
vshuffoe
    Vdd.b=vshuffoe(Vu.b,Vv.b)  44
    Vdd.h=vshuffoe(Vu.h,Vv.h)  45
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                       269
Hexagon V66 HVX Programmer’s Reference Manual                                             Instruction Index
vwhist128
    vwhist128 36
    vwhist128(#u1) 37
    vwhist128(Qv4,#u1)  37
    vwhist128(Qv4) 37
vwhist256
    sat
        vwhist256:sat 38
    vwhist256 37
    vwhist256(Qv4) 38
    vwhist256(Qv4):sat 38
vxor
    Vd=vxor(Vu,Vv)  66
vzxt
    Vdd.uh=vzxt(Vu.ub)  49
    Vdd.uw=vzxt(Vu.uh)  49
vzxtb
    Vdd=vzxtb(Vu)  49
vzxth
    Vdd=vzxth(Vu)  49
X
xor
    Qd4=xor(Qs4,Qt4)  40
80-N2040-44 Rev. B       MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION               270
